<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram program="umlet" version="14.3.0">
  <zoom_level>1</zoom_level>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>260</x>
      <y>32</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_pipe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>245</x>
      <y>40</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_pipe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>251</x>
      <y>35</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>266</x>
      <y>39</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果没有出错（!error），通过copy_to_user
	将两个fd复制到用户空间fildes中
2.如果出错，返回错误码
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>265</x>
      <y>35</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>220</x>
      <y>48</y>
      <w>43</w>
      <h>57</h>
    </coordinates>
    <panel_attributes>1.通过get_empty_filp得到读端和写端的
	file结构
2.通过get_pipe_inode获取管道的inode结构
3.通过get_unused_fd获取读端和写端的文件
	描述符
4.通过d_alloc给inode分配dentry：
	this.name = name;
	this.len = strlen(name);
	this.hash = inode-&gt;i_ino; /* will go */
	dentry = d_alloc(pipe_mnt-&gt;mnt_sb-&gt;s_root, &amp;this);
	dentry-&gt;d_op = &amp;pipefs_dentry_operations;
	//将dentry加入到inode的链表中，并且entry-&gt;d_inode指向inode
	d_add(dentry, inode);
5.增加挂载点和dentry的计数
	f1-&gt;f_vfsmnt = f2-&gt;f_vfsmnt = mntget(mntget(pipe_mnt));
	//注：d_alloc中有对dentry计数，这里只需记一次
	f1-&gt;f_dentry = f2-&gt;f_dentry = dget(dentry);
6.初始化读file和写file
	f1-&gt;f_pos = f2-&gt;f_pos = 0;
	f1-&gt;f_flags = O_RDONLY;
	f1-&gt;f_op = &amp;read_pipe_fops;
	f1-&gt;f_mode = 1;
	f1-&gt;f_version = 0;

	f2-&gt;f_flags = O_WRONLY;
	f2-&gt;f_op = &amp;write_pipe_fops;
	f2-&gt;f_mode = 2;
	f2-&gt;f_version = 0;
注：f_flags表示进程要求对file的权限（读写，append，block）
	f_mode表示file本身的读写权限（第0位置上表示可读，第1位置上表示可写）
7.在fd处安装file，并返回两个fd
	fd_install(i, f1);
	fd_install(j, f2);
	fd[0] = i;
	fd[1] = j;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>227</x>
      <y>108</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_pipe_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>250</x>
      <y>43</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>210</x>
      <y>114</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_empty_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>214</x>
      <y>111</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>225</x>
      <y>115</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_new</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>230</x>
      <y>111</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化inode</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>209</x>
      <y>122</y>
      <w>38</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.为inode申请fifo内存
	(inode).i_pipe-&gt;base=__get_free_page
2.为pipe申请pipe_inode_info结构
	inode-&gt;i_pipe = kmalloc(sizeof(struct pipe_inode_info)
3.初始化pipe_inode_info和inode.size：
	init_waitqueue_head(PIPE_WAIT(*inode));
	PIPE_START(*inode) = PIPE_LEN(*inode) = 0;
	PIPE_READERS(*inode) = PIPE_WRITERS(*inode) = 0;
	PIPE_WAITING_READERS(*inode) = PIPE_WAITING_WRITERS(*inode) = 0;
	PIPE_RCOUNTER(*inode) = PIPE_WCOUNTER(*inode) = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>229</x>
      <y>118</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>240</x>
      <y>116</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>PIPE_READERS(*inode) = 
PIPE_WRITERS(*inode) = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>231</x>
      <y>111</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>264</x>
      <y>116</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //i_fop不赋给file，因为读端和写端都
 //只具有读或者写，但是对inode却具有
 //读和写的特性
inode-&gt;i_fop = &amp;rdwr_pipe_fops;
inode-&gt;i_sb = pipe_mnt-&gt;mnt_sb;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>232</x>
      <y>111</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>290</x>
      <y>116</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_state = I_DIRTY;
inode-&gt;i_mode = S_IFIFO | S_IRUSR | S_IWUSR;
inode-&gt;i_uid = current-&gt;fsuid;
inode-&gt;i_gid = current-&gt;fsgid;
inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;
inode-&gt;i_blksize = PAGE_SIZE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>232</x>
      <y>111</y>
      <w>66</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;640.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>232</x>
      <y>104</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>176</x>
      <y>211</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_signal
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>147</x>
      <y>218</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>new_sa.sa.sa_handler = handler;
new_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK
注：SA_ONESHOT：“一次性”，使用函数指针之后，将其改为SIG_DFL
	SA_NOMASK：不适用信号屏蔽
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>164</x>
      <y>214</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>191</x>
      <y>218</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_sigaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>180</x>
      <y>214</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果正常返回
则返回old_sa.sa.sa_handler</panel_attributes>
    <additional_attributes>30.0;10.0;150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>219</x>
      <y>210</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_rt_sigaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>212</x>
      <y>217</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.判断sigsetsize的大小是否sigset_t一致
2.通过copy_from_user将sigaction复制到new_sa.sa
3.调用do_sigaction，安装signal
4.通过copy_to_user将old_sa.sa复制到用户空间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>224</x>
      <y>213</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>261</x>
      <y>210</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sigaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>253</x>
      <y>216</y>
      <w>32</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.通过verify_area验证待安装的act的读权限
	并通过__get_user将act中的元素，依次从
	用户空间取出，填充到new_ka.sa中
注：因为old_sigaction和k_sigaction中mask的偏移
	不相同，所以不能像sys_rt_sigaction一样copy
2.通过do_sigaction安装signal
3.同样通过verify_area验证之前oact的写权限
	然后通过__put_user依次将old_ka.sa中的元素填入
	oact中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>266</x>
      <y>213</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>140</x>
      <y>229</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.sig要在1~_NSIG之间
2.如果要安装signal，不能覆盖SIGKILL和
	SIGSTOP的响应
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>156</x>
      <y>221</y>
      <w>43</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter
</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>167</x>
      <y>229</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.current-&gt;sig-&gt;siglock保护
2.如果要输出之前的响应：
	*oact=current-&gt;sig-&gt;action[sig-1]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>174</x>
      <y>221</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>190</x>
      <y>227</y>
      <w>40</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>signal_pending1.current-&gt;sig-&gt;action[sig-1]=*act
2.通过sigdelsetmask将sa_mask中的SIGKILL
	和SIGSTOP的屏蔽去掉：
	sigdelsetmask：
		set-&gt;sig[0] &amp;= ~mask
3.如果要将信号的响应设置成SIG_IGN
	或者将SIGCONT、SIGCHLD、SIGWINCH
		的响应设置成SIG_DFL
	1.通过rm_sig_from_queue将信号队列中对这个信号的请求取消
	2.通过recalc_sigpending重新计算
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>196</x>
      <y>221</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要替换signal的响应
</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>187</x>
      <y>248</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rm_sig_from_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>193</x>
      <y>244</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>185</x>
      <y>256</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rm_from_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>190</x>
      <y>251</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>176</x>
      <y>263</y>
      <w>30</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.通过sigismember查看是否在signal中存在信号
	请求，如果不存在直接返回0
2.如果存在信号请求，通过sigdelset将信号请求去掉
	set-&gt;sig[sig / _NSIG_BPW] &amp;= ~(1UL &lt;&lt; (sig % _NSIG_BPW));
3.遍历task的信号请求队列pending.head
	如果队列中请求的信号和当前的信号相同（q-&gt;info.si_signo == sig）
	1.将其中链表中移除（*pp = q-&gt;next），如果移除的info是最后一个
		将s-&gt;tail指向链表最后一个的next
	2.释放队列中的sigqueue，并递减信号数：
		kmem_cache_free(sigqueue_cachep,q);
		atomic_dec(&amp;nr_queued_signals);
4.返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>190</x>
      <y>259</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>215</x>
      <y>248</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>recalc_sigpending</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>221</x>
      <y>244</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>217</x>
      <y>256</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>has_pending_signals</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>222</x>
      <y>251</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
t-&gt;sigpending
因为信号可能不止用一个字能表示
所以不能用pending.signal直接显示</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>210</x>
      <y>263</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.检查t-&gt;pending.signal中除了t-&gt;blocked
	中屏蔽的信号，是否还有其他信号需要处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>223</x>
      <y>259</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>304</x>
      <y>209</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sigprocmask</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>293</x>
      <y>215</y>
      <w>35</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果带设置的set不为NULL
	1.通过copy_from_user将set从用户层复制到内核，并将
		其SIGKILL和SIGSTOP清除（不允许屏蔽）
	2.将之前的block信号先提取：
		old_set = current-&gt;blocked.sig[0];
	3.如果是SIG_BLOCK，那么利用sigaddsetmask将urrent-&gt;blocked中set规定的位置上
	如果是SIG_UNBLOCK，那么利用sigdelsetmask将current-&gt;blocked中set规定的位清除
	如果SIG_SETMASK，那么将直接用set覆盖blocked：
		current-&gt;blocked.sig[0] = new_set	
	4.利用recalc_sigpending重新计算sigpending
2.如果oset不为空，那么将task原来的blocked通过copy_to_user返回到用户空间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>309</x>
      <y>212</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>345</x>
      <y>210</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sigpending</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>345</x>
      <y>217</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_sigpending</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>350</x>
      <y>213</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>332</x>
      <y>224</y>
      <w>42</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.传入参数sigsetsize的大小不能大于sizeof(sigset_t)
2.通过sigandsets查看除了blocked的信号之外，pending.signal
	中是否还有其他未处理的信号
3.通过copy_to_user将未处理的信号复制到用户空间
注：sigandsets是通过_SIG_SET_BINOP(sigandsets, _sig_and)
	定义的，_SIG_SET_BINOP是逐位的按照_sig_and的方法操作
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>349</x>
      <y>220</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>389</x>
      <y>210</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sigsuspend</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>377</x>
      <y>217</y>
      <w>33</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.将要求屏蔽的mask中的SIGKILL和SIGSTOP去掉
2.将之前屏蔽的保存：
	saveset = current-&gt;blocked;
3.通过siginitset将mask赋给blocked
4.通过recalc_sigpending重新计算sigpending
5.regs-&gt;eax = -EINTR;
6.将task睡眠
	current-&gt;state = TASK_INTERRUPTIBLE;
	schedule()
7.醒来之后通过do_signal处理信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>394</x>
      <y>213</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>171</x>
      <y>305</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_kill</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>156</x>
      <y>312</y>
      <w>17</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>info.si_signo = sig;
info.si_errno = 0;
 //标记从用户空间过来
info.si_code = SI_USER;
info.si_pid = current-&gt;pid;
info.si_uid = current-&gt;uid;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>164</x>
      <y>308</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>180</x>
      <y>313</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kill_something_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>176</x>
      <y>308</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>174</x>
      <y>320</y>
      <w>38</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果pid=0，通过kill_pg_info给当前进程组（current-&gt;pgrp）
	发信号
2.如果pid=-1，遍历task链表，通过send_sig_info对每个
	task发信号
3.如果pid&lt;-1,通过kill_pg_info给进程组（-pid）发信号
4.如果pid&gt;0，通过kill_proc_info给task发信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>173</x>
      <y>335</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kill_pg_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>196</x>
      <y>336</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kill_proc_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>188</x>
      <y>316</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>179</x>
      <y>330</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>192</x>
      <y>330</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>168</x>
      <y>342</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.遍历task链表，通过send_sig_info
	给该进程组（p-&gt;pgrp == pgrp）
	task发信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>178</x>
      <y>338</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>194</x>
      <y>342</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过find_task_by_pid在hash表
	中查找pid对应的task
2.通过send_sig_info给task发信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>202</x>
      <y>339</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>198</x>
      <y>351</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>send_sig_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>203</x>
      <y>348</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>218</x>
      <y>313</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_rt_sigqueueinfo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>215</x>
      <y>320</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过copy_from_user将siginfo_t
	从用户空间赋值到内核
2.info.si_code 需要小于0（不能是SI_USER和SI_KERNEL）
3.info.si_signo = sig
4.通过kill_proc_info向task发信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>224</x>
      <y>316</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>157</x>
      <y>358</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.0&lt;sig&lt;_NSIG,否则返回EINVAL
2.!bad_signal,否则返回EPERM
	1.当info为0或者不为1的时候，info.si_code&lt;=0(来自用户空间)
	2.当信号为SIGCONT，唤醒task的session不和当前task相同
	3.当前task的euid和接收信号task的suid和uid都不相等
	4.当前task的uid和接收信号task的suid和uid都不相等
	5.没有CAP_KILL权限
	上述条件全满足时，bad_signal
3.sig不为0，并且接收信号的task的"信号向量表"（sig）需要注册
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>168</x>
      <y>354</y>
      <w>38</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>360.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>198</x>
      <y>358</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_stop_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>203</x>
      <y>354</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>188</x>
      <y>364</y>
      <w>34</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果发送SIGKILL或者SIGCONT，让task继续运行
	1.如果进程处于TASK_STOPPED，通过wake_up_process将进程唤醒
	2.通过rm_sig_from_queue移除信号动作队列中因为SIGSTOP，SIGTSTP
		SIGTTOU，SIGTTIN停止的动作
注：SIGKILL虽然是让进程终止，但是需要其运行自行终止
2.如果发送SIGSTOP，SIGTSTP，SIGTTIN，SIGTTOU，让task停止运行
	通过rm_sig_from_queue取消队列中让其运行（SIGCONT）的动作
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>204</x>
      <y>361</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>226</x>
      <y>357</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ignored_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>204</x>
      <y>354</y>
      <w>29</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>224</x>
      <y>364</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果接收信号的task的ptrace &amp; PT_PTRACED置上，不忽略
2.如果信号blocked，不忽略，防止之后blocked取消能处理
3.signal_type返回0才忽略
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>231</x>
      <y>360</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>231</x>
      <y>372</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>signal_type</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>236</x>
      <y>369</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>210</x>
      <y>378</y>
      <w>42</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.如果“信号向量表不存在”，返回0（忽略）
2.如果向量表中的action不为ign，dfl，err，返回1（不忽略）
3.如果action为ign（1），如果是SIGCHLD就不忽略，不是就忽略
4.如果action为dfl（或者err），
	1.如果信号是SIGCONT，SIGWINCH，SIGCHLD，SIGURG，忽略
	2.如果信号是SIGTSTP，SIGTTIN，SIGTTOU停止task运行信号，不忽略
	3.如果是其他信号，返回-1（不忽略）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>236</x>
      <y>375</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>255</x>
      <y>358</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果sig&lt;SIGRTMIN(rt signal)
	并且通过sigismember检查到已经在
	pending中置上，因为这样的信号合并
	成一次info，所以这次忽略
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>205</x>
      <y>354</y>
      <w>59</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;570.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>281</x>
      <y>358</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>deliver_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>204</x>
      <y>354</y>
      <w>84</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;820.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>276</x>
      <y>365</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>send_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>281</x>
      <y>361</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>281</x>
      <y>361</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果正常返回，
并通过sigismember检查没被blocked</panel_attributes>
    <additional_attributes>60.0;10.0;170.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>292</x>
      <y>366</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>signal_wake_up</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>290</x>
      <y>373</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>t-&gt;sigpending = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>304</x>
      <y>373</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>294</x>
      <y>369</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>296</x>
      <y>369</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果task的状态是
TASK_INTERRUPTIBLE</panel_attributes>
    <additional_attributes>30.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>253</x>
      <y>372</y>
      <w>36</w>
      <h>47</h>
    </coordinates>
    <panel_attributes>1.如果队列中的info数量（nr_queued_signals）
	没超过max_queued_signals，才通过kmem_cache_alloc
	申请sigqueue
2.如果申请到sigqueue
	1.增加nr_queued_signals的计数
	2.将sigqueue加到链表中：
		q-&gt;next = NULL;
		*signals-&gt;tail = q;
		signals-&gt;tail = &amp;q-&gt;next;
	3.初始化sigqueue：
		info：0
		q-&gt;info.si_signo = sig;
		q-&gt;info.si_errno = 0;
		q-&gt;info.si_code = SI_USER;
		q-&gt;info.si_pid = current-&gt;pid;
		q-&gt;info.si_uid = current-&gt;uid;
		info：1
		q-&gt;info.si_signo = sig;
		q-&gt;info.si_errno = 0;
		q-&gt;info.si_code = SI_KERNEL;
		q-&gt;info.si_pid = 0;
		q-&gt;info.si_uid = 0;
		普通info：
		copy_siginfo(&amp;q-&gt;info, info);
3.如果因为队列中的info足够多，所以没申请sigqueue：
	如果sig不是rt（sig &gt;= SIGRTMIN），并且是普通info
	且si_code不是SI_USER，直接返回EAGAIN
4.如果正常，通过sigaddset将pending中sig-1位置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>271</x>
      <y>368</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>306</x>
      <y>357</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>205</x>
      <y>354</y>
      <w>109</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果接收信号的task是TASK_INTERRUPTIBLE
并且signal_pending
注；情形1：blocked，但是有其他信号</panel_attributes>
    <additional_attributes>10.0;10.0;1070.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>271</x>
      <y>307</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>force_sig</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>271</x>
      <y>314</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>force_sig_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>276</x>
      <y>310</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
info:1</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>258</x>
      <y>321</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果接收task的“信号向量表”sig不存在，返回ESRCH
2.如果sa_handler是ign，将其变换位dfl
3.通过sigdelset将bloced中的位清除（强制执行singal）
	并通过recalc_sigpending重新计算sigpending
4.通过send_sig_info向task发送信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>276</x>
      <y>317</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>373</x>
      <y>282</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>341</x>
      <y>290</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果不是从用户空间陷入到系统空间
	((regs-&gt;xcs &amp; 3) != 3),直接返回1
2.如果要求返回之前的blocked
	oldset = &amp;current-&gt;blocked
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>352</x>
      <y>285</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>378</x>
      <y>285</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
死循环</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>359</x>
      <y>374</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dequeue_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>469</x>
      <y>374</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>368</y>
      <w>81</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;790.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>365</x>
      <y>368</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>379</x>
      <y>285</y>
      <w>66</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
regs-&gt;orig_eax &gt;= 0
中断：这里是中断号-255，小于0
异常：这里是-1，error_code
sys_call:这里是系统调用号，大于0</panel_attributes>
    <additional_attributes>10.0;10.0;640.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>426</x>
      <y>288</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果要求重新sys_call(返回值regs-&gt;eax是
	ERESTARTNOHAND,ERESTARTSYS，ERESTARTNOINTR)
	将regs-&gt;eax换成系统调用号，并将eip调整到
	系统调用的语句：
	regs-&gt;eax = regs-&gt;orig_eax;
	regs-&gt;eip -= 2;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>346</x>
      <y>381</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>next_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>334</x>
      <y>388</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.在pending.signal.sig中查看没被mask（这里是blocked）
	屏蔽的信号，如果有返回sig，否则返回0
注；ffz：find first zero 
	bsf：bit scan forward 是从低向高位检索bit，找到第一个1
	传参和ffz分别经过了两次非
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>353</x>
      <y>377</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>349</x>
      <y>384</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>362</x>
      <y>377</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果存在current-&gt;notifier
并且notifier_mask中sig有置上</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>363</x>
      <y>384</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>current-&gt;notifier)(current-&gt;notifier_data)
current-&gt;sigpending = 0;
return 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>362</x>
      <y>377</y>
      <w>37</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>392</x>
      <y>384</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>collect_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>373</x>
      <y>391</y>
      <w>38</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>1.如果sig在pending中被置上
	1.遍历pending的info队列，查找队列中是否有和sig一致的
	info.si_signo，如果有跳到3
	2.如果队列中没有，通过sigdelset清除sig在pending中的标志并初始化info：
		info-&gt;si_signo = sig;
		info-&gt;si_errno = 0;
		info-&gt;si_code = 0;
		info-&gt;si_pid = 0;
		info-&gt;si_uid = 0;
	3.如果在队列中找到了info
		1.将info从链表中断开
			*pp = q-&gt;next
			//如果info是链表中的最后一个
			list-&gt;tail = pp
		2.复制info，释放链表中的info
			copy_siginfo(info, &amp;q-&gt;info);
			kmem_cache_free(sigqueue_cachep,q);
			atomic_dec(&amp;nr_queued_signals);
		3.如果信号不是rt（&gt;= SIGRTMIN），继续遍历链表
			如果再次找到，就不清pending中的sig。
			否则通过sigdelset将sig清掉
2.如果sig没在pending中置上，直接返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>387</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>410</x>
      <y>383</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>recalc_sigpending</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>362</x>
      <y>377</y>
      <w>55</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
重新计算sigpending</panel_attributes>
    <additional_attributes>10.0;10.0;530.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>443</x>
      <y>377</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
regs-&gt;orig_eax &gt;= 0
如果来自sys_call</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>422</x>
      <y>384</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果返回值是ERESTARTNOHAND，返回EINTR
2.如果返回值是ERESTARTSYS，如果信号向量表
	的sa_flags中的SA_RESTART没置上，返回EINTR
	否则，重新执行sys_call
3.如果返回值是ERESTARTNOINTR，重新执行sys_call:
	regs-&gt;eax = regs-&gt;orig_eax;
	regs-&gt;eip -= 2;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>469</x>
      <y>377</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>459</x>
      <y>380</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
信号向量表的sa_flags
中SA_SIGINFO置上</panel_attributes>
    <additional_attributes>110.0;10.0;30.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>456</x>
      <y>387</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_rt_frame</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>469</x>
      <y>380</y>
      <w>21</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SA_SIGINFO没置上</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>482</x>
      <y>389</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_frame</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>471</x>
      <y>377</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
之前在SA_ONESHOT置上的时候，handler设成SIG_DFL
防止中断嵌套，现在可以通过信号向量表中的mask屏蔽</panel_attributes>
    <additional_attributes>50.0;10.0;320.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>498</x>
      <y>383</y>
      <w>20</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>ka-&gt;sa.sa_handler = SIG_DFL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>476</x>
      <y>377</y>
      <w>63</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SA_NODEFER没置上
</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>522</x>
      <y>381</y>
      <w>34</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //blocked|=mask
sigorsets(&amp;current-&gt;blocked,&amp;current-&gt;blocked,&amp;ka-&gt;sa.sa_mask);
 //blocked |=sig
sigaddset(&amp;current-&gt;blocked,sig);
recalc_sigpending(current);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>448</x>
      <y>392</y>
      <w>40</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请栈帧</panel_attributes>
    <additional_attributes>380.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>443</x>
      <y>398</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_sigframe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>422</x>
      <y>405</y>
      <w>34</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.默认是用户栈regs-&gt;esp
2.如果SA_ONSTACK置上，并且通过on_sig_stack
	查看用户栈是否在sig的栈上（current-&gt;sas_ss_sp + current-&gt;sas_ss_size）
	如果不在：
	esp = current-&gt;sas_ss_sp + current-&gt;sas_ss_size
注；系统调用sigaltstack设置信号栈
3.如果xss不在用户段（__USER_DS）
	并且SA_RESTORER没置上
	sa_restorer存在
	esp =ka-&gt;sa.sa_restorer
注：不清楚为什么xss会不在用户段，sig只有xss在用户段的时候才会处理啊？
4.申请栈空间：
	(esp - frame_size) &amp; -8ul
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>441</x>
      <y>401</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>456</x>
      <y>400</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>access_ok
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>461</x>
      <y>392</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
验证栈的写（VERIFY_WRITE）权限</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>476</x>
      <y>392</y>
      <w>15</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>471</x>
      <y>401</y>
      <w>29</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.通过__put_user压栈参数sig：
	如果进程有要求转换：
	current-&gt;exec_domain
  &amp;&amp; current-&gt;exec_domain-&gt;signal_invmap
  &amp;&amp; sig &lt; 32
  	就通过current-&gt;exec_domain-&gt;signal_invmap[sig]转换
  	否则就是sig
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>505</x>
      <y>402</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_sigcontext</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>488</x>
      <y>392</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将上下文环境保存到sigcontext中</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>502</x>
      <y>409</y>
      <w>27</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>__put_user(tmp, (unsigned int *)&amp;sc-&gt;gs);
__put_user(tmp, (unsigned int *)&amp;sc-&gt;fs);
__put_user(regs-&gt;xes, (unsigned int *)&amp;sc-&gt;es);
__put_user(regs-&gt;xds, (unsigned int *)&amp;sc-&gt;ds);
__put_user(regs-&gt;edi, &amp;sc-&gt;edi);
__put_user(regs-&gt;esi, &amp;sc-&gt;esi);
__put_user(regs-&gt;ebp, &amp;sc-&gt;ebp);
__put_user(regs-&gt;esp, &amp;sc-&gt;esp);
__put_user(regs-&gt;ebx, &amp;sc-&gt;ebx);
__put_user(regs-&gt;edx, &amp;sc-&gt;edx);
__put_user(regs-&gt;ecx, &amp;sc-&gt;ecx);
__put_user(regs-&gt;eax, &amp;sc-&gt;eax);
__put_user(current-&gt;thread.trap_no, &amp;sc-&gt;trapno);
__put_user(current-&gt;thread.error_code, &amp;sc-&gt;err);
__put_user(regs-&gt;eip, &amp;sc-&gt;eip);
__put_user(regs-&gt;xcs, (unsigned int *)&amp;sc-&gt;cs);
__put_user(regs-&gt;eflags, &amp;sc-&gt;eflags);
__put_user(regs-&gt;esp, &amp;sc-&gt;esp_at_signal);
__put_user(regs-&gt;xss, (unsigned int *)&amp;sc-&gt;ss);
 //do_signal在entry.S中调用的是oldmask好像是edx，所以是blocked
 //这里只复制了blocked[0]
__put_user(mask, &amp;sc-&gt;oldmask);
__put_user(current-&gt;thread.cr2, &amp;sc-&gt;cr2);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>510</x>
      <y>405</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>488</x>
      <y>392</y>
      <w>44</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制oldset.sig[1]开始的mask到frame-&gt;extramask</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>524</x>
      <y>401</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__copy_to_user
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>488</x>
      <y>392</y>
      <w>64</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>539</x>
      <y>399</y>
      <w>29</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.如果SA_RESTORER置上，ka-&gt;sa.sa_restorer将作为其信号处理完成之后的返回地址
	__put_user(ka-&gt;sa.sa_restorer, &amp;frame-&gt;pretcode
2.如果没置上，frame-&gt;retcode将作为其信号处理完的返回地址
	__put_user(frame-&gt;retcode, &amp;frame-&gt;pretcode);
	//依次执行popl %eax ; movl $,%eax ; int $0x80
	__put_user(0xb858, (short *)(frame-&gt;retcode+0));
	__put_user(__NR_sigreturn, (int *)(frame-&gt;retcode+2));
	__put_user(0x80cd, (short *)(frame-&gt;retcode+6));
3.设置返回用户空间的ip和sp
	regs-&gt;esp = (unsigned long) frame;
	regs-&gt;eip = (unsigned long) ka-&gt;sa.sa_handler;

	set_fs(USER_DS);
	regs-&gt;xds = __USER_DS;
	regs-&gt;xes = __USER_DS;
	regs-&gt;xss = __USER_DS;
	regs-&gt;xcs = __USER_CS;
	//将硬件跟踪的flag清掉
	regs-&gt;eflags &amp;= ~TF_MASK;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>509</x>
      <y>279</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sigreturn</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>491</x>
      <y>286</y>
      <w>47</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.*frame = (struct sigframe *)(regs-&gt;esp - 8)
注：因为进入系统调用的时候，pretcode返回，并且会有popl eax
2.通过verify_area验证栈帧区域的写权限
3.通过__get_user和__copy_from_user将之前的blocked信息
	存储到set.sig中
4.通过sigdelsetmask清除set中的SIGKILL和SIGSTOP
5.还原blocked，并重新计算sigpending
	current-&gt;blocked = set;
	recalc_sigpending(current);
6.通过restore_sigcontext恢复signal_handler破坏的现场
注：处理完signal不能直接回到原理陷入内核的地方，是因为：
	1.signal_handler会破环用户层的寄存器现场，需要save_all和restore_all
		但是用户层没手段去做寄存器现场的保护和恢复
	2.返回系统空间有利于一次性处理完所有的sig
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>515</x>
      <y>282</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>507</x>
      <y>313</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>restore_sigcontext</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>513</x>
      <y>309</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>497</x>
      <y>320</y>
      <w>33</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.恢复gs，fs到相应的段寄存器中
2.恢复es，ds，edi，esi，ebp，esp，ebx，edx，ecx，eip，cs，ss
	到对应的reg上下文现场中
3.用户层的（~0x40DD5）和之前现场的（0x40DD5）组成恢复现场的regs-&gt;eflags
4.禁止sys_call检查
	regs-&gt;orig_eax = -1;
5.通过restore_i387将sc-&gt;fpstate恢复
6.将do_signal之前的返回值，放在peax中
	__get_user(*peax, &amp;sc-&gt;eax)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>513</x>
      <y>316</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>373</x>
      <y>289</y>
      <w>45</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.通过dequeue_signal找到要处理的信号（signr），
	并将其从info队列中移除
2.如果返回是0，则退出循环
3.如果task的ptrace &amp; PT_PTRACED置上，且
	处理的信号不是SIGKILL：
	1.task stopped
		current-&gt;exit_code = signr;
		current-&gt;state = TASK_STOPPED;
		notify_parent(current, SIGCHLD);
		schedule();
	2.如果gdb continue时，exit_code为0，继续处理其他信号
		并清楚current-&gt;exit_code = 0
	3.如果exit_code是SIGSTOP，继续处理其他信号
	4.如果信号变了，更新info
		info.si_signo = signr;
		info.si_errno = 0;
		info.si_code = SI_USER;
		info.si_pid = current-&gt;p_pptr-&gt;pid;
		info.si_uid = current-&gt;p_pptr-&gt;uid;
	5.如果信号被blocked，通过send_sig_info重新将信号加入到队列中
4.获取信号向量表：
	ka = &amp;current-&gt;sig-&gt;action[signr-1]
5.如果sa_handler是ign，但是信号不是SIGCHLD
	继续下一个信号；如果是，通过sys_wait4等待
	子进程stopped或者zombie
注：WNOHANG表示不睡眠
6.如果sa_handler是SIG_DFL：
	1.不能是init进程接收
	2.如果是SIGCONT，SIGCHLD，SIGWINCH不处理
	3.如果是SIGTSTP，SIGTTIN，SIGTTOU，如果是孤儿进程，不处理
		否则4一致
	4.如果是SIGSTOP
		1.如果父进程没有要求在子进程stopped时停发SIGCHLD
			通过notify_parent给父进程发送SIGCHLD
		2.schedule
	5.如果是以下情况
		case SIGQUIT: case SIGILL: case SIGTRAP:
		case SIGABRT: case SIGFPE: case SIGSEGV:
		case SIGBUS: case SIGSYS: case SIGXCPU: case SIGXFSZ:
		通过do_coredump将必要信息存储到core文件中，exit_code |= 0x80;
		然后与6一致
	6.默认是：
		1.通过sigaddset将pending中sig重新置上，并通过recalc_sigpending
			计算sigpending
		2.标识进程被信号杀死
			current-&gt;flags |= PF_SIGNALED
		3.do_exit(exit_code)
	注：如果是ign和dfl，基本上是在这里（内核空间）处理完
7.如果需要用户空间处理，通过handle_signal处理信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>203</x>
      <y>535</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_ptrace</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>148</x>
      <y>538</y>
      <w>62</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_TRACEME</panel_attributes>
    <additional_attributes>600.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>132</x>
      <y>544</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果进程ptrace &amp; PT_PTRACED置上
	直接返回
2.否则置上标志，并返回0
	current-&gt;ptrace |= PT_PTRACED;
	ret = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>161</x>
      <y>546</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_task_by_pid
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>165</x>
      <y>538</y>
      <w>46</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>176</x>
      <y>546</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_task_struct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>181</x>
      <y>538</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>173</x>
      <y>552</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>atomic_inc(page.count)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>182</x>
      <y>549</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
task虚拟地址转换成page管理结构</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>191</x>
      <y>546</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.如果pid找不到child，返回ESRCH
2.如果是init进程（pid == 1），返回EPERM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>197</x>
      <y>538</y>
      <w>14</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>209</x>
      <y>538</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_ATTACH</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>214</x>
      <y>545</y>
      <w>30</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.要跟踪的进程不能是当前进程（child == current）
2.下面条件要全满足，或者进程有CAP_SYS_PTRACE权限
	child-&gt;dumpable不为0
	当前进程uid要和child的euid，suid，uid相同
	当前进程的gid要和child的egid，sgid，gid相同
	child的cap_permitted要是当前进程cap_permitted的子集
3.child的	PT_PTRACED要置上
4.如果child的养父（pptr）不是当前进程
	通过REMOVE_LINKS将其从task链表和其族谱中删除
	并通过以下方法将其加入到current的族谱中
	child-&gt;p_pptr = current;
	SET_LINKS(child);
5.给child发送SIGSTOP，并返回0
	send_sig(SIGSTOP, child, 1);
	ret = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>245</x>
      <y>545</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果PT_PTRACED没置上，报ESRCH
2.如果child的状态不是TASK_STOPPED时，只要发送的不是
	PTRACE_KILL就直接返回ESRCH
3.child养父要是当前进程
注：虽然1，3也在attached中检测，但是报错好像不一样
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>209</x>
      <y>538</y>
      <w>43</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>210</x>
      <y>538</y>
      <w>86</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;840.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>274</x>
      <y>543</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_PEEKTEXT
PTRACE_PEEKDATA
读取数据段或者代码段addr上4个字节的数据</panel_attributes>
    <additional_attributes>190.0;10.0;90.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>275</x>
      <y>550</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>277</x>
      <y>550</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查读取的长度和期待的长度相同</panel_attributes>
    <additional_attributes>60.0;10.0;150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>287</x>
      <y>554</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>268</x>
      <y>555</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>access_process_vm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>258</x>
      <y>561</y>
      <w>30</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.获取mm
	mm = tsk-&gt;mm;
	atomic_inc(&amp;mm-&gt;mm_users
2.通过find_extend_vma找到addr所处的vma
3.通过access_mm将vma中的数据存储到buf中
4.释放mm
	mmput(mm)
5.返回复制的字节数copied
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>274</x>
      <y>558</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>254</x>
      <y>577</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_extend_vma</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>258</x>
      <y>574</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>280</x>
      <y>576</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>access_mm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>274</x>
      <y>573</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;20.0;110.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>243</x>
      <y>583</y>
      <w>29</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.addr &amp;= PAGE_MASK
2.通过find_vma找到end高于addr的最小vma
3.如果没找到vma，返回NULL
4.如果vm_start &lt;= addr，地址完全在这个vma内
	返回vma
5.如果vma的VM_GROWSDOWN没置上(不是栈)，返回NULL
6.通过expand_stack将栈扩展
7.如果vma的VM_LOCKED，通过make_pages_present给其分配
	物理页面
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>258</x>
      <y>580</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>275</x>
      <y>583</y>
      <w>35</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.计算当前页有多少空间可以读
	offset = addr &amp; ~PAGE_MASK
	 this_len = PAGE_SIZE - offset
	 //确定此次读的长度
	 min（this_len， len）
2.通过access_one_page将此次要读的长度，读到buf中
3.更新：
	copied += retval;//如果没读到预期长度，直接退出
	len -= retval;//len读完了，退出
	addr += retval;
	buf += retval;
4.如果当前vma没读完，再次读这个vma
5.如果当前vma读完了，下一个vma存在且和当前vma连续
	vma = vma-&gt;vm_next
	否则退出
halign=left
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>285</x>
      <y>579</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>285</x>
      <y>611</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>access_one_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>291</x>
      <y>607</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>275</x>
      <y>618</y>
      <w>34</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.获取pgdir
2.检查pgd_none，pgd_bad，pmd_none，pmd_bad
	pte_present，pte_write&amp;&amp;pte_dirty（如果要求写）
	如果是none或者！present,先去handle_mm_fault分配物理页，然后再次执行
3.获取物理页
	page = pte_page(*pgtable)
4.在要写或者不是ZERO_PAGE时，要是VALID_PAGE并且不是PageReserved
5.执行读写操作
	//获取page的虚拟地址
	maddr = kmap(page)
	//写
	memcpy(maddr + (addr &amp; ~PAGE_MASK), buf, len);
	//读
	memcpy(buf, maddr + (addr &amp; ~PAGE_MASK), len);
	kunmap(page);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>290</x>
      <y>614</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>293</x>
      <y>543</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_PEEKUSR</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>303</x>
      <y>550</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>299</x>
      <y>554</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.addr要4字节对齐（addr &amp; 3）!=0
2.addr&gt;=0
3.addr读取的数据不能超过sizeof(struct user)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>321</x>
      <y>555</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getreg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>311</x>
      <y>550</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
addr &lt; 17*sizeof(long)
如果要读取寄存器</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>311</x>
      <y>550</y>
      <w>35</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
u_debugreg[0]&lt;=addr&lt;=u_debugreg[7]
如果要读取调试寄存器，算出偏移量</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>337</x>
      <y>555</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tmp = child-&gt;thread.debugreg[addr]
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>367</x>
      <y>555</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>311</x>
      <y>550</y>
      <w>62</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;600.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>327</x>
      <y>558</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>307</x>
      <y>562</y>
      <w>34</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果要读fs，gs，从thread中读取
	retval = child-&gt;thread.fs;
	retval = child-&gt;thread.gs;
2.ds，es，ss,cs只读16位，其他读32位
	1.因为有pt_regs中没有fs，gs，所以gs之后的序号需要向前2个
	2.计算在pt_regs中的偏移，这里正负没关系，之后会越界
		regno = regno - sizeof(struct pt_regs);
	3.通过get_stack_long得到栈上寄存器的值
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>319</x>
      <y>579</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_stack_long</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>323</x>
      <y>575</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>313</x>
      <y>586</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.获取系统栈顶,每次用户栈切换系统栈时，会到这
	stack=task-&gt;thread.esp0
2.计算寄存器的实际地址
	stack += offset;//offset虽然解析时正值，但是会发生越界
3.返回栈中地址的值
	return (*((int *)stack))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>324</x>
      <y>582</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>292</x>
      <y>543</y>
      <w>101</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_POKETEXT
PTRACE_POKEDATA
写用户数据段和代码段</panel_attributes>
    <additional_attributes>10.0;10.0;990.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>382</x>
      <y>553</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>access_process_vm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>293</x>
      <y>543</y>
      <w>121</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_POKEUSR</panel_attributes>
    <additional_attributes>10.0;10.0;1190.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>401</x>
      <y>551</y>
      <w>27</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.filter和PTRACE_PEEKUSR相同
2.如果需要写寄存器（addr &lt; 17*sizeof(long)），
	通过putreg将数据写入
3.如果要写debugreg寄存器
	1.不能写4,5，
	2如果写0,1,2,3（&lt;4）需要data在用户空间
	3.如果是7,data的DR_CONTROL_RESERVED位清掉
		并且其数据需要使下列不成立
		((0x5f54 &gt;&gt; ((data &gt;&gt; (16 + 4*i)) &amp; 0xf)) &amp; 1)
	4.将addr转换之后，将data存入到thread中
		child-&gt;thread.debugreg[addr] = data
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>410</x>
      <y>573</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>putreg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>414</x>
      <y>569</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>394</x>
      <y>580</y>
      <w>45</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果是FS，gs(低2位是3，可以是0)
	child-&gt;thread.fs = value
	child-&gt;thread.gs = value
	return 0;
2.如果是ds，es（低2位是3，可以是0），ss,cs(低2位是3，所以一定不能是0)
	只取低16位
3.如果是eflag，只取value &amp;= FLAG_MASK;其他位和get_stack_long中
	相同
4.换算regno在pt_regs中的offset，并通过put_stack_long填入到栈中
注：put_stack_long和get_stack_long，只不过这个是将data写入stack中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>416</x>
      <y>576</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>293</x>
      <y>543</y>
      <w>152</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_SYSCALL
PTRACE_CONT</panel_attributes>
    <additional_attributes>10.0;10.0;1500.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>433</x>
      <y>548</y>
      <w>37</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.data要小于 _NSIG
2.如果是PTRACE_SYSCALL
	child-&gt;ptrace |= PT_TRACESYS
	如果不是，将其清掉
	child-&gt;ptrace &amp;= ~PT_TRACESYS
注：这将在每次sys_call时检测这个标志
3.child-&gt;exit_code = data;
4.将eflag中的TRAP_FLAG清掉，防止单步运行
	tmp = get_stack_long(child, EFL_OFFSET) &amp; ~TRAP_FLAG;
	put_stack_long(child, EFL_OFFSET,tmp);
5.唤醒子进程，返回0
	wake_up_process(child)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>456</x>
      <y>573</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>syscall_trace
详情查看entry.S中的system_call
在PT_TRACESYS置上时，这个函数将会执行
注;在sys_call前后都会执行一次，会让用户查看sys_call返回值</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>450</x>
      <y>580</y>
      <w>26</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.PT_PTRACED|PT_TRACESYS要置上
2.因为要使进程进sys_call时睡眠，所以stopped
	current-&gt;exit_code = SIGTRAP | ((current-&gt;ptrace &amp; PT_TRACESYSGOOD)
					? 0x80 : 0);
	current-&gt;state = TASK_STOPPED;
	notify_parent(current, SIGCHLD);
	schedule();
注:这里stopped，父进程可以查看其内存和寄存器
	例如可以将orig_eax设置为NR_syscalls，就可以跳过系统调用
3.醒来之后，检查current-&gt;exit_code，如果存在就给当前进程发
	send_sig(current-&gt;exit_code, current, 1);
	current-&gt;exit_code = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>462</x>
      <y>576</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>292</x>
      <y>543</y>
      <w>189</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_KILL</panel_attributes>
    <additional_attributes>10.0;10.0;1870.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>474</x>
      <y>547</y>
      <w>28</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.进程的state不能是TASK_ZOMBIE
2. //疑问：此时只有child在syscall_trace中schedule了，才能将这个信号发送到child
	child-&gt;exit_code = SIGKILL;
	//取消单步运行
	tmp = get_stack_long(child, EFL_OFFSET) &amp; ~TRAP_FLAG;
	put_stack_long(child, EFL_OFFSET, tmp);
	wake_up_process(child);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>293</x>
      <y>543</y>
      <w>226</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_SINGLESTEP</panel_attributes>
    <additional_attributes>10.0;10.0;2240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>506</x>
      <y>547</y>
      <w>25</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.data不能大于_NSIG
2.将sys_call的trace去掉
	child-&gt;ptrace &amp;= ~PT_TRACESYS
3.置上单步运行的标志
	child-&gt;ptrace |= PT_DTRACE;
	tmp = get_stack_long(child, EFL_OFFSET) | TRAP_FLAG;
	put_stack_long(child, EFL_OFFSET, tmp);
4.唤醒子进程
	child-&gt;exit_code = data;
	wake_up_process(child);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>950</x>
      <y>27</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>sys_ipc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>957</x>
      <y>31</y>
      <w>53</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MSGGET</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1003</x>
      <y>44</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_msgget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1008</x>
      <y>47</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>994</x>
      <y>51</y>
      <w>39</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果自己收自己发（key == IPC_PRIVATE），通过newque
	申请一个报文队列
2.如果不是IPC_PRIVATE，通过ipc_findkey，寻找key
	如果没找到：
	1.如果IPC_CREAT没置上，返回ENOENT
	2.如果置上，通过newque申请报文队列
3.如果找到了key
	1.如果IPC_CREAT和IPC_EXCL（独享）都置上，返回EEXIST
	2.通过msg_lock获取报文队列msq（ids-&gt;entries[lid].p），并获取锁（ids-&gt;ary）
		通过ipcperms检查队列中key的权限是否和msgflg要求的相同
		如果相同就通过msg_buildid为其建一个标识号
注：整个过程通过msg_ids.sem保护
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>994</x>
      <y>72</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>newque</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1000</x>
      <y>69</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>100.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>985</x>
      <y>79</y>
      <w>28</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.通过kmalloc申请msg_queue
注：msg_queue中的第一个元素就是kern_ipc_perm
	是数组指针entries指向的元素
2.通过ipc_addid在msg_ids.entries申请一个空闲位
	并将kern_ipc_perm装入entries
3.初始化msg_queue
	msq-&gt;q_perm.mode = (msgflg &amp; S_IRWXUGO);
	msq-&gt;q_perm.key = key;

	msq-&gt;q_stime = msq-&gt;q_rtime = 0;
	msq-&gt;q_ctime = CURRENT_TIME;
	msq-&gt;q_cbytes = msq-&gt;q_qnum = 0;
	msq-&gt;q_qbytes = msg_ctlmnb;
	msq-&gt;q_lspid = msq-&gt;q_lrpid = 0;
	INIT_LIST_HEAD(&amp;msq-&gt;q_messages);
	INIT_LIST_HEAD(&amp;msq-&gt;q_receivers);
	INIT_LIST_HEAD(&amp;msq-&gt;q_senders);
4.为了防止标识号在一段时间内重复，通过msg_buildid
	重构标识号：
	SEQ_MULTIPLIER*seq + id
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>998</x>
      <y>75</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>981</x>
      <y>115</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipc_addid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>986</x>
      <y>111</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>969</x>
      <y>122</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>grow_ary</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>988</x>
      <y>122</y>
      <w>29</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.遍历entries，找到其中空闲的位，如果没找到，返回-1
2.更新msg_ids：
	ids-&gt;in_use++;
	//当id大于max_id
	ids-&gt;max_id = id
3.初始化kern_ipc_perm
	new-&gt;cuid = new-&gt;uid = current-&gt;euid;
	new-&gt;gid = new-&gt;cgid = current-&gt;egid;
	new-&gt;seq = ids-&gt;seq++;
	//如果seq&gt;seq_max
	ids-&gt;seq = 0
4.安装kern_ipc_perm
	spin_lock(&amp;ids-&gt;ary)
	ids-&gt;entries[id].p = new
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>987</x>
      <y>118</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>973</x>
      <y>118</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
要求扩充到size</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>955</x>
      <y>128</y>
      <w>31</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.size最大只能是IPCMNI，并且不能缩小
2.通过ipc_alloc申请size大小的空间，valloc（&gt;1页）
	kalloc
3.通过memcpy将之前的entries复制到新申请的空间，并将其他
	空间赋值为0
4.保存之前的entries和size，并将新申请的数组赋值给entries
	old = ids-&gt;entries;
	ids-&gt;entries = new;
	i = ids-&gt;size;
	ids-&gt;size = newsize;
5.通过ipc_free释放旧的entries
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>974</x>
      <y>125</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1018</x>
      <y>73</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipc_findkey</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1014</x>
      <y>70</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1015</x>
      <y>79</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.遍历entries（最大是max_id）
	找到其中p.key是key的id
	否则返回-1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1023</x>
      <y>76</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1043</x>
      <y>72</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipcperms</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1022</x>
      <y>69</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;20.0;260.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1039</x>
      <y>78</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.将flag的u，g，o所有请求权限都集中在低3位
2.如果当前进程的euid和报文队列ipcp的cuid，uid相同，选取6~8位
	如果报文队列ipcp的cgid或者gid在当前进程的进程组中，选取3~5位
3.检查requested_mode和granted_mode是否存在不一致，或者进程有没有
	CAP_IPC_OWNER权限，当两者都不满足时返回-1，否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1049</x>
      <y>75</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>866</x>
      <y>31</y>
      <w>92</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MSGSND</panel_attributes>
    <additional_attributes>900.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>860</x>
      <y>40</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_msgsnd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>850</x>
      <y>43</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>828</x>
      <y>48</y>
      <w>45</w>
      <h>51</h>
    </coordinates>
    <panel_attributes>1.0&lt;=msgsz(message size)&lt;=msg_ctlmax
	msqid(标识号)&gt;=0
2.通过get_user获取msgp-&gt;mtype，其值不能小于1
注：msgp是用户层传下的type和message
3.通过load_msg将msgp中的数据复制到msg中，并
	msg-&gt;m_type = mtype;
	msg-&gt;m_ts = msgsz;//msg_msg长度是整个链表数据的长度
4.通过msg_lock将ids-&gt;ary上锁，并获取报文队列msq
5.通过msg_checkid检查msqid是否符合ipcp-&gt;seq
	通过ipcperms检查当前进程对msq是否有写权限
6.如果报文队列满了（msgsz+q_cbytes&gt;q_qbytes
	1+q_qnum&gt;q_qbytes(队列中的message的size可能是0)）：
	1.如果要求不等待（IPC_NOWAIT）,解锁，返回EAGAIN退出
	2.如果要求等待，通过ss_add将msg_sender挂入到msq的发送等待队列
		并通过msg_unlock解锁后schedule
	3.醒来之后：
		current-&gt;state= TASK_RUNNING;
		msq = msg_lock(msqid)//上锁
		ss_del(&amp;s);//将msg_sender从msq的发送等待队列中移除
	4.如果检测到signal_pending，返回EINTR，
		否则重新执行5
7.通过pipelined_send检测msq中是否有等待接收msg的rcv，
	如果没有，将msg挂入到msq的q_messages中：
	list_add_tail(&amp;msg-&gt;m_list,&amp;msq-&gt;q_messages);
	msq-&gt;q_cbytes += msgsz;
	msq-&gt;q_qnum++;
	atomic_add(msgsz,&amp;msg_bytes);
	atomic_inc(&amp;msg_hdrs);
8.更新数据，并返回0
	msq-&gt;q_lspid = current-&gt;pid;
	msq-&gt;q_stime = CURRENT_TIME;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>811</x>
      <y>103</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ss_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>803</x>
      <y>110</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>mss-&gt;tsk=current;
current-&gt;state=TASK_INTERRUPTIBLE;
list_add_tail(&amp;mss-&gt;list,&amp;msq-&gt;q_senders);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>813</x>
      <y>106</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>838</x>
      <y>103</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipelined_send</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>826</x>
      <y>110</y>
      <w>25</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.遍历msq的接收等待队列q_receivers
	1.通过testmsg验证在相应的r_mode下
		msg的type和msr的r_msgtype条件是否满足
	2.如果不满足，遍历下一个。
		如果满足：
		1.通过list_del将接收等待者脱链
		2.如果msg的size大于接收者的r_maxsize，返回ERR_PTR(-E2BIG)
			并通过wake_up_process唤醒msr-&gt;r_tsk
		3.如果大小满足条件：
			msr-&gt;r_msg = msg;//将msg挂入到msr中
			msq-&gt;q_lspid = msr-&gt;r_tsk-&gt;pid;
			msq-&gt;q_rtime = CURRENT_TIME;
			wake_up_process(msr-&gt;r_tsk);
			return 1;
2.遍历完整个链表，没有接受者接收这个msg，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>842</x>
      <y>106</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>782</x>
      <y>103</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>load_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>762</x>
      <y>110</y>
      <w>39</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.msg_msg管理的数据长度不能超过PAGE_SIZE-sizeof(struct msg_msg)
2.通过kmalloc申请管理结构msg和数据alen
	msg-&gt;next = NULL
3.通过copy_from_user复制用户数据到msg+1，并更新数据
	len -= alen;
	src = ((char*)src)+alen;
4.如果还有数据需要复制（说明1到了最大长度）
	1.需要通过kmalloc申请msg_msgseg和数据alen，并将管理结构加入到msg链表中
		*pseg = seg;
		seg-&gt;next = NULL;
	2.通过copy_from_user将数据复制到seg+1，并更新：
		pseg = &amp;seg-&gt;next;
		len -= alen;
		src = ((char*)src)+alen;
5.最后返回链表头msg
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>784</x>
      <y>106</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>788</x>
      <y>98</y>
      <w>48</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>816</x>
      <y>98</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>833</x>
      <y>98</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>917</x>
      <y>31</y>
      <w>42</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MSGRCV</panel_attributes>
    <additional_attributes>400.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>913</x>
      <y>50</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_msgrcv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>900</x>
      <y>39</y>
      <w>36</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果call高16位是0：
	1.通过copy_from_user将用户层的ptr复制到ipc_kludge
	2.调用sys_msgrcv接收报文
2.否则，直接调用sys_msgrcv接收message
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>918</x>
      <y>46</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>892</x>
      <y>57</y>
      <w>47</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.标识号不能小于0，要收的size不能小于0
2.通过convert_mode计算要接收的方式：
	1.如果msgtyp=0，SEARCH_ANY，任意message都收
	2.如果msgtyp&lt;0,SEARCH_LESSEQUAL,只有msg.m_type&lt;=-msgtyp才接收
	3.如果msgflg中MSG_EXCEPT置上，SEARCH_NOTEQUAL，只有msg.m_type！=msgtyp才接收
	4.除此之外，SEARCH_EQUAL，只有msg.m_type=msgtyp才接收
3.通过msg_lock得到报文队列msq，并上锁
4.通过ipcperms检查当前进程是否有msq的读权限S_IRUGO，没有返回EACCES
5.遍历报文队列的q_messages链表：
	1.通过testmsg检查在mode下msg.m_type和msgtyp是否符合条件
	2.如果符合条件：
		1.要求SEARCH_LESSEQUAL，如果msg-&gt;m_type不是最小（1）：
			//将msg定为暂时最优
			found_msg=msg;
			//继续查找更小的值
			msgtyp=msg-&gt;m_type-1;
		2.其他条件找到msg，直接退出
	3.如果没退出循环，继续查找链表
6.如果找到了message
	1.如果要接收的size小于message的size，并且MSG_NOERROR（不报错，允许截断）
		没置上，报E2BIG
	2.否则将msg脱链，并更新数据
		list_del(&amp;msg-&gt;m_list);//将msg脱链
		msq-&gt;q_qnum--;
		msq-&gt;q_rtime = CURRENT_TIME;
		msq-&gt;q_lrpid = current-&gt;pid;
		msq-&gt;q_cbytes -= msg-&gt;m_ts;
		atomic_sub(msg-&gt;m_ts,&amp;msg_bytes);
		atomic_dec(&amp;msg_hdrs);
		ss_wakeup(&amp;msq-&gt;q_senders,0);//唤醒msq的发送等待队列
		msg_unlock(msqid);//释放锁
	3.要收的长度是msgsz和msg-&gt;m_ts的最小值，通过put_user将msg-&gt;m_type
		存入到msgp，通过store_msg将数据存入到msgp
7.如果队列中没有对应的message：
	1.如果要求IPC_NOWAIT，返回ENOMSG
	2.通过list_add_tail将msr_d加入到msq的接收等待队列中
		msr_d.r_tsk = current;
		msr_d.r_msgtype = msgtyp;
		msr_d.r_mode = mode;	
		//当MSG_NOERROR置上是INT_MAX
		msr_d.r_maxsize = msgsz
		msr_d.r_msg = ERR_PTR(-EAGAIN);//默认返回EAGAIN，不是接收的到信息唤醒
		current-&gt;state = TASK_INTERRUPTIBLE;
		msg_unlock(msqid);
		schedule();
	3.如果醒来之后：
		1.current-&gt;state = TASK_RUNNING
		2.如果接收到msg（msr_d.r_msg），去6.3执行
		3.试图通过msg_lock获取锁和msq
			1.因为获取锁可能等待，需要再次检查msr_d.r_msg，如果收到了msg
				去6.3执行
			2.如果检测到是EAGAIN（不是接收msg唤醒）
				1.通过list_del将接收者msr_d从报文的接收等待队列中删除
				2.如果signal_pending，返回EINTR
				3.否则继续执行4
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>918</x>
      <y>53</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>897</x>
      <y>152</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ss_wakeup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>921</x>
      <y>152</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>store_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>902</x>
      <y>146</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>914</x>
      <y>146</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>883</x>
      <y>159</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.遍历msq的发送等待队列msq-&gt;q_senders
	通过wake_up_process唤醒队列中sender
	对应的mss-&gt;tsk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>898</x>
      <y>155</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>924</x>
      <y>155</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>915</x>
      <y>158</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.遍历msg链表，将其中的内容，通过copy_to_user
	存放在用户空间
注：msg链表的具体结构参考load_msg
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>957</x>
      <y>31</y>
      <w>147</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MSGCTL</panel_attributes>
    <additional_attributes>10.0;10.0;1450.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1094</x>
      <y>45</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_msgctl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1083</x>
      <y>52</y>
      <w>32</w>
      <h>58</h>
    </coordinates>
    <panel_attributes>IPC_INFO，MSG_INFO：
	memset(&amp;msginfo,0,sizeof(msginfo));	
	msginfo.msgmni = msg_ctlmni;
	msginfo.msgmax = msg_ctlmax;
	msginfo.msgmnb = msg_ctlmnb;
	msginfo.msgssz = MSGSSZ;
	msginfo.msgseg = MSGSEG
	msginfo.msgpool = msg_ids.in_use;
	msginfo.msgmap = atomic_read(&amp;msg_hdrs);
	msginfo.msgtql = atomic_read(&amp;msg_bytes);
	copy_to_user
MSG_STAT，IPC_STAT：
	kernel_to_ipc64_perm(&amp;msq-&gt;q_perm, &amp;tbuf.msg_perm);
	tbuf.msg_stime  = msq-&gt;q_stime;
	tbuf.msg_rtime  = msq-&gt;q_rtime;
	tbuf.msg_ctime  = msq-&gt;q_ctime;
	tbuf.msg_cbytes = msq-&gt;q_cbytes;
	tbuf.msg_qnum   = msq-&gt;q_qnum;
	tbuf.msg_qbytes = msq-&gt;q_qbytes;
	tbuf.msg_lspid  = msq-&gt;q_lspid;
	tbuf.msg_lrpid  = msq-&gt;q_lrpid;
	copy_msqid_to_user
IPC_SET:
	copy_msqid_from_user
	msq-&gt;q_qbytes = setbuf.qbytes;
	ipcp-&gt;uid = setbuf.uid;
	ipcp-&gt;gid = setbuf.gid;
	ipcp-&gt;mode = (ipcp-&gt;mode &amp; ~S_IRWXUGO) | 
		(S_IRWXUGO &amp; setbuf.mode);
	msq-&gt;q_ctime = CURRENT_TIME;
	//因为改变了msq的属性，需要唤醒接收和发送等待队列，重新检查
	expunge_all(msq,-EAGAIN);
	ss_wakeup(&amp;msq-&gt;q_senders,0)
IPC_RMID：释放msq
	freeque (msqid)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1098</x>
      <y>48</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1077</x>
      <y>114</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expunge_all</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1104</x>
      <y>115</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>freeque</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1081</x>
      <y>109</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1097</x>
      <y>109</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1069</x>
      <y>120</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.遍历msq的q_receivers链表：
	msr-&gt;r_msg = ERR_PTR(res);//res是传参
	wake_up_process(msr-&gt;r_tsk);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1080</x>
      <y>117</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1094</x>
      <y>122</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>msg_rmid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1094</x>
      <y>129</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipc_rmid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1098</x>
      <y>118</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1099</x>
      <y>125</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1087</x>
      <y>136</y>
      <w>26</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.检查标识号在entries中的位置id % SEQ_MULTIPLIER
	并提取msq
	p = ids-&gt;entries[lid].p;
	ids-&gt;entries[lid].p = NULL;
	ids-&gt;in_use--;
2.如果lid是max_id，需要为其重新选择max_id
	1.倒序遍历id（lid--）,直到找到第一个不为NULL的entry
		ids-&gt;max_id = lid;
3.返回msq
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1100</x>
      <y>132</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1114</x>
      <y>123</y>
      <w>27</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.唤醒接收等待队列，提醒id_remove
	expunge_all(msq,-EIDRM);
2.唤醒发送等待队列，并脱链
	ss_wakeup(&amp;msq-&gt;q_senders,1);
3.遍历q_messages链表：
	atomic_dec(&amp;msg_hdrs);
	free_msg(msg);
4.更新数据，并释放
	atomic_sub(msq-&gt;q_cbytes, &amp;msg_bytes);
	kfree(msq);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1108</x>
      <y>118</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>958</x>
      <y>31</y>
      <w>179</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SHMGET</panel_attributes>
    <additional_attributes>10.0;10.0;1770.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1130</x>
      <y>44</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_shmget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1122</x>
      <y>51</y>
      <w>37</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.如果IPC_PRIVATE，直接通过newseg申请shmid_kernel
2.通过ipc_findkey查看在shm_ids中是否找到key
	如果不能找到，
	1.如果IPC_CREAT没置，返回ENOENT
	2.如果置上，通过newseg申请shmid_kernel
	如果能找到
	1.如果IPC_CREAT置上，IPC_EXCL（独享）置上，返回EEXIST
	2.通过shm_lock在entries获取shp，并获取锁
	3.shp-&gt;shm_segsz要大于要获取的size
	4.通过ipcperms对比权限
	5.通过shm_buildid获取统一标识号
	6.通过shm_unlock释放锁
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1135</x>
      <y>47</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1132</x>
      <y>75</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>newseg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1137</x>
      <y>71</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1138</x>
      <y>78</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1122</x>
      <y>82</y>
      <w>37</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.SHMMIN&lt;=size&lt;=shm_ctlmax
2.shm_tot+numpages(size的页大小)要小于shm_ctlall
3.通过kmalloc申请shmid_kernel结构shp
4.通过shmem_file_setup给shp分配file
5.通过shm_addid（ipc_addid）给shp分配统一标识号
6.初始化shp
	shp-&gt;shm_perm.key = key;
	shp-&gt;shm_flags = (shmflg &amp; S_IRWXUGO);
	shp-&gt;shm_cprid = current-&gt;pid;
	shp-&gt;shm_lprid = 0;
	shp-&gt;shm_atim = shp-&gt;shm_dtim = 0;
	shp-&gt;shm_ctim = CURRENT_TIME;
	shp-&gt;shm_segsz = size;
	shp-&gt;shm_nattch = 0;
	shp-&gt;id = shm_buildid(id,shp-&gt;shm_perm.seq);
	shp-&gt;shm_file = file;
	file-&gt;f_dentry-&gt;d_inode-&gt;i_ino = shp-&gt;id;
	file-&gt;f_op = &amp;shm_file_operations;
	shm_tot += numpages;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1149</x>
      <y>118</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shmem_file_setup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1144</x>
      <y>113</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1085</x>
      <y>0</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_shmem_fs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1070</x>
      <y>8</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1076</x>
      <y>3</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历file_systems链表
看有没有shmem_fs_type
没有就将其挂入到链表</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1098</x>
      <y>10</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kern_mount
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1088</x>
      <y>3</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1.获取设备号get_unnamed_dev
2.read_super
3.add_vfsmnt，</panel_attributes>
    <additional_attributes>50.0;10.0;150.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1143</x>
      <y>125</y>
      <w>33</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.通过vm_enough_memory验证有没有足够的物理内存供共享内存
2.申请dentry
	//kern_mount中将root赋值
	root = shmem_fs_type.kern_mnt-&gt;mnt_root;
	dentry = d_alloc(root, &amp;this);
3.通过get_empty_filp申请file
4.通过shmem_get_inode获取inode
5.初始化dentry，file
	//将dentry和inode挂钩
	d_instantiate(dentry, inode);
	dentry-&gt;d_inode-&gt;i_size = size;
	file-&gt;f_vfsmnt = mntget(shmem_fs_type.kern_mnt);
	file-&gt;f_dentry = dentry;
	file-&gt;f_op = &amp;shmem_file_operations;
	file-&gt;f_mode = FMODE_WRITE | FMODE_READ;
	inode-&gt;i_nlink = 0;	/* It is unlinked */
	return(file);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1155</x>
      <y>121</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1153</x>
      <y>156</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shmem_get_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1158</x>
      <y>152</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1144</x>
      <y>163</y>
      <w>32</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.检查有没有空闲inode，并递减
	sb-&gt;u.shmem_sb.free_inodes--;
2.通过new_inode申请inode
3.初始化inode
	inode-&gt;i_mode = mode;
	inode-&gt;i_uid = current-&gt;fsuid;
	inode-&gt;i_gid = current-&gt;fsgid;
	inode-&gt;i_blksize = PAGE_CACHE_SIZE;
	inode-&gt;i_blocks = 0;
	inode-&gt;i_rdev = to_kdev_t(dev);
	inode-&gt;i_mapping-&gt;a_ops = &amp;shmem_aops;
	inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;
	spin_lock_init (&amp;inode-&gt;u.shmem_i.lock);
	S_IFREG：
	inode-&gt;i_op = &amp;shmem_inode_operations;
	inode-&gt;i_fop = &amp;shmem_file_operations;
	S_IFDIR：
	inode-&gt;i_op = &amp;shmem_dir_inode_operations;
	inode-&gt;i_fop = &amp;shmem_dir_operations;
	S_IFLNK：
	inode-&gt;i_op = &amp;page_symlink_inode_operations;
	其他：
	init_special_inode(inode, mode, dev);
4.将inode挂入到shmem_inodes链表中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1158</x>
      <y>159</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1170</x>
      <y>43</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_shmat</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>957</x>
      <y>31</y>
      <w>222</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SHMAT</panel_attributes>
    <additional_attributes>10.0;10.0;2200.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1162</x>
      <y>50</y>
      <w>36</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.标识号不能小于0
2.	如果指定了映射的地址shmaddr
	1.如果没按页对齐：
		如果SHM_RND（自动调整）置上，
		addr &amp;= ~(SHMLBA-1)
		如果没置上：返回EINVAL
	2.flags = MAP_SHARED | MAP_FIXED//fixed表示map地址固定
	如果没指定地址(shmaddr为0)
	flags = MAP_SHARED;
3.转换shmflg的权限
4.通过shm_lock获取shp，并上锁
5.通过ipcperms验证当前进程对shp的权限
6.获取file
	file = shp-&gt;shm_file;
	shp-&gt;shm_nattch++;
7.通过do_mmap获取虚存空间（current-&gt;mm-&gt;mmap_sem保护）
8.将shp的attach计数递减
	shp-&gt;shm_nattch--
	如果减到0，并且SHM_DEST置上，通过shm_destroy将shp释放
9.raddr返回map的地址
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1176</x>
      <y>46</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1167</x>
      <y>86</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shm_mmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1172</x>
      <y>82</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
do_mmap-&gt;do_mmap_pgoff-&gt;
file-&gt;f_op-&gt;mmap(shm_file_operations)</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1162</x>
      <y>93</y>
      <w>25</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.通过UPDATE_ATIME更新inode-&gt;i_atime
	并且其中利用mark_inode_dirty_sync
	将inode置上I_DIRTY_SYNC
2.vma-&gt;vm_ops = &amp;shm_vm_ops;//do_page_fault中用
3.通过shm_inc递增attache计数
	shp-&gt;shm_atim = CURRENT_TIME;
	shp-&gt;shm_lprid = current-&gt;pid;
	shp-&gt;shm_nattch++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1172</x>
      <y>89</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1194</x>
      <y>86</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shm_destroy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1187</x>
      <y>82</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1191</x>
      <y>93</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>shm_tot -= (shp-&gt;shm_segsz + PAGE_SIZE - 1) &gt;&gt; PAGE_SHIFT;
shm_rmid (shp-&gt;id);
fput (shp-&gt;shm_file);
kfree (shp)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1200</x>
      <y>89</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1188</x>
      <y>111</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shmem_nopage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1175</x>
      <y>107</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
do_no_page-&gt;
vma-&gt;vm_ops-&gt;nopage(shm_vm_ops)</panel_attributes>
    <additional_attributes>50.0;10.0;200.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1181</x>
      <y>118</y>
      <w>41</w>
      <h>59</h>
    </coordinates>
    <panel_attributes>1.计算访问的地址在文件中的页偏移
	idx = (address - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT;
	idx += vma-&gt;vm_pgoff;//vm_pgoffi是start在file中的页偏移
2.在vm_mm是当前进程的mm时，要访问的页不能大于inode的size，vma
3.通过__find_lock_page在page_hash_table中查找page
4.如果找到，跳到6
	如果没找到，通过shmem_swp_entry勋在在设备上的entry：
	1.如果entry-&gt;val不为零：
		1.首先通过lookup_swap_cache查找页面是否在交换队列swapper_space中
		2.如果没找到，去交换盘中将page读进内存
			swapin_readahead(*entry);
			page = read_swap_cache(*entry);
		3.将page从swapper_space移除
			swap_free(*entry);
			lock_page(page);
			delete_from_swap_cache_nolock(page);
			*entry = (swp_entry_t) {0};
		4.将page加入到inode-&gt;i_mapping中：
			flags = page-&gt;flags &amp; ~((1 &lt;&lt; PG_uptodate) | (1 &lt;&lt; PG_error) | (1 &lt;&lt; PG_referenced) | (1 &lt;&lt; PG_arch_1));
			page-&gt;flags = flags | (1 &lt;&lt; PG_dirty);
			add_to_page_cache_locked(page, mapping, idx);
			info-&gt;swapped--;
	2.如果entry-&gt;val为零,表示没有交换到盘上，需要从内存重新申请;
		inode-&gt;i_sb-&gt;u.shmem_sb.free_blocks--
		page = page_cache_alloc();
		clear_user_highpage(page, address);
		inode-&gt;i_blocks++;
		add_to_page_cache (page, mapping, idx);
5.将page uptodate
	SetPageUptodate
6.如果不要求共享（no_share）
	new_page = page_cache_alloc
	copy_user_highpage(new_page, page, address)
	page_cache_release(page);
	return new_page;
7.如果要求共享，返回page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1194</x>
      <y>114</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1182</x>
      <y>181</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shmem_swp_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1179</x>
      <y>188</y>
      <w>26</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果是直接映射（SHMEM_NR_DIRECT），
	返回info-&gt;i_direct+index
2.如果SHMEM_NR_DIRECT&lt; index&lt;ENTRIES_PER_PAGE*ENTRIES_PER_PAGE
	如果i_indirect为NULL,先为其分配get_zeroed_page
	如果i_indirect[index/ENTRIES_PER_PAGE]为NULL,也先为其分配get_zeroed_page
注：i_direct是数组，i_indirect又为其分配零页
	所以返回的entry地址必定存在，只不过里面的内容可能是零
3.返回index在i_indirect中的间接引用
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1188</x>
      <y>184</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1187</x>
      <y>176</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>958</x>
      <y>31</y>
      <w>263</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SHMDT</panel_attributes>
    <additional_attributes>10.0;10.0;2610.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1212</x>
      <y>40</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_shmdt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1204</x>
      <y>47</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.遍历vma链表（current-&gt;mm.mmap），
	其vm_ops要是shm_vm_ops
	要释放的地址shmaddr=vm_start-vm_pgoff(vm_pgoff在sys_shmat中为0)
	满足以上两个条件，通过do_munmap将vma释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1218</x>
      <y>43</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1242</x>
      <y>38</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_shmctl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1247</x>
      <y>41</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1238</x>
      <y>45</y>
      <w>30</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.SHM_LOCK/SHM_UNLOCK
	1.进程要有CAP_IPC_LOCK
	2.shm_lock获取shp，并上锁
	3.shm_checkid检查标识号
	4.SHM_LOCK：
		shp-&gt;shm_file-&gt;f_dentry-&gt;d_inode-&gt;u.shmem_i.locked = 1;
		shp-&gt;shm_flags |= SHM_LOCKED;
	SHM_UNLOCK：
		shp-&gt;shm_file-&gt;f_dentry-&gt;d_inode-&gt;u.shmem_i.locked = 0;
		shp-&gt;shm_flags &amp;= ~SHM_LOCKED;
	5.通过	shm_unlock解锁shp
2.其他的和sys_msgctl相似
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>958</x>
      <y>31</y>
      <w>291</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SHMCTL</panel_attributes>
    <additional_attributes>10.0;10.0;2890.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>957</x>
      <y>31</y>
      <w>334</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SEMGET</panel_attributes>
    <additional_attributes>10.0;10.0;3320.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1282</x>
      <y>37</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_semget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1282</x>
      <y>44</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>newary</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1287</x>
      <y>40</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
其他和MSGGET相似
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1273</x>
      <y>51</y>
      <w>33</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.如果要申请的这组信号量的数目nsems是0，返回EINVAL
2.如果用的信号量的数目（used_sems + nsems）超过了
	sc_semmns，返回ENOSPC
3.通过ipc_alloc申请sma和nsems个信号量的内存空间
	并清0
注：为了防止死锁，用户每次申请信号量是所有的信号量一起申请
4.通过ipc_addid在sem_ids中找到空闲的entry
5.更新并初始化：
	used_sems += nsems;
	sma-&gt;sem_perm.mode = (semflg &amp; S_IRWXUGO);
	sma-&gt;sem_perm.key = key;
	//sma后面紧接着就是sem
	sma-&gt;sem_base = (struct sem *) &amp;sma[1];
	/* sma-&gt;sem_pending = NULL; */
	sma-&gt;sem_pending_last = &amp;sma-&gt;sem_pending;
	/* sma-&gt;undo = NULL; */
	sma-&gt;sem_nsems = nsems;
	sma-&gt;sem_ctime = CURRENT_TIME;
6.通过sem_buildid生成统一标识号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1287</x>
      <y>47</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>957</x>
      <y>31</y>
      <w>375</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SEMOP</panel_attributes>
    <additional_attributes>10.0;10.0;3730.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1324</x>
      <y>36</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_semop</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1329</x>
      <y>39</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1310</x>
      <y>43</y>
      <w>63</w>
      <h>77</h>
    </coordinates>
    <panel_attributes>1.	1&lt;nsops&lt;sc_semopm,semid&gt;=0
2.当nsops&gt;SEMOPM_FAST时，就不用栈上的空间了
	需要通过kmalloc申请到nsops个sembuf的内存
3.将用户层想要申请的一组信号量tsops通过copy_from_user
	复制到sops
4.通过sem_lock获取sma并上锁，并通过sem_checkid检查标识号
5.遍历sops数组，记录其中的SEM_UNDO的数量undos，是否申请decrease
	是否释放alter，最后alter表示是否改变（lter |= decrease）
注：SEM_UNDO：是进程exit之后，如果没将信号量释放，内核会自动释放(sem_exit)
6.通过ipcperms验证当前进程的权限，如果要申请或者释放，需要写
	否则只需要读
7.遍历进程的current-&gt;semundo链表(proc_next链接)，
	1.如果semid为-1，通过freeundos释放（因为semundo是单向链表，所以需要重新遍历链表，然后再将其从链表中删除）
	2.如果semid和现在要申请的相同，即找到，退出循环
	3.如果遍历完整个链表都没找到，通过alloc_undo申请sem_undo
8.通过try_atomic_semop申请释放信号量（do_undo是0，表示不是查询，是真实的想申请）
9.如果申请到了，去update处处理sma的等待链表
	如果没申请到，初始化queue，并加入到sma的sem_pending链表中
	queue.sma = sma;
	queue.sops = sops;
	queue.nsops = nsops;
	queue.undo = un;
	queue.pid = current-&gt;pid;
	queue.alter = decrease;
	queue.id = semid;
	如果alter（信号量改变），append_to_queue尾插至链表（sem_pending_last指向最后一个箭头，q-&gt;prev指向（指向自己的）箭头）
	否则通过prepend_to_queue头插至链表
	current-&gt;semsleeping = &amp;queue;
10.循环等待信号量：
	1.让进程睡眠：
		//默认返回状态是EINTR
		queue.status = -EINTR;
		queue.sleeper = current;
		current-&gt;state = TASK_INTERRUPTIBLE;
		sem_unlock(semid);
		schedule();
	2.进程醒来时：
		1.通过sem_lock获取sma，如果没获取到，说明是因为sma被释放唤醒，此时queue.status=EIDRM
		2.queue.status为1，表示是在其他进程update_queue时，试着给当前进程申请信号量成功
			所以通过try_atomic_semop真正去申请，如果成功，退出循环；如果失败，继续循环1
		3.queue.status不为1时：
			1.如果queue.prev存在，所以queue在sem_pending链表中，所以是信号唤醒，所以退出等待，通过remove_from_queue将queue移除队列
			，处理信号
			2.如果不在链表中，只有可能是其他进程在update_queue时，为其申请信号量时出错，remove_from_queue
				所以返回queue.status（这里因为在update_queue中已经移除了queue，所以不用再移除）
11.如果能正常申请到信号量（或者信号唤醒？）	，如果信号量发生了改变（alter），通过update_queue
	去唤醒sem_pending链表中的等待队列	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1303</x>
      <y>125</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_undo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1309</x>
      <y>119</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1293</x>
      <y>133</y>
      <w>25</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.通过kmalloc申请sem_undo管理结构，和其semadj
	数组（sma-&gt;sem_nsems个元素），并清0
2.因为kmalloc有可能睡，所以通过sem_revalidate重新检查
	sma，标识号，权限
3.初始化：
	//exit后要调整的值
	un-&gt;semadj = (short *) &amp;un[1];
	un-&gt;semid = semid;
	//头插至current-&gt;semundo链表中
	un-&gt;proc_next = current-&gt;semundo;
	current-&gt;semundo = un;
	//头插至sma-&gt;undo链表中
	un-&gt;id_next = sma-&gt;undo;
	sma-&gt;undo = un;
	//返回值
	*unp = un;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1304</x>
      <y>128</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1326</x>
      <y>126</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>try_atomic_semop</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1330</x>
      <y>119</y>
      <w>3</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1320</x>
      <y>133</y>
      <w>27</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.遍历数组sops，找到数组在sma中对应的sem
	curr = sma-&gt;sem_base + sop-&gt;sem_num;
	1.如果要申请的信号量sem_op为0，并且sem存在可申请的值semval
	将其block（为什么？）
	2.curr-&gt;sempid低16位记入最新申请的进程
		curr-&gt;sempid = (curr-&gt;sempid &lt;&lt; 16) | pid;
		//申请释放信号量
		curr-&gt;semval += sem_op;
		//SEM_UNDO
		un-&gt;semadj[sop-&gt;sem_num] -= sem_op;
	3.如果申请信号量之后semval &lt; 0将会block
		如果semval&gt;SEMVMX,将会返回ERANGE
2.如果do_undo置上，将会将所有申请的信号量还原，只是为了
	尝试申请，看是否能申请到
注：如果block：
		1.如果IPC_NOWAIT置上，则返回EAGAIN，否则返回1
	如果出错，或者block，或者do_undo，
		1.都会将其申请的信号量，记入的pid，以及进程记入的undo还原

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1332</x>
      <y>129</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1350</x>
      <y>126</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>update_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1352</x>
      <y>120</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1349</x>
      <y>133</y>
      <w>28</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.遍历sem_pending链表：
	1.如果queue能申请到（q-&gt;status == 1），直接跳过
	2.通过try_atomic_semop试图（在要改变信号量时q-&gt;alter）为其申请信号量
	3.如果申请成功或者出错：
		1.通过wake_up_process唤醒进程
		2.如果申请成功，并且需要改变（q-&gt;alter）
			q-&gt;status = 1;
		注：1.这里没有将queue从链表中移除
			 2.这里只要能申请成功，就直接返回，所以使用的队列的方式，和进程的优先级没关系
		3.如果出错，移除queue，并继续循环
			q-&gt;status = error;
			remove_from_queue(sma,q);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1357</x>
      <y>129</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>957</x>
      <y>31</y>
      <w>437</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SEMCTL</panel_attributes>
    <additional_attributes>10.0;10.0;4350.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1386</x>
      <y>36</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_semctl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1379</x>
      <y>43</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>SETVAL：给单个信号量设置semval
SETALL：给sma这组所有的信号量设置semval
GETALL：获取sma这组所有的信号量semval
GETNCNT：获取sma中因为某个信号量因获取信号量被pending的queue数目
注：其他和sys_msgctl类似，参考代码
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1391</x>
      <y>39</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1360</x>
      <y>409</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_socketcall</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>678</x>
      <y>412</y>
      <w>690</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_SOCKET</panel_attributes>
    <additional_attributes>6880.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>673</x>
      <y>429</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_socket</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>660</x>
      <y>436</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>664</x>
      <y>432</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>651</x>
      <y>443</y>
      <w>30</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.域：0&lt;=family&lt;NPROTO
2.将(PF_INET,SOCK_PACKET)转换成PF_PACKET
3.如果net_families[family]为空，利用request_module请求模块，如果还为空返回EAFNOSUPPORT
4.通过sock_alloc申请inode（socket是inode内的结构）
	sock-&gt;type  = type;
5.调用 net_families[family]-&gt;create创建socket
6.*res = sock
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>664</x>
      <y>439</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>650</x>
      <y>459</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>653</x>
      <y>455</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>636</x>
      <y>466</y>
      <w>30</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.通过sock_alloc获取inode
2.初始化inode
	inode-&gt;i_sb = sock_mnt-&gt;mnt_sb;//sock_mnt在sock_init中被kern_mount
	sock = socki_lookup(inode);//sock为inode中的union结构
	inode-&gt;i_mode = S_IFSOCK|S_IRWXUGO;
	inode-&gt;i_sock = 1;
	inode-&gt;i_uid = current-&gt;fsuid;
	inode-&gt;i_gid = current-&gt;fsgid;
3.初始化sock
	sock-&gt;inode = inode;
	init_waitqueue_head(&amp;sock-&gt;wait);
	sock-&gt;fasync_list = NULL;
	sock-&gt;state = SS_UNCONNECTED;
	sock-&gt;flags = 0;
	sock-&gt;ops = NULL;
	sock-&gt;sk = NULL;
	sock-&gt;file = NULL;
	sockets_in_use[smp_processor_id()].counter++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>654</x>
      <y>462</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>671</x>
      <y>459</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>net_families[family]-&gt;create
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>666</x>
      <y>455</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>680</x>
      <y>462</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 unix_family_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>675</x>
      <y>466</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>671</x>
      <y>473</y>
      <w>31</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果protocol存在，就必须是PF_UNIX
	不存在默认是PF_UNIX
2.默认是unconnected
	sock-&gt;state = SS_UNCONNECTED
3.sock-&gt;type：
	SOCK_STREAM：sock-&gt;ops = &amp;unix_stream_ops
	SOCK_RAW-&gt;SOCK_DGRAM:sock-&gt;ops = &amp;unix_dgram_ops
4.通过unix_create1申请sock结构
注：socket和sock一一对应
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>681</x>
      <y>469</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>679</x>
      <y>491</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_create1</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>684</x>
      <y>488</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>684</x>
      <y>494</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>672</x>
      <y>497</y>
      <w>32</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.unix_nr_socks不能超过2*files_stat.max_files
2.通过sk_alloc申请sk
	1.在sk_cachep中申请
	2.如果zero_it置上：
		memset(sk, 0, sizeof(struct sock));
		sk-&gt;family = family;
		sock_lock_init(sk);
3.增加unix_nr_socks计数
4.sock_init_data初始化sk：
	skb_queue_head_init(&amp;sk-&gt;receive_queue);
	skb_queue_head_init(&amp;sk-&gt;write_queue);
	skb_queue_head_init(&amp;sk-&gt;error_queue);
	init_timer(&amp;sk-&gt;timer);
	sk-&gt;rcvbuf	=	sysctl_rmem_default;
	sk-&gt;sndbuf	=	sysctl_wmem_default;
	sk-&gt;state_change	=	sock_def_wakeup;
	sk-&gt;data_ready		=	sock_def_readable;
	...
5.继续初始化sk
	sk-&gt;write_space		=	unix_write_space;

	sk-&gt;max_ack_backlog = sysctl_unix_max_dgram_qlen;
	sk-&gt;destruct = unix_sock_destructor;
	sk-&gt;protinfo.af_unix.dentry=NULL;
	sk-&gt;protinfo.af_unix.mnt=NULL;
	sk-&gt;protinfo.af_unix.lock = RW_LOCK_UNLOCKED;
	atomic_set(&amp;sk-&gt;protinfo.af_unix.inflight, 0);
	//信号量设置为1
	init_MUTEX(&amp;sk-&gt;protinfo.af_unix.readsem);/* single task reading lock */
	init_waitqueue_head(&amp;sk-&gt;protinfo.af_unix.peer_wait);
	sk-&gt;protinfo.af_unix.list=NULL;
6.通过unix_insert_socket将sk加入到hash表中，这里加到unix_socket_table
	最后一个中（容纳unbound）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>682</x>
      <y>540</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_insert_socket</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>687</x>
      <y>536</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>675</x>
      <y>546</y>
      <w>27</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.sk-&gt;protinfo.af_unix.list指向hash头
	sk-&gt;protinfo.af_unix.list = list
2.将sk头插至hash中
	sk-&gt;prev = NULL;
	sk-&gt;next = *list;
	if (*list)
		(*list)-&gt;prev = sk;
	*list=sk;
3.通过sock_hold递增refcnt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>686</x>
      <y>543</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>688</x>
      <y>437</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_map_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>678</x>
      <y>432</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>685</x>
      <y>444</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过get_unused_fd从当前进程的open_fds位图中获取空闲fd
2.通过get_empty_filp获取file结构体
3.通过d_alloc给file-&gt;f_dentry申请dentry，注意这里的parent是sock_mnt-&gt;mnt_sb-&gt;s_root
4.初始化file，并将dentry和inode关联
	file-&gt;f_dentry-&gt;d_op = &amp;sockfs_dentry_operations;
	d_add(file-&gt;f_dentry, sock-&gt;inode);
	file-&gt;f_vfsmnt = mntget(sock_mnt);

	sock-&gt;file = file;
	file-&gt;f_op = sock-&gt;inode-&gt;i_fop = &amp;socket_file_ops;
	file-&gt;f_mode = 3;
	file-&gt;f_flags = O_RDWR;
	file-&gt;f_pos = 0;
5.通过fd_install将file安装在fd处，并返回fd
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>694</x>
      <y>440</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>762</x>
      <y>430</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_bind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>766</x>
      <y>412</y>
      <w>603</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_BIND</panel_attributes>
    <additional_attributes>6010.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>736</x>
      <y>438</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sockfd_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>741</x>
      <y>433</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>733</x>
      <y>445</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过fget获取file（增加了file的计数）
2.找到file中的inode（i_sock标志位要存在），
	并通过socki_lookup找到inode中的uion--socket结构
3.检查socket中的file指针是否指向该file
	（sock_map_fd中关联）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>741</x>
      <y>441</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>762</x>
      <y>439</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>move_addr_to_kernel</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>759</x>
      <y>445</y>
      <w>25</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.要复制的长度0&lt;=ulen&lt;=ulen
2.如果长度ulen是0，直接返回0，不bind
3.通过copy_from_user复制地址（包括sa_family）
	到内核
注：kernel的内存是在栈上申请的MAX_SOCK_ADDR字节的地址
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>766</x>
      <y>433</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>769</x>
      <y>442</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>769</x>
      <y>433</y>
      <w>57</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放socket.file</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>818</x>
      <y>439</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sockfd_put</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>803</x>
      <y>440</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;bind
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>768</x>
      <y>433</y>
      <w>43</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果需要bind</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>792</x>
      <y>448</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_bind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>793</x>
      <y>443</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops/unix_dgram_ops</panel_attributes>
    <additional_attributes>160.0;10.0;60.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>765</x>
      <y>455</y>
      <w>54</w>
      <h>59</h>
    </coordinates>
    <panel_attributes>1.获取sk：
	sk = sock-&gt;sk
2.以sockaddr_un解析用户层传来的地址
3.用户传来的sun_family必须是AF_UNIX
4.如果传来的长度addr_len是short，表示是自动分配地址
	通过unix_autobind完成
5.通过unix_mkname解析name，并计算hash
 //readsem临界区
6.如果sk的早就bind（sk-&gt;protinfo.af_unix.addr），返回EINVAL
7.通过kmalloc申请unix_address和其name（sockaddr_un）的内存空间，并初始化：
	memcpy(addr-&gt;name, sunaddr, addr_len);
	addr-&gt;len = addr_len;
	addr-&gt;hash = hash^sk-&gt;type;
	atomic_set(&amp;addr-&gt;refcnt, 1);
8.如果是普通地址：
	1.通过path_init和path_walk找到传来地址（sun_path）的父目录（sun_path）
	2.最后一个元素要是LAST_NORM
	3.通过lookup_hash找到文件的dentry，不管有没有找到都会返回dentry，没找到dentry中的inode会是NULL
	4.如果是文件夹（最后一个字节是/），其inode要存在
	5.通过vfs_mknod创建socket的inode
		inode-&gt;i_fop = &amp;bad_sock_fops;
	注：这里没把dentry挂入到hash表中，所以不能用fops的open打开，不然会有两个inode
	6.替换nd下的dentry为socket的dentry
		dput(nd.dentry);
		nd.dentry = dentry;
	7.以inode的i_ino为hash值选择在unix_socket_table中的链表list，并将其dentry和mnt赋给sk
		sk-&gt;protinfo.af_unix.dentry = nd.dentry;
		sk-&gt;protinfo.af_unix.mnt = nd.mnt;
9.如果是抽象地址（!sun_path[0]）
	1.通过__unix_find_socket_byname遍历unix_socket_table中对应的链表（注意：其hash值在前面有对type异或）
		查找其中有没有name相同的sk
	2.如果有，释放addr，并退出。如果没有选择在unix_socket_table中的链表（addr-&gt;hash）
10.通过__unix_remove_socket将sk移除hash表，
11.赋值addr
	sk-&gt;protinfo.af_unix.addr = addr;
12.将sk通过__unix_insert_socket加到对应的hash中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>798</x>
      <y>451</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>760</x>
      <y>518</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_autobind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>787</x>
      <y>519</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_mkname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>779</x>
      <y>526</y>
      <w>28</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.len如果不在sizeof(short)~sizeof(*sunaddr)之间，返回EINVAL
2.如果sunaddr不存在，或者sun_family不是AF_UNIX，返回EINVAL
3.如果是普通地址（首字节不是0）
	1.在sun_path最后一位添0，使其字符串结束
	2.返回的长度是:地址字符串的长度+sun_family长度
4.如果是抽象地址（首字节是0），通过unix_hash_fold对其checksum(csum_partial)
	计算hash，返回len是传进来的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>792</x>
      <y>522</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>815</x>
      <y>519</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__unix_remove_socket</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>811</x>
      <y>526</y>
      <w>25</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.找到sk挂载的hash表
	list = sk-&gt;protinfo.af_unix.list
2.先和前后断开
	if (sk-&gt;next)
		sk-&gt;next-&gt;prev = sk-&gt;prev;
	if (sk-&gt;prev)
		sk-&gt;prev-&gt;next = sk-&gt;next;
3.如果是list的第一个，指向下一个
	if (*list == sk)
		*list = sk-&gt;next;
4.还原，并释放sk
	sk-&gt;protinfo.af_unix.list = NULL;
	sk-&gt;prev = NULL;
	sk-&gt;next = NULL;
	__sock_put(sk);//递减refcnt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>821</x>
      <y>522</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>792</x>
      <y>513</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>787</x>
      <y>513</y>
      <w>6</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>765</x>
      <y>513</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>749</x>
      <y>526</y>
      <w>29</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.sk-&gt;protinfo.af_unix.addr不能存在
2.通过kmalloc申请unix_address+sockaddr_un（name是16字节）
	内存，并清0
3.初始化addr
	addr-&gt;name-&gt;sun_family = AF_UNIX;
	atomic_set(&amp;addr-&gt;refcnt, 1);
	addr-&gt;len（长度是ordernum+1+sizeof(short)，首字节是0）
	addr-&gt;hash = unix_hash_fold
4.递增ordernum = (ordernum+1)&amp;0xFFFFF
5.通过__unix_find_socket_byname寻找hash中有没有对应的sk
	如果有，再次计算len，hash
6.真实hash
	addr-&gt;hash ^= sk-&gt;type;
7.地址，挂载hash
	__unix_remove_socket(sk);
	sk-&gt;protinfo.af_unix.addr = addr;
	__unix_insert_socket(&amp;unix_socket_table[addr-&gt;hash], sk);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>764</x>
      <y>521</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>910</x>
      <y>412</y>
      <w>459</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_LISTEN</panel_attributes>
    <additional_attributes>4570.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>905</x>
      <y>429</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_listen</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>902</x>
      <y>436</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过sockfd_lookup依据fd找到sock
2.backlog最大只能是SOMAXCONN
3.通过sock-&gt;ops-&gt;listen监听sock
4.通过sockfd_put将file释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>911</x>
      <y>432</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>908</x>
      <y>447</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;listen
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>913</x>
      <y>443</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>913</x>
      <y>450</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>908</x>
      <y>454</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_listen</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>899</x>
      <y>461</y>
      <w>31</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.sock类型必须是“有链接”（SOCK_STREAM）
2.bind了socket地址（sk-&gt;protinfo.af_unix.addr）
3.要是TCP_CLOSE（sock刚建立），或者TCP_LISTEN（已经设置成serve，链接没建立）
	才能调用
4.如果扩大其队列长度（backlog），唤醒等待挂入队列的进程
	wake_up_interruptible_all(&amp;sk-&gt;protinfo.af_unix.peer_wait)
5.设置队列长度和状态：
	sk-&gt;max_ack_backlog=backlog;
	sk-&gt;state=TCP_LISTEN;
6.设置sk主：
	sk-&gt;peercred.pid = current-&gt;pid;
	sk-&gt;peercred.uid = current-&gt;euid;
	sk-&gt;peercred.gid = current-&gt;egid
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>913</x>
      <y>457</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1012</x>
      <y>428</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_accept</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1016</x>
      <y>412</y>
      <w>353</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_ACCEPT</panel_attributes>
    <additional_attributes>3510.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1005</x>
      <y>434</y>
      <w>37</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.根据fd通过sockfd_lookup查找sock
2.通过sock_alloc重新申请一个newsock（新inode）
	newsock-&gt;type = sock-&gt;type;
	newsock-&gt;ops = sock-&gt;ops;
3.通过sock-&gt;ops-&gt;accept接收链接
4.如果要求返回client地址（upeer_sockaddr），通过
	newsock-&gt;ops-&gt;getname获取
5.通过move_addr_to_user将地址和长度复制到用户空间
6.通过sock_map_fd为newsock分配新的fd，file，dentry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1017</x>
      <y>431</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1013</x>
      <y>453</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;accept
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1013</x>
      <y>460</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_accept</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1018</x>
      <y>456</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1018</x>
      <y>463</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1001</x>
      <y>467</y>
      <w>37</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.要是“有链接”（SOCK_STREAM），否则返回EOPNOTSUPP
2.要处于TCP_LISTEN，否则返回EINVAL
3.通过skb_recv_datagram接收控制请求
4.通过skb_free_datagram将sk_buff（skb）释放
5.通过wake_up_interruptible唤醒因为投递报文超过backlog
	而睡眠的进程（sk-&gt;protinfo.af_unix.peer_wait）
6.设置newsock的状态，并通过sock_graft将newsock和
	client的sk关联
	newsock-&gt;state = SS_CONNECTED;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1028</x>
      <y>487</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_graft</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1024</x>
      <y>494</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //指向new_socket的等待队列
sk-&gt;sleep = &amp;parent-&gt;wait;
 //将new_socket和client的sk关联
parent-&gt;sk = sk;
sk-&gt;socket = parent;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1034</x>
      <y>490</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1020</x>
      <y>482</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1007</x>
      <y>486</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_free_datagram</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1013</x>
      <y>482</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1007</x>
      <y>492</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kfree_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1014</x>
      <y>489</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1013</x>
      <y>495</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
atomic_dec_and_test
skb-&gt;users=1</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1008</x>
      <y>499</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__kfree_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>989</x>
      <y>486</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_recv_datagram</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>998</x>
      <y>482</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>974</x>
      <y>493</y>
      <w>31</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.通过sock_error提取sk-&gt;err，并置0，如果有错返回NULL
2.通过sock_rcvtimeo查看noblock标志，如果没置上，就设置timeout时间
3.do..while
	1.如果file.flag中MSG_PEEK置上，表示只是查询是否有报文可以接收
		所以通过skb_peek查询serve的receive_queue链表是否为空
		如果不为空，递增skb-&gt;users计数
	2.如果MSG_PEEK没置上，通过skb_dequeue将skb取出链表
	3.如果找到了skb，返回
	4.如果不要求等待（timeo=0），返回EAGAIN
	5.如果要求等待，通过wait_for_packet等待client发送控制报文
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>995</x>
      <y>489</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>969</x>
      <y>515</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_dequeue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>973</x>
      <y>511</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>969</x>
      <y>521</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__skb_dequeue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>974</x>
      <y>518</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>966</x>
      <y>527</y>
      <w>16</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.取出skb
	result = next;
	//链表个数和链表操作
	next = next-&gt;next;
	list-&gt;qlen--;
	next-&gt;prev = prev;
	prev-&gt;next = next;
2.初始化skb
	result-&gt;next = NULL;
	result-&gt;prev = NULL;
	result-&gt;list = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>973</x>
      <y>524</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>992</x>
      <y>515</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait_for_packet</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>986</x>
      <y>511</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>997</x>
      <y>518</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>984</x>
      <y>521</y>
      <w>46</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.栈中申明wait（DECLARE_WAITQUEUE），并将其加入导等待头
	__set_current_state(TASK_INTERRUPTIBLE);
	add_wait_queue_exclusive(sk-&gt;sleep, &amp;wait);
2.通过sock_error检查sk的error
3.通过skb_queue_empty查看serve的接收队列（receive_queue）是否为空
	如果不为空跳到8，如果为空，说明没数据
4.查看sk.shutdown的RCV_SHUTDOWN是否置上，如果置上，返回
5.如果sk的类型是SOCK_SEQPACKET（顺序包），SOCK_STREAM（有链接）类型时，
	sk的状态一定要是TCP_ESTABLISHED或者TCP_LISTEN
6.如果检查到signal_pending，通过sock_intr_errno查看是否有限时间等待，
	如果是，返回EINTR，否则，返回ERESTARTSYS重试
7.根据timeo时间通过schedule_timeout将其挂入到闹钟中
8.醒来之后，直接返回0。
	current-&gt;state = TASK_RUNNING;
	remove_wait_queue(sk-&gt;sleep, &amp;wait);
	return 0;
注：直接返回0，使其进do..while中检测skb，如果没检查到skb
	1.timeo时间到，执行上一层的4
	2.如果sk.error，执行本层2
	3.如果sigal_pending,执行本层6
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1099</x>
      <y>453</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>newsock-&gt;ops-&gt;getname
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1092</x>
      <y>456</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops/unix_dgram_ops</panel_attributes>
    <additional_attributes>160.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1093</x>
      <y>460</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_getname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1098</x>
      <y>463</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1084</x>
      <y>467</y>
      <w>30</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果peer置上，通过unix_peer_get获得对方sk
	否则，是要获取自己的sk地址，通过sock_hold增加自己sk的refcnt计数
2.如果sk没地址（对于unix域，client可以没有地址,就是没bind）(!sk-&gt;protinfo.af_unix.addr)
	sunaddr-&gt;sun_family = AF_UNIX;
	sunaddr-&gt;sun_path[0] = 0;
	*uaddr_len = sizeof(short);
	如果存在地址：
	addr = sk-&gt;protinfo.af_unix.addr
	//地址和长度，传给caller
	*uaddr_len = addr-&gt;len;
	memcpy(sunaddr, addr-&gt;name, *uaddr_len
3.通过sock_put递减refcnt计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1097</x>
      <y>490</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_peer_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1103</x>
      <y>486</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1090</x>
      <y>497</y>
      <w>27</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.获取连接的sk（sk.pair）
2.通过sock_hold递增获取sk.refcnt计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1102</x>
      <y>493</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1018</x>
      <y>449</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1029</x>
      <y>449</y>
      <w>80</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;780.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1167</x>
      <y>412</y>
      <w>202</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_CONNECT</panel_attributes>
    <additional_attributes>2000.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1163</x>
      <y>423</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1153</x>
      <y>430</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过sockfd_lookup利用fd查找sock
2.通过move_addr_to_kernel将用户想要连接的地址复制到用户层
3.通过sock-&gt;ops-&gt;connect连接到serve
4.通过sockfd_put将sock.file释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>426</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1154</x>
      <y>448</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_stream_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1163</x>
      <y>441</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;connect
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1169</x>
      <y>437</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1160</x>
      <y>444</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1212</x>
      <y>449</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_dgram_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1171</x>
      <y>444</y>
      <w>52</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1149</x>
      <y>456</y>
      <w>45</w>
      <h>61</h>
    </coordinates>
    <panel_attributes>1.通过unix_mkname计算具体地址的长度
	如果是抽象地址，计算其hash值
2.如果要求传递地址给server（passcred），但是
	没有地址（!sk-&gt;protinfo.af_unix.addr），通过unix_autobind
	自动将socket bind
3.通过sock_sndtimeo确定其timeout时间，如果O_NONBLOCK没置上
	时间是sk-&gt;sndtimeo
4.通过unix_create1为serve创建sock结构sk（子serve）
5.通过sock_wmalloc申请skb准备发给serve
6.通过unix_find_other找到serve端的sock
7.当other-&gt;dead置上时，表示该sock已经被serve撤销
	解开锁，并通过sock_put释放sock，并进一步去6查询hash表中
	是否还有对应地址的sock
注：这里说的是通过unix_find_other递增sock.refcnt，但是其他核撤销该sock，递减refcnt
	然后该核通过unix_state_rlock获取锁，但是此时已经撤销，所以把dead置上
	主要原因是获取sock和sock的相关操作没在一把大锁下，因为获取sock可能会睡。
8.serve端sock.state必须是TCP_LISTEN，否则返回ECONNREFUSED
9.如果serve端receive_queue的qlen超过了其限制max_ack_backlog
	1.如果不要求等待（!timeo），返回EAGAIN
	2.否则通过unix_wait_for_peer等待
	3.醒来之后发现有signal_pending，如果等待实现timeo是不限时，返回ERESTARTSYS重试
		否则返回EINTR
	4.如果是其他原因唤醒，通过sock_put将sk释放，并跳到6重试
10.检查client sk的状态，只有TCP_CLOSE才可以，TCP_ESTABLISHED时返回EISCONN，其他返回EINVAL
注：这里通过写锁对client sk上锁，前面是通过读锁对serve sk上锁
11.上锁之后需要检查sk.state和上锁之前是否相同，如果不同，将锁解开，并将other释放，重试6
注：因为上写锁时，其他进程可能正在读或者写（不同核）
12.对new_sk(serve子sock的)初始化：
	sock_hold(sk);
	unix_peer(newsk)=sk;//和client sk挂钩
	newsk-&gt;state=TCP_ESTABLISHED;//连接状态
	newsk-&gt;type=SOCK_STREAM;
	newsk-&gt;peercred.pid = current-&gt;pid;
	newsk-&gt;peercred.uid = current-&gt;euid;
	newsk-&gt;peercred.gid = current-&gt;egid;
	newsk-&gt;sleep = &amp;newsk-&gt;protinfo.af_unix.peer_wait
	//sk的地址和serve端源sk地址相同
	atomic_inc(&amp;other-&gt;protinfo.af_unix.addr-&gt;refcnt);
	newsk-&gt;protinfo.af_unix.addr=other-&gt;protinfo.af_unix.addr;
	newsk-&gt;protinfo.af_unix.dentry=dget(other-&gt;protinfo.af_unix.dentry);
	newsk-&gt;protinfo.af_unix.mnt=mntget(other-&gt;protinfo.af_unix.mnt);
13.设置client端sk：
	sk-&gt;peercred = other-&gt;peercred;
	sock_hold(newsk);
	unix_peer(sk)=newsk; //和newsk挂钩
	sock-&gt;state=SS_CONNECTED;
	sk-&gt;state=TCP_ESTABLISHED;
14.通过skb_queue_tail将skb尾插到serve sk的receive_queue中
	调用other-&gt;data_ready提醒数据准备好了
	通过sock_put将serve sk释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1160</x>
      <y>451</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1134</x>
      <y>522</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_wmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1138</x>
      <y>516</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1132</x>
      <y>525</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1122</x>
      <y>529</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.sk的skb计数wmem_alloc应该小于其限额sndbuf
	除非在force置上的时候
2.通过alloc_skb申请skb
3.通过skb_set_owner_w初始化skb关系
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1126</x>
      <y>540</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1132</x>
      <y>536</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1107</x>
      <y>547</y>
      <w>34</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果是在中断中（alloc_skb），并且要求申请内存时
	等待（__GFP_WAIT），将其等待标志__GFP_WAIT清除
2.通过skb_head_from_pool向skb_head_pool链表中申请skb
	如果在链表中没找到，通过kmem_cache_alloc向skbuff_head_cache
	申请skb
3.申请skb中数据的内存，需要16字节对齐，并且需要加上atomic_t的空间
	size = ((size + 15) &amp; ~15); 
	data = kmalloc(size + sizeof(atomic_t), gfp_mask);
	如果没申请到，通过skb_head_to_pool将skb释放
4.初始化skb数据
	//实际长度=data+skb
	skb-&gt;truesize = size + sizeof(struct sk_buff);
	//数据指针，head和tail是队列的头尾指针，data和end是缓冲区的头尾指针
	skb-&gt;head = data;
	skb-&gt;data = data;
	skb-&gt;tail = data;
	skb-&gt;end = data + size;
	//长度
	skb-&gt;len = 0;
	skb-&gt;cloned = 0;
	skb-&gt;users=1
	skb-&gt;end=1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1131</x>
      <y>543</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1113</x>
      <y>567</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_head_to_pool</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1119</x>
      <y>564</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1104</x>
      <y>574</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.遍历skb_head_pool链表，如果其长度小于
	限值sysctl_hot_list_len，就通过__skb_queue_head
	释放到链表中
2.否则通过kmem_cache_free释放到skbuff_head_cache中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1116</x>
      <y>570</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1109</x>
      <y>584</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__skb_queue_head</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1115</x>
      <y>581</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1106</x>
      <y>590</y>
      <w>19</w>
      <h>17</h>
    </coordinates>
    <panel_attributes> //newsk就是skb
newsk-&gt;list = list;
list-&gt;qlen++;
prev = (struct sk_buff *)list;
next = prev-&gt;next;
 //头插置链表中
newsk-&gt;next = next;
newsk-&gt;prev = prev;
next-&gt;prev = newsk;
prev-&gt;next = newsk;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1115</x>
      <y>587</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1146</x>
      <y>540</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_set_owner_w</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1139</x>
      <y>536</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1143</x>
      <y>547</y>
      <w>20</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //递增sk引用
sock_hold(sk);
 //将其和sk关联，accept会通过skb找到newsk
skb-&gt;sk = sk;
 //skb释放时执行
skb-&gt;destructor = sock_wfree;
wmem_alloc+=truesize
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1151</x>
      <y>543</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1166</x>
      <y>524</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_find_other</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1164</x>
      <y>516</y>
      <w>9</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1164</x>
      <y>530</y>
      <w>32</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果是具体地址（sunname-&gt;sun_path[0]）：
	1.通过path_init和path_walk寻找到sock inode
		LOOKUP_POSITIVE：在找不到indoe时，返回ENOENT
		LOOKUP_FOLLOW：顺着link查找，直到找到真实inode
	2.通过permission检查MAY_WRITE
	3.如果inode的S_ISSOCK没置上，返回ECONNREFUSED
	4.利用unix_find_socket_byinode通过inode的ino
		作为hash值，在hash表中查找sk
	5.通过path_release释放获取的nd
	6.如果要连接地址的sk的type和client的type不相同，返回EPROTOTYPE
2.如果是抽象地址，通过unix_find_socket_byname查找sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1173</x>
      <y>527</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1165</x>
      <y>554</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_find_socket_byinode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1171</x>
      <y>548</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1164</x>
      <y>561</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.遍历hash表unix_socket_table，查看其中的sk
	（protinfo.af_unix.dentry.inode）是否
	和当前传进的inode相同，如果相同通过sock_hold
	递增sever sk的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1172</x>
      <y>557</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1187</x>
      <y>554</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_find_socket_byname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1192</x>
      <y>561</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过__unix_find_socket_byname遍历unix_socket_table
	hash表，找到其中name和len相同的sk返回
2.通过sock_hold递增sever sk的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1189</x>
      <y>548</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1197</x>
      <y>557</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1202</x>
      <y>524</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_wait_for_peer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1176</x>
      <y>516</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1200</x>
      <y>531</y>
      <w>28</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.申明等待wait，并将task状态设置为TASK_INTERRUPTIBLE
	最后将wait挂入到peer_wait中
2.下面要都成立，才schedule_timeout：
	1.other-&gt;dead没置上
	2.other的RCV_SHUTDOWN没置上
	3.receive_queue长度没超过max_ack_backlog
3.将task状态设置为TASK_RUNNING，并将wait从peer_wait移除
注：这里没有像wait_for_packet一样，在醒来之后先去查看receive_queue
	再去看signal_pending。因为connect不仅需要控制报文投递，需要等待到serve
	端accept，这是一个不确定的时间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1210</x>
      <y>527</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1231</x>
      <y>522</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>other-&gt;data_ready
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1176</x>
      <y>516</y>
      <w>62</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;600.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1237</x>
      <y>525</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sock_init_data</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1230</x>
      <y>529</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_def_readable</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1230</x>
      <y>536</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过wake_up_interruptible唤醒同步等待队列sk-&gt;sleep
2.通过sk_wake_async给异步等待队列socket-&gt;fasync_list
	发信号(原因是POLL_IN)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1236</x>
      <y>532</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1237</x>
      <y>546</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_wake_async</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1242</x>
      <y>542</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1242</x>
      <y>549</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果存在异步等待队列fasync_list</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1237</x>
      <y>553</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_wake_async</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1242</x>
      <y>556</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1227</x>
      <y>560</y>
      <w>37</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.how=1：sock-&gt;flags的SOCK_ASYNC_WAITDATA不能置上
	并通过__kill_fasync给队列发SIGIO
	how=2:SOCK_ASYNC_NOSPACE要置上，并通过__kill_fasync给队列发SIGIO
	how=3:通过__kill_fasync给队列发SIGURG
	how=0:通过__kill_fasync给队列发SIGIO
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1195</x>
      <y>456</y>
      <w>46</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.如果sa_family是AF_UNSPEC，表示单向连接关系断开
	other = NULL
	如果sa_family不为AF_UNSPEC：
	1.通过unix_mkname获取addr的长度，并且为抽象地址分配hash
	2.如果要求传递地址（passcred），但是地址没有sk-&gt;protinfo.af_unix.addr
		通过unix_autobind为其bind一个地址
	3.通过unix_find_other利用地址，找到inode，并进一步在hash中找到sock
	4.为其sk上写锁
	5.通过unix_may_send检查other是否有链接，如果有，是否是sk，如果不是，返回EPERM
2.如果sk已经有连接（sk.pair）
	1.取出其连接，并连接到other
		old_peer = unix_peer(sk);
		unix_peer(sk)=other;
		unix_state_wunlock(sk);
	2.如果old_peer不是现在要连接的other，通过unix_dgram_disconnected将其连接断开
	3.通过sock_put将old_peer释放
3.如果sk没有连接：
	unix_peer(sk)=other;
	unix_state_wunlock(sk);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1219</x>
      <y>452</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1209</x>
      <y>491</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_dgram_disconnected</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1217</x>
      <y>487</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1201</x>
      <y>498</y>
      <w>32</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果receive_queue中qlen不为0
	1.通过skb_queue_purge将receive_queue中所有的skb释放
	2.通过wake_up_interruptible_all唤醒sk的peer_wait
	3.如果old_peer没被撤销（other-&gt;dead ），并且其连接的还是
		当前的sk：
		other-&gt;err = ECONNRESET;
		other-&gt;error_report(other);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1217</x>
      <y>494</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1367</x>
      <y>412</y>
      <w>153</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_SENDTO
SYS_SEND只是在地址为NULL
文件系统的sys_write对应的sock_write也和这个类似</panel_attributes>
    <additional_attributes>10.0;10.0;1510.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1511</x>
      <y>431</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sendto</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1517</x>
      <y>434</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1499</x>
      <y>438</y>
      <w>35</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.通过sockfd_lookup利用fd找到sock
2.初始化msg：
	//缓冲区
	iov.iov_base=buff;
	iov.iov_len=len;
	msg.msg_name=NULL;
	msg.msg_iov=&amp;iov;
	msg.msg_iovlen=1;
	//附加信息
	msg.msg_control=NULL;
	msg.msg_controllen=0;
	//地址
	msg.msg_namelen=addr_len;
	move_addr_to_kernel(addr, addr_len, address)
	msg.msg_name=address
	//如果O_NONBLOCK置上，就将MSG_DONTWAIT置上
	msg.msg_flags = flags
3.通过sock_sendmsg发送msg
4.通过sockfd_put将file释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1510</x>
      <y>472</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_sendmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1515</x>
      <y>468</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1366</x>
      <y>412</y>
      <w>347</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_RECVFROM
SYS_RECV只是在地址为NULL
文件系统的sys_read对应的sock_read也和这个类似</panel_attributes>
    <additional_attributes>10.0;10.0;3450.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1705</x>
      <y>432</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_recvfrom</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1710</x>
      <y>435</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1694</x>
      <y>439</y>
      <w>35</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.通过sockfd_lookup利用fd找到sock
2.初始化msg：
	//附加信息
	msg.msg_control=NULL;
	msg.msg_controllen=0
	//缓冲区
	msg.msg_iovlen=1;
	msg.msg_iov=&amp;iov;
	iov.iov_len=size;
	iov.iov_base=ubuf;
	//用来接收发送者的地址
	msg.msg_name=address;
	msg.msg_namelen=MAX_SOCK_ADDR;
	//如果O_NONBLOCK置上，就将MSG_DONTWAIT置上
	flags |= MSG_DONTWAIT
3.通过sock_recvmsg接收msg
4.通过move_addr_to_user将发送者的地址复制到用户层
5.通过sockfd_put将file释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1704</x>
      <y>472</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_recvmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1708</x>
      <y>468</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1697</x>
      <y>478</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.将scm清0
2.通过sock-&gt;ops-&gt;recvmsg接收msg
3.如果有收到msg，通过scm_recv将发送方授权的file
	安装在进程中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1710</x>
      <y>475</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1695</x>
      <y>487</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;recvmsg
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1702</x>
      <y>484</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1667</x>
      <y>495</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_stream_recvmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1676</x>
      <y>490</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1701</x>
      <y>490</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1723</x>
      <y>494</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_dgram_recvmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1712</x>
      <y>501</y>
      <w>54</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果flag的MSG_OOB置上，返回EOPNOTSUPP
注：MSG_OOB主要是有链接用于控制传输的目的
2.通过skb_recv_datagram接收发送方传过来的skb
3.通过wake_up_interruptible唤醒接收方peer_wait队列中
	等待发送的进程
4.如果要求返回发送方的地址（msg_name），通过unix_copy_addr获取
5.读取的长度不能超过skb的长度skb-&gt;len，如果不足这个长度，长度就是用户提供的size
	但是需要将msg-&gt;msg_flags |= MSG_TRUNC
6.通过skb_copy_datagram_iovec将skb中的报文读取到用户层
7.将skb.cb的48字节通过unix_skb_parms解析，将其中的creds放在scm-&gt;creds中
8.如果MSG_PEEK没置上（正常读取数据），通过unix_detach_fds将发送方传来的file取出
	如果MSG_PEEK置上（查看一下），通过scm_fp_dup将file复制到scm-&gt;fp
9.最后通过skb_free_datagram将skb释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1731</x>
      <y>497</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1703</x>
      <y>525</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_copy_addr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1709</x>
      <y>522</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1696</x>
      <y>531</y>
      <w>22</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果没有addr，则：
	msg-&gt;msg_namelen = sizeof(short)
2.如果有addr，则：
	msg-&gt;msg_namelen=sk-&gt;protinfo.af_unix.addr-&gt;len
	memcpy(msg-&gt;msg_name,
		       sk-&gt;protinfo.af_unix.addr-&gt;name,
		       sk-&gt;protinfo.af_unix.addr-&gt;len);
注：有链接skb的sk指向的子serve方的sk
	无连接skb的sk指向的是发送方的sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1706</x>
      <y>528</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1724</x>
      <y>526</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_copy_datagram_iovec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1731</x>
      <y>522</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1724</x>
      <y>539</y>
      <w>28</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.将skb中的内容通过copy_to_user复制到iov_base中
	复制的长度是要读的长度len和iov的长度iov_len的最小值
2.更新：
	kdata+=copy;
	len-=copy;
	iov-&gt;iov_len-=copy;
	iov-&gt;iov_base+=copy;
3.如果一个iov放不下，将iov++
注；如果用户层没注意，将要读的长度，超过了iov的长度，可能要自己负责
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1729</x>
      <y>533</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memcpy_toiovec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1734</x>
      <y>529</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1734</x>
      <y>536</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1756</x>
      <y>526</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_detach_fds</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1750</x>
      <y>522</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1754</x>
      <y>533</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.将skb中的scm_fp_list复制到scm-&gt;fp
	并将其fp置NULL
2.skb-&gt;destructor = sock_wfree
3.遍历scm_fp_list，通过unix_notinflight
	提示sock不在飞行中：
	atomic_dec(&amp;s-&gt;protinfo.af_unix.inflight);
	atomic_dec(&amp;unix_tot_inflight);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1762</x>
      <y>529</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1784</x>
      <y>526</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>scm_fp_dup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1760</x>
      <y>522</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1779</x>
      <y>533</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果要复制的scm_fp_list为NULL,直接返回
2.通过kmalloc申请file数组。通过get_file
	递增file的计数，并通过memcpy将scm_fp_list复制到
	申请的内存中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1790</x>
      <y>529</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1797</x>
      <y>487</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>scm_recv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1715</x>
      <y>484</y>
      <w>90</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;880.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1789</x>
      <y>495</y>
      <w>32</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.如果不要求传输控制消息（!msg_control）
	1.如果是要求传递消息（passcred），或者对方有传递消息过来scm-&gt;fp
		将msg-&gt;msg_flags |= MSG_CTRUNC
	2.通过scm_destroy将发送方传过来的file释放，并释放数组结构scm_fp_list
2.如果passcred置上，通过put_cmsg将类型（参数）和creds复制到msg_control中
3.如果发送方没传送file过来（!fp），直接返回
4.通过scm_detach_fds将传送过来的file安装
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1803</x>
      <y>490</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1804</x>
      <y>510</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>scm_detach_fds</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1804</x>
      <y>507</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1807</x>
      <y>516</y>
      <w>36</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.计算出用户给的msg中能容纳的fd的数量（fdmax），（空间是msg_controllen-cmsghdr）
	所以要传递给用户fd的数量是传送方传递的file和fdmax的最小值
2.通过get_unused_fd获取fd，并将其通过put_user放到CMSG_DATA中，
	通过get_file递增 scm-&gt;fp-&gt;fp数组中相应file的计数，并通过fd_install将其安装至当前进程中
3.将SOL_SOCKET，SCM_RIGHTS，cmlen（data长度，即fd）填充cmsghdr
	并更新：
	cmlen = CMSG_SPACE(i*sizeof(int));
	msg-&gt;msg_control += cmlen;
	msg-&gt;msg_controllen -= cmlen;
4.如果发送方的file没全部传递msg-&gt;msg_flags |= MSG_CTRUNC
5.通过__scm_destroy将scm中的file数组释放
注；1.这里将发送方的file传递给接收方，应用于如下场景
	在有链接的时候，serve因为要accept，所以会fork一个子进程去和client通信，这会在通信时有相当大的花费
	如果提前fork一些进程，然后通过传递连接的sock_file给子进程，这样就不用在通信的时候fork了
	2.msg_controll由多个cmsghdr+data组成（data中包含creds（put_cms）或者fd数组）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1812</x>
      <y>513</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1504</x>
      <y>479</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过scm_send将用户层中传输的控制信息msg组装金scm中
2.通过sock-&gt;ops-&gt;sendmsg将msg发送
	并通过scm_destroy将scm中的file数组和file释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1460</x>
      <y>490</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>scm_send</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1515</x>
      <y>475</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1464</x>
      <y>485</y>
      <w>53</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1452</x>
      <y>496</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.将scm清0
2.将进程的pid，uid，gid赋给scm-&gt;creds
3.如果msg_controllen&gt;0,通过__scm_send将msg的controll信息复制到scm中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1463</x>
      <y>493</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1455</x>
      <y>504</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__scm_send</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1461</x>
      <y>501</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1452</x>
      <y>510</y>
      <w>31</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.利用cmsghdr解析msg的各个片段（cmsghdr+data（data长度是cmsg-&gt;cmsg_len））
	这个片段的长度不能超过msg_controllen
2.cmsg_level要是SOL_SOCKET
3.如果cmsg_type是SCM_RIGHTS，通过scm_fp_copy将fp数组从msg中复制到scm中
	如果是SCM_CREDENTIALS，将数据复制到scm-&gt;creds中，并通过scm_check_creds检查其cred
4.如果没有任何file需要传输（!p-&gt;fp-&gt;count）将scm中的scm_fp_list释放
注：scm_fp_copy中可能是继续向scm中添加file（fp已经存在，所有count+num不能大于SCM_MAX_FD，num是msg传递的file）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1460</x>
      <y>507</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1545</x>
      <y>487</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;sendmsg
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1517</x>
      <y>485</y>
      <w>38</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1555</x>
      <y>490</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1569</x>
      <y>495</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_dgram_sendmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1504</x>
      <y>495</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_stream_sendmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1514</x>
      <y>490</y>
      <w>42</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops</panel_attributes>
    <additional_attributes>400.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1546</x>
      <y>501</y>
      <w>60</w>
      <h>48</h>
    </coordinates>
    <panel_attributes>1.msg_flags的MSG_OOB不能置上，否则返回EOPNOTSUPP
2.如果用户提供和发送地址（msg_namelen）通过unix_mkname计算其len和抽象地址hash
	如果没提供通过unix_peer_get获取接收方的sk--other(connect时连接)，如果没有返回ENOTCONN
3.如果要求传递地址（passcred），但是却没有地址（！af_unix.addr），通过unix_autobind
	自动bind一个地址
4.如果发送长度超过了sndbuf - 32（要留32字节冗余），返回EMSGSIZE
5.通过sock_alloc_send_skb分配skb，注意传参是发送方的sk
6.将scm-&gt;creds复制到skb的cb中
7.如果要求传递文件（scm-&gt;fp），通过unix_attach_fds将scm.fp复制到skb的cb中
8.将skb-&gt;h.raw指向缓冲区skb-&gt;data，并通过memcpy_fromiovec将数据冲io_base
	复制到缓冲区，并通过skb_put更新尾指针tail和长度len
9.通过sock_sndtimeo确定进程是否block
10.如果没有确定收方（!other），unix_find_other通过sunaddr在hash中找到收方的sk
11.unix_may_send检查发方sk，不能和除了other之外的其他sk相连
12.如果收方的sk被撤销（other-&gt;dead）
	1.通过sock_put将other释放
	2.如果sk和other相连，将其接触绑定
		unix_peer(sk)=NULL;
		unix_dgram_disconnected(sk, other);
		sock_put(other);
		并返回err = -ECONNREFUSED;
	3.如果other为null，从10再次查询执行
13.如果RCV_SHUTDOWN，返回EPIPE
14.如果收方other没和sk相连，并且收方的receive_queue超过了其max_ack_backlog
	1.如果没要求等待（!timeo），返回EAGAIN
	2.如果要求等待，通过unix_wait_for_peer等待other释放空间
	3.醒来之后，检查signal_pending，根据timeo决定返回值
15.利用skb_queue_tail将skb加入到receive_queue链表
16.执行other-&gt;data_ready，释放other，返回发送长度len
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1578</x>
      <y>498</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1556</x>
      <y>553</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_alloc_send_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1563</x>
      <y>548</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1534</x>
      <y>560</y>
      <w>45</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.通过sock_sndtimeo确定如果要睡眠需要等待的时间
2.循环等待sndbuf空闲，申请skb
	1.通过sock_error检查sk.err，如果出错，返回错误
	2.如果sk-&gt;shutdown&amp;SEND_SHUTDOWN，返回EPIPE
	3.如果sk发送的长度wmem_alloc没超过sndbuf
		1.如果fallback置上，通过alloc_skb申请用户定义大小的buffer，如果没申请到利用fallback大小再试
		2.通过alloc_skb申请skb，如果没申请到返回ENOBUFS
		3.如果上述两个任意一个申请到，退出循环
	4.将socket-&gt;flags中的SOCK_ASYNC_NOSPACE和SOCK_NOSPACE置上
	5.如果不要求等待（!timeo），返回EAGAIN
	6.如果signal_pending，如果是无限等待，返回ERESTARTSYS重试；否则返回EINTR
	7.通过sock_wait_for_wmem等待，醒来之后再次执行循环，重新申请
3.通过skb_set_owner_w设置sk（注意这里是发送方的sk）和skb的关系，并更新wmem_alloc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1562</x>
      <y>556</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1549</x>
      <y>588</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_wait_for_wmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1535</x>
      <y>595</y>
      <w>33</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.申请wait，并挂入到sk-&gt;sleep
2.将socket-&gt;flags中的SOCK_ASYNC_NOSPACE清掉
3.循环检查醒来之后的状态：
	1.如果signal_pending，退出循环
	2.将socket的SOCK_NOSPACE置上，并将task状态设置为TASK_INTERRUPTIBLE
	3.如果sk的wmem_alloc小于发送限值sndbuf，退出循环
	4.如果SEND_SHUTDOWN，退出循环
	5.如果err，退出循环
	6.否则采用schedule_timeout调度task
4.确认退出检查之后，将task状态改为TASK_RUNNING，并将wait移除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1556</x>
      <y>591</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1556</x>
      <y>582</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1584</x>
      <y>553</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_attach_fds</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1581</x>
      <y>560</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历scm中的fp数组，通过unix_inflight检查如果是sock_file
	递增sk的af_unix.inflight和总数unix_tot_inflight
2.将scm-&gt;fp复制到skb的cb中，并：
	skb-&gt;destructor = unix_destruct_fds;
	scm-&gt;fp = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1591</x>
      <y>556</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1581</x>
      <y>548</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1622</x>
      <y>502</y>
      <w>70</w>
      <h>61</h>
    </coordinates>
    <panel_attributes>1.如果sk的状态不是TCP_ESTABLISHED，返回EINVAL
2.flag中MSG_OOB不能置上，这个控制报文对Unix域不适用
3.通过sock_rcvlowat计算本次接收的最少接收量
	1.如果要求MSG_WAITALL，要接收就是用户规定的size
	2.否则是用户规定和sk-&gt;rcvlowat的最小值
	3.如果上述两个条件返回0，则最小是1
4.通过sock_rcvtimeo确定进程是否需要等待
 //这里耗时较长，用信号量readsem，是进程能够睡眠
5.循环读取skb，知道读取size
	1.利用skb_dequeue从receive_queue中获取skb
	2.如果sk没有skb：
		1.如果接收的已经超过了规定的最小值target，退出循环，返回copied
		2.检查sock_error，检查RCV_SHUTDOWN
		3.如果要求等待，通过unix_stream_data_wait等待，等待之前将信号量readsem释放：
			1.receive_queue中有skb，有sk.err,RCV_SHUTDOWN,signal_pending,！timeo退出等待
			2.再调度之前将SOCK_ASYNC_WAITDATA置上，醒来之后，将SOCK_ASYNC_WAITDATA清除
		4.醒来之后检查signal_pending，是否重试，看timeo，
		5.重新申请信号量readsem，并执行5.1
	3.如果之前有接收skb（check_creds），通过memcmp对比两个skb的creds是否一致，如果不一致通过skb_queue_head
		将skb重新加入队列，并且退出循环，返回接收的长度copied
		如果之前没接收skb：
			scm-&gt;creds = *UNIXCREDS(skb);
			check_creds = 1;
	4.如果要求接收发送方地址（sunaddr），通过unix_copy_addr将发送方sk的地址复制到sunaddr
	5.通过memcpy_toiovec将数据从skb的缓冲区data中复制到msg_iov，复制的长度是skb的长度和要读的长度size的最小值
		如果复制因为权限出错，将skb通过skb_queue_head重新加入到队列中，然后退出循环返回复制的长度，并更新：
		copied += chunk;//复制的长度
		size -= chunk//剩下要读的量
	6.如果是正式读（！MSG_PEEK）:
		1.通过skb_pull更新skb
		2.如果skb中fp存在，通过unix_detach_fds将skb中的fp复制到scm中
		3.如果skb中还存在数据，通过skb_queue_head将skb重新加入队列
		4.如果skb被读完，通过kfree_skb将skb释放
		5.如果此次传输了文件scm.fp，直接退出，返回复制长度
	7.如果是偷看一下（MSG_PEEK）：
		1.通过scm_fp_dup将skb.cb中的数据复制到scm-&gt;fp
		2.并通过skb_queue_head将skb重新连入链表中，退出循环，返回读取的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1674</x>
      <y>498</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1661</x>
      <y>562</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1656</x>
      <y>566</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_pull</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1650</x>
      <y>573</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果读取的长度超过了skb.len,直接返回NULL
2.skb-&gt;len-=len
	skb-&gt;data+=len
3.返回skb.data指针
注：这里直接调整data，是因为skb数据读完之后会直接释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1661</x>
      <y>569</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1487</x>
      <y>502</y>
      <w>55</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.Unix域没有MSG_OOB
2.在发送时，不能传递地址（msg_namelen），需要通过
	unix_peer_get获取接收方的sk--other
3.发送方sk不能SEND_SHUTDOWN
4.while循环发送数据：
	1.一次发送的长度不能超过sk-&gt;sndbuf/2（16字节是头，但是sk_buff却不止16字节？）
		这是为了可以交替向sk的buf中发送数据
	2.如果发送的长度超过了一页，可以用一页的长度进行尝试（fallback）
	3.通过sock_alloc_send_skb申请skb，如果其中超过了sendbuf会睡眠
注：无连接会检查发送长度是否超过了receive_queue的限制，但是有链接却没有检查
	这是因为无连接不关心两个sk是否相连，只要有接收方的地址就能发过去（所以任何进程只要有对方的地址都可以放到接收方的sk上）
	但是有链接必须是两个连接的sk才能互相收发，所以接收方的sk只有与其连接的sk才能发送，所以这里只通过发送方的sendbuf长度控制发送
	4.发送的长度不能超过skb的剩余空间（skb_tailroom）
	5.复制scm-&gt;creds到skb的cb中
	6.通过memcpy_fromiovec复制数据msg_iov到skb.tail，并通过skb_put更新tail和len
	7.如果读端dead，或者RCV_SHUTDOWN，解锁other，释放skb，并返回发送的长度
	8.通过skb_queue_tail将skb添加到receive_queue
	9.other-&gt;data_ready(other, size);
		sent+=size;
5.通过sock_put释放ohtre，并返回发送的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1509</x>
      <y>498</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1008</x>
      <y>506</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.通过dst_release释放skb-&gt;dst
2.执行skb-&gt;destructor
3.通过skb_headerinit在skb初始化
4.通过kfree_skbmem将skb的数据缓冲释放
	其中通过skb_head_to_pool将skb释放至cache或者pool
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1013</x>
      <y>502</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1033</x>
      <y>518</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb-&gt;destructor
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1035</x>
      <y>514</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1030</x>
      <y>526</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_wfree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1035</x>
      <y>521</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
skb_set_owner_w</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1145</x>
      <y>562</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_wfree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1150</x>
      <y>558</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1141</x>
      <y>569</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.释放skb申请的空间
	wmem_alloc-=truesize
2.调用sk-&gt;write_space
3.通过sock_put将sk释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1150</x>
      <y>565</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1145</x>
      <y>579</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_write_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1150</x>
      <y>575</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_create1</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1137</x>
      <y>585</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.上callback_lock锁
2.通过unix_writable检查已写的buf是否超过了sk的限制的一半
	如果没超过：
	1.如果sk-&gt;sleep中存在等待进程，通过wake_up_interruptible将其唤醒
	2.通过sk_wake_async异步通知sock-&gt;fasync_list进程POLL_OUT
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1150</x>
      <y>582</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1366</x>
      <y>412</y>
      <w>438</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_SENDMSG</panel_attributes>
    <additional_attributes>10.0;10.0;4360.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1795</x>
      <y>430</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sendmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1367</x>
      <y>412</y>
      <w>498</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_RECVMSG</panel_attributes>
    <additional_attributes>10.0;10.0;4960.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1857</x>
      <y>430</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_recvmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1779</x>
      <y>436</y>
      <w>41</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.通过copy_from_user将用户要传输的msghdr复制到用户空间
2.利用sockfd_lookup通过fd找到sock
3.iov的个数（msg_iovlen）不能超过UIO_MAXIOV
4.如果iov的个数是8，就用栈中的空间，否则通过通过sock_kmalloc申请
5.通过verify_iovec将iov复制到内核，并返回总共传输数据的长度
注：这里没有复制具体数据，具体数据的复制是在sock-&gt;ops-&gt;sendmsg中
	通过memcpy_fromiovec复制
6.msg_controllen不能超过INT_MAX，如果超过了一个control，通过sock_kmalloc
	申请空间，否则利用栈上的空间ctl
7.通过copy_from_user将msg_control复制到内核
	msg_sys.msg_control = ctl_buf
8.复制flag
	msg_sys.msg_flags = flags
	//O_NONBLOCK置上
	msg_sys.msg_flags |= MSG_DONTWAIT
9.sock_sendmsg发送msg
注：只有这个函数会传递control，进而授权file
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1801</x>
      <y>433</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1782</x>
      <y>466</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1788</x>
      <y>463</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1772</x>
      <y>472</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果申请的内存size，不能超过sysctl_optmem_max
	omem_alloc+size不能超过sysctl_optmem_max
2.通过kmalloc申请size，之前要将omem_alloc+=size
	之后要omem_alloc-=size（不清楚为什么要这样？）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1787</x>
      <y>469</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1816</x>
      <y>467</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>verify_iovec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1807</x>
      <y>463</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1809</x>
      <y>473</y>
      <w>32</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果传递了name（msg_namelen）：
	1.如果要VERIFY_READ，就将name复制到address中
	2.m-&gt;msg_name = address
	没传递name，m-&gt;msg_name = NULL
2.通过copy_from_user将iov复制到内核，并修改其指向内核
	m-&gt;msg_iov=iov
3.算出iov数组的总长度，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1822</x>
      <y>470</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1844</x>
      <y>438</y>
      <w>40</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.通过copy_from_user将msg复制到内核
2.利用sockfd_lookup通过fd找到sock
3.获取内核iov，过程和sys_sendmsg类似
4.通过verify_iovec验证iov，并将m-&gt;msg_name
	指向内核
5.查看O_NONBLOCK是否置上，决定MSG_DONTWAIT是否置上
6.通过sock_recvmsg继续填充msg
7.如果有地址（用户接收，且地址传过来），通过move_addr_to_user将地址复制到用户空间
8.通过__put_user分别将msg_flags和msg_controllen复制到用户
注：data和msgcontrol分别在sock-&gt;ops-&gt;recvmsg和scm_recv中复制到用户空间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1862</x>
      <y>433</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1040</x>
      <y>526</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_destruct_fds</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1039</x>
      <y>521</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_attach_fds</panel_attributes>
    <additional_attributes>30.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1591</x>
      <y>572</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_destruct_fds</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1596</x>
      <y>569</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1582</x>
      <y>578</y>
      <w>31</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.将scm清0
2.通过unix_detach_fds将skb.cb中的fp放到scm中
	并在其中通过unix_notinflight递减sk中inflight的file计数
	最后将skb-&gt;destructor = sock_wfree
3.通过scm_destroy释放scm.fp中的file，及其管理数组
4.通过sock_wfree释放skb的缓存，并递减sk计数（是对发送端计数）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1596</x>
      <y>575</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>682</x>
      <y>462</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_family_ops</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>708</x>
      <y>466</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>705</x>
      <y>472</y>
      <w>33</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.设置sock状态
	sock-&gt;state = SS_UNCONNECTED
2.通过sk_alloc申请sk
3.根据sock-&gt;type确定运输层协议：
	//SOCK_STREAM
	protocol = IPPROTO_TCP;
	prot = &amp;tcp_prot;
	sock-&gt;ops = &amp;inet_stream_ops;
	//SOCK_DGRAM
	protocol = IPPROTO_UDP;
	sk-&gt;no_check = UDP_CSUM_DEFAULT;
	prot=&amp;udp_prot;
	sock-&gt;ops = &amp;inet_dgram_ops;
	//SOCK_RAW
4.初始化sk
	sock_init_data(sock,sk);

	sk-&gt;destruct = inet_sock_destruct;

	sk-&gt;zapped = 0;
	sk-&gt;family = PF_INET;
	sk-&gt;protocol = protocol;

	sk-&gt;prot = prot;
	sk-&gt;backlog_rcv = prot-&gt;backlog_rcv;

	sk-&gt;protinfo.af_inet.ttl=sysctl_ip_default_ttl;

	sk-&gt;protinfo.af_inet.mc_loop=1;
	sk-&gt;protinfo.af_inet.mc_ttl=1;
	sk-&gt;protinfo.af_inet.mc_index=0;
	sk-&gt;protinfo.af_inet.mc_list=NULL;
5.sk.num不为0（只有在SOCK_RAW）：
	sk-&gt;sport = htons(sk-&gt;num)
	sk-&gt;prot-&gt;hash(sk)
6.初始化sk-&gt;prot-&gt;init
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>714</x>
      <y>469</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>713</x>
      <y>505</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;prot-&gt;init
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>718</x>
      <y>502</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>713</x>
      <y>508</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>707</x>
      <y>512</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_init_sock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>705</x>
      <y>518</y>
      <w>27</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.初始化skb链表tp-&gt;out_of_order_queue
2.初始化timer：
	tp-&gt;retransmit_timer.function=&amp;tcp_write_timer;
	tp-&gt;retransmit_timer.data = (unsigned long) sk;
	tp-&gt;pending = 0;

	tp-&gt;delack_timer.function=&amp;tcp_delack_timer;
	tp-&gt;delack_timer.data = (unsigned long) sk;
	tp-&gt;ack.pending = 0;

	sk-&gt;timer.function=&amp;tcp_keepalive_timer;
	sk-&gt;timer.data = (unsigned long) sk;
3.初始化tp-&gt;ucopy
	tp-&gt;ucopy.task = NULL;
	tp-&gt;ucopy.len = 0;
	tp-&gt;ucopy.memory = 0;
	skb_queue_head_init(&amp;tp-&gt;ucopy.prequeue)
4.初始化tp
	tp-&gt;rto  = TCP_TIMEOUT_INIT;
	tp-&gt;mdev = TCP_TIMEOUT_INIT;
	tp-&gt;snd_cwnd = 2;
	tp-&gt;snd_ssthresh = 0x7fffffff;	/* Infinity */
	tp-&gt;snd_cwnd_clamp = ~0;
	tp-&gt;mss_cache = 536;
	tp-&gt;reordering = sysctl_tcp_reordering;
5.初始化sk
	sk-&gt;state = TCP_CLOSE;
	sk-&gt;write_space = tcp_write_space;
	sk-&gt;tp_pinfo.af_tcp.af_specific = &amp;ipv4_specific;
	sk-&gt;sndbuf = sysctl_tcp_wmem[1];
	sk-&gt;rcvbuf = sysctl_tcp_rmem[1];
	atomic_inc(&amp;tcp_sockets_allocated);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>712</x>
      <y>515</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>810</x>
      <y>442</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops/inet_dgram_ops</panel_attributes>
    <additional_attributes>10.0;20.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>823</x>
      <y>445</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_bind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>820</x>
      <y>451</y>
      <w>36</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.如果sk-&gt;prot-&gt;bind存在（这里不存在），则运行
2.用户传来的地址长度不能小于内核解析（sockaddr_in）的长度
3.通过inet_addr_type查看用户传来的ip地址的类型
4.filter：
	1.如果没有local的bind（sysctl_ip_nonlocal_bind）
		并且已经被bind（freebind），地址类型也不是（0，local，多播或者广播），报错
	2.如果要申请1024一下的port，需要CAP_NET_BIND_SERVICE的权限
	3.sk的状态要不是TCP_CLOSE，或者sk已经关联了port（sk-&gt;num），报错EINVAL
5.设置地址：
	sk-&gt;rcv_saddr = sk-&gt;saddr = addr-&gt;sin_addr.s_addr;
	如果是广播或者多播：sk-&gt;saddr = 0
6.通过sk-&gt;prot-&gt;get_port分配port
7.设置sk
	sk-&gt;userlocks（rcv_saddr指定，SOCK_BINDADDR_LOCK置上；
		snum指定，SOCK_BINDPORT_LOCK置上）
	sk-&gt;sport = htons(sk-&gt;num);
	sk-&gt;daddr = 0;
	sk-&gt;dport = 0;
	sk_dst_reset(sk);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>829</x>
      <y>448</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>822</x>
      <y>476</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_addr_type</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>821</x>
      <y>482</y>
      <w>37</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果最高字节是0或者最高4位是f，RTN_BROADCAST
2.如果最高4位是e,RTN_MULTICAST
3.如果local_table存在，默认是RTN_UNICAST，
	通过local_table-&gt;tb_lookup查找其类型，如果返回是0
	表示有新的type
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>829</x>
      <y>500</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fn_hash_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>827</x>
      <y>493</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>local_table-&gt;tb_lookup
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>828</x>
      <y>479</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>830</x>
      <y>488</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>834</x>
      <y>496</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ip_fib_init-&gt;fib_hash_init</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>821</x>
      <y>507</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>注：
1.local_table.tb_data中有一个fn_zone的链表
2.每个fn_zone中有一个关于fib_node的hash表
3.fib_node中的fn_key是这个域内，这个type对应的最大值。
	如果是小于这个值，推出这个循环（hash链表中可能按照从大到小的顺序）
	如果等于这个值，还需要通过fib_semantic_match验证，验证通过后返回0.
4.如果在local_table中没有找到，返回1。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>835</x>
      <y>503</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>875</x>
      <y>476</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;prot-&gt;get_port
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>860</x>
      <y>482</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_get_port</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>865</x>
      <y>479</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>852</x>
      <y>489</y>
      <w>31</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.如果传入的port（snum），表示由os指定，os会遍历low~high之间的
	port，在hash表tcp_bhash中查找，看是否被用，如果没有被用，则找到
	（snum = rover;tb = NULL;）如果所有的port都被用，则fail
2.如果snum不为0，同样查看tcp_bhash，如果没找到tb为NULL,否则如果
	重复使用port，tb则会被找到。
3.如果port被重复使用（tb!=NULL）:
	1.如果port允许重复使用（tb-&gt;fastreus），并且申请port的sk也允许
		重复使用（sk-&gt;reuse），只要sk的状态不是TCP_LISTEN，tb就能被重复申请
	2.查看tb的bind链表，查看其中是否有和当前申请sk冲突的sk2（地址相同），如果有
		port不能被重复使用，否则也是可以重复使用的。
4.如果找到了空闲的port，通过tcp_bucket_create申请tb，并根据情况设置tb-&gt;fastreuse
5.如果sk没被分配tb（sk-&gt;prev == NULL），将sk加入到tb的bind链表（tb-&gt;owners是
	链表头，双向链表（bind_pprev，bind_next））
	sk-&gt;prev = (struct sock *) tb;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>865</x>
      <y>485</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>861</x>
      <y>515</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_bucket_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>867</x>
      <y>511</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>855</x>
      <y>521</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过kmem_cache_alloc申请tb
2.初始化tb，并将tb加入到hash表头head中
	tb-&gt;port = snum;
	tb-&gt;fastreuse = 0;
	tb-&gt;owners = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>868</x>
      <y>518</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>827</x>
      <y>471</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>839</x>
      <y>471</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>917</x>
      <y>450</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>936</x>
      <y>454</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_listen</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>932</x>
      <y>461</y>
      <w>38</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.sock的状态要是SS_UNCONNECTED，类型要是SOCK_STREAM
2.sk的状态要是TCPF_CLOSE或者TCPF_LISTEN
3.如果sk状态是close，通过tcp_listen_start监听网络
4.设置队列长度
	sk-&gt;max_ack_backlog = backlog;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>942</x>
      <y>457</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>940</x>
      <y>473</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_listen_start</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>945</x>
      <y>469</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>931</x>
      <y>480</y>
      <w>34</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.设置sk，tp
	sk-&gt;max_ack_backlog = 0;
	sk-&gt;ack_backlog = 0;
	tp-&gt;accept_queue = tp-&gt;accept_queue_tail = NULL;
	tp-&gt;syn_wait_lock = RW_LOCK_UNLOCKED;
2.申请tcp_listen_opt，并初始化其lopt-&gt;max_qlen_log
	最后赋给：
	tp-&gt;listen_opt = lopt;
3.sk-&gt;state = TCP_LISTEN;
4.通过sk-&gt;prot-&gt;get_port申请port，如果之前通过bind申请，
	这里只是改变tb的fastreuse
5.成功之后：
	sk-&gt;sport = htons(sk-&gt;num);
	sk_dst_reset(sk);
	sk-&gt;prot-&gt;hash(sk);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>944</x>
      <y>476</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>939</x>
      <y>505</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;prot-&gt;hash
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>945</x>
      <y>500</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>939</x>
      <y>511</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>945</x>
      <y>508</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>944</x>
      <y>514</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!= TCP_CLOSE</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>939</x>
      <y>517</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__tcp_v4_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>921</x>
      <y>524</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果sk的状态在TCP_LISTEN，链入到tcp_listening_hash
	（tcp_lhash_lock保护），以port号sk.num为hash值
	tcp_lhash_users要为0，否则睡眠（等待队列是tcp_lhash_wait）
2.如果处于其他状态，链入到tcp_ehash（每个表头都有一个锁）
3.将sk头插置hash表中（双链表（pprev，next））
4.prot-&gt;stats[smp_processor_id()].inuse++;
5.如果在TCP_LISTEN，需要唤醒等待队列tcp_lhash_wait
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>944</x>
      <y>520</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>883</x>
      <y>479</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
udp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>888</x>
      <y>483</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_v4_get_port</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>884</x>
      <y>489</y>
      <w>34</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果snum为0，表示由os指定port号，遍历hash表（以port号找sk）
	如果表头是空，说明该port号（或者result/UDP_HTABLE_SIZE）是空闲的
注：1.sysctl_local_port_range[0]是UDP_HTABLE_SIZE的整数倍
	2.port号要在sysctl_local_port_range[0]~sysctl_local_port_range[1]之间
2.如果在hash表中找不到空闲的，就选择hash链表中最短的那个，然后查看port号
	（result += UDP_HTABLE_SIZE）是否空闲（!udp_lport_inuse）
注：这里一直在循环遍历，直到找到为止。

3.如果snum不为0，则在hash表udp_hash中找对应链表，遍历链表，查看是否有和要申请sk
	冲突的sk2（port相同，但是不能reuse），如果存在，fail
4.找到之后，sk-&gt;num = snum;
5.将sk加入到udp_hash对应的链表中，增加计数prot-&gt;stats[smp_processor_id()].inuse++;
	并通过sock_hold增加sk的计数。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>894</x>
      <y>486</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1018</x>
      <y>456</y>
      <w>40</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1050</x>
      <y>460</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_accept</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1040</x>
      <y>467</y>
      <w>40</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过sk1-&gt;prot-&gt;accept接受client发来的请求
2.通过sock_graft将创建的newsock和接收的sk2建立关系
3.newsock-&gt;state = SS_CONNECTED
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1055</x>
      <y>463</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1052</x>
      <y>477</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk1-&gt;prot-&gt;accept
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1057</x>
      <y>473</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1057</x>
      <y>480</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1052</x>
      <y>484</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_accept</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1047</x>
      <y>490</y>
      <w>35</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果sk.state不是TCP_LISTEN，返回EINVAL
2.如果暂时没收到connect请求（!tp-&gt;accept_queue）
	1.通过sock_rcvtimeo确定serve端等待的时间timeo，如果O_NONBLOCK，返回EAGAIN
	2.通过wait_for_connect等待client端连接
3.接收到连接请求：
	1.将req移出链表，并更新链表
		req = tp-&gt;accept_queue;
		tp-&gt;accept_queue = req-&gt;dl_next
	2.获取新的sk
		newsk = req-&gt;sk;
	3.通过tcp_acceptq_removed减少sk接收队列的长度
		sk-&gt;ack_backlog--
	4.通过tcp_openreq_fastfree释放req
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1058</x>
      <y>487</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1057</x>
      <y>515</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait_for_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1062</x>
      <y>511</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1053</x>
      <y>521</y>
      <w>47</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.申请wait，通过add_wait_queue_exclusive加入到sk-&gt;sleep
2.循环等待，直到client端连接
	1.task状态设置为TASK_INTERRUPTIBLE
	2.如果没有connect请求（tcp.accept_queue == NULL），通过schedule_timeout睡眠
	3.醒来之后查看：
		1.如果有连接请求（tcp.accept_queue），跳出循环处理
		2.如果没有连接请求，sk的状态不在TCP_LISTEN，返回EINVAL
		3.如果signal_pending，根据timeo的值看在处理完signal之后，是否在继续accept
		4.如果超时，返回EAGAIN
3.跳出循环后，task状态设置为TASK_RUNNING，并移除wait
注：accept_queue&lt;-tcp_acceptq_queue&lt;-tcp_check_req&lt;-tcp_v4_hnd_req&lt;-tcp_v4_do_rcv&lt;-tcp_prot
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1063</x>
      <y>518</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1108</x>
      <y>456</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops/inet_dgram_ops</panel_attributes>
    <additional_attributes>50.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1118</x>
      <y>461</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_getname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1115</x>
      <y>467</y>
      <w>28</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.sin-&gt;sin_family = AF_INET
2.如果peer不为0
	1.如果没有目标port（!sk-&gt;dport），返回ENOTCONN
	2.如果sk处于TCPF_CLOSE|TCPF_SYN_SENT，但是peer=1，返回ENOTCONN
	3.如果检查通过：
		sin-&gt;sin_port = sk-&gt;dport;
		sin-&gt;sin_addr.s_addr = sk-&gt;daddr;
3.如果peer为0
	1.sin-&gt;sin_port = sk-&gt;sport;
	2.sin-&gt;sin_addr.s_addr默认是sk-&gt;rcv_saddr，只有当其不存在时，才是sk-&gt;saddr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1125</x>
      <y>464</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sock是server端创建的sock</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1171</x>
      <y>444</y>
      <w>90</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops</panel_attributes>
    <additional_attributes>10.0;10.0;880.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1252</x>
      <y>450</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_stream_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1282</x>
      <y>448</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_dgram_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1173</x>
      <y>444</y>
      <w>119</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;1170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1243</x>
      <y>456</y>
      <w>37</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果要连接的地址的sa_family是AF_UNSPEC，通过sk-&gt;prot-&gt;disconnect
	断开连接
2.如果sock的状态是SS_UNCONNECTED，才能处理，其他返回错误码
	1.sk的状态要在TCP_CLOSE
	2.如果sk没被分配port（sk-&gt;num为0），通过sk-&gt;prot-&gt;get_port给sk分配port号
		sk-&gt;sport = htons(sk-&gt;num)
	3.通过sk-&gt;prot-&gt;connect连接serve：
		sock-&gt;state = SS_CONNECTING
3.
注：sock状态：SS_UNCONNECTED  SS_CONNECTING SS_CONNECTED
	sk的状态：TCPF_CLOSE，TCPF_LISTEN
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1259</x>
      <y>453</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1244</x>
      <y>469</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;prot-&gt;disconnect
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1245</x>
      <y>476</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_disconnect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1250</x>
      <y>465</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1250</x>
      <y>472</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1261</x>
      <y>469</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;prot-&gt;connect
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1267</x>
      <y>465</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1267</x>
      <y>472</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1262</x>
      <y>476</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1003</x>
      <y>318</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_init
(linux/net/ipv4)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>994</x>
      <y>325</y>
      <w>42</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.检查网络传输数据（inet_skb_parm）的大小是否超过skb.cb
	如果超过，返回EINVAL
2.通过sock_register将inet_family_ops注册到net_families中
3.遍历链表inet_protocol_base，通过inet_add_protocol将协议
	放在hash表inet_protos中
4.分别执行一下初始化：arp_init，ip_init，tcp_v4_init，tcp_init，icmp_init
5.在proc_net下创建raw，netstat，snmp，sockstat，tcp，udp文件
	并赋值其get_info方法：raw_get_info，netstat_get_info，snmp_get_info，afinet_get_info，tcp_get_info，udp_get_info
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1009</x>
      <y>321</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>937</x>
      <y>346</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_add_protocol</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>923</x>
      <y>353</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过prot-&gt;protocol计算hash值，并将inet_protocol连接到inet_protos
2.检查原来的hash表中是否有和当前protocol一样的inet_protocol，如果有：
	prot-&gt;copy = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>940</x>
      <y>349</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>998</x>
      <y>343</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1004</x>
      <y>338</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp是地址解析协议
用于硬件通过广播利用ip地址获取以太网地址</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>971</x>
      <y>349</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_table_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>977</x>
      <y>346</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_tbl</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>959</x>
      <y>355</y>
      <w>30</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.将tbl-&gt;parms.reachable_time取1/2~3/2的tbl-&gt;parms.base_reachable_time
2.申请tbl-&gt;entry_size长度（16字节对齐）的内存，tbl-&gt;id是其cache的名字
3.通过tasklet_init初始化tbl-&gt;gc_task：
	tasklet-&gt;routine = SMP_TIMER_NAME(neigh_periodic_timer)
	tasklet-&gt;data = tbl
4.初始化tbl-&gt;gc_timer，并通过add_timer将其加入timer队列
	tbl-&gt;lock = RW_LOCK_UNLOCKED;
	tbl-&gt;gc_timer.data = (unsigned long)tbl;
	tbl-&gt;gc_timer.function = neigh_periodic_timer;
	tbl-&gt;gc_timer.expires = now + tbl-&gt;gc_interval + tbl-&gt;parms.reachable_time;
5.初始化tbl-&gt;proxy_timer
	init_timer(&amp;tbl-&gt;proxy_timer);
	tbl-&gt;proxy_timer.data = (unsigned long)tbl;
	tbl-&gt;proxy_timer.function = neigh_proxy_process;
	skb_queue_head_init(&amp;tbl-&gt;proxy_queue);
6.设置时间，并将其加入链表neigh_tables
	tbl-&gt;last_flush = now;
	tbl-&gt;last_rand = now + tbl-&gt;parms.reachable_time*20;
	tbl-&gt;next = neigh_tables;
	neigh_tables = tbl;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>971</x>
      <y>352</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>943</x>
      <y>338</y>
      <w>64</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>993</x>
      <y>350</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_add_pack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>995</x>
      <y>346</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_packet_type</panel_attributes>
    <additional_attributes>80.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>990</x>
      <y>356</y>
      <w>35</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果CONFIG_NET_FASTROUTE打开，并且pt-&gt;data存在
	通过dev_clear_fastroute清除其fast_path，并：
	netdev_fastroute_obstacles++
2.如果type是ETH_P_ALL，将其加入链表ptype_all，并递增netdev_nit
3.否则加入到hash表ptype_base中
	hash=ntohs(pt-&gt;type)&amp;15;
	pt-&gt;next = ptype_base[hash];
	ptype_base[hash] = pt;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>999</x>
      <y>353</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>993</x>
      <y>373</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_clear_fastroute</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>990</x>
      <y>381</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果dev存在，通过dev_do_clear_fastroute
	清除其fast_path
2.如果不存在，遍历链表dev_base，通过dev_do_clear_fastroute
	清除其fast_path
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>991</x>
      <y>392</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_do_clear_fastroute</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>988</x>
      <y>399</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.遍历数组dev-&gt;fastpath：
	dst = dev-&gt;fastpath[i];
	dev-&gt;fastpath[i] = NULL;
2.通过dst_release释放dst
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>999</x>
      <y>369</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1000</x>
      <y>376</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>999</x>
      <y>388</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>998</x>
      <y>395</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1012</x>
      <y>350</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_net_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1001</x>
      <y>346</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在proc_net下创建文件arp
get_info是arp_get_info</panel_attributes>
    <additional_attributes>20.0;10.0;150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1029</x>
      <y>350</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_sysctl_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1002</x>
      <y>346</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1026</x>
      <y>356</y>
      <w>35</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.申请neigh_sysctl_table，
2.创建目录：neigh_root_dir/neigh_proto_dir/neigh_neigh_dir/neigh_dev
	并对每一层赋值（前面一大段是将neigh_sysctl_template赋值，并对其中的neigh_vars.data赋值）
3.通过register_sysctl_table申请ctl_table_header，加入到root_table_header链表
	并返回赋给t-&gt;sysctl_header。其次通过register_proc_table在procfs中创建1的路径
	（如果有table-&gt;proc_handler是普通文件，没有是dir。另外如果是dir会在root-&gt;subdir中
		查找是否有procname一直的文件夹，有的话就不创建了）
4.将neigh_sysctl_table赋给p-&gt;sysctl_table
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1038</x>
      <y>353</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;30.0</additional_attributes>
  </element>
</diagram>
