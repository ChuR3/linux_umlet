<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram program="umlet" version="14.3.0">
  <help_text>t// Uncomment the following line to change the fontsize and font:
// fontsize=14
// fontfamily=SansSerif //possible: SansSerif,Serif,Monospaced


//////////////////////////////////////////////////////////////////////////////////////////////
// Welcome to UMLet!
//
// Double-click on elements to add them to the diagram, or to copy them
// Edit elements by modifying the text in this panel
// Hold Ctrl to select multiple elements
// Use Ctrl+mouse to select via lasso
//
// Use +/- or Ctrl+mouse wheel to zoom
// Drag a whole relation at its central square icon
//
// Press Ctrl+C to copy the whole diagram to the system clipboard (then just paste it to, eg, Word)
// Edit the files in the "palettes" directory to create your own element palettes
//
// Select "Custom Elements &gt; New..." to create new element types
//////////////////////////////////////////////////////////////////////////////////////////////


// This text will be stored with each diagram;  use it for notes.</help_text>
  <zoom_level>10</zoom_level>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3190</x>
      <y>1280</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>610</x>
      <y>1470</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_scan_one_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1280</x>
      <y>1470</y>
      <w>100</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>sget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>700</x>
      <y>1310</y>
      <w>2570</w>
      <h>180</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2550.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>840</x>
      <y>1480</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_open_devices</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>920</x>
      <y>1310</y>
      <w>2370</w>
      <h>190</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2350.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>760</x>
      <y>1550</y>
      <w>380</w>
      <h>330</h>
    </coordinates>
    <panel_attributes>1.遍历fs_devices-&gt;devices
	1.bdev不能存在
	2.name要存在
	3.btrfs_get_bdev_and_sb打开设备，并读取sb
	4.比较sb中的devid，uuid，
	5.选取generation最大的device
	6.设置device.writeable
	7.查看QUEUE_FLAG_DISCARD，设置device-&gt;can_discard
	8.device-&gt;bdev = bdev;
		device-&gt;in_fs_metadata = 0;
		device-&gt;mode = flags;
	9.查看QUEUE_FLAG_NONROT，设置fs_devices-&gt;rotating
	10.fs_devices-&gt;open_devices++;
	11.writeable  &amp;&amp;   BTRFS_DEV_REPLACE_DEVID
		fs_devices-&gt;rw_devices++;
		device加入到fs_devices-&gt;alloc_list
2.fs_devices-&gt;seeding = seeding;
	fs_devices-&gt;opened = 1;
	fs_devices-&gt;latest_bdev = latest_dev-&gt;bdev;
	fs_devices-&gt;total_rw_bytes = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>910</x>
      <y>1510</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>750</x>
      <y>1920</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_get_bdev_and_sb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>650</x>
      <y>1990</y>
      <w>340</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.通过blkdev_get_by_path获取并打开bdev
2.如果flush置上，通过filemap_write_and_wait刷写等待
3.set_blocksize设置block_size是4096
4.invalidate_bdev无效化buffer
5.btrfs_read_dev_super读取sb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>820</x>
      <y>1950</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>610</x>
      <y>2110</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>blkdev_get_by_path</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>510</x>
      <y>2180</y>
      <w>350</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.通过lookup_bdev通过dev_path获取bdev
2.blkdev_get打开bdev
3.如果bdev是readonly，但是需要write，blkdev_put
	将其释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>670</x>
      <y>2140</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>360</x>
      <y>2300</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lookup_bdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>300</x>
      <y>2360</y>
      <w>280</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.pathname要存在
2.通过kern_path查找path
3.inode要是ISBLK
	mnt_flags的MNT_NODEV不能置上
4.通过bd_acquire获取bdev，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>370</x>
      <y>2490</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>bd_acquire</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>260</x>
      <y>2560</y>
      <w>350</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.如果inode-&gt;i_bdev存在，直接返回
2.bdget通过设备号i_rdev获取bdev
3.如果找到
	1.inode-&gt;i_bdev = bdev;
	inode-&gt;i_mapping = bdev-&gt;bd_inode-&gt;i_mapping;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>420</x>
      <y>2520</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>350</x>
      <y>2690</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>bdget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>400</x>
      <y>2650</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>220</x>
      <y>2770</y>
      <w>390</w>
      <h>230</h>
    </coordinates>
    <panel_attributes>1.通过iget5_locked查找或者创建inode
2.如果inode的状态是I_NEW，设置bdev_inode.bdev
	1.bdev-&gt;bd_contains = NULL;
	bdev-&gt;bd_super = NULL;
	bdev-&gt;bd_inode = inode;
	bdev-&gt;bd_block_size = (1 &lt;&lt; inode-&gt;i_blkbits);
	bdev-&gt;bd_part_count = 0;
	bdev-&gt;bd_invalidated = 0;
	inode-&gt;i_mode = S_IFBLK;
	inode-&gt;i_rdev = dev;
	inode-&gt;i_bdev = bdev;
	inode-&gt;i_data.a_ops = &amp;def_blk_aops;
	2.将i_data的GFP_USER置上
	3.将bdev加入到链表all_bdevs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>210</x>
      <y>3030</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>iget5_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>110</x>
      <y>3100</y>
      <w>360</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>1.通过find_inode在inode_hashtable中找到inode
2.如果找到inode，通过wait_on_inode等待inode变成__I_NEW
	后返回
3.通过alloc_inode分配inode
4.如果找到
	1.通过find_inode再次在hash表中查找
		1.如果没找到，(bdev_set)设置bdev的设备号
		2.inode-&gt;i_state = I_NEW;
		3.hlist_add_head将inode挂入到hash表
		4.inode_sb_list_add将inode和sb关联
		5.返回inode
	2.如果找到
		1.通过destroy_inode摧毁新申请的inode
		2.返回old
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>260</x>
      <y>2990</y>
      <w>160</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
blockdev_superblock
bdev_test</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>100</x>
      <y>3370</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>0</x>
      <y>3440</y>
      <w>340</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.遍历hash表
	1.找到sb相同的inode
	2.test(bdev_test)检查设备号是否相同
	3.如果inode的状态在I_FREEING或者I_WILL_FREE
		通过__wait_on_freeing_inode等待变成__I_NEW
		然后再次查找hash
	4.找到即返回inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>150</x>
      <y>3330</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>140</x>
      <y>3400</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>260</x>
      <y>3060</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>400</x>
      <y>2720</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>420</x>
      <y>2330</y>
      <w>40</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>410</x>
      <y>2450</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>700</x>
      <y>2300</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>blkdev_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>630</x>
      <y>2370</y>
      <w>280</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>1.通过bd_start_claiming等待claiming
2.__blkdev_get打开bdev
3.如果有whole
	1.如果bdev正确打开
		whole-&gt;bd_holders++;
		whole-&gt;bd_holder = bd_may_claim;
		bdev-&gt;bd_holders++;
		bdev-&gt;bd_holder = holder
	2.whole-&gt;bd_claiming = NULL;
	3.wake_up_bit唤醒bd_claiming为0的
	4.如果
		bdev-&gt;bd_write_holder = true;
		disk_block_events(disk);
	5.bdput释放whole	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>700</x>
      <y>2660</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>bd_start_claiming</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>640</x>
      <y>2740</y>
      <w>360</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.通过get_gendisk获取disk
2.如果有partno，通过disk--&gt;part--&gt;dev--&gt;bdev
	否则直接获取bdev
3.bd_prepare_to_claim等待whole.bd_claiming变0
	whole-&gt;bd_claiming = holder
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>760</x>
      <y>2860</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>get_gendisk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>670</x>
      <y>2920</y>
      <w>340</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.如果主设备号不是BLOCK_EXT_MAJOR
	1.kobj_lookup在bdev_map中查找
	2.kobj--&gt;dev--&gt;gendisk
2.如果主设备号是BLOCK_EXT_MAJOR
	1.idr_find在ext_devt_idr获取part
	2.part--&gt;disk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>630</x>
      <y>3070</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>kobj_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>540</x>
      <y>3140</y>
      <w>330</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.根据主设备号，遍历对应的bucket
	1.设备号要在dev~dev+range-1
	2.找到range最小的best
	3.try_module_get获取probe
	4.p-&gt;lock要能成功
	5.执行p-&gt;get
	6.index返回的是设备号在bucket的偏移
	7.返回kobj
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>690</x>
      <y>3100</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>930</x>
      <y>3070</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>idr_find</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>880</x>
      <y>3130</y>
      <w>310</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.如果idr-&gt;hint的prefix相同，找到hint-&gt;ary[后缀]
2.idr_find_slowpath
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1000</x>
      <y>3100</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>680</x>
      <y>3020</y>
      <w>100</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>840</x>
      <y>3020</y>
      <w>170</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>810</x>
      <y>2890</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>810</x>
      <y>2820</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>750</x>
      <y>2690</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1110</x>
      <y>2660</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__blkdev_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1050</x>
      <y>2720</y>
      <w>380</w>
      <h>410</h>
    </coordinates>
    <panel_attributes>1.devcgroup_inode_permission
2.get_gendisk获取disk
3.如果bd_openers不存在
	1.bdev-&gt;bd_disk = disk;
		bdev-&gt;bd_queue = disk-&gt;queue;
		bdev-&gt;bd_contains = bdev;
		bdev-&gt;bd_inode-&gt;i_flags 
	2.如果partno为0
		1.设置bdev-&gt;bd_part
		2.disk-&gt;fops-&gt;open
		3.bd_set_size设置size
		4.如果存在bdev-&gt;bd_invalidated
	3.如果不为0
		1.__blkdev_get递归调用
		2.bdev-&gt;bd_contains = whole;
			bdev-&gt;bd_part = disk_get_part
		3.bd_set_size设置size
		4.
4.如果有bd_openers
	1. bdev-&gt;bd_disk-&gt;fops-&gt;open
	2.如果有bdev-&gt;bd_invalidated
	3.
5.bdev-&gt;bd_openers++
6.如果设置了for_part
	bdev-&gt;bd_part_count++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1190</x>
      <y>3150</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>bd_set_size</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1190</x>
      <y>3210</y>
      <w>320</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>1.设置bdev-&gt;bd_inode.i_size
2.bdev-&gt;bd_block_size = bsize;
	bdev-&gt;bd_inode-&gt;i_blkbits = blksize_bits(bsize)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1250</x>
      <y>3180</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1150</x>
      <y>2690</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1240</x>
      <y>3120</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>740</x>
      <y>2600</y>
      <w>30</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>780</x>
      <y>2600</y>
      <w>390</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>750</x>
      <y>2330</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>410</x>
      <y>2260</y>
      <w>230</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>640</x>
      <y>2260</y>
      <w>150</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>950</x>
      <y>2120</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>set_blocksize</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>920</x>
      <y>2190</y>
      <w>270</w>
      <h>130</h>
    </coordinates>
    <panel_attributes>1.size要在512~page，并且是2的倍数
2.size不能小于bdev_logical_block_size
3.如果bd_block_size发生改变
	1.sync_blockdev进行同步
	2.bdev-&gt;bd_block_size = size;
		bdev-&gt;bd_inode-&gt;i_blkbits = blksize_bits
	3.kill_bdev将bdev的buffer同步
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1010</x>
      <y>2150</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>660</x>
      <y>2070</y>
      <w>60</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>860</x>
      <y>2070</y>
      <w>170</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1290</x>
      <y>2110</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_read_dev_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>910</x>
      <y>2070</y>
      <w>460</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1220</x>
      <y>2180</y>
      <w>300</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.通过btrfs_read_dev_one_super读取超级块
2.选取generation最大的sb(但是这里的i是1)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1370</x>
      <y>2140</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1260</x>
      <y>2270</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_read_dev_one_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1190</x>
      <y>2340</y>
      <w>270</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.btrfs_sb_offset计算sb的偏移
2.其长度不能超过bdev-&gt;bd_inode.i_size
3.__bread读取超级块
4.检查sb的偏移和magic
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1340</x>
      <y>2300</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1340</x>
      <y>2230</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>820</x>
      <y>1870</y>
      <w>40</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1330</x>
      <y>1310</y>
      <w>1960</w>
      <h>180</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_test_super
btrfs_set_super</panel_attributes>
    <additional_attributes>1940.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1180</x>
      <y>1540</y>
      <w>330</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.遍历fs_type.fs_supers链表
	1.test(btrfs_test_super)检查到fs_devices相同
	2.grab_super检查到MS_BORN，并且s_active置上
	3.如果之前找到s，通过destroy_super将其释放
	4.返回old
2.如果没找到s
	1.通过alloc_super申请，并初始化sb
	2.申请到之后，跳到1，看是否能找到
3.set(btrfs_set_super)设置s-&gt;s_fs_info
4.和filesystem_type关联
	s-&gt;s_type = type
	s-&gt;s_id=type-&gt;name
	s-&gt;s_instances加入到链表type-&gt;fs_supers
	s-&gt;s_list加入到链表super_blocks
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1320</x>
      <y>1500</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5110</x>
      <y>1310</y>
      <w>330</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.如果存在s-&gt;s_root
	1.通过btrfs_close_devices关闭fs_devices和fs_devices-&gt;seed
	2.free_fs_info释放fs_info
	3.MS_RDONLY标记要一样
2.如果不存在
	1.s-&gt;s_id= bdevname(bdev, b)
	2.sb-&gt;s_fs_info.bdev_holder=fs_type
	3.btrfs_fill_super填充sb
3.返回s-&gt;s_root
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3260</x>
      <y>1300</y>
      <w>1960</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;20.0;1940.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5210</x>
      <y>1500</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_fill_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5260</x>
      <y>1460</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5090</x>
      <y>1570</y>
      <w>400</w>
      <h>290</h>
    </coordinates>
    <panel_attributes>1.sb-&gt;s_maxbytes = MAX_LFS_FILESIZE;
	sb-&gt;s_magic = BTRFS_SUPER_MAGIC;
	sb-&gt;s_op = &amp;btrfs_super_ops;
	sb-&gt;s_d_op = &amp;btrfs_dentry_operations;
	sb-&gt;s_export_op = &amp;btrfs_export_ops;
	sb-&gt;s_xattr = btrfs_xattr_handlers;
	sb-&gt;s_time_gran = 1;
	sb-&gt;s_flags |= MS_POSIXACL;
	sb-&gt;s_flags |= MS_I_VERSION;
	sb-&gt;s_iflags |= SB_I_CGROUPWB;
2.open_ctree打开sb
3.btrfs_iget获取key对应的inode
4.d_make_root设置sb.root
	dentry-&gt;d_op=dentry-&gt;d_sb-&gt;s_d_op
5.保存sb-&gt;s_options
6.cleancache_init_fs
7.sb-&gt;s_flags |= MS_ACTIVE
8.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5260</x>
      <y>1530</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4590</x>
      <y>1940</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>open_ctree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2000</x>
      <y>2050</y>
      <w>370</w>
      <h>360</h>
    </coordinates>
    <panel_attributes>1.申请fs_info-&gt;tree_root和fs_info-&gt;chunk_root
	root-&gt;fs_info = fs_info
2.init_srcu_struct初始化fs_info-&gt;subvol_srcu
3.setup_bdi初始化fs_info-&gt;bdi
4.percpu_counter_init初始化dirty_metadata_bytes
	delalloc_bytes bio_counter
5.设置dirty_metadata_batch
6.设置fs_info-&gt;btree_inode
7.初始化fs_info
	fs_info-&gt;sb = sb;
8.sb-&gt;s_blocksize = 4096;
	sb-&gt;s_blocksize_bits = blksize_bits(4096);
	sb-&gt;s_bdi = &amp;fs_info-&gt;bdi;
9.btrfs_init_btree_inode初始化fs_info-&gt;btree_inode
	1.extent_io_tree_init通过btree_inode-&gt;i_mapping初始化freed_extents
10.btrfs_alloc_stripe_hash_table
11.__setup_root设置tree_root
12.btrfs_read_dev_super读取sb，并根据sb设置fs_info-&gt;super_copy
	super_for_commit
	1.fs_info-&gt;fsid=fs_info-&gt;super_copy-&gt;fsid
	2.btrfs_check_super_valid检查sb
	3.btrfs_super_root要存在
	4.btrfs_super_flags设置fs_state error
	5.find_oldest_super_backup设置backup_root_index
	6.fs_info-&gt;compress_type = BTRFS_COMPRESS_ZLIB
13.btrfs_parse_options根据options设置tree_root
14.设置dirty_metadata_batch delalloc_batch
15.btrfs_init_workqueues设置fs_info
16.设置fs_info-&gt;bdi.ra_pages
17.tree_root-&gt;nodesize = nodesize;
	tree_root-&gt;sectorsize = sectorsize;
	tree_root-&gt;stripesize = stripesize
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2110</x>
      <y>1970</y>
      <w>2560</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2540.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1750</x>
      <y>2470</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>setup_bdi</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1790</x>
      <y>2400</y>
      <w>320</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1570</x>
      <y>2540</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>bdi_setup_and_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1660</x>
      <y>2500</y>
      <w>150</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1780</x>
      <y>2550</y>
      <w>270</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>bdi-&gt;ra_pages = VM_MAX_READAHEAD * 1024 / PAGE_CACHE_SIZE;
	bdi-&gt;congested_fn	= btrfs_congested_fn;
	bdi-&gt;congested_data	= info;
	bdi-&gt;capabilities |= BDI_CAP_CGROUP_WRITEBACK
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1800</x>
      <y>2500</y>
      <w>90</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2130</x>
      <y>2480</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>new_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2180</x>
      <y>2400</y>
      <w>120</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2090</x>
      <y>2550</y>
      <w>330</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.通过new_inode_pseudo申请inode
2.inode_sb_list_add将inode挂入到inode-&gt;i_sb-&gt;s_inodes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2180</x>
      <y>2510</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2160</x>
      <y>2630</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>new_inode_pseudo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2220</x>
      <y>2590</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2220</x>
      <y>2660</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2180</x>
      <y>2700</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>alloc_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1920</x>
      <y>2950</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;alloc_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2220</x>
      <y>2730</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1970</x>
      <y>2980</y>
      <w>130</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_super_ops</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1930</x>
      <y>3010</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_alloc_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2530</x>
      <y>2470</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_init_btree_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2310</x>
      <y>2400</y>
      <w>320</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2450</x>
      <y>2540</y>
      <w>390</w>
      <h>170</h>
    </coordinates>
    <panel_attributes>1.fs_info-&gt;btree_inode-&gt;i_ino = BTRFS_BTREE_INODE_OBJECTID
	fs_info-&gt;btree_inode.__i_nlink=1
	fs_info-&gt;btree_inode-&gt;i_size = OFFSET_MAX;
	fs_info-&gt;btree_inode-&gt;i_mapping-&gt;a_ops = &amp;btree_aops;
2.btrfs_inode.io_tree
	btrfs_inode.extent_tree
	btrfs_inode.io_tree.ops = &amp;btree_extent_io_ops
3.btrfs_inode.root = tree_root
4.fs_info-&gt;btree_inode挂入到inode_hashtable
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2600</x>
      <y>2500</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3220</x>
      <y>2450</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_read_sys_array</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3180</x>
      <y>2520</y>
      <w>380</w>
      <h>230</h>
    </coordinates>
    <panel_attributes>1.btrfs_find_create_tree_block查找并创建eb以及其中的page
2.btrfs_set_buffer_uptodate设置eb的所有page uptodate
3.btrfs_set_buffer_lockdep_class
4.如果page超过了block的长度，将sb-&gt;pages[0]设置为uptodate
5.write_extent_buffer将sb写入到eb中
6.遍历sys_chunk_array
	1.以btrfs_disk_key解析(disk_key+ btrfs_chunk + (n-1)*btrfs_stripe)
	2.如果超过了array_size，跳到out_short_read
	3.btrfs_disk_key_to_cpu设置key
	4.如果是BTRFS_CHUNK_ITEM_KEY
		1.长度不能超过array_size
		2.read_one_chunk读取chunk加入到mapping_tree中
7.free_extent_buffer将sb释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3290</x>
      <y>2480</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3040</x>
      <y>2770</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_find_create_tree_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3040</x>
      <y>2830</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>alloc_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2990</x>
      <y>2900</y>
      <w>310</w>
      <h>420</h>
    </coordinates>
    <panel_attributes>1.find_extent_buffer在buffer_radix中看是否能找到eb
	如果找到，直接返回eb
	如果找不到，通过__alloc_extent_buffer申请eb
2.遍历eb的所有page
	1.通过find_or_create_page获取eb的page
	注：mapping指向btree_inode
	2.如果PagePrivate
		1.如果p-&gt;private.refs是0
			1.释放p
			2.将exists中除了p之外的page设置为access
			3.跳到free_eb
	3.ClearPagePrivate，并释放p
	4.attach_extent_buffer_page设置p的eb
		eb-&gt;pages[i] = p
	5.如果有存在!PageUptodate
		uptodate=0
3.如果uptodate置上，将eb的EXTENT_BUFFER_UPTODATE置上
4.通过radix_tree_insert将eb插入到fs_info-&gt;buffer_radix
5.如果返回EEXIST，通过find_extent_buffer再次查找eb，
	如果找到，跳到free_eb，如果没找到，跳到4重新插入eb
6.通过check_buffer_tree_ref检查eb.refs
7.设置eb的EXTENT_BUFFER_IN_TREE
8.将eb的page[0]的PageChecked置上，将其他page 通过PageChecked
	清掉
9.返回eb
10.free_eb
	1.解锁eb所有的page
	2.btrfs_release_extent_buffer释放eb和page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2480</x>
      <y>3380</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2400</x>
      <y>3600</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>radix_tree_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2400</x>
      <y>3670</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__radix_tree_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2440</x>
      <y>3550</y>
      <w>150</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fs_info-&gt;buffer_radix</panel_attributes>
    <additional_attributes>90.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2310</x>
      <y>3740</y>
      <w>370</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>1.如果root-&gt;rnode为NULL,返回NULL
2.如果node是direct(指针最低位不为1)
	1.如果index&gt;0，返回NULL
	2.如果存在slotp，返回&amp;root-&gt;rnode
	3.返回node
3.将node最低位的1清掉，成为指针
4.index超过了maxindex(由height(path)转化)，返回NULL
5.递归遍历height次node-&gt;slots，返回node
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2470</x>
      <y>3700</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2470</x>
      <y>3630</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2420</x>
      <y>3450</y>
      <w>360</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.radix_tree_lookup在fs_info-&gt;buffer_radix找eb
2.如果找到，并且索引eb-&gt;refs不为0
	1.eb-&gt;refs++
	2.如果eb在EXTENT_BUFFER_STALE，试图上锁
	3.mark_extent_buffer_accessed将eb中的page reference
3.返回eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2700</x>
      <y>3600</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>mark_extent_buffer_accessed</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2680</x>
      <y>3550</y>
      <w>120</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2740</x>
      <y>3730</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>check_buffer_tree_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2720</x>
      <y>3790</y>
      <w>290</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.如果eb-&gt;refs大于2，并且EXTENT_BUFFER_TREE_REF，直接返回
2.如果不在EXTENT_BUFFER_TREE_REF
	1.置上EXTENT_BUFFER_TREE_REF
	2.递增eb-&gt;refs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2810</x>
      <y>3760</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2700</x>
      <y>3650</y>
      <w>320</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.check_buffer_tree_ref检查ref
2.将数组eb-&gt;pages中的page mark_page_accessed
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2800</x>
      <y>3690</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2540</x>
      <y>3410</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2970</x>
      <y>3400</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__alloc_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2930</x>
      <y>3470</y>
      <w>320</w>
      <h>130</h>
    </coordinates>
    <panel_attributes>1.申请eb，并初始化
	eb-&gt;start = start;
	eb-&gt;len = len;
	eb-&gt;fs_info = fs_info;
	btrfs_leak_debug_add(&amp;eb-&gt;leak_list, &amp;buffers)
	atomic_set(&amp;eb-&gt;refs, 1);
	atomic_set(&amp;eb-&gt;io_pages, 0)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3040</x>
      <y>3430</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3320</x>
      <y>3400</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_or_create_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3320</x>
      <y>3460</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>pagecache_get_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3400</x>
      <y>3430</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3200</x>
      <y>3810</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_get_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3070</x>
      <y>3870</y>
      <w>370</w>
      <h>190</h>
    </coordinates>
    <panel_attributes>1.radix_tree_lookup_slot在mapping-&gt;page_tree找到对应的offset
	page的指针
2.如果找到
	1.如果page为NULL,跳出
	2.检查page indirect exception有没有置上
		1.如果indirect置上，跳到1重新查找
		2.否则跳出
	3.page_cache_get_speculative检查page.count，如果为0
		跳到1重新查找
	4.如果指针指向的page发生了改变，重新查找
3.返回page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3250</x>
      <y>3840</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3280</x>
      <y>3520</y>
      <w>320</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.通过find_get_entry在mapping中查找缓存page
	1.如果exception，page=NULL
	2.如果FGP_LOCK
		1.如果FGP_NOWAIT
			1.设置PG_locked，如果已经locked，将page释放
		2.否则通过lock_page锁page
		3.如果page-&gt;mapping发生改变，将page解锁，并释放，然后重新在mapping中查找
	3.如果找到page，并且FGP_ACCESSED，通过mark_page_accessed索引page
2.如果没找到page，并且FGP_CREAT
	1.设置gfp_mask
	2.__page_cache_alloc申请page
		fgp_flags |= FGP_LOCK
	3.如果FGP_ACCESSED，将page索引
	4.通过add_to_page_cache_lru添加到，如果出错，释放page
3.返回page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3400</x>
      <y>3490</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3250</x>
      <y>3760</y>
      <w>140</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3520</x>
      <y>3800</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>add_to_page_cache_lru</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3520</x>
      <y>3870</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__add_to_page_cache_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3600</x>
      <y>3830</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3460</x>
      <y>3760</y>
      <w>170</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3520</x>
      <y>3940</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>page_cache_tree_insert</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3600</x>
      <y>3900</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3470</x>
      <y>4010</y>
      <w>350</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.__radix_tree_create创建node
2.如果slot有值
	1.exceptional要置上
	2.*shadowp = p;
		mapping-&gt;nrshadows--
	3.递减node-&gt;count
3.*slot= page
	mapping-&gt;nrpages++;
4.如果node存在
	1.node-&gt;count++
	2.如果private_list在链表中，将其脱链
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3600</x>
      <y>3970</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3430</x>
      <y>4240</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__radix_tree_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3480</x>
      <y>4200</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3290</x>
      <y>4310</y>
      <w>400</w>
      <h>230</h>
    </coordinates>
    <panel_attributes>1.如果index超过了2^height，通过radix_tree_extend对height扩充
2.遍历树root-&gt;rnode
	1.从高到低位遍历index（有height个RADIX_TREE_MAP_SHIFT组）成为offset的slot
	2.如果该slot不存在
		1.通过radix_tree_node_alloc申请一个node
			slot-&gt;path = height;
			slot-&gt;parent = node;
		2.如果存在node
			1.node-&gt;slots[offset]=slot
				node-&gt;count++;
				slot-&gt;path |= offset &lt;&lt; RADIX_TREE_HEIGHT_SHIFT
		3.如果不存在
			root-&gt;rnode= ptr_to_indirect(slot)
3.nodep返回父节点，slotp返回指向slot的指针
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3480</x>
      <y>4270</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3280</x>
      <y>4570</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>radix_tree_extend</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3190</x>
      <y>4640</y>
      <w>390</w>
      <h>230</h>
    </coordinates>
    <panel_attributes>1.递增root-&gt;height，直到index大于2^height
2.如果rnode为NULL,直接赋值height，并返回
	root-&gt;height = height
3.否则
	1.radix_tree_node_alloc申请node
	2.如果对应的gfp_mask中对应的tag位置上，通过tag_set将
		node-&gt;tags[tag]第0位置上
	3.新申请的node成为rnode的parent
		node-&gt;path = root-&gt;height+1;
		node-&gt;count = 1;
		node-&gt;parent = NULL;
		node-&gt;slots[0]=root-&gt;rnode//根据height看是否转化成ptr
		root-&gt;rnode= node//转换成indirect
		root-&gt;height = newheight
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3140</x>
      <y>4910</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>radix_tree_node_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3060</x>
      <y>4980</y>
      <w>350</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.如果__GFP_DIRECT_RECLAIM没置上，并且不在中断中
	1.提取链表rtp-&gt;nodes中的node
		rtp-&gt;nr--
2.否则通过kmem_cache_alloc申请node
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3220</x>
      <y>4940</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3210</x>
      <y>4860</y>
      <w>50</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3320</x>
      <y>4600</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3340</x>
      <y>4530</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3690</x>
      <y>3390</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>attach_extent_buffer_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3640</x>
      <y>3460</y>
      <w>270</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.如果PagePrivate没置上
	1.SetPagePrivate置上page
	2.page_cache_get递增page计数
	3.set_page_private设置page.private=eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3770</x>
      <y>3420</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4060</x>
      <y>3380</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>radix_tree_insert</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3940</x>
      <y>3450</y>
      <w>310</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.通过__radix_tree_create创建index对应的slot
2.*slot=item
3.如果有父节点
	node.count++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4110</x>
      <y>3410</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4360</x>
      <y>3370</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_release_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4260</x>
      <y>3440</y>
      <w>230</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_release_extent_buffer_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4530</x>
      <y>3440</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__free_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4370</x>
      <y>3400</y>
      <w>90</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4480</x>
      <y>3400</y>
      <w>160</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4260</x>
      <y>3510</y>
      <w>250</w>
      <h>130</h>
    </coordinates>
    <panel_attributes>1.如果eb的page数为0，直接返回
2.从后向前遍历eb.page
	1.如果PagePrivate，并且private指向eb
		1.ClearPagePrivate
		2.page.private=0
		3.page_cache_release释放page
	2.page_cache_release释放page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4360</x>
      <y>3470</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4530</x>
      <y>3510</y>
      <w>210</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.将eb-&gt;leak_list脱链
2.kmem_cache_free释放eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4610</x>
      <y>3470</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3120</x>
      <y>2860</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3120</x>
      <y>2800</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3320</x>
      <y>2770</y>
      <w>220</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_set_buffer_uptodate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3310</x>
      <y>2910</y>
      <w>310</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.将eb的EXTENT_BUFFER_UPTODATE置上
2.通过SetPageUptodate设置所有的eb-&gt;pages
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3440</x>
      <y>2800</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3340</x>
      <y>2840</y>
      <w>220</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>set_extent_buffer_uptodate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3430</x>
      <y>2870</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3650</x>
      <y>2760</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>write_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3630</x>
      <y>2830</y>
      <w>330</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.将数据从src赋值到eb.page中，复制的长度不能
	超过page
注：start表示在eb内偏移量
	start_offset表示page内的偏移
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3710</x>
      <y>2790</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4050</x>
      <y>2750</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_disk_key_to_cpu</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4120</x>
      <y>2780</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3990</x>
      <y>2820</y>
      <w>290</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>cpu-&gt;offset = le64_to_cpu(disk-&gt;offset);
cpu-&gt;type = disk-&gt;type;
cpu-&gt;objectid = le64_to_cpu(disk-&gt;objectid)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4350</x>
      <y>2740</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>read_one_chunk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4300</x>
      <y>2820</y>
      <w>340</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.通过lookup_extent_mapping在mapping_tree.map_tree找disk对应的offset
2.如果找到了，并且在范围内，说明disk已经在map_tree中，通过free_extent_map递减其计数，并返回0
	如果不在返回内，也通过free_extent_map递减其计数，并继续
3.通过alloc_extent_map申请em
4.kmalloc申请map(map_lookup + n* btrfs_bio_stripe)
5.初始化em和map
	set_bit(EXTENT_FLAG_FS_MAPPING, &amp;em-&gt;flags);
	em-&gt;bdev = (struct block_device *)map;
	em-&gt;start = logical;
	em-&gt;len = length;
	em-&gt;orig_start = 0;
	em-&gt;block_start = 0;
	em-&gt;block_len = em-&gt;len;

	//map
	map-&gt;num_stripes = num_stripes;
	map-&gt;io_width = btrfs_chunk_io_width(leaf, chunk);
	map-&gt;io_align = btrfs_chunk_io_align(leaf, chunk);
	map-&gt;sector_size = btrfs_chunk_sector_size(leaf, chunk);
	map-&gt;stripe_len = btrfs_chunk_stripe_len(leaf, chunk);
	map-&gt;type = btrfs_chunk_type(leaf, chunk);
	map-&gt;sub_stripes = btrfs_chunk_sub_stripes(leaf, chunk);
	//stripe
	map-&gt;stripes[i].physical//strip在super中的地址
	map-&gt;stripes[i].dev//chunk.devid，strip.uuid
	map-&gt;stripes[i].dev-&gt;in_fs_metadata = 1
6.add_extent_mapping将em添加到map_tree
7.free_extent_map递减em计数，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4440</x>
      <y>2770</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2560</x>
      <y>3310</y>
      <w>550</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>530.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3060</x>
      <y>3310</y>
      <w>50</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3090</x>
      <y>3310</y>
      <w>320</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3120</x>
      <y>3310</y>
      <w>670</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3160</x>
      <y>3310</y>
      <w>980</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;960.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3230</x>
      <y>3310</y>
      <w>1230</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1210.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3120</x>
      <y>2740</y>
      <w>180</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3350</x>
      <y>2740</y>
      <w>120</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3460</x>
      <y>2740</y>
      <w>280</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3470</x>
      <y>2740</y>
      <w>670</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3490</x>
      <y>2730</y>
      <w>960</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;20.0;940.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3270</x>
      <y>2180</y>
      <w>2870</w>
      <h>290</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2850.0;10.0;10.0;270.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4500</x>
      <y>3090</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lookup_extent_mapping</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4490</x>
      <y>3160</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__lookup_extent_mapping</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4560</x>
      <y>3060</y>
      <w>210</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
root-&gt;fs_info-&gt;mapping_tree</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4560</x>
      <y>3120</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4560</x>
      <y>3230</y>
      <w>350</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>1.通过__tree_search查找offset所在的rb_node
2.如果没找到,重新设置rb_node
	1.如果存在prev，即为prev
	2.如果存在next，即为next
	3.否则为NULL
3.如果要求stict，表示需要严格在start~end内，如果不在，
	返回NULL
4.递增rb_left，并返回em
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4600</x>
      <y>3190</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4780</x>
      <y>3410</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__tree_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4830</x>
      <y>3370</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4750</x>
      <y>3480</y>
      <w>380</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.遍历root-&gt;rb_node，找到start&lt;=offset&lt;end的rb_node
2.如果没找到
	1.如果有prev_ret，rb_next找到offset&lt;end的rb_node
	2.如果有next_ret，rb_prev找到offset&gt;start的rb_node
注：为什么pre_ret记录的是链表中的next，而next_ret记录的确是
	链表中的prev
3.返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4840</x>
      <y>3440</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4710</x>
      <y>3630</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>rb_next</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4760</x>
      <y>3590</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4600</x>
      <y>3700</y>
      <w>360</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.如果存在rb_right，找到rb_right的最左节点
2.如果不存在，向上找父节点，直到找到左节点的父节点，
	即在链表中为其next（父-左-右）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4760</x>
      <y>3660</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5020</x>
      <y>3630</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>rb_prev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5060</x>
      <y>3590</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4970</x>
      <y>3700</y>
      <w>360</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.如果存在rb_left，找到rb_left的最右节点
2.如果不存在，向上找父节点，直到找到右节点的父节点，
	即在链表中为其prev（父-右-左）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5070</x>
      <y>3660</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4260</x>
      <y>3100</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>alloc_extent_map</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4180</x>
      <y>3160</y>
      <w>290</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.kmem_cache_zalloc申请em
2.初始化
	em-&gt;flags = 0;
	em-&gt;compress_type = BTRFS_COMPRESS_NONE;
	em-&gt;generation = 0;
	atomic_set(&amp;em-&gt;refs, 1);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4310</x>
      <y>3130</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4320</x>
      <y>3060</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5030</x>
      <y>3090</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>add_extent_mapping</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4620</x>
      <y>3060</y>
      <w>490</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4950</x>
      <y>3170</y>
      <w>100</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tree_insert</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5330</x>
      <y>3170</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>setup_extent_mapping</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4980</x>
      <y>3120</y>
      <w>140</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5100</x>
      <y>3120</y>
      <w>340</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4940</x>
      <y>3240</y>
      <w>320</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.遍历root-&gt;rb_node
	1.如果小于start，遍历左节点
	2.如果大于end，遍历右节点
	3.否则该rb_node存在
2.需要再次检查不和链表中next和prev重合
	之前的遍历只做了start的检查，没做end的检查，可能线段重合
3.rb_link_node和rb_insert_color进行红黑树的插入
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4970</x>
      <y>3200</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5290</x>
      <y>3240</y>
      <w>340</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.atomic_inc(&amp;em-&gt;refs);
	em-&gt;mod_start = em-&gt;start;
	em-&gt;mod_len = em-&gt;len;
2.如果modified置上，将em加入modified_extents链表中
3.否则，try_merge_map看em是否能进行合并
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5380</x>
      <y>3200</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5370</x>
      <y>3360</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>try_merge_map</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5430</x>
      <y>3320</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4770</x>
      <y>2750</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>free_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4680</x>
      <y>2820</y>
      <w>330</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.不加锁循环递减ref
	1.读取eb-&gt;refs，如果小于3，退出循环
	2.atomic_cmpxchg递减eb-&gt;refs
	3.如果ref之前发生改变，则继续循环，否则直接退出
2.如果有EXTENT_BUFFER_DUMMY或者EXTENT_BUFFER_TREE_REF
	递减ref
3.release_extent_buffer试图释放eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4840</x>
      <y>2780</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3540</x>
      <y>2740</y>
      <w>1320</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1300.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>6090</x>
      <y>2320</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>read_tree_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5970</x>
      <y>2380</y>
      <w>350</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>1.通过btrfs_find_create_tree_block查询或者申请eb和page
2.btree_read_extent_buffer_pages读取eb.page
3.如果出错，free_extent_buffer释放eb，否则返回eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6130</x>
      <y>2350</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>6110</x>
      <y>2480</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btree_read_extent_buffer_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6190</x>
      <y>2440</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>6030</x>
      <y>2560</y>
      <w>330</w>
      <h>290</h>
    </coordinates>
    <panel_attributes>1.清除eb的EXTENT_BUFFER_CORRUPT
2.循环
	1.read_extent_buffer_pages在io_tree中读取eb.page
	2.如果正确返回
		1.通过verify_parent_transid验证，如果成功，退出循环
		2.验证出错，ret=EIO
	3.如果eb的EXTENT_BUFFER_CORRUPT置上，退出循环
	4.通过btrfs_num_copies检查eb有多少备份，如果备份是1，退出循环
	5.如果failed_mirror还没置上
		failed = 1;
		failed_mirror = eb-&gt;read_mirror//read_mirror存储的是最终失败后修复镜像？
	6.mirror_num++，不读取read_mirror，所以读到read_mirror
		mirror_num++
	7.如果出错的镜像超过了备份，退出循环
3.如果读取所有的镜像出错，并且有修复镜像failed_mirror
	通过repair_eb_io_failure利用修复镜像进行修复
4.返回ret
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5770</x>
      <y>2890</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>read_extent_buffer_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6200</x>
      <y>2510</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5860</x>
      <y>2840</y>
      <w>250</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btree_get_extent</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5800</x>
      <y>2960</y>
      <w>350</w>
      <h>370</h>
    </coordinates>
    <panel_attributes>1.如果EXTENT_BUFFER_UPTODATE置上，直接返回0
2.计算在eb.page内的偏移start_i
3.遍历eb的page(start_i~num_pages)
	1.如果是WAIT_NONE，通过trylock_page锁住page，如果page已经被锁住，解锁其他page，并返回
	2.否则通过lock_page锁住page
	3.locked_pages++;
	4.统计需要读page的数量(!PageUptodate)
		num_reads++;
		all_uptodate = 0;
4.如果全部被更新，将eb的EXTENT_BUFFER_UPTODATE置上，并解锁所有的page，返回
5.清除掉eb的EXTENT_BUFFER_READ_ERR
6.eb-&gt;read_mirror = 0;
	atomic_set(&amp;eb-&gt;io_pages, num_reads)
7.遍历eb的page
	1.如果!PageUptodate
		1.ClearPageError
		2.__extent_read_full_page读取page
	2.否则unlock_page
8.如果返回了bio，通过submit_one_bio提交请求
9.如果出错，或者不用WAIT_COMPLETE，返回ret
10.否则通过wait_on_page_locked等待每个page解锁
	如果page没有uptodate，返回EIO
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5870</x>
      <y>2920</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5850</x>
      <y>3350</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__extent_read_full_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5930</x>
      <y>3320</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5750</x>
      <y>3420</y>
      <w>450</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.循环处理ordered_extent
	1.通过btrfs_lookup_ordered_extent查找ordered_tree是否有对应的ordered_extend
	2.如果有，通过btrfs_start_ordered_extent刷写，并wait到BTRFS_ORDERED_COMPLETE
	3.通过btrfs_put_ordered_extent释放ordered_extend
	4.直到ordered_tree内没有对应的ordered_extent
2.通过__do_readpage读取page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5940</x>
      <y>3380</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5430</x>
      <y>3560</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_lookup_ordered_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5810</x>
      <y>3570</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__do_readpage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5330</x>
      <y>3630</y>
      <w>360</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.通过tree_search查找inode.ordered_tree的file_offset
2.如果file_offset不在entry范围内，返回NULL
3.递增entry-&gt;refs，并返回entry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5520</x>
      <y>3520</y>
      <w>340</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5510</x>
      <y>3590</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5850</x>
      <y>3520</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5700</x>
      <y>3630</y>
      <w>380</w>
      <h>640</h>
    </coordinates>
    <panel_attributes>1.set_page_extent_mapped设置pageprivate
2.如果page没有uptodate,通过cleancache_get_page获取page
	如果成功，直接返回
3.如果所读取的page超过了inode.size
	1.将page内超过inode.size的部分清零
4.循环读取start~end（一个page）
	1.如果正在读取的长度超过了inode.size
		1.
	2.通过__get_extent_map获取em
	3.如果em的EXTENT_FLAG_COMPRESSED置上
		1.置上this_bio_flag的EXTENT_BIO_COMPRESSED
		2.this_bio_flag合并em-&gt;compress_type
	4.根据EXTENT_BIO_COMPRESSED设置disk_io_size和sector
	5.如果EXTENT_FLAG_PREALLOC置上，
		block_start = EXTENT_MAP_HOLE
	6.如果EXTENT_FLAG_COMPRESSED，prev_em_start不是-1，不是orig_start
		force_bio_submit = true
	7.如果要求prev_em_start
		*prev_em_start = em-&gt;orig_start
	8.free_extent_map释放em
	9.如果block_start在EXTENT_MAP_HOLE
		1.
	10.test_range_bit检查段的所有区域在io_tree中是否EXTENT_UPTODATE都置上
		1.通过check_page_uptodate检查page的相应的段EXTENT_UPTODATE是否置上，
			如果置上SetPageUptodate
		2.更新变量，继续下一次循环
			cur = cur + iosize;
			pg_offset += iosize;
	11.如果block_start是EXTENT_MAP_INLINE
		1.SetPageError
		2.更新变量，继续下一次循环
			cur = cur + iosize;
			pg_offset += iosize;
	12.submit_extent_page申请bio，并根据情况提交上一次bio
	13.如果正确返回
		nr++;
		*bio_flags = this_bio_flag;//保存上一次flag
		否则SetPageError
	14.更新循环变量，并继续循环
		cur = cur + iosize;
		pg_offset += iosize
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5800</x>
      <y>3600</y>
      <w>110</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4320</x>
      <y>4310</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>set_page_extent_mapped</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4250</x>
      <y>4370</y>
      <w>280</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.如果PagePrivate没置上
	1.设置PagePrivate
	2.page_cache_get递增page计数
	3.page.private=EXTENT_PAGE_PRIVATE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4420</x>
      <y>4340</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4560</x>
      <y>4310</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__get_extent_map</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4560</x>
      <y>4370</y>
      <w>350</w>
      <h>170</h>
    </coordinates>
    <panel_attributes>1.如果有指定的em_cached，先看cache是否满足要求
	1.extent_map_in_tree检查到extend在tree中欧冠
	2.em.start&lt;start&lt;em.end
	3.如果满足上述两个条件，递增em-&gt;refs，并返回em
	4.否则通过free_extent_map递减em计数，并释放*em_cached
2.通过get_extent获取em
3.如果有指定了em_cached，并且获取em没出错
	atomic_inc(&amp;em-&gt;refs);
	*em_cached = em
4.返回em	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4630</x>
      <y>4340</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4550</x>
      <y>4630</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btree_get_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4600</x>
      <y>4660</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4490</x>
      <y>4690</y>
      <w>280</w>
      <h>270</h>
    </coordinates>
    <panel_attributes>1.通过lookup_extent_mapping在extent_tree中查找start~start+len
2.如果找到em，设置em-&gt;bdev，并退出
	em-&gt;bdev=fs_info-&gt;fs_devices-&gt;latest_bdev
3.如果没找到
	1.通过alloc_extent_map申请em
	2.em-&gt;start = 0;
		em-&gt;len = (u64)-1;
		em-&gt;block_len = (u64)-1;
		em-&gt;block_start = 0;
		em-&gt;bdev=fs_info-&gt;fs_devices-&gt;latest_bdev
	3.通过add_extent_mapping将em加入到extent_tree
	4.因为之前有lock，需要发现已经存在map_tree
		1.free_extent_map释放em
		2.lookup_extent_mapping查找em
	5.如果添加出现错误，释放em，并返回错误
4.返回em	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4550</x>
      <y>4570</y>
      <w>110</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>get_extent
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4590</x>
      <y>4600</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4590</x>
      <y>4530</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>6270</x>
      <y>2880</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>verify_parent_transid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>6570</x>
      <y>2880</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_num_copies</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>6520</x>
      <y>2950</y>
      <w>320</w>
      <h>290</h>
    </coordinates>
    <panel_attributes>1.通过lookup_extent_mapping找到偏移对应的em
2.如果没找到em，返回1
3.如果偏移不在em内，free_extent_map释放em，并返回1
4.检查em-&gt;bdev.type
	1.如果BTRFS_BLOCK_GROUP_DUP，BTRFS_BLOCK_GROUP_RAID1
		ret=map-&gt;num_stripes
	2.如果BTRFS_BLOCK_GROUP_RAID10
		ret = map-&gt;sub_stripes
	3.如果BTRFS_BLOCK_GROUP_RAID5
		ret=2
	4.如果BTRFS_BLOCK_GROUP_RAID6
		ret=3
	5.否则ret=1
5.free_extent_map释放em
6.btrfs_dev_replace_is_ongoing检查fs_info-&gt;dev_replace
	递增ret
7.返回ret
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6650</x>
      <y>2910</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>6190</x>
      <y>2950</y>
      <w>310</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.如果指定了parent_transid要和eb.page[0].generation相同
	即返回0，表示验证通过
注：generation通过BTRFS_SETGET_HEADER_FUNCS进行解析
2.如果atomic置上，返回EAGAIN
3.如果进程的journal_info需要BTRFS_SEND_TRANS_STUB
	1.btrfs_tree_read_lock递增reader
	2.btrfs_set_lock_blocking_rw递增blocking_readers的计数
4.如果eb uptodate，并且generation，返回0，验证通过(因为之前可能有等待)
5.出错
	1.如果extent_buffer_under_io检查其没在io操作，通过
		clear_extent_buffer_uptodate清除eb.page的uptodate
	2.btrfs_tree_read_unlock_blocking释放reader
	3.返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6350</x>
      <y>2910</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>6150</x>
      <y>3210</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_tree_read_lock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6230</x>
      <y>3240</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>6150</x>
      <y>3280</y>
      <w>280</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.如果存在blocking_writers，并且当前进程是eb.lock_owner,返回
	eb-&gt;lock_nested = 1;
2.如果存在blocking_writers，但是是其他进程，需要等待
	blocking_writers变为0，想来之后跳到1再次做检测（因为进程竞争）
3.atomic_inc(&amp;eb-&gt;read_locks);
	atomic_inc(&amp;eb-&gt;spinning_readers);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6220</x>
      <y>3160</y>
      <w>90</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>6330</x>
      <y>3200</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_set_lock_blocking_rw</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6400</x>
      <y>3160</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>6450</x>
      <y>3280</y>
      <w>290</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>1.如果是eb.lock_owner锁住，直接返回
2.如果是BTRFS_WRITE_LOCK
	1.如果blocking_writers为0
		atomic_dec(&amp;eb-&gt;spinning_writers);
		atomic_inc(&amp;eb-&gt;blocking_writers);
	2.如果是BTRFS_READ_LOCK
		atomic_inc(&amp;eb-&gt;blocking_readers);
		atomic_dec(&amp;eb-&gt;spinning_readers);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6440</x>
      <y>3230</y>
      <w>50</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6220</x>
      <y>2840</y>
      <w>130</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6310</x>
      <y>2840</y>
      <w>350</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6110</x>
      <y>2180</y>
      <w>130</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5080</x>
      <y>4300</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>test_range_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4950</x>
      <y>4370</y>
      <w>380</w>
      <h>310</h>
    </coordinates>
    <panel_attributes>1.如果指定了cached，extent_state_in_tree查看cache是否在io_tree中
	并且看start是否在cache的范围内，如果在
	node = &amp;cached-&gt;rb_node
2.否则通过tree_search在io_tree中查找
3.循环检查start~end是否在io_tree中
	1.如果start&lt;node.start,表示该段不在范围内，并且filled置上(要求所有的段都在范围内)，退出循环，并返回false
		bitset = 0
	2.如果end&lt;node.start，说明tree中没有段相关，根据之前的设置退出
	注：这里会返回0，因为start&lt;end，所以前面只能是filled没置上，filled没置上，但是循环的原因是bitset = 0
	3.如果node.state的相应的bit置上
		1.bitset = 1;
		2.如果filled没置上，退出循环
	4.如果相应bit没置上，并且filled置上，退出循环
		bitset = 0
	5.如果node.end=-1，表示只有之后这个node，所以直接退出循环
	6.更新start = state-&gt;end + 1，如果start超过end，表示段遍历完成，退出循环
	7.通过rb_next遍历下一个node，如果filled置上，说明段有一部分不在io_tree的范围内，
		bitset = 0，退出循环
4.返回bitset
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5130</x>
      <y>4330</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5510</x>
      <y>4290</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>submit_extent_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5580</x>
      <y>4320</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5400</x>
      <y>4360</y>
      <w>420</w>
      <h>300</h>
    </coordinates>
    <panel_attributes>1.如果存在bio_ret
	1.contig记录两个bio是否连接
		1.如果bio_ret的EXTENT_BIO_COMPRESSED置上，sector相同，contig置上
		2.否则sector紧接着，contig置上
	2.以下情况，submit_one_bio会提交bio_ret,如果失败直接返回，如果成功清除bio_ret，并继续2
		1.现在的要申请的bio的bio_flags和bio_ret不同
		2.两个bio没紧接着
		3.force_bio_submit
		4.merge_bio或者bio_add_page失败
	5.如果成功merge，返回0
2.通过btrfs_bio_alloc申请bio
3.通过bio_add_page将page添加到bio_vec中
	bio-&gt;bi_end_io = end_io_func;
	bio-&gt;bi_private = tree;
4.如果wbc存在
	1.wbc_init_bio
	2.wbc_account_io
5.如果存在bio_ret
	*bio_ret = bio;
6.否则通过submit_one_bio提交bio
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5570</x>
      <y>4260</y>
      <w>380</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
end_bio_extent_readpage</panel_attributes>
    <additional_attributes>360.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5370</x>
      <y>4920</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>bio_alloc_bioset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5430</x>
      <y>4650</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5260</x>
      <y>4980</y>
      <w>350</w>
      <h>490</h>
    </coordinates>
    <panel_attributes>1.如果没有内存池bs
	1.申请的vec不能超过UIO_MAXIOV
	2.通过kmalloc申请bio + nr_iovecs *bio_vec
		front_pad = 0;//没有pad
		inline_vecs = nr_iovecs
2.如果指定了内存池bs
	1.如果进程的bio_list不为空，将__GFP_DIRECT_RECLAIM去掉
		通过mempool_alloc申请bio
	2.如果没申请到，再将__GFP_DIRECT_RECLAIM加上，
		再次通过mempool_alloc申请bio
	3.front_pad = bs-&gt;front_pad;
		inline_vecs = BIO_INLINE_VECS
3.如果没申请到bio，返回NULL
4.如果申请到
	1.bio = p + front_pad;
	2.bio_init对bio进行初始化
		memset(bio, 0, sizeof(*bio));
		atomic_set(&amp;bio-&gt;__bi_remaining, 1);
		atomic_set(&amp;bio-&gt;__bi_cnt, 1);
	3.如果是在内存池中申请的bio，并且bio_vec内存空间不足
		1.bvec_alloc申请bio_vec
		2.如果没申请到，通过saved_gfp再次通过bvec_alloc申请bio_vec
		3.设置bio.bi_flagsBIO_OWNS_VEC
	4.否则直接指向之前申请的bio_vec空间
		bvl = bio-&gt;bi_inline_vecs;
	5.初始化bio，并返回
		bio-&gt;bi_pool = bs;
		bio-&gt;bi_flags |= idx &lt;&lt; BIO_POOL_OFFSET;
		bio-&gt;bi_max_vecs = nr_iovecs;
		bio-&gt;bi_io_vec = bvl;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5410</x>
      <y>4950</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5340</x>
      <y>5500</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>bvec_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5390</x>
      <y>5460</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5390</x>
      <y>5530</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5260</x>
      <y>5570</y>
      <w>340</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.根据申请bio_vec的个数，确定idx
2.如果idx是BIOVEC_MAX_IDX，通过mempool_alloc
	在内存池中申请
3.否则，根据idx选择对应的slab，在slab中申请
	如果没申请到，并且__GFP_DIRECT_RECLAIM，再回到2
	中从内存池中申请
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5380</x>
      <y>4690</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_bio_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5290</x>
      <y>4750</y>
      <w>350</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>1.通过bio_alloc_bioset申请bio+bio_vec
2.如果没申请到，并且进程的PF_MEMALLOC置上
	bio_vec数量减半，然后再次通过bio_alloc_bioset申请
	直到申请成功
3.bio-&gt;bi_bdev = bdev;
	bio-&gt;bi_iter.bi_sector = first_sector;
	//初始化bio的container btrfs_bio(这里只能是在内存池中申请)
	btrfs_bio-&gt;csum = NULL;
	btrfs_bio-&gt;csum_allocated = NULL;
	btrfs_bio-&gt;end_io = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5410</x>
      <y>4890</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5430</x>
      <y>4720</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5730</x>
      <y>4690</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>bio_add_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5770</x>
      <y>4650</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5670</x>
      <y>4750</y>
      <w>330</w>
      <h>230</h>
    </coordinates>
    <panel_attributes>1.如果之前存有page（bi_vcnt&gt;0）,看是否能和上一个bio_vec合并
	1.page要相同
	2.offset=vec.offset+vec.len
	3.满足上述两个条件可以合并，并跳到4
		bv-&gt;bv_len += len;
2.如果使用bio_vec的数量超过了bi_max_vecs，返回0
3.将page添加到bio_vec中
	bv		= &amp;bio-&gt;bi_io_vec[bio-&gt;bi_vcnt];
	bv-&gt;bv_page	= page;
	bv-&gt;bv_len	= len;
	bv-&gt;bv_offset	= offset;
	bio-&gt;bi_vcnt++;
4.递增bio中的字节数量，并返回len
	bio-&gt;bi_iter.bi_size += len
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5770</x>
      <y>4720</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5100</x>
      <y>4700</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>merge_bio</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5150</x>
      <y>4650</y>
      <w>290</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4950</x>
      <y>4770</y>
      <w>310</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.如果存在tree-&gt;ops-&gt;merge_bio_hook，通过这个函数merge
2.否则返回0，表示merge失败
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5140</x>
      <y>4730</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5030</x>
      <y>4840</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tree-&gt;ops-&gt;merge_bio_hook
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5130</x>
      <y>4800</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5120</x>
      <y>4870</y>
      <w>160</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_init_btree_inode
btree_extent_io_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5020</x>
      <y>4910</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_merge_bio_hook</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>6130</x>
      <y>4710</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>submit_one_bio</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5800</x>
      <y>4650</y>
      <w>410</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;390.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>6030</x>
      <y>4780</y>
      <w>360</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.计算需要进行io的地址page+bv_offset
2.bio-&gt;bi_private = NULL
3.bio_get递增bio的计数
4.如果有tree-&gt;ops-&gt;submit_bio_hook，通过这个函数提交
	否则通过btrfsic_submit_bio提交
5.bio_put释放bio
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6180</x>
      <y>4740</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>6010</x>
      <y>4930</y>
      <w>100</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>bio_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>6550</x>
      <y>4910</y>
      <w>100</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>bio_put</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6040</x>
      <y>4880</y>
      <w>40</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5980</x>
      <y>4960</y>
      <w>100</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5840</x>
      <y>5010</y>
      <w>260</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.将bio.bi_flags的BIO_REFFED置上
2.增加bio.__bi_cnt的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>6480</x>
      <y>4980</y>
      <w>260</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.如果BIO_REFFED没置上，通过bio_free将bio释放
2.递减bio.__bi_cnt,如果减到0，通过bio_free释放bio
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6600</x>
      <y>4940</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6350</x>
      <y>4880</y>
      <w>270</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>6130</x>
      <y>4920</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tree-&gt;ops-&gt;submit_bio_hook
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6190</x>
      <y>4880</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>6130</x>
      <y>4990</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btree_submit_bio_hook</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6190</x>
      <y>4950</y>
      <w>160</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_init_btree_inode
btree_extent_io_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>6320</x>
      <y>4920</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfsic_submit_bio</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6340</x>
      <y>4880</y>
      <w>80</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>6460</x>
      <y>2300</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_set_root_node</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6520</x>
      <y>2330</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>6390</x>
      <y>2360</y>
      <w>310</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.item.bytenr=node-&gt;start
	item.level=(btrfs_header *)node.page[0]-&gt;level
	item.generation=(btrfs_header *)node.page[0]-&gt;generation
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>5870</x>
      <y>2000</y>
      <w>390</w>
      <h>190</h>
    </coordinates>
    <panel_attributes>18.btrfs_read_sys_array根据chunk设置extend_map
19.__setup_root设置chunk_root的size
20.read_tree_block读取chunk_root
21.btrfs_set_root_node根据读取的chunk_root.node设置chunk_root-&gt;root_item
22.chunk_root-&gt;commit_root=chunk_root.node
23.read_extent_buffer设置fs_info-&gt;chunk_tree_uuid
	fs_info-&gt;chunk_tree_uuid=（btrfs_header*）chunk_root-&gt;node-&gt;chunk_tree_uuid
24.btrfs_read_chunk_tree遍历root中的所有dev_item
25.btrfs_close_extra_devices将fs_devices.devices链表中脱链
	fs_devices-&gt;latest_bdev = latest_dev-&gt;bdev
26.如果不存在fs_devices-&gt;latest_bdev，跳到fail_tree_roots

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4670</x>
      <y>1970</y>
      <w>1370</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置chunk_root</panel_attributes>
    <additional_attributes>10.0;10.0;1350.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>8900</x>
      <y>2320</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_read_chunk_tree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8980</x>
      <y>2350</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>8830</x>
      <y>2380</y>
      <w>360</w>
      <h>180</h>
    </coordinates>
    <panel_attributes>1.通过btrfs_alloc_path在btrfs_path_cachep中申请path
2.btrfs_search_slot查找BTRFS_DEV_ITEMS_OBJECTID
3.循环
	1.如果slot超过了leaf的item的个数，通过btrfs_next_leaf
		遍历下一个leaf
		1.如果返回0，表示下一个leaf还存在，continue
		2.如果出错，跳到error
		3.如果返回1，表示不存在下一个leaf，break
	2.获取slot对应的key
	3.如果key.type是BTRFS_DEV_ITEM_KEY
		1.以btrfs_dev_item解析slot对应的数据
		2.通过read_one_dev初始化dev_item对应的device
	4.如果type是BTRFS_CHUNK_ITEM_KEY
		1.以btrfs_chunk方式解析slot item数据
		2.通过read_one_chunk初始化chunk对应的extent_map
	5.遍历下一个slot
		path-&gt;slots[0]++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>9000</x>
      <y>2580</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_search_slot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9060</x>
      <y>2550</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>7720</x>
      <y>2680</y>
      <w>380</w>
      <h>480</h>
    </coordinates>
    <panel_attributes>1.如果ins_len&lt;0
	lowest_unlock = 2;
	write_lock_level = 2
	如果ins_len&gt;0
	write_lock_level = 1
2.如果不用cow
	write_lock_level = -1
3.如果要cow，并且path的keep_locks或者lowest_level存在
	write_lock_level = BTRFS_MAX_LEVEL
4.again
	1.如果path存在search_commit_root
		1.b = root-&gt;commit_root//extend_buffer
			level = btrfs_header_level(b)
		2.如果skip_locking没开，通过btrfs_tree_read_lock给其上读锁
	2.否则
		1.如果skip_locking置上
			1.b = btrfs_root_node(root);//选择root.node
				level = btrfs_header_level(b)
		2.否则
			1.通过btrfs_read_lock_root_node给eb上读锁的同时，获取root.node
			2.如果需要上写锁(level小于write_lock_level)
				1.通过btrfs_tree_read_unlock释放读锁,并通过free_extent_buffer释放获取的eb
				2.通过btrfs_lock_root_node上写锁，并重新获取root.node
					level = btrfs_header_level(b)
				3.root_lock = BTRFS_WRITE_LOCK
				注：其他情况默认是BTRFS_READ_LOCK
	3.p-&gt;nodes[level] = b
	4.如果skip_locking没置
		p-&gt;locks[level] = root_lock
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7850</x>
      <y>2610</y>
      <w>1240</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1220.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>7220</x>
      <y>3200</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_set_path_blocking</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7300</x>
      <y>3150</y>
      <w>460</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>7200</x>
      <y>3260</y>
      <w>350</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.遍历path
	1.如果没有node或者lock，跳过
	2.btrfs_set_lock_blocking_rw根据lock类型递增以下两个量
		1.blocking_writers或者blocking_readers
		2.spinning_writers或者spinning_readers
	3.将lock转换成blocking
		1.BTRFS_READ_LOCK--&gt;BTRFS_READ_LOCK_BLOCKING
		2.BTRFS_WRITE_LOCK--&gt;BTRFS_WRITE_LOCK_BLOCKING
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7300</x>
      <y>3230</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>7800</x>
      <y>3190</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_cow_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7850</x>
      <y>3150</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>9130</x>
      <y>3430</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>key_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9180</x>
      <y>3320</y>
      <w>1530</w>
      <h>130</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1510.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>9070</x>
      <y>3500</y>
      <w>350</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.如果prev_cmp不为0，通过bin_search进行二分查找
2.否则slot返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9180</x>
      <y>3460</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>9140</x>
      <y>3570</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>bin_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9190</x>
      <y>3530</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>9110</x>
      <y>3640</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>generic_bin_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9180</x>
      <y>3600</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>9010</x>
      <y>3710</y>
      <w>390</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.循环进行二分查找
	1.以下情况需要重新通过map_private_extent_buffer map新的eb空间
		1)没指定page
		2)要访问的item不在之前map的范围内
		1.key的解析为kaddr + offset -map_start
			1.kaddr-map_start即为eb.start的虚拟地址
		2.如果失败
			1.通过read_extent_buffer读取key到temp，这是允许跨page读取的
	2.如果在map_len范围内，直接赋值kaddr + offset - map_start
	3.comp_keys进行比较，如果key&lt;temp返回1，遍历左边，key&gt;temp返回-1，遍历右边
		如果相同，返回0，*slot = mid
2.如果最后找不到，slot返回low(这里的low应该是相对寻找的slot高)，并返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4390</x>
      <y>4260</y>
      <w>1350</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1330.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4600</x>
      <y>4260</y>
      <w>1180</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>5120</x>
      <y>4260</y>
      <w>800</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>780.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9180</x>
      <y>3670</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>9040</x>
      <y>3930</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>map_private_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9120</x>
      <y>3900</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>9000</x>
      <y>3990</y>
      <w>250</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.如果min_len跨了page，返回EINVAL
2.offset记录在page中的偏移量
	map_start是item相对eb.start的偏移量
3.offset+min_len不能超过eb.len
4.map返回其item或者eb的虚拟地址
	map_len返回可供访问的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9120</x>
      <y>3960</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>10780</x>
      <y>3350</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_leaf_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10830</x>
      <y>3320</y>
      <w>90</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>10780</x>
      <y>3420</y>
      <w>300</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.返回(root.nodesize-header)-(data+item)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>10890</x>
      <y>3490</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>leaf_space_used</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10930</x>
      <y>3450</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>10780</x>
      <y>3560</y>
      <w>320</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.end默认是start+nr，但是不能超过nritems
2.首先算出start数据的位置
	datalen=offset+size
3.然后减去end_item.offset得到真实的数据长度
注：item和data从两边向中间增长
4.数据长度+item*nr的长度，得到leaf_space
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10940</x>
      <y>3520</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>11900</x>
      <y>3770</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>push_leaf_right</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>11740</x>
      <y>3830</y>
      <w>420</w>
      <h>230</h>
    </coordinates>
    <panel_attributes>1.如果没有path.nodes[1]，返回1
2.如果存储的slot超过了upper的nritems，返回1
3.通过read_node_slot读取upper的slot+1，如果没找到对应的eb，返回1
4.如果找到了eb
	1.通过btrfs_tree_lock和btrfs_set_lock_blocking等待锁
	2.如果right的btrfs_leaf_free_space空间不足，解锁并释放eb，返回1
	3.btrfs_cow_block进行，然后再次检查right的free_space
	4.如果是在left的最后添加，将node[0]换成right，并返回0
		path-&gt;nodes[0] = right;
		path-&gt;slots[0] = 0;
		path-&gt;slots[1]++;
	5.通过__push_leaf_right试着将node[0]中的中的数据复制到
		right的eb中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11940</x>
      <y>3800</y>
      <w>50</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>11830</x>
      <y>4090</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>read_node_slot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11890</x>
      <y>4050</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>11710</x>
      <y>4150</y>
      <w>350</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.要读的slot要在0~nritems之前，否则返回NULL
2.通过read_tree_block读取slot中存储的blockptr
3.如果出错，或者读取的eb没有uptodate，返回NULL
	如果是没有uptodate，通过free_extent_buffer将eb释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11870</x>
      <y>4120</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>12100</x>
      <y>4090</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__push_leaf_right</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12130</x>
      <y>4050</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>12080</x>
      <y>4160</y>
      <w>460</w>
      <h>670</h>
    </coordinates>
    <panel_attributes>1.如果想将左节点删除，将nr=0作为min_slot
	否则最小的nr设置为1
注：这里确定要移到right的最小slot
2.循环遍历node的item直到nr
	1.如果不要求将node清空，并且已经记录了要被转移到right的push_items
		1.不能将小于slot[0]的item移到right
		2.是否移slot[0]的item到right取决于node和right哪边的free_space更大
			如果node更大，就保留到node，否则就移到right
	2.当将slot[0]移到right中时，需要增加其空间
		push_space += data_size//如果slot[0]不在node范围内，在循环之前就相加了
	3.如果将这个item移到right会超过其free_space,退出循环
	4.更新移到right的item及其空间
		push_items++;
		push_space += this_item_size + sizeof(*item);
	5.如果遍历到0item，退出循环（因为i是unsigned的，所以不用循环条件）
	6.i--
	注:push_space记录着需要向right中转移的内存大小
3.如果不需要移到right，跳到out_unlock
4.leaf_data_end返回最后item的offset
注：item.offset是相对item数组的偏移,item.key.offset表示整个文件的offset
5.腾出right数据区，并从left复制
	1.memmove_extent_buffer将数据从right的data_end复制到data_end-push_space
	注：数据到node中是从尾端向前伸展
	2.copy_extent_buffer将left的push_space复制到right的最尾端的push_space
6.memmove_extent_buffer在前面腾出push_items个item的空间
	并且copy_extent_buffer将item从left复制到right
7.btrfs_set_header_nritems设置right.header中的item的数量加上push_items
8.btrfs_set_token_item_offset循环设置每个item.offset
9.通过btrfs_set_header_nritems将left的nritems减去push_items
10.如果还存在left_nritems，通过btrfs_mark_buffer_dirty将eb标记为dirty
	否则通过clean_tree_block清除left的page.dirty
11.btrfs_mark_buffer_dirty标记right的page dirty
12.通过btrfs_item_key提取right.item[0]的key，然后btrfs_set_node_key
	存储到父节点的item[slot+1].key中，并且通过btrfs_mark_buffer_dirty
	标记父节点dirty
13.如果slot[0]超过了left_nritems
	path-&gt;slots[0] -= left_nritems;
	path-&gt;nodes[0] = right;
	path-&gt;slots[1] += 1;
14.btrfs_tree_unlock和free_extent_buffer解锁并释放slot不在的eb，并返回0
15.btrfs_tree_unlock和free_extent_buffer解锁并释放right，返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12160</x>
      <y>4120</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>12000</x>
      <y>4920</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>memmove_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12080</x>
      <y>4820</y>
      <w>30</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>11940</x>
      <y>4990</y>
      <w>330</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.要复制的长度不能超过dst-&gt;len，被复制的段也不能超过dst-&gt;len
2.如果dest的地址低于src的地址，通过memcpy_extent_buffer从前向后复制
3.循环从后向前通过copy_pages复制len长度的数据
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12070</x>
      <y>4950</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>11880</x>
      <y>5100</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>memcpy_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11950</x>
      <y>5060</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>11800</x>
      <y>5170</y>
      <w>340</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.要复制的长度不能超过dst-&gt;len，被复制的段也不能超过dst-&gt;len
2.循环通过copy_pages从src_off_in_page复制数据到dst_off_in_page
	并更新循环变量
	src_offset += cur;
	dst_offset += cur;
	len -= cur
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11940</x>
      <y>5130</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>11880</x>
      <y>5310</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>copy_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11930</x>
      <y>5270</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>11790</x>
      <y>5380</y>
      <w>330</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.如果dst_page和src_page是同一page，通过areas_overlap
	检查两者段是否有重叠的部分，如果重叠使用memmove按字节复制，
	否则直接使用memcpy
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11930</x>
      <y>5340</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>12330</x>
      <y>4860</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>copy_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12390</x>
      <y>4820</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>12290</x>
      <y>4930</y>
      <w>330</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.循环通过read_extent_buffer将长度len的数据从
	dst_page[i]+offset读到src+src_offset，并更新循环变量
	src_offset += cur;
	len -= cur;
	offset = 0;
	i++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12410</x>
      <y>4890</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>12650</x>
      <y>4860</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_mark_buffer_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12390</x>
      <y>4820</y>
      <w>370</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>12650</x>
      <y>4930</y>
      <w>340</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.set_extent_buffer_dirty设置eb.page所有的page为dirty
2.如果之前EXTENT_BUFFER_DIRTY没置上，
	fs_info-&gt;dirty_metadata_bytes+= buf-&gt;len
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12750</x>
      <y>4890</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13020</x>
      <y>4860</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>clean_tree_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12390</x>
      <y>4820</y>
      <w>720</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;700.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13070</x>
      <y>4890</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13000</x>
      <y>4930</y>
      <w>330</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.如果eb的generation和fs_info-&gt;running_transaction-&gt;transid一致
	1.如果EXTENT_BUFFER_DIRTY置上
		1.dirty_metadata_bytes-=buf-&gt;len
		2.btrfs_set_lock_blocking设置write_lock
		3.clear_extent_buffer_dirty清除page_dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10840</x>
      <y>3380</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>9870</x>
      <y>3400</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>setup_nodes_for_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9950</x>
      <y>3320</y>
      <w>750</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>730.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>9770</x>
      <y>3470</y>
      <w>470</w>
      <h>300</h>
    </coordinates>
    <panel_attributes>1.如果满足以下两个条件
	1)search_for_split或者需要插入数据ins_len
	2)eb.nritems到达了限制
	1.write_lock_level不能小于level+1，否则调整并释放path，返回EAGAIN
	2.btrfs_set_path_blocking设置blocking
	3.reada_for_balance对左右node进行预读
	4.split_node
	5.btrfs_clear_path_blocking清除blocking
	6.如果出错，返回错误，否则获取p-&gt;nodes[level]，返回0
2.如果满足以下条件
	1）如果要删除data，
	2)eb的free_space小于总大小的一半
	1.write_lock_level不能小于level+1，否则调整并释放path，返回EAGAIN
	2.btrfs_set_path_blocking设置blocking
	3.reada_for_balance对左右node进行预读
	4.balance_level根据item的数量进行合并(主要向左合并)，并尽量递减level
	5.btrfs_clear_path_blocking清除blocking
	6.如果出错，返回错误，否则获取p-&gt;nodes[level]，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9960</x>
      <y>3430</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>9410</x>
      <y>3850</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>reada_for_balance</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9480</x>
      <y>3760</y>
      <w>440</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>420.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>9300</x>
      <y>3920</y>
      <w>350</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.找到父节点所在的eb(parent)和所在的item(slot)
2.如果slot&gt;0
	1.找slot-1的blockptr和gen，通过btrfs_find_tree_block
	在buffer_radix找到对应的子eb
	2.如果已经更新并且检查通过，不再读
	3.并且通过free_extent_buffer释放eb
3.再读slot+1
	1.同样获取slot+1的blockptr和gen，通过btrfs_find_tree_block
		查找
	2.如果找到，并且更新和验证通过，不在读
	3.通过free_extent_buffer释放
4.上述两个block如果需要读，通过readahead_tree_block读取
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9470</x>
      <y>3880</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>9330</x>
      <y>4150</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>readahead_tree_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9410</x>
      <y>4110</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>9230</x>
      <y>4220</y>
      <w>300</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.btrfs_find_create_tree_block查找或者创建eb
2.read_extent_buffer_pages读取eb
3.free_extent_buffer释放eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9390</x>
      <y>4180</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>9700</x>
      <y>3850</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>split_node</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9750</x>
      <y>3760</y>
      <w>190</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>9670</x>
      <y>3920</y>
      <w>380</w>
      <h>210</h>
    </coordinates>
    <panel_attributes>1.如果所在的level是root，通过insert_new_root插入新的root
2.否则通过push_nodes_for_insert将node中item移到left或者right中
	如果成功将node的item数量腾出来，即返回
3.btrfs_node_key读取node的key
4.btrfs_alloc_tree_block申请eb和extent
	1.root_add_used递增root.root_item.bytes_used
	2.	清空split的btrfs_header
		btrfs_header.level=btrfs_header_level(c)
		btrfs_header.bytenr=split-&gt;start
		btrfs_header.generation=trans-&gt;transid
		btrfs_header.flags=eb | BTRFS_MIXED_BACKREF_REV
		btrfs_header.owner= root-&gt;root_key.objectid
		btrfs_header.fsid=root-&gt;fs_info-&gt;fsid
		btrfs_header.chunk_tree_uuid=fs_info-&gt;chunk_tree_uuid
5.tree_mod_log_eb_copy记录log，如果失败，通过btrfs_abort_transaction
	结束trans，并返回
6.通过copy_extent_buffer将c中一半的item(这里可以看出这个函数不适用于leaf)复制到split中,
	并通过btrfs_mark_buffer_dirty标记c和split为dirty
	split.btrfs_header.nritems=c_nritems - mid
	c.btrfs_header.nritems=c_nritems - mid
7.insert_ptr将split插入到parent.slot[level+1]+1的slot中
8.如果原来在c的右边
	1.更新path
		path-&gt;slots[level] -= mid;
		path-&gt;nodes[level] = split;
		path-&gt;slots[level + 1] += 1;
	2.free_extent_buffer释放对c的应用
9.如果在c的左边，直接通过free_extent_buffer释放对split的引用
10.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9750</x>
      <y>3880</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>10340</x>
      <y>3800</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>balance_level</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10040</x>
      <y>3760</y>
      <w>370</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>10080</x>
      <y>3870</y>
      <w>440</w>
      <h>310</h>
    </coordinates>
    <panel_attributes>1.level为0，直接返回0
2.如果有父节点，获取其parent
	parent = path-&gt;nodes[level + 1];
	pslot = path-&gt;slots[level + 1];
3.如果父节点不存在
	1.如果该节点的item不止一个，返回0
	2.read_node_slot读取改item对应的eb
	3.如果没读到，返回EROFS，跳到enospc
	4.btrfs_tree_lock，btrfs_set_lock_blocking和btrfs_cow_block设置锁
	5.tree_mod_log_set_root_pointer申请log插入红黑树
	6.将root变换为child
		root-&gt;node=child
	7.clean_tree_block和btrfs_tree_unlock解锁
	8.释放mid
		1.free_extent_buffer递减mid计数
		2.root_sub_used设置
			root.root_item.bytes_used -=size
		3.free_extent_buffer_stale真正释放mid
	9.返回0

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10170</x>
      <y>3830</y>
      <w>240</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>10260</x>
      <y>4230</y>
      <w>220</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tree_mod_log_set_root_pointer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>10250</x>
      <y>4300</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tree_mod_log_insert_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10340</x>
      <y>4260</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>10160</x>
      <y>4370</y>
      <w>430</w>
      <h>310</h>
    </coordinates>
    <panel_attributes>1.tree_mod_need_log检查不需要log，返回0
2.需要移除log，并且old_root.level&gt;0
	1.申请数组tm_list
	2.alloc_tree_mod_elem对old_root申请tm
		tm_list[i] =i
3.kzalloc申请tm并初始化
	tm-&gt;index = new_root-&gt;start &gt;&gt; PAGE_CACHE_SHIFT;
	tm-&gt;old_root.logical = old_root-&gt;start;
	tm-&gt;old_root.level = btrfs_header_level(old_root);
	tm-&gt;generation = btrfs_header_generation(old_root);
	tm-&gt;op = MOD_LOG_ROOT_REPLACE;
4.如果存在tm_list，通过__tree_mod_log_free_eb
5.如果插入成功。在将tm通过__tree_mod_log_insert插入到红黑树
6.如果中间失败，跳到free_tms
7.释放tm_list，并返回
8.free_tms：
	1.释放tm_list中所有的tm释放，并释放tm_list
	2.释放单独申请的tm
	3.返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10330</x>
      <y>4330</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>9610</x>
      <y>4740</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tree_mod_need_log</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9660</x>
      <y>4670</y>
      <w>550</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>530.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>9520</x>
      <y>4810</y>
      <w>210</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.以下情况返回0
	1.链表tree_mod_seq_list为空
	2.eb的level为0
2.其他情况返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9650</x>
      <y>4770</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>9800</x>
      <y>4740</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>alloc_tree_mod_elem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9880</x>
      <y>4670</y>
      <w>350</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>9770</x>
      <y>4810</y>
      <w>340</w>
      <h>170</h>
    </coordinates>
    <panel_attributes>1.申请tm
2.tm-&gt;index = eb-&gt;start &gt;&gt; PAGE_CACHE_SHIFT
3.如果操作不是MOD_LOG_KEY_ADD
	1.btrfs_node_key读取slot的key到tm-&gt;key中
	2.tm-&gt;blockptr记录slot的blockptr
4.tm-&gt;op = op;
	tm-&gt;slot = slot;
	tm-&gt;generation = btrfs_node_ptr_generation
	RB_CLEAR_NODE(&amp;tm-&gt;node)//红黑树初始化
5.返回tm
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9870</x>
      <y>4770</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>10150</x>
      <y>4730</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tree_mod_dont_log</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10210</x>
      <y>4670</y>
      <w>30</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>10120</x>
      <y>4800</y>
      <w>240</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.以下情况返回1
	1.tree_mod_seq_list链表为空
	2.eb的level为0
	3.上锁后tree_mod_seq_list为空
2.其他情况返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10230</x>
      <y>4760</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>10450</x>
      <y>4720</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__tree_mod_log_free_eb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>10390</x>
      <y>4790</y>
      <w>340</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.遍历tm_list
	1.__tree_mod_log_insert将tm插入到红黑树tree_mod_log
	2.如果tm存在，将之前插入的节点删除，并返回
2.如果成功插入，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10540</x>
      <y>4750</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10520</x>
      <y>4670</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>10400</x>
      <y>4900</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__tree_mod_log_insert</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10470</x>
      <y>4860</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>10300</x>
      <y>4970</y>
      <w>360</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.btrfs_inc_tree_mod_seq设置tm-&gt;seq为tree_mod_seq
	并递增tree_mod_seq
2.将tm插入到红黑树tree_mod_seq中按照tm-&gt;index 和tm-&gt;seq
3.如果tm在红黑树中存在，返回EEXIST，否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10480</x>
      <y>4930</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10340</x>
      <y>4170</y>
      <w>30</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>10810</x>
      <y>3890</y>
      <w>390</w>
      <h>790</h>
    </coordinates>
    <panel_attributes>4.如果parent存在
	1.如果mid的item超过了1/4,返回0
	2.read_node_slot读left(parent的pslot-1),
		和right(parent的pslot+1)，并对两者上锁
	3.如果left存在，通过push_node_left将mid的item移到left(如果能清空，需要将mid清空)
		并更改orig_slot相对于left偏移
	4.如果right存在
		1.通过push_node_left将right的item移到mid(如果能清空right，将其清空)
		2.如果right被清空
			1.del_ptr
			2.root_sub_used设置root的bytes_used
				root.root_item.bytes_used -=right-&gt;len
			3.free_extent_buffer_stale释放right
		3.如果没被清空
			1.btrfs_node_key提取right.slot[0]的key
			2.tree_mod_log_set_node_key记录log parent.slot[pslot+1]
				MOD_LOG_KEY_REPLACE
			3.btrfs_set_node_key通过right_key设置pslot+1的key
			4.btrfs_mark_buffer_dirty标记parent dirty
	5.如果mid还有1个item
		1.如果不存在left，必然从right中移动一部分到mid，所以不可能为1，返回EROFS
		2.balance_node_right将left的item移到mid
		3.如果没有足够的item，通过push_node_left将mid的item移到left
	6.如果mid的item被移完
		1.del_ptr删除mid
		2.root_sub_used递减root.root_item.bytes_used中mid的长度
		3.free_extent_buffer_stale释放mid
			mid=NULL
	7.如果mid还存在item
		1.btrfs_node_key提取mid.slot[0]的key
		2.tree_mod_log_set_node_key记录parent.slot[pslot]key的变化
		3.btrfs_set_node_key设置parent.slot[pslot]key
		4.btrfs_mark_buffer_dirty标记parent dirty
	8.如果left存在
		1.如果slot到了left中
			1.extent_buffer_get增加left计数
			2.path-&gt;nodes[level] = left;
				path-&gt;slots[level + 1] -= 1;
				path-&gt;slots[level] = orig_slot;
			3.如果mid还存在，free_extent_buffer递减mid计数
		2.如果还在mid中，更新其path.slot
			orig_slot -= btrfs_header_nritems(left);
			path-&gt;slots[level] = orig_slot
	9.如果发现path中slot指向的blockptr和之前不一致，博爱错
	10.enospc
		1.如果right存在，free_extent_buffer递减right家属
		2.如果left存在
			1.只有在left没被path引用时才解锁
			2.free_extent_buffer递减left计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10390</x>
      <y>3830</y>
      <w>540</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;520.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>10880</x>
      <y>4710</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>push_node_left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10920</x>
      <y>4670</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>10750</x>
      <y>4780</y>
      <w>420</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.如果不把src清空，并且src的item数小于8，直接返回1
2.如果能移到left的item数量小于0，返回1
3.确定push_items
	1.如果要清空src
		1.push_items不能超过src_item
		2.如果src没全部移除，至少给src保留8个item，否则直接返回1
	2.如果不需要清空，push_items不能超过src_item-8
4.tree_mod_log_eb_copy将item的移动log记录到红黑树中
5.copy_extent_buffer移动btrfs_key_ptr到dst中
6.如果src没全部移除，通过memmove_extent_buffer将src中
	item调整其位置
7.btrfs_set_header_nritems重新设置dst和src的item数量
8.btrfs_mark_buffer_dirty标记dst和src dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10940</x>
      <y>4740</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>10840</x>
      <y>5030</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tree_mod_log_eb_copy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10910</x>
      <y>4990</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>10780</x>
      <y>5100</y>
      <w>390</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.tree_mod_need_log检查不需要log，即返回0
2.如果dst和src的level是0，返回0
3.申请数组tm_list
4.通过alloc_tree_mod_elem申请tm，src的放到tm_list_rem中
	dst放到tm_list_add
5.tree_mod_dont_log检查是否需要log，并上锁
6.通过__tree_mod_log_insert将tm_list_rem和tm_list_add
	插入到红黑树中
7.释放tm_list，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>10940</x>
      <y>5060</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>11620</x>
      <y>4720</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>balance_node_right</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11180</x>
      <y>4670</y>
      <w>540</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;520.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>11620</x>
      <y>4790</y>
      <w>370</w>
      <h>190</h>
    </coordinates>
    <panel_attributes>1.如果不能移动，返回1
2.如果src数量小于4个，返回1
3.最多只能移动src/2，但是不能清空src，否则返回1
4.tree_mod_log_eb_move记录dst item移动的log
	1.记录move的keys
	2.记录移动过程中删除的keys
5.memmove_extent_buffer将dst的item移到偏移量为push_items的地方
6.tree_mod_log_eb_copy记录copy的log，copy_extent_buffer复制
	src的src_nritems - push_items到dst的0
7.btrfs_set_header_nritems设置dst和src的nritems
8.btrfs_mark_buffer_dirty标记src和dst dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11690</x>
      <y>4750</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>11260</x>
      <y>4720</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>del_ptr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11160</x>
      <y>4670</y>
      <w>160</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>11190</x>
      <y>4780</y>
      <w>390</w>
      <h>190</h>
    </coordinates>
    <panel_attributes>1.如果slot不是parent最后一个item
	1.如果level不是0，通过tree_mod_log_eb_move记录parent slot的移动
	2.memmove_extent_buffer填充删除的slot
2.如果时最后一个item，并且level不是0，通过tree_mod_log_insert_key
	记录slot被移除
3.btrfs_set_header_nritems重新设置parent的nritems
4.如果整个node被清除，btrfs_set_header_level设置node的level为0
5.如果删除的slot为0
	1.btrfs_node_key读取parent.slot[0].key
	2.fixup_low_keys循环取修复上层的key
6.btrfs_mark_buffer_dirty标记parent为dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11320</x>
      <y>4750</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>11310</x>
      <y>5000</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>fixup_low_keys</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11360</x>
      <y>4960</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>11190</x>
      <y>5070</y>
      <w>370</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.向上遍历level
	1.tree_mod_log_set_node_key表示上层eb的key被更改
	2.btrfs_set_node_key设置上层item的key
	3.btrfs_mark_buffer_dirty标记上层eb dirty
	4.如果上层slot不是0，退出循环
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11360</x>
      <y>5030</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>10600</x>
      <y>2640</y>
      <w>480</w>
      <h>690</h>
    </coordinates>
    <panel_attributes>5.循环处理b
	1.重新获取level
		level = btrfs_header_level(b)
	2.如果需要cow
		1.如果通过should_cow_block检查到不用block，跳到cow_done
		2.需要对该节点和parent上锁
			1.如果level大于write_lock_level，说明node没上锁
			2.如果write_lock_level&lt;level+1&lt;BTRFS_MAX_LEVEL，说明parent没上锁
			3.如果满足上述两个条件
				1.write_lock_level = level + 1;
				2.btrfs_release_path释放path，并跳到again
		3.btrfs_cow_block
	3.cow_done
		1.p-&gt;nodes[level] = b
		2.btrfs_clear_path_blocking
		3.如果ins_len为0，并且不存在keep_locks，清除p-&gt;locks[level+1]
		4.key_search在eb中查找key
		5.如果level不为0
			1.如果正确返回，并且所处的slot不是最小(这里在二分查找中找到的时high)
				dec = 1;
				slot -= 1;
			2.p-&gt;slots[level] = slot;
			3.setup_nodes_for_search对即将到来的插入或者删除动作左split或者合并操作
			4.如果要对slot0进行插入或者删除，因为需要改上一层的key
				write_lock_level不能小于level + 1
			5.如果遍历到了期望的level，还原slot，跳到done
				p-&gt;slots[level]++
			6.read_block_for_search读取子eb
			注：如果是现读，b不会发生改变，然后循环重新查找就能找到了
			7.如果skip_locking没置上
				1.如果level在write_lock_level范围内，通过btrfs_try_tree_write_lock
					对其上锁，如果上锁失败，通过btrfs_tree_lock等待上锁
					p-&gt;locks[level] = BTRFS_WRITE_LOCK
				2.否则上读锁
					p-&gt;locks[level] = BTRFS_READ_LOCK
				3.p-&gt;nodes[level] = b
		6.如果level=0
			1.p-&gt;slots[level] = slot
			2.如果btrfs_leaf_free_space剩余的空间低于ins_len
				1.如果write_lock_level低于1，释放path，跳到again重新寻找path
				2.btrfs_set_path_blocking设置path blocking
				3.split_leaf为node[0]腾出足够的空间(如果恰好在item.offset上插入数据，extend置上
					否则offset在查找item.offset的左边)
				4.btrfs_clear_path_blocking清除path blocking
			3.如果没有search_for_split，通过unlock_up调整write_lock_level
			4.跳到done
6.如果没找到，返回1		
7.done
	1.如果leave_spinning没置上，btrfs_set_path_blocking将path block
	2.如果出错，但是skip_release_on_error没置上，btrfs_release_path释放path
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>11250</x>
      <y>3370</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>read_block_for_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11060</x>
      <y>3320</y>
      <w>280</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>11150</x>
      <y>3430</y>
      <w>420</w>
      <h>310</h>
    </coordinates>
    <panel_attributes>1.读取slot的blockptr和gen
2.btrfs_find_tree_block查找slot对应的eb
3.如果找到
	1.如果btrfs_buffer_uptodate检查eb uptodate，返回0
		*eb_ret = tmp
	2.btrfs_read_buffer读取eb，如果成功，返回0
		*eb_ret = tmp
	3.否则通过free_extent_buffer递减eb计数，并btrfs_release_path
		释放path，返回EIO
4.如果没找到
	1.如果path要求预读(reada),reada_for_search根据reada向前或者向后预读
	2.通过btrfs_release_path将path清掉
	注：如果leaf没读进来，是不能清掉的，因为是从0level开始遍历
	3.read_tree_block读取blockptr对应的子节点
	4.如果正确读取
		1.如果eb没有uptodate，返回EIO
		2.free_extent_buffer递减temp计数
	注：这里并没有返回temp，只有找到时，才将temp作为eb_ret返回
		不更新eb_ret，让其重新再次查找
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11320</x>
      <y>3400</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>11370</x>
      <y>3800</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>reada_for_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11430</x>
      <y>3730</y>
      <w>30</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>11310</x>
      <y>3880</y>
      <w>310</w>
      <h>270</h>
    </coordinates>
    <panel_attributes>1.只对leaf进行预读
2.nodes[level]不存在，返回
3.btrfs_find_tree_block查找slot对应的eb
4.如果找到，递减eb计数，返回
5.循环
	1.确定预读的slot nr
		1.如果是向后预读，nr不为0，
			nr--
		2.如果是向前预读，nr不超过nritems
			nr++
	2.如果向后预读，后面eb的objectid要和node相同，
		否则退出循环
	3.预读范围不能超过65535
		1.readahead_tree_block进行预读
		2.nread += blocksize
	4.预读长度不能超过65535，遍历slot不能超过32
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11430</x>
      <y>3830</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9080</x>
      <y>2610</y>
      <w>1640</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1620.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1880</x>
      <y>3080</y>
      <w>240</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.申请btrfs_inode
2.设置并初始化ei和inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1980</x>
      <y>3040</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2040</x>
      <y>2770</y>
      <w>390</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.通过sb-&gt;s_op-&gt;alloc_inode申请inode，或者直接通过
	kmem_cache_alloc申请
2.inode_init_always进行inode的初始化
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2000</x>
      <y>2900</y>
      <w>180</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2260</x>
      <y>2940</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>inode_init_always</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2330</x>
      <y>2900</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2210</x>
      <y>3010</y>
      <w>330</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op = &amp;empty_iops;
inode-&gt;i_fop = &amp;no_open_fops;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2320</x>
      <y>2970</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>9580</x>
      <y>4160</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>push_nodes_for_insert</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9670</x>
      <y>4120</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>9540</x>
      <y>4230</y>
      <w>330</w>
      <h>410</h>
    </coordinates>
    <panel_attributes>1.读取父节点，如果不存在，直接返回1
	parent = path-&gt;nodes[level + 1];
	pslot = path-&gt;slots[level + 1];
2.read_node_slot读取parent[pslot-1] left
	1.btrfs_tree_lock和btrfs_set_lock_blocking对left上锁
	2.如果left的item数量超过限制，或者btrfs_cow_block上锁失败
		wret = 1
	3.否则上锁后，push_node_left将mid中的item移部分到left中
3.如果成功
	1.btrfs_node_key读取mid[0]的key，通过btrfs_set_node_key写入parent[pslot]
		并通过tree_mod_log_set_node_key记录log，btrfs_mark_buffer_dirty标记
		parent为dirty
	2.如果node在left
		1.更新path
			path-&gt;nodes[level] = left;
			path-&gt;slots[level + 1] -= 1;
			path-&gt;slots[level] = orig_slot;//之前已经加上了left中的item的数量
		2.free_extent_buffer释放对mid的引用
	3.如果node还在mid中
		1.path-&gt;slots[level] -=btrfs_header_nritems(left)
		2.free_extent_buffer释放对left的引用
	4.返回0
4.这里没对mid进行push_left操作，free_extent_buffer释放对left的引用
5.读取right，通过balance_node_right将mid的item移到right中，如果成功返回0
6.如果失败，返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9650</x>
      <y>4190</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6230</x>
      <y>2180</y>
      <w>320</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6240</x>
      <y>2180</y>
      <w>2780</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2760.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15440</x>
      <y>3340</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>split_leaf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13920</x>
      <y>3440</y>
      <w>350</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>1.如果在item正好item.offset插入(extend)
	1.如果data(新数据+item.size)+item超过了nodesize，返回EOVERFLOW
2.如果存在要插入的datasize，并且存在node[1]
	1.space_needed默认是需要的datasize
	2.如果slot小于eb.nritems
		space_needed -= btrfs_leaf_free_space
	3.push_leaf_right查看right是否有足够的空间，如果有将node的后半部分item移到right
		头部，item停留到free_space多的eb
	4.如果right没有足够的空间(wret=1)，通过push_leaf_left查看left是否有足够的空间
		如果有，将node前半部分item移到left尾端，item停留在free_space多的eb
	注：push_leaf_right因为移动的是后部分，所以只需要改变right的item.offset
		push_leaf_left移动的是前半部分，所以left和node的item的offset都要改变
	5.如果item所在的node的空间超过了所需要的data_size，返回0
3.如果没有父节点，通过insert_new_root向上提一层
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14110</x>
      <y>3370</y>
      <w>1420</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1400.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15080</x>
      <y>3740</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>insert_new_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15110</x>
      <y>3800</y>
      <w>500</w>
      <h>500</h>
    </coordinates>
    <panel_attributes>1.如果是最后一个节点，btrfs_item_key提取btrfs_item.key,
	否则通过btrfs_node_key提取btrfs_key_ptr.key
2.btrfs_alloc_tree_block申请eb，并预留硬盘空间extend
3.root_add_used递增
	root-&gt;root_item.bytes_used+=nodesize
4.设置申请的eb
	1.清空btrfs_header，并设置
		btrfs_header.nritems=1
		btrfs_header.level=level
		btrfs_header.bytenr=c-&gt;start
		btrfs_header.generation=trans-&gt;transid
		btrfs_header.flags=eb | BTRFS_MIXED_BACKREF_REV
		btrfs_header.owner= root-&gt;root_key.objectid
		btrfs_header.fsid=root-&gt;fs_info-&gt;fsid
		btrfs_header.chunk_tree_uuid=fs_info-&gt;chunk_tree_uuid
	2.btrfs_set_node_key设置key
	3.设置eb和leaf的关系
		1.btrfs_set_node_blockptr设置blockptr，
		2.btrfs_set_node_ptr_generation设置gen(lower header中的generation)
	4.btrfs_mark_buffer_dirty将eb标记为dirty
5.tree_mod_log_set_root_pointer申请MOD_LOG_ROOT_REPLACE的log，加入红黑树
6.更新根节点，并通过free_extent_buffer释放原来的根节点
	root-&gt;node=c
7.add_root_to_dirty_list将root加入dirty_cowonly_roots链表
8.extent_buffer_get(c);
	path-&gt;nodes[level] = c;
	path-&gt;locks[level] = BTRFS_WRITE_LOCK_BLOCKING;
	path-&gt;slots[level] = 0;
9.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15130</x>
      <y>3770</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14760</x>
      <y>4320</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_alloc_tree_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14840</x>
      <y>4290</y>
      <w>500</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14790</x>
      <y>4390</y>
      <w>430</w>
      <h>350</h>
    </coordinates>
    <panel_attributes>1.如果是dummy_root，通过btrfs_init_new_buffer申请alloc_bytenr处的eb
	调整alloc_bytenr，并返回
	root-&gt;alloc_bytenr += blocksize
2.通过use_block_rsv在对应的block_rsv中预留空间
3.btrfs_reserve_extent预留并寻找硬盘空间ins
4.btrfs_init_new_buffer申请ins对应的eb
5.如果root是BTRFS_TREE_RELOC_OBJECTID
	1.如果没有parent
		parent = ins.objectid
	2.将flags的BTRFS_BLOCK_FLAG_FULL_BACKREF置上
6.如果root不是BTRFS_TREE_LOG_OBJECTID
	1.btrfs_alloc_delayed_extent_op申请extent_op
		并通过传参key初始化extent_op-&gt;key
		extent_op-&gt;flags_to_set = flags;
		extent_op-&gt;update_key=!!skinny_metadata
		extent_op-&gt;update_flags = 1;
		extent_op-&gt;is_data = 0;
		extent_op-&gt;level = level
	2.btrfs_add_delayed_tree_ref申请head_ref和ref加入trans链表
7.返回eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13400</x>
      <y>4790</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_init_new_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13480</x>
      <y>4730</y>
      <w>1450</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1430.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13340</x>
      <y>4860</y>
      <w>360</w>
      <h>290</h>
    </coordinates>
    <panel_attributes>1.通过btrfs_find_create_tree_block创建在bytenr中的eb和page
2.通过btrfs_set_header_generation设置btrfs_header.generation为trans-&gt;transid
3.lock和状态设置
	1.btrfs_set_buffer_lockdep_class和btrfs_tree_lock等待并设置lock
	2.clean_tree_block如果transid一致，清除EXTENT_BUFFER_DIRTY
	3.清除buf的EXTENT_BUFFER_STALE
	4.btrfs_set_lock_blocking
	5.btrfs_set_buffer_uptodate设置buf和其中page uptodate
4.如果root的objectid是BTRFS_TREE_LOG_OBJECTID
	1.buf-&gt;log_index = root-&gt;log_transid % 2
	2.如果log_index是0，设置dirty_log_pages中buf段为EXTENT_DIRTY
		否则将其设置为EXTENT_NEW
5.如果不是log_object
	1.buf-&gt;log_index = -1;
	2.设置transaction-&gt;dirty_pages的buf段为EXTENT_DIRTY
6.trans-&gt;blocks_used++
7.返回buf
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13480</x>
      <y>4820</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13450</x>
      <y>5190</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>set_extent_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13500</x>
      <y>5140</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13500</x>
      <y>5220</y>
      <w>130</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
EXTENT_DIRTY</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13440</x>
      <y>5260</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>set_extent_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13440</x>
      <y>5330</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__set_extent_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13490</x>
      <y>5290</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13290</x>
      <y>5400</y>
      <w>480</w>
      <h>890</h>
    </coordinates>
    <panel_attributes>1.将bit的EXTENT_FIRST_DELALLOC置上
2.again
	1.如果没有prealloc，并且允许blocking(__GFP_DIRECT_RECLAIM),通过
		alloc_extent_state申请prealloc
	2.如果有cache_state，如果start在state-&gt;start~ state-&gt;end范围内
		并且state在红黑树中，跳到hit_next
		node = &amp;state-&gt;rb_node;
	3.tree_search_for_insert在tree.state中寻找start
	4.如果没找到node
		1.通过alloc_extent_state_atomic申请prealloc
		2.insert_state将state插入到红黑树中，并设置bit
		3.cache_state如果在EXTENT_IOBITS | EXTENT_BOUNDARY置上的时候
			将state存储到cached_state中
		4.重置prealloc，并跳到out
	5.如果找到 hit_next
		1.如果start相同，end超过了state范围
			1.如果不被预期的exclusive_bits置上，跳到out，返回EEXIST
				*failed_start = state-&gt;start
			2.set_state_bits置上state要求的bit，并根据情况插入到changeset
			3.cache_state将state缓存到cached_state，并且通过merge_state看是否能将红黑树中的state合并
			4.如果next_state和之前紧挨着，更换start，重新跳到hit_next，重新设置
				start = last_end + 1
			5.否则跳到search_again
		2.如果start大于state.start
			1.如果不被预期的exclusive_bits置上，跳到out，返回EEXIST
				*failed_start = state-&gt;start
			2.alloc_extent_state_atomic申请prealloc
			3.split_state让prealloc继承state的前半部分，并将prealloc置空
			4.如果end超过了start.end，将
				1.set_state_bits将需要置上的bit置上
				2.cache_state缓存state到cached_state，merge_state将红黑树中的state合并
				3.如果next_state和之前紧挨着，更换start，重新跳到hit_next，重新设置
					start = last_end + 1
			5.跳到search_again
		3.如果start在state.start之前
			1.首先this_end指向start之前所要的段
			2.alloc_extent_state_atomic申请prealloc
			3.将所期望的段在state前面的部分，通过insert_state插入到tree.state中
			4.insert_state缓存state，并释放prealloc
			5.调整start，并重新search_again
				start = this_end + 1
		注：前面改变的是start的位置(这里serch，绝对导致start&lt;state.end)，后面改变的是end的wei'zhi
		4.如果state.starte&lt;=end&lt;=state.end（这里2.5.3，start&gt;=state.start）（和条件1，改变了end的位置）
			1.如果不被预期的exclusive_bits置上，跳到out，返回EEXIST
				*failed_start = state-&gt;start
			2.split_state将prealloc设置为state的前半部分，并插到红黑树中
			3.set_state_bits设置状态，cache_state缓存prealloc，merge_state
				进行红黑树的合并
			4.释放prealloc，跳到out
		5.跳到search_again
3.out：如果存在prealloc，将其释放，并返回err
4.search_again：
	1.如果range遍历完成，跳到out
	2.如果gfpflags_allow_blocking，允许调度
	3.跳到again，重新查找段
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13490</x>
      <y>5360</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13180</x>
      <y>6320</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>alloc_extent_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13230</x>
      <y>6280</y>
      <w>140</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13230</x>
      <y>6350</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13450</x>
      <y>6320</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>insert_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13500</x>
      <y>6280</y>
      <w>70</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13380</x>
      <y>6390</y>
      <w>370</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.state-&gt;start = start;
	state-&gt;end = end;
2.set_state_bits创建state对应的ulist_node插入到changeset，并设置state-&gt;state
3.通过tree_insert将state插入到红黑树tree-&gt;state中
4.如果有相同的ndoe，返回EEXIST
5.merge_state查看红黑树中的node是否能合并
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13330</x>
      <y>6530</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>set_state_bits</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13500</x>
      <y>6350</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13390</x>
      <y>6490</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13220</x>
      <y>6600</y>
      <w>340</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.清除要设置bit中的EXTENT_CTLBITS
2.set_state_cb
3.如果之前EXTENT_DIRTY没置上，现在需要置
	tree-&gt;dirty_bytes += range
4.add_extent_changeset添加node到changeset中
5.state-&gt;state |= bits_to_set
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13380</x>
      <y>6560</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13310</x>
      <y>6720</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>add_extent_changeset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13380</x>
      <y>6690</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13190</x>
      <y>6790</y>
      <w>300</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.如果不存在changeset，直接返回
2.如果state和要求bits相同，直接返回
3.changeset-&gt;bytes_changed +=range
4.ulist_add创建node插入到红黑树
	changeset-&gt;range_changed中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13380</x>
      <y>6750</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13270</x>
      <y>6910</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>ulist_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13270</x>
      <y>6980</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>ulist_add_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13320</x>
      <y>6870</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13320</x>
      <y>6940</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13310</x>
      <y>7010</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13150</x>
      <y>7050</y>
      <w>330</w>
      <h>190</h>
    </coordinates>
    <panel_attributes>1.ulist_rbtree_search在ulist寻找val
2.如果找到对应的node，
	1.如果要求返回之前的end，通过old_aux返回
	2.返回0
3.申请node
	node-&gt;val = val;
	node-&gt;aux = aux;
4.ulist_rbtree_insert将node插入到红黑树中，并且
	插入到链表ulist-&gt;nodes中
	ulist-&gt;nnodes++
5.返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13610</x>
      <y>6530</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>merge_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13660</x>
      <y>6490</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13580</x>
      <y>6600</y>
      <w>360</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.如果state的EXTENT_IOBITS | EXTENT_BOUNDARY置上，直接返回
2.如果rb_prev和state可以合并，将两者合并，然后将prev从红黑树中移除
	并释放prev
3.如果有rb_next可以和state合并，将两个段合并，然后将next从红黑树
	中移除，并释放next
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13660</x>
      <y>6560</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13870</x>
      <y>6320</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>split_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13680</x>
      <y>6280</y>
      <w>260</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13820</x>
      <y>6400</y>
      <w>210</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>1.split_cb
2.prealloc继承orig前半部分
	prealloc-&gt;start = orig-&gt;start;
	prealloc-&gt;end = split - 1;
	prealloc-&gt;state = orig-&gt;state
3.调整orig
	orig-&gt;start = split
4.tree_insert插入prealloc
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13920</x>
      <y>6350</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14840</x>
      <y>4350</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13810</x>
      <y>4790</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>use_block_rsv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13860</x>
      <y>4730</y>
      <w>1070</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1050.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13720</x>
      <y>4860</y>
      <w>430</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.get_block_rsv获取block_rsv，如果size为0，跳到try_reserve
2.如果有足够的空间直接返回block_rsv
3.如果failfast，返回
4.如果BTRFS_BLOCK_RSV_GLOBAL，并且之前没更新，通过update_global_block_rsv
	更新，并跳到2重新查看空间
5.try_reserve
	1.reserve_metadata_bytes
	2.如果不是BTRFS_BLOCK_RSV_GLOBAL，并且space_info是global_rsv-&gt;space_info
		通过block_rsv_use_bytes向global_rsv申请
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13870</x>
      <y>4820</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13730</x>
      <y>5060</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>get_block_rsv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13780</x>
      <y>5010</y>
      <w>90</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13720</x>
      <y>5130</y>
      <w>280</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.以下情况下取trans-&gt;block_rsv
	1.root的BTRFS_ROOT_REF_COWS置上
	2.root是csum_root，并且adding_csums
	3.root是uuid_root
2.否则取root-&gt;block_rsv
3.否则取root-&gt;fs_info-&gt;empty_block_rsv
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13790</x>
      <y>5090</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14030</x>
      <y>5060</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>block_rsv_use_bytes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14060</x>
      <y>5010</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14020</x>
      <y>5130</y>
      <w>260</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.如果reserved超过要求的bytes
	1.block_rsv-&gt;reserved -= num_bytes
	2.如果block_rsv的reserved低于其size
		block_rsv-&gt;full = 0;
	3.返回0
2.返回ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14120</x>
      <y>5090</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14380</x>
      <y>5070</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>update_global_block_rsv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14130</x>
      <y>5010</y>
      <w>360</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14300</x>
      <y>5140</y>
      <w>450</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>1.calc_global_metadata_size计算extend_tree,checksum_tree和root_tree的空间
2.用这个空间更新block_rsv-&gt;size，不能低于52M
3.如果sinfo.total_bytes超过了已经所有的空间
	block_rsv-&gt;reserved += num_bytes;
	sinfo-&gt;bytes_may_use += num_bytes;
4.如果block_rsv.reserved超过了其size
	1.sinfo-&gt;bytes_may_use -= num_bytes
	2.block_rsv-&gt;reserved = block_rsv-&gt;size;
		block_rsv-&gt;full = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14470</x>
      <y>5100</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14220</x>
      <y>5320</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>calc_global_metadata_size</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14310</x>
      <y>5280</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14880</x>
      <y>4770</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_reserve_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14910</x>
      <y>4730</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14770</x>
      <y>4840</y>
      <w>380</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>1.btrfs_get_alloc_profile获取配置
2.find_free_extent查找空间充足的extend
3.如果返回ENOSPC
	1.如果还没final_tried，并且返回最大extend空间
		1.申请size   num_bytes/2(max_size)&lt;=size&lt;min_alloc_size
		2.如果到达了min_alloc_size
			final_tried = true
		3.跳到2，重新申请
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14950</x>
      <y>4800</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14800</x>
      <y>5030</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_get_alloc_profile</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14870</x>
      <y>4980</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14760</x>
      <y>5100</y>
      <w>360</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.如果是data，BTRFS_BLOCK_GROUP_DATA
2.如果是chunk_root，BTRFS_BLOCK_GROUP_SYSTEM
3.其他情况，BTRFS_BLOCK_GROUP_METADATA
4.get_alloc_profile
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14870</x>
      <y>5060</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14850</x>
      <y>5210</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>get_alloc_profile</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14900</x>
      <y>5170</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14740</x>
      <y>5280</y>
      <w>390</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.seq_lock读下面变量，如果发现seq有更改说明写了，循环读
	1.如果BTRFS_BLOCK_GROUP_DATA，将avail_data_alloc_bits置上
	2.如果BTRFS_BLOCK_GROUP_SYSTEM，将avail_system_alloc_bits置上
	3.如果BTRFS_BLOCK_GROUP_METADATA，将avail_metadata_alloc_bits置上
2.btrfs_reduce_alloc_profile
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14890</x>
      <y>5240</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14830</x>
      <y>5410</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_reduce_alloc_profile</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14900</x>
      <y>5370</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15310</x>
      <y>5020</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_free_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15090</x>
      <y>4980</y>
      <w>290</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15220</x>
      <y>5050</y>
      <w>170</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15140</x>
      <y>5090</y>
      <w>400</w>
      <h>340</h>
    </coordinates>
    <panel_attributes>1.__find_space_info遍历链表root-&gt;fs_info-&gt;space_info，找到
	和flags一致的space_info
2.如果space_info.max_extent_size存在
	1.如果申请的空间超过了max_extent_size，返回最大空间和ENOSPC
		ins-&gt;offset = space_info-&gt;max_extent_size
	2.否则
		use_cluster = false
3.通过fetch_cluster_info获取cluster，如果找到
	1.如果存在block_group
		hint_byte = last_ptr-&gt;window_start
	2.如果fragmented
		hint_byte = last_ptr-&gt;window_start;
		use_cluster = false;
注：space_info是将block_group按功能分类(flag raid)
	cluster是截取block_group中的free_space的一段用于分配
4.search_start是hint_byte和first_logical_byte的最大值
5.如果hint_byte是这个最大值
	1.btrfs_lookup_block_group找到包含search_start的block_group
	2.如果找到了block_group，其flag和要求的一致，并且cached不是BTRFS_CACHE_NO
		1.如果其链表block_group-&gt;list是空，或者ro(readonly?)将block_group释放
		2.通过get_block_group_index获取其raid_index,并跳到have_block_group
	3.如果其他情况不一致，直接将block_group释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14770</x>
      <y>5490</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>fetch_cluster_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14660</x>
      <y>5560</y>
      <w>410</w>
      <h>170</h>
    </coordinates>
    <panel_attributes>1.如果是btrfs_mixed_space_info(METADATA &amp;&amp;  DATA),返回NULL
3.如果是METADATA
	ret=meta_alloc_cluster
	empty_cluster=64k//不是ssd,是ssd则是2M
4.DATA，并且是ssd
	ret=data_alloc_cluster
	empty_cluster=2M
5.其他情况
	ret=NULL
	empty_cluster=2M//是ssd
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14820</x>
      <y>5520</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15150</x>
      <y>5490</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>first_logical_byte</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15200</x>
      <y>5520</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15090</x>
      <y>5560</y>
      <w>380</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.获取缓存fs_info-&gt;first_logical_byte，如果有效，直接返回
2.btrfs_lookup_first_block_group找最小block_group的cache(传参是0)
3.获取其起始byte，并通过btrfs_put_block_group释放cache
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15110</x>
      <y>5660</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_lookup_first_block_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15200</x>
      <y>5610</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15020</x>
      <y>5810</y>
      <w>440</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.遍历红黑树fs_info.block_group_cache_tree
	1.如果contain=0，ret记录不包含bytenr的最小node
	2.如果contain=1,ret记录包含bytenr的node
	3.如果找到start相同的node，ret则是改node
2.如果有ret
	1.通过btrfs_get_block_group递增cache.count
	2.如果是从0开始查找，first_logical_byte超过了cache的起始objectid，记录
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15200</x>
      <y>5690</y>
      <w>40</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
0</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15380</x>
      <y>5450</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_lookup_block_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15380</x>
      <y>5510</y>
      <w>220</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>block_group_cache_tree_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15100</x>
      <y>5740</y>
      <w>230</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>block_group_cache_tree_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15200</x>
      <y>5770</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15480</x>
      <y>5480</y>
      <w>40</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15350</x>
      <y>5420</y>
      <w>140</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15210</x>
      <y>5420</y>
      <w>70</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14850</x>
      <y>5420</y>
      <w>430</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15370</x>
      <y>5040</y>
      <w>1480</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
search</panel_attributes>
    <additional_attributes>10.0;20.0;1460.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16750</x>
      <y>5070</y>
      <w>390</w>
      <h>340</h>
    </coordinates>
    <panel_attributes>1.如果index(之前获取flag的raid)为0，或者其index没发生改变
	full_search = true
2.遍历链表space_info-&gt;block_groups[index]
	1.btrfs_grab_block_group递增block_group计数，并且根据delalloc是否申请data_rwsem
	2.如果flag在extra上不一致（用户要求，但是没提供），跳到loop，继续下一个block_group
	3.have_block_group
		1.确定block_group(数组中的，last_ptr中的？)
		2.当cluster不满足要求，要release_cluster，并加以填充
		3.如果cluster中不能申请，unclustered_alloc直接从block_group中申请
		4.如果成功申请到free_space，checks
3.如果CACHING_NOWAIT，并且期间有cached
	orig_have_caching_bg = true
4.如果没找到，并且CACHING_WAIT，期间有cached(have_caching_bg),跳到search
5.如果没找到，index低于BTRFS_NR_RAID_TYPES，递增index之后，跳到search
6.如果没找到，loop没超过限制
	1.index = 0
	2.如果是CACHING_NOWAIT 
		1.如果期间有被cache(orig_have_caching_bg)，或者没有full_search
			状态变为CACHING_WAIT，否则为ALLOC_CHUNK
	3.否则loop++
	4.如果是ALLOC_CHUNK
		1.查看current-&gt;journal_info是否存在，如果不存在，通过btrfs_join_transaction开启trans
		2.通过do_chunk_alloc申请chunk，如果ENOSPC，LOOP_NO_EMPTY_SIZE
		3.如果出错，但是不是ENOSPC，btrfs_abort_transaction，否则返回0
		4.如果join_transaction,btrfs_end_transaction
		5.如果出错，跳到out
	5.如果LOOP_NO_EMPTY_SIZE
		1.如果empty_size和empty_cluster，返回ENOSPC
		2.否则将empty清空，在search一遍
			empty_size = 0;
			empty_cluster = 0
	6.跳到search
7.如果没找到，loop超过限制，返回ENOSPC
8.如果找到
	1.若是在cluster申请
		last_ptr-&gt;window_start = ins-&gt;objectid
	2.返回0
9.如果ENOSPC
	space_info-&gt;max_extent_size = max_extent_size
	ins-&gt;offset = max_extent_size	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16000</x>
      <y>5420</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>have_block_group
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16060</x>
      <y>5400</y>
      <w>770</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>750.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16000</x>
      <y>5490</y>
      <w>320</w>
      <h>290</h>
    </coordinates>
    <panel_attributes>1.如果没有cached(cached:BTRFS_CACHE_FINISHED   BTRFS_CACHE_ERROR)
	1.have_caching_bg = true
	2.cache_block_group加载blockgroup的free_space的inode，并加载free_space到caching_ctl
2.错误检查，如果不通过，跳到loop，继续下一个block_group
	1.不能有BTRFS_CACHE_ERROR
	2.不能是read_only（block_group-&gt;ro）
3.如果使用cluster
	1.btrfs_lock_cluster找到last_ptr对应的block_group
	2.如果找到，跳到refill_cluster
	3.如果找到的和block_group不同，并且
		是read_only或者和要求的flag不同
		跳到release_cluster
	4.btrfs_alloc_from_cluster以链表方式遍历红黑树last_ptr.root
		申请extend
	5.如果成功申请
		1.btrfs_release_block_group要将之前找到的block_group释放
			block_group = used_block_group
		2.跳到checks
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16050</x>
      <y>5450</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15490</x>
      <y>5840</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>cache_block_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15530</x>
      <y>5770</y>
      <w>520</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>500.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15370</x>
      <y>5920</y>
      <w>460</w>
      <h>760</h>
    </coordinates>
    <panel_attributes>1.申请caching_ctl，并初始化
	caching_ctl-&gt;block_group = cache;
	caching_ctl-&gt;progress = cache-&gt;key.objectid;
	atomic_set(&amp;caching_ctl-&gt;count, 1);
	btrfs_init_work(&amp;caching_ctl-&gt;work, btrfs_cache_helper,
			caching_thread, NULL, NULL);
2.如果cached状态是BTRFS_CACHE_FAST，循环等待cache-&gt;caching_ctl.wait被唤醒
3.如果不是BTRFS_CACHE_NO，将申请的caching_ctl释放，并返回0
4.关联cache和cache_control
	cache-&gt;caching_ctl = caching_ctl;
	cache-&gt;cached = BTRFS_CACHE_FAST;
5.如果在挂载时，BTRFS_MOUNT_SPACE_CACHE置上
	1.load_free_space_cache加载cache到caching_ctl
	2.如果返回1，表示成功加载
		1.cache-&gt;caching_ctl = NULL;
			cache-&gt;cached = BTRFS_CACHE_FINISHED;
			cache-&gt;last_byte_to_unpin = (u64)-1;
			caching_ctl-&gt;progress = (u64)-1;
	3.如果没加载
		1.如果只是load_cache_only
			cache-&gt;caching_ctl = NULL;
			cache-&gt;cached = BTRFS_CACHE_NO;
		2.否则
			cache-&gt;cached = BTRFS_CACHE_STARTED;
			cache-&gt;has_caching_ctl = 1;
	4.唤醒caching_ctl-&gt;wait
	5.如果成功加载
		1.put_caching_control递减caching_ctl计数，必要时释放
		2.free_excluded_extents清除freed_extents数组EXTENT_UPTODATE标志
		3.返回0
6.否则
	1.如果只是load_cache_only
			cache-&gt;caching_ctl = NULL;
			cache-&gt;cached = BTRFS_CACHE_NO;
	2.否则
		cache-&gt;cached = BTRFS_CACHE_STARTED;
		cache-&gt;has_caching_ctl = 1;
	3.唤醒caching_ctl-&gt;wait
7.如果是load_cache_only
	1.put_caching_control释放caching_ctl，并返回0
8.否则
	1.递增caching_ctl-&gt;count，并将caching_ctl.list加入链表caching_block_groups
	2.btrfs_get_block_group增加cache计数
	3.btrfs_queue_work将caching_ctl-&gt;work加入队列caching_workers
	4.返回ret
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15460</x>
      <y>5870</y>
      <w>140</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14520</x>
      <y>6680</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>load_free_space_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14630</x>
      <y>6670</y>
      <w>800</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>780.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14370</x>
      <y>6750</y>
      <w>410</w>
      <h>230</h>
    </coordinates>
    <panel_attributes>1.如果disk_cache_state被标记为清除或不被trust(!BTRFS_DC_WRITTEN)，返回0
2.btrfs_alloc_path申请path
	path-&gt;search_commit_root = 1;
	path-&gt;skip_locking = 1;
3.lookup_free_space_inode获取对应block_group-&gt;key.objectid偏移的inode
4.如果上锁之后，发现disk_cache_state不在BTRFS_DC_WRITTEN，释放path之后，跳到out
5.__load_free_space_cache读取inode的free_space信息插入到ctl-&gt;free_space_offset
6.如果ctl-&gt;free_space和block_group的记录不同
	1.__btrfs_remove_free_space_cache将cluster_list和红黑树中ctl-&gt;free_space_offset
		的元素btrfs_free_space全部释放
7.out:
	1.如果失败
		1.block_group-&gt;disk_cache_state = BTRFS_DC_CLEAR
	2.释放inode，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14590</x>
      <y>6710</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13730</x>
      <y>7030</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lookup_free_space_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13820</x>
      <y>6970</y>
      <w>580</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>560.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13640</x>
      <y>7100</y>
      <w>370</w>
      <h>170</h>
    </coordinates>
    <panel_attributes>1.如果block_group-&gt;inode不是I_FREEING|I_WILL_FREE，直接返回
2.__lookup_free_space_inode获取偏移为block_group-&gt;key.objectid的inode
注：1.block_group中btrfs_key中object_id是block_group的offset，offset是size
	2.如果偏移不在范围内，btrfs_search_slot找offset较大的eb
3.如果inode的BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW没全置上
	BTRFS_I(inode)-&gt;flags |= BTRFS_INODE_NODATASUM |
			BTRFS_INODE_NODATACOW;
	block_group-&gt;disk_cache_state = BTRFS_DC_CLEAR;
4.如果block_group-&gt;iref没置上
	block_group-&gt;inode = igrab(inode);
	block_group-&gt;iref = 1;
5.返回inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13790</x>
      <y>7060</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13730</x>
      <y>7300</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__lookup_free_space_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13820</x>
      <y>7260</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13600</x>
      <y>7370</y>
      <w>420</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>1.通过btrfs_search_slot查找下面的key
	key.objectid = BTRFS_FREE_SPACE_OBJECTID;
	key.offset = offset;
	key.type = 0;
2.btrfs_item_ptr是slot对应的数据
3.以btrfs_free_space_header解析header，读取header.location到disk_key中
4.btrfs_release_path释放path
5.btrfs_iget根据location获取inode
6.错误处理
	1.没有申请到inode，返回ENOENT
	2.如果出错，直接返回错误
	3、如果是is_bad_inode，释放inode，并返回ENOENT
7.mapping_set_gfp_mask将inode-&gt;i_mapping.flags
	的__GFP_FS | __GFP_HIGHMEM清掉
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13820</x>
      <y>7330</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13590</x>
      <y>7650</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_iget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13440</x>
      <y>7720</y>
      <w>390</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.btrfs_iget_locked获取inode
2.如果inode是新创建的(I_NEW)
	1.btrfs_read_locked_inode读取inode
	2.如果不是is_bad_inode(bad_inode_ops)，inode_tree_add
		*new = 1
	3.否则释放inode，并返回ESTALE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13640</x>
      <y>7680</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>12820</x>
      <y>7870</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_iget_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12880</x>
      <y>7820</y>
      <w>610</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>590.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>12660</x>
      <y>7940</y>
      <w>290</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.通过location-&gt;objectid(inode号)计算hash
2.iget5_locked获取inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12850</x>
      <y>7900</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>12590</x>
      <y>8010</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_find_actor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12650</x>
      <y>7980</y>
      <w>90</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>12490</x>
      <y>8080</y>
      <w>260</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.inode的location-&gt;objectid要和arg相同
2.inode.root要和arg相同
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12620</x>
      <y>8040</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>12820</x>
      <y>8020</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_init_locked_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12880</x>
      <y>7980</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>12780</x>
      <y>8090</y>
      <w>270</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.inode-&gt;i_ino = args-&gt;location-&gt;objectid
2.arg的location复制到inode.location中
3.设置root
	BTRFS_I(inode)-&gt;root = args-&gt;root
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12900</x>
      <y>8050</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13900</x>
      <y>7860</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>inode_tree_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13640</x>
      <y>7820</y>
      <w>350</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13860</x>
      <y>7930</y>
      <w>330</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.如果inode没连接到hash中，直接返回
2.遍历红黑树root-&gt;inode_tree
	1.按照ino的大小进行插入
	2.如果有ino相同的inode，通过rb_replace_node进行替换
3.最后插入到红黑树中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13940</x>
      <y>7890</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13980</x>
      <y>8040</y>
      <w>100</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_ino</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14010</x>
      <y>8010</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13860</x>
      <y>8110</y>
      <w>350</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.默认是BTRFS_I(inode)-&gt;location.objectid
2.如果这个ino不存在，或者type是BTRFS_ROOT_ITEM_KEY
	ino = inode-&gt;i_ino
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14010</x>
      <y>8070</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14310</x>
      <y>8040</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>rb_replace_node</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14110</x>
      <y>8010</y>
      <w>260</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14240</x>
      <y>8110</y>
      <w>340</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.__rb_change_child将parent的left或者right改成new
2.rb_set_parent重新设置子节点的父节点为new
3.更新new的红黑树特性(左右子节点和clolor)
	*new = *victim
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14360</x>
      <y>8070</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13650</x>
      <y>7600</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15120</x>
      <y>7060</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__load_free_space_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14680</x>
      <y>6970</y>
      <w>560</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;540.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15110</x>
      <y>7140</y>
      <w>340</w>
      <h>460</h>
    </coordinates>
    <panel_attributes>1.如果读取inode.size不为0，直接返回
2.btrfs_search_slot在free_space中搜索offset，如果没找到，返回0
3.以btrfs_free_space_header解析slot数据，获取其num_entries num_bitmaps generation
4.btrfs_release_path释放path
5.如果btrfs_inode.generation为0或者和free_space不同，并且num_entries要存在，否则直接返回0
6.io_ctl_init初始化io_ctl
7.readahead_cache将整个inode.i_size读进来，通过io_ctl_prepare_pages
	将都进来的page和io_ctl关联
8.io_ctl_check_crc检查首页的crc
9.循环申请num_entries个btrfs_free_space
	1.kmem_cache_zalloc申请btrfs_free_space e
	2.io_ctl_read_entry通过io_ctl.cur中的page初始化e
	3.e-&gt;bytes要存在
	4.如果entry type是BTRFS_FREE_SPACE_EXTENT
		1.将e通过link_free_space加入ctl中
	5.否则
		1.为e-&gt;bitmap申请bitmap
			num_bitmaps--
		2.link_free_space将e加入到ctl
		3.ctl-&gt;total_bitmaps++;
			ctl-&gt;op-&gt;recalc_thresholds
		4.list_add_tail将e.list加入到链表bitmaps
10.io_ctl_unmap_page将cur unmmap
11.遍历链表bitmaps
	1.通过list_del_init将e.list从链表中移除
	2.io_ctl_read_bitmap读取page中的bitmap
12.io_ctl_drop_pages释放io_ctl中的page
13.merge_space_tree
14.io_ctl_free释放pages数组，并返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15230</x>
      <y>7090</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14440</x>
      <y>7700</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>io_ctl_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14500</x>
      <y>7590</y>
      <w>720</w>
      <h>130</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>700.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14420</x>
      <y>7770</y>
      <w>320</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.读取inode.size并对page向上取整得出其io_ctl_init
2.inode.i_ino不是BTRFS_FREE_INO_OBJECTID，需要check_crcs
3.如果写操作，并且需要check_crc，其crc的大小要小于1page
4.将io_ctl清0
5.为io_ctl-&gt;pages申请num_pages数组
	io_ctl-&gt;num_pages = num_pages;
	io_ctl-&gt;root = root;
	io_ctl-&gt;check_crcs = check_crcs;
	io_ctl-&gt;inode = inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14490</x>
      <y>7730</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14810</x>
      <y>7700</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>readahead_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14850</x>
      <y>7590</y>
      <w>390</w>
      <h>130</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14750</x>
      <y>7770</y>
      <w>330</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.申请ra，并通过file_ra_state_init进行初始化
	1.从inode.sb.sbdi.ra_pages读取预读的page的数目ra-&gt;ra_pages
	2.ra-&gt;prev_pos = -1
2.last_index是inode.size的page数
3.page_cache_sync_readahead进行同步预读
4.释放ra，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14870</x>
      <y>7730</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14830</x>
      <y>7900</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>page_cache_sync_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14910</x>
      <y>7860</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14700</x>
      <y>7970</y>
      <w>450</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.如果没有预读的page数ra-&gt;ra_pages，直接返回
2.如果存在file，并且是FMODE_RANDOM，通过force_page_cache_readahead
	直接读，不进行预读
3.否则通过ondemand_readahead预读
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14910</x>
      <y>7930</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15150</x>
      <y>8070</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>ondemand_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15090</x>
      <y>8040</y>
      <w>150</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15010</x>
      <y>8140</y>
      <w>400</w>
      <h>490</h>
    </coordinates>
    <panel_attributes>1.如果读的地方offset是file start，直接跳到initial_readahead
2.如果到达了异步预读的点((ra-&gt;start + ra-&gt;size - ra-&gt;async_size)
	或者所有的预读均已读完(ra-&gt;start + ra-&gt;size)
	1.更新预读窗口
		ra-&gt;start += ra-&gt;size;
		ra-&gt;size = get_next_ra_size(ra, max);
		ra-&gt;async_size = ra-&gt;size;
	2.跳到readit
3.如果是异步预读(同步预读，hit_readahead_marker为false，异步预读，为true)
	1.page_cache_next_hole寻找了从offset+1开始的没被缓存的page
	2.如果超过index的bit限制(start=0),或者遍历的长度（start-offset）超过了max
		1.ra-&gt;start = start
			//ra-&gt;size变换为pre_async_size+req_size之后，在get_next_ra_size
			ra-&gt;size = get_next_ra_size
			ra-&gt;async_size = ra-&gt;size
		2.跳到readit
4.如果req_size超过了max，跳到initial_readahead
5.如果和之前读取的位置ra-&gt;prev_pos只相差一页，跳到initial_readahead
6.try_context_readahead查看是否进行了预读，但是因为long-run没读进来
	如果是，跳到readit
7.否则通过__do_page_cache_readahead进行读取req_size，预读传参为0
8.initial_readahead
	1.ra-&gt;start = offset;
		ra-&gt;size = get_init_ra_size(req_size, max);
		ra-&gt;async_size = ra-&gt;size &gt; req_size ? ra-&gt;size - req_size : ra-&gt;size;
9.readit：
	1.如果此时满足异步读取条件，增加next_size
		1.ra-&gt;async_size = get_next_ra_size
			ra-&gt;size += ra-&gt;async_size
	2.通过ra_submit提交预读请求
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15220</x>
      <y>8100</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14740</x>
      <y>8660</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>get_next_ra_size</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14800</x>
      <y>8620</y>
      <w>250</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14650</x>
      <y>8730</y>
      <w>310</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.如果当前窗口偏小(相对于max)，next为当前窗口的4倍
2.如果当前窗口偏大，则为当前窗口的2倍
3.不能超过max
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14790</x>
      <y>8690</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15320</x>
      <y>8670</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>try_context_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15300</x>
      <y>8620</y>
      <w>90</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15310</x>
      <y>8740</y>
      <w>310</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.从count_history_pages计算被缓存的page数
2.如果缓存的page数不错过req_size,直接返回0
3.如果offset在size的范围内，但是没达到size-async_size
	说明是一个long-run stream（size相对async_size较大），
	size *=2
4.ra-&gt;start = offset;
	ra-&gt;size = min(size + req_size, max);
	ra-&gt;async_size = 1
5.返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15400</x>
      <y>8700</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15350</x>
      <y>8930</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>count_history_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15290</x>
      <y>9000</y>
      <w>340</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.page_cache_prev_hole找到最小被cache的page_index
2.返回其到offset-1的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15420</x>
      <y>8960</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15390</x>
      <y>9080</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>page_cache_prev_hole</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15440</x>
      <y>9040</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15290</x>
      <y>9150</y>
      <w>380</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.遍历mapping-&gt;page_tree的radix_tree，最多只能遍历max_scan
	1.如果通过radix_tree_lookup找不到page或者有exception，直接退出
	2.index--,index遍历到~0（溢出）,直接退出
2.返回index
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15460</x>
      <y>9110</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15410</x>
      <y>8890</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15030</x>
      <y>8670</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>page_cache_next_hole</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15090</x>
      <y>8620</y>
      <w>150</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14980</x>
      <y>8730</y>
      <w>300</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.从index开始遍历mapping-&gt;page_tree，最多只能遍历max_scan
	1.radix_tree_lookup如果找不到page或者page exception，退出
	2.index++，直到index溢出
2.返回index
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15100</x>
      <y>8700</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15670</x>
      <y>8660</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>ra_submit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15630</x>
      <y>8720</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__do_page_cache_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15720</x>
      <y>8690</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15370</x>
      <y>8620</y>
      <w>370</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15730</x>
      <y>8750</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15640</x>
      <y>8790</y>
      <w>340</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.如果inode.i_size是0，直接返回
2.循环读nr_to_read个page
	1.如果超过了inode.i_size，退出循环
	2.radix_tree_lookup在mapping-&gt;page_tree寻找对应的page
		如果找到，并且不是exception，继续下一个
	3.page_cache_alloc_readahead申请page，并将page.lru加入page_pool
		page-&gt;index = page_offset;
	4.如果到达了size-asyncsize,SetPageReadahead
3.如果有要读的pgae，通过read_pages读取，并返回读取的page数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15770</x>
      <y>8980</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>read_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15690</x>
      <y>9050</y>
      <w>320</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.如果有mapping-&gt;a_ops-&gt;readpages，通过这个函数读取pages
2.否则向后遍历pages，读取nr_pages
	1.将page-&gt;lru从pages中断开
	2.如果add_to_page_cache_lru插入到mapping.page_tree成功，
		通过mapping-&gt;a_ops-&gt;readpage读取page
	3.page_cache_release释放page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15820</x>
      <y>8940</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15820</x>
      <y>9010</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15740</x>
      <y>9190</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;readpage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15820</x>
      <y>9150</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14660</x>
      <y>8080</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>force_page_cache_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14740</x>
      <y>8040</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14600</x>
      <y>8140</y>
      <w>360</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>1.readpage和readpages至少有一个存在，否则返回EINVAL
2.nr_to_read不能超过inode.sb.sbdi.ra_pages
3.循环读nr_to_read
	1.一次不能超过2k
	2.通过__do_page_cache_readahead直接读（预读传参是0）
	3.更新循环变量
		offset += this_chunk;
		nr_to_read -= this_chunk;
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14740</x>
      <y>8110</y>
      <w>50</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15140</x>
      <y>7680</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>io_ctl_prepare_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15200</x>
      <y>7590</y>
      <w>50</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15100</x>
      <y>7750</y>
      <w>320</w>
      <h>180</h>
    </coordinates>
    <panel_attributes>1.循环检查io_ctl-&gt;num_pages个page
	1.通过find_or_create_page寻找或者创建page
		io_ctl-&gt;pages[i] = page
	2.如果需要page_uptodate,并且PageUptodate检查
		page没有更新
		1.通过btrfs_readpage将page都进来
		2.lock_page后，检查page是否更新，如果没更新，报错EIO
2.遍历所有的num_pages
	1.clear_page_dirty_for_io
	2.set_page_extent_mapped设置page.private
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15210</x>
      <y>7710</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15550</x>
      <y>7670</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>io_ctl_check_crc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15230</x>
      <y>7590</y>
      <w>400</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15440</x>
      <y>7740</y>
      <w>390</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.如果不需要check_crcs，通过io_ctl_map_page初始化，并返回0
2.如果是首页，要排除crc的空间，其他页offset为0
	offset = sizeof(u32) * io_ctl-&gt;num_pages
3.取出首页中，对应index的crc
4.io_ctl_map_page对ioctl进行初始化
5.btrfs_csum_data和btrfs_csum_final计算crc，与page记录的
	进行比较，如果不同，返回EIO
6.如果成功，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15580</x>
      <y>7700</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15440</x>
      <y>7900</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>io_ctl_map_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15490</x>
      <y>7870</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15400</x>
      <y>7960</y>
      <w>280</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.io_ctl-&gt;page取io_ctl-&gt;pages[io_ctl-&gt;index]
	io_ctl-&gt;index++
2.io_ctl-&gt;cur = page_address(io_ctl-&gt;page);
	io_ctl-&gt;orig = io_ctl-&gt;cur;
	io_ctl-&gt;size = PAGE_CACHE_SIZE;
3.如果设置了clear，将io_ctl-&gt;cur清0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15500</x>
      <y>7930</y>
      <w>40</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15890</x>
      <y>7660</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>io_ctl_check_generation</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15240</x>
      <y>7590</y>
      <w>730</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;710.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15850</x>
      <y>7730</y>
      <w>330</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.确定generation的位置
	1.如果需要check_crcs，io_ctl-&gt;cur和io_ctl-&gt;size排除crc的空间
	2.否则，io_ctl-&gt;cur和io_ctl-&gt;size排除一个64位的chunk
2.读取generation并对比，如果不同，返回EIO
3.把generation的空间排除，并返回0
	io_ctl-&gt;cur += sizeof(u64)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15960</x>
      <y>7690</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16290</x>
      <y>7650</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>io_ctl_read_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15230</x>
      <y>7590</y>
      <w>1130</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16200</x>
      <y>7720</y>
      <w>370</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.如果没有io_ctl-&gt;cur，通过io_ctl_check_crc去map_page
2.以btrfs_free_space_entry方式解析io_ctl-&gt;cur
	1.entry-&gt;offset = le64_to_cpu(e-&gt;offset);
		entry-&gt;bytes = le64_to_cpu(e-&gt;bytes);
		*type = e-&gt;type;
	2.更新io_ctl-&gt;cur和io_ctl-&gt;size
3.如果该page内还存在e，直接返回0
4.否则通过io_ctl_unmap_page将cur释放，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16350</x>
      <y>7680</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16730</x>
      <y>7650</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>link_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16770</x>
      <y>7680</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16610</x>
      <y>7720</y>
      <w>360</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.通过tree_insert_offset将info插入红黑树ctl-&gt;free_space_offset
2.ctl-&gt;free_space += info-&gt;bytes;
	ctl-&gt;free_extents++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15260</x>
      <y>7590</y>
      <w>1530</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1510.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16690</x>
      <y>7810</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tree_insert_offset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16740</x>
      <y>7770</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16730</x>
      <y>7840</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16610</x>
      <y>7880</y>
      <w>390</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.根据offset遍历红黑树
	1.如果找到offset相同的，有bitmap的要在没有的右边
	2.如果红黑树中有和info.bitmap性质相同的entry，返回EEXIST
2.rb_link_node和rb_insert_color进行红黑树插入
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17060</x>
      <y>7640</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>io_ctl_read_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17300</x>
      <y>7630</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>io_ctl_drop_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17580</x>
      <y>7630</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>merge_space_tree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17830</x>
      <y>7630</y>
      <w>110</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>io_ctl_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17010</x>
      <y>7710</y>
      <w>290</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.io_ctl_check_crc检查crc，并且给cur map到page io_ctl-&gt;index
2.复制整页cur给entry-&gt;bitmap
3.io_ctl_unmap_page释放cur
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17130</x>
      <y>7670</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17370</x>
      <y>7660</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17310</x>
      <y>7700</y>
      <w>230</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.io_ctl_unmap_page释放cur
2.遍历数组io_ctl-&gt;pages中的page
	1.ClearPageChecked
	2.unlock_page
	3.page_cache_release释放page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17900</x>
      <y>7660</y>
      <w>40</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17820</x>
      <y>7690</y>
      <w>180</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.释放数组io_ctl-&gt;pages
	io_ctl-&gt;pages = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15270</x>
      <y>7590</y>
      <w>1870</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1850.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15270</x>
      <y>7590</y>
      <w>2120</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15230</x>
      <y>7590</y>
      <w>2460</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2440.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15240</x>
      <y>7590</y>
      <w>2660</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2640.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17650</x>
      <y>7660</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17550</x>
      <y>7700</y>
      <w>260</w>
      <h>170</h>
    </coordinates>
    <panel_attributes>1.以链表的形式遍历红黑树
	1.两个指针：当前e 以及pre
	2.两个bitmap要都不存在
	3.如果prev.offset+prev.bytes=e.offset
		1.unlink_free_space将e和prev从红黑树中删除
		2.将两者合并
			prev-&gt;bytes += e-&gt;bytes;
		3.释放e
		4.link_free_space将prev重新加入红黑树
		5.prev = NULL，并重新遍历整个红黑树链表
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15680</x>
      <y>6700</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>free_excluded_extents</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15650</x>
      <y>6670</y>
      <w>140</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15610</x>
      <y>6770</y>
      <w>380</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.通过clear_extent_bits清除freed_extents数组从cache.start~cache.end的
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15780</x>
      <y>6730</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15740</x>
      <y>6830</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>clear_extent_bits</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15790</x>
      <y>6790</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15710</x>
      <y>6890</y>
      <w>290</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.如果EXTENT_LOCKED置上，将wake置上
2.通过clear_extent_bit清除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15810</x>
      <y>6860</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15760</x>
      <y>6960</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>clear_extent_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15810</x>
      <y>6920</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15780</x>
      <y>7020</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__clear_extent_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15830</x>
      <y>6990</y>
      <w>40</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15490</x>
      <y>7090</y>
      <w>400</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>1.设置bits
	1.如果EXTENT_DELALLOC置上，将EXTENT_NORESERVE也置上
	2.如果需要delete，将EXTENT_CTLBITS置上
	3.将EXTENT_FIRST_DELALLOC置上
	4.如果EXTENT_IOBITS或者EXTENT_BOUNDARY置上，clear置上
2.again
	1.如果没有prealloc，并且内存申请允许__GFP_DIRECT_RECLAIM
		通过alloc_extent_state申请prealloc
	2.如果有cache_state
		1.如果clear，将cached_state清掉
		2.如果之前的cached正常，并且start在其范围内
			1.如果clear，递减cached-&gt;refs
			2.state = cached，并跳到hit_next
		3.如果clear置上，通过free_extent_state将cached释放
	3.直接通过tree_search在红黑树tree中查找
	注：__tree_search如果没找到，先向后找到offset&lt;end，在向前找offset&gt;start
	4.如果没找到，跳到out，如果找到，转换为state
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15620</x>
      <y>7050</y>
      <w>260</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15860</x>
      <y>7050</y>
      <w>210</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15990</x>
      <y>7090</y>
      <w>390</w>
      <h>290</h>
    </coordinates>
    <panel_attributes>3.hit_next
	1.如果end&lt;state.start(没有重叠的部分)，跳到out
	2.如果state.state要清的bit没置上，跳到next继续下一个state
	3.如果start在state.start~end之间(由tree_search可知不可能找到一个offset&gt;end的node)
		1.alloc_extent_state_atomic申请prealloc
		2.split_state将state从start分为两段，并将后面一段插入红黑树
			后面一段作为orig返回
		3.如果后段state完全在要clear的范围内，通过clear_state_bit清除state内对应的bit
			并跳到next
		4.跳到search_again
	4.如果end在state的范围内
		1.alloc_extent_state_atomic申请prealloc
		2.split_state将state从end+1分为两部分
		3.如果需要wake，唤醒state-&gt;wq
		4.通过clear_state_bit清除前段的state的bit
		5.prealloc = NULL，并跳到out
	5.如果和state完全重合，直接通过clear_state_bit清除
	6.next：
		1.如果state之后没有next，直接跳到out
		2.如果有nextstate，并且要求的段没遍历完，跳到hit_next
		3.否则重新search_again
	7.out
		1.如果有prealloc，通过free_extent_state释放
		2.返回0
4.search_again
	1.如果段被遍历完，直接跳到out
	2.如果gfpflags_allow_blocking，考虑schedule
	3.跳到again
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16070</x>
      <y>7400</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>clear_state_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15980</x>
      <y>7460</y>
      <w>340</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>1.不能清EXTENT_CTLBITS
2.如果要清EXTENT_DIRTY
	tree-&gt;dirty_bytes -= range
3.clear_state_cb
4.add_extent_changeset更新changeset-&gt;bytes_changed
	并通过ulist_add将chang插入红黑树range_changed
5.state-&gt;state &amp;= ~bits_to_clear;
6.如果要wake，唤醒state-&gt;wq
7.如果state的状态被清空
	1.返回next_state
	2.将state冲红黑树中删除，并释放
8.否则
	1.merge_state合并state和其他node
	2.返回next_state
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16120</x>
      <y>7370</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16120</x>
      <y>7430</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16200</x>
      <y>6700</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_queue_work</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15810</x>
      <y>6670</y>
      <w>460</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16130</x>
      <y>6760</y>
      <w>310</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>1.如果work的WORK_HIGH_PRIO_BIT置上，并且wq-&gt;high存在
	即用队列wq-&gt;high，否则使用队列wq-&gt;normal
2.__btrfs_queue_work将work挂入队列
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16250</x>
      <y>6730</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16170</x>
      <y>6850</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_queue_work</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16240</x>
      <y>6820</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16110</x>
      <y>6920</y>
      <w>380</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.work-&gt;wq = wq
2.thresh_queue_hook在不是NO_THRESHOLD的情况下
	递增wq-&gt;pending
3.如果work.ordered_func存在
	1.work加入链表wq-&gt;ordered_list
4.queue_work将work(normal_work)加入队列wq-&gt;normal_wq
5.trace_btrfs_work_queued
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16240</x>
      <y>6880</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15970</x>
      <y>5860</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_lock_cluster</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16010</x>
      <y>5770</y>
      <w>310</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15960</x>
      <y>5920</y>
      <w>350</w>
      <h>230</h>
    </coordinates>
    <panel_attributes>1.如果used_bg之前被lock
	1.如果used_bg没发生改变，直接返回used_bg
	2.否则释放其信号量data_rwsem，btrfs_put_block_group
		递减其计数后，向下重新查找
2.查看used_bg，如果不存在，返回NULL
	used_bg = cluster-&gt;block_group
3.如果和正在遍历的block_group相同，直接返回
4.否则
	1.btrfs_get_block_group递增used_bg计数
	2.如果不需要delalloc，直接返回
	3.如果需要
		1.首先利用down_read_trylock尝试申请信号量，如果成功，直接返回
		2.如果失败，再用down_read申请，置上lock之后，跳到1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16020</x>
      <y>5890</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16720</x>
      <y>5790</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_alloc_from_cluster</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16290</x>
      <y>5770</y>
      <w>520</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16620</x>
      <y>5850</y>
      <w>390</w>
      <h>500</h>
    </coordinates>
    <panel_attributes>1.如果要申请的空间超过了cluster.max_size，直接跳到out
2.如果cluster-&gt;block_group发生改变，跳到out
3.以链表的方式遍历cluster-&gt;root
	1.如果entry的空间不足，但是超过之前遍历的max_extent_size
		*max_extent_size = entry-&gt;bytes
	2.如果entry空间不足，或者
		bitmap不存在，其offset小于min_start
		1.选择rb_next，继续下一个循环
	3.如果空间充足
		1.如果有bitmap
			1.btrfs_alloc_from_bitmap在bitmap中申请extend
			2.如果没成功，继续遍历rb_next
			3.如果成功
				cluster-&gt;window_start += bytes
		2.起始的extend为ret = entry-&gt;offset
			entry-&gt;offset += bytes;
			entry-&gt;bytes -= bytes;
		3.如果entry的free_space被申请完，将其从红黑树中删除
		4.退出循环
4.out:
	1.如果没申请成功，返回0
	2.更新ctl
		1.ctl-&gt;free_space -= bytes
		2.如果entry的free_space被申请完
			1.ctl-&gt;free_extents--;
			2.如果存在bitmap
				kfree(entry-&gt;bitmap);
				ctl-&gt;total_bitmaps--;
				ctl-&gt;op-&gt;recalc_thresholds(ctl);
			3.释放entry
	3.返回extend的offset
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16780</x>
      <y>5820</y>
      <w>40</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16710</x>
      <y>6370</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_alloc_from_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16640</x>
      <y>6440</y>
      <w>340</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.确认start和空间大小后，通过search_bitmap查找是否有充足空间可以被申请
2.如果没有，max_extent_size返回遍历查找的max_extent_size
3.如果成功，通过__bitmap_clear_bits清除对应bitmap，并返回offset
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16900</x>
      <y>6520</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>search_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16920</x>
      <y>6580</y>
      <w>340</w>
      <h>330</h>
    </coordinates>
    <panel_attributes>1.如果for_alloc置上(申请bitmap?),但是max_extent_size达不到要求，返回-1
2.从offset对应的bit开始，通过find_next_bit查找空闲的(标为1？)，直到BITS_PER_BITMAP
	1.如果for_alloc置上，并且只申请1个extend，退出循环
		found_bits = 1
	2.否则find_next_zero_bit找已经被申请的，并计算空闲extend数量
		extent_bits = next_zero - i
	3.如果extent_bits超过了要求，退出循环
		found_bits = extent_bits
	4.如果其超过了max_bits，更新
		max_bits = extent_bits
	5.然后从next_zero+1开始find_next_bit
3.如果找到对应的extend_size
	1.*offset = (u64)(i * ctl-&gt;unit) + bitmap_info-&gt;offset;
		*bytes = (u64)(found_bits) * ctl-&gt;unit;
	2.返回0
4.如果没找到，返回max_bits，并返回-1
	*bytes = (u64)(max_bits) * ctl-&gt;unit;
	bitmap_info-&gt;max_extent_size = *bytes
疑问：1.for_alloc仅仅是在申请1个extend和不满足max_extent_size会更快一点，还有其他作用吗？
		2.如果要读的bytes是unit多一点，那么那多的那些空间不会申请extend?
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16630</x>
      <y>6520</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__bitmap_clear_bits</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16560</x>
      <y>6580</y>
      <w>310</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.bitmap_clear清除offset对应bit，大小为bytes对应的bits
2.更新free_space空间大小
	info-&gt;bytes -= bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16640</x>
      <y>6660</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>bitmap_clear</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16550</x>
      <y>6720</y>
      <w>340</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>1.准备第一次(没对齐)要清的bit(bits_to_clear)和mask(mask_to_clear)
2.循环清除bit，直到本次清完还有剩余(尾端没对齐的情况，3进行处理)
	1.清除bit
		*p &amp;= ~mask_to_clear;
		len -= bits_to_clear;
	2.更新下次要清楚的长度和mask
		bits_to_clear = BITS_PER_LONG;
		mask_to_clear = ~0UL;
		p++;
3.如果还有没对齐的没请
	1.BITMAP_LAST_WORD_MASK更新尾端的mask，并清除
		*p &amp;= ~mask_to_clear
	注：这个size是end=start+len
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16960</x>
      <y>6550</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16700</x>
      <y>6550</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16690</x>
      <y>6630</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16690</x>
      <y>6690</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16940</x>
      <y>6490</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16700</x>
      <y>6490</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16780</x>
      <y>6400</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16770</x>
      <y>6340</y>
      <w>40</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18170</x>
      <y>5540</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>release_cluster
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17090</x>
      <y>5400</y>
      <w>1150</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1130.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18110</x>
      <y>5600</y>
      <w>350</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.如果循环次数超过了LOOP_NO_EMPTY_SIZE
	并且used_block_group和遍历的block_group不同
	1.btrfs_release_block_group将used_block_group释放
	2.跳到unclustered_alloc，不用cluster申请extend
2.btrfs_return_cluster_to_free_space将last_ptr中所有的free_space
	释放给last_ptr.block_group
3.如果used_block_group和遍历的block_group不同，
	1.通过btrfs_release_block_group将其释放
	2.refill_cluster：
		1.如果loop次数超过了限制，不从cluster中申请，跳到unclustered_alloc
4.btrfs_find_space_cluster在block_group中为last_ptr申请要求的free_space
5.如果成功返回0
	1.btrfs_alloc_from_cluster从cluster中申请extend，如果成功，跳到checks
6.如果block_group没有cached，并且loop次数超过限制，failed_cluster_refill没置上
	1.failed_cluster_refill = true
	2.wait_block_group_cache_progress等待block_group cached完成，并且其空间超过要求
	3.跳到have_block_group
7.如果继续失败，btrfs_return_cluster_to_free_space将free_space归还给block_group
8.跳到loop
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18240</x>
      <y>5570</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17740</x>
      <y>5890</y>
      <w>240</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_return_cluster_to_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17860</x>
      <y>5840</y>
      <w>350</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17810</x>
      <y>5920</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17710</x>
      <y>5960</y>
      <w>330</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.block_group要是cluster-&gt;block_group，否则返回0
2.递增block_group.count
3.__btrfs_return_cluster_to_free_space
4.btrfs_put_block_group释放block_group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17760</x>
      <y>6070</y>
      <w>260</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_return_cluster_to_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17870</x>
      <y>6030</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17870</x>
      <y>6100</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17710</x>
      <y>6140</y>
      <w>390</w>
      <h>230</h>
    </coordinates>
    <panel_attributes>1.如果不是cluster-&gt;block_group，跳到out
2.重置cluster
	cluster-&gt;block_group = NULL;
	cluster-&gt;window_start = 0;
	list_del_init(&amp;cluster-&gt;block_group_list);
3.以链表的方式遍历cluster-&gt;root
	1.首先将entry从红黑树中删除
	2.如果entry没有bitmap
		1.try_merge_free_space将左右紧挨着的free_space合并
		2.steal_from_bitmap从bitmap中合并紧挨着的free_space
	3.将entry插入block_group.free_space_ctl.free_space_offset
4.清空cluster-&gt;root
5.btrfs_put_block_group释放block_group后，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17540</x>
      <y>6390</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>try_merge_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17440</x>
      <y>6460</y>
      <w>450</w>
      <h>260</h>
    </coordinates>
    <panel_attributes>1.通过tree_search_offset查看红黑树中右边是否有何其重合的right_info
2.如果找到了right_info，并且其rb_prev存在
	left_info=rb_entry
	否则通过tree_search_offset查找于entry左边界(offset-1)相重合的left_info
3.如果right_info存在，并且其bitmap不存在
	1.如果update_stat置上，需要通过unlink_free_space释放right_info
		否则直接通过__unlink_free_space释放right_info
		info-&gt;bytes += right_info-&gt;bytes
	2.释放right_info
		merged = true
4.如果left_info存在，并且其bitmap不存在,并且其left_info紧挨着entry
	1.如果update_stat置上，需要通过unlink_free_space释放left_info
		否则直接通过__unlink_free_space释放left_info
		info-&gt;offset = left_info-&gt;offset;
		info-&gt;bytes += left_info-&gt;bytes
	2.释放left_info
		merged = true
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17480</x>
      <y>6760</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tree_search_offset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17530</x>
      <y>6710</y>
      <w>40</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17430</x>
      <y>6830</y>
      <w>320</w>
      <h>530</h>
    </coordinates>
    <panel_attributes>1.在红黑树free_space_offset中查找offset
2.如果bitmap_only
	1.如果没找到entry，返回NULL
	2.如果entry的bitmap存在，直接返回entry
	3.查找其链表的下一个rb_next，
		1.如果offset不同，表示这个offset没有bitmap类型，返回NULL
		2.否则将rb_next返回
3.如果不是bitmap_only,并且entry找到了
	1.如果entry的bitmap要存在
		1.如果rb_prev的bitmap不存在，并且prev覆盖了offset，
			优先将没有bitmap的prev返回
	2.返回entry
4.如果红黑树是空，返回NULL
5.否则
	1.如果offset在entry的左边
		1.如果rb_prev存在，entry置换成prev
		2.如果不存在，在fuzzy置上，返回entry，否则返回NULL
	2.此时offset在entry的右边
		1.如果entry.bitmap存在
			1.如果rb_prev的bitmap不存在，并且其范围覆盖了offset，将其返回
			2.如果entry的bitmap返回覆盖了offset，将entry返回
		2.如果其bitmap不存在，并且其范围覆盖了offset,将其返回
		3.如果fuzzy没置上，返回NULL
	//这里entry在offset左边,并且其end&lt;offset
	3.rb_next进行循环
		1.检查entry的范围是否覆盖了offset，如果覆盖，退出循环
		注：这里可能不是真的覆盖，可能entry.offset&gt;offset
		2.rb_next进行循环
	4.返回entry	
注：1.如果fuzzy没置上，如果entry范围覆盖了offset即返回，否则返回NULL
		如果fuzzy置上，只能说明offset&lt;entry.end
	2.bitmap_only置上，表示必须offset相同，并且bitmap存在的entry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17530</x>
      <y>6790</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17790</x>
      <y>6760</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>unlink_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17830</x>
      <y>6710</y>
      <w>40</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17850</x>
      <y>6790</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17770</x>
      <y>6830</y>
      <w>240</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.通过__unlink_free_space释放info
2.ctl-&gt;free_space -= info-&gt;bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17850</x>
      <y>6900</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__unlink_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17920</x>
      <y>6860</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17820</x>
      <y>6970</y>
      <w>180</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.将info从红黑树中删除
2.ctl-&gt;free_extents--
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17930</x>
      <y>6930</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18120</x>
      <y>6380</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>steal_from_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18040</x>
      <y>6450</y>
      <w>330</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.ctl存在bitmap(ctl.total_bitmaps)
	1.steal_from_bitmap_to_end从尾端bitmap中拿一部分free_space过来
	2.如果total_bitmaps还有
		1.steal_from_bitmap_to_front从前端拿free_space
	注：如果info本来在ctl中，只是进行合并update_stat设置为false
		如果info不在ctl中，要和ctl中原有的进行合并，update_stat设置为true
	3.如果有steal过来，因为改变了info的范围，所以通过
	try_merge_free_space进行合并
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18170</x>
      <y>6410</y>
      <w>150</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
info.bitmap不能存在</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18030</x>
      <y>6620</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>steal_from_bitmap_to_end</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18110</x>
      <y>6580</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18010</x>
      <y>6690</y>
      <w>370</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.通过tree_search_offset寻找包含(end bitmap page对齐)的bitmap
2.如果没找到，返回false
3.计算info.end在bitmap中的位偏移
4.find_next_zero_bit寻找从end开始第一个0的位置
5.如果end之后的区域都被占用，返回false
6.否则递增info的free_space空间的大小
	bytes = (j - i) * ctl-&gt;unit;
	info-&gt;bytes += bytes
7.如果update_stat置上，通过bitmap_clear_bits比较bitmap中bytes的空间被占用(因为分配到info)
	否则通过__bitmap_clear_bits标记
8.如果bitmap没有剩余空间，通过free_bitmap将其释放
9.返回true
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18120</x>
      <y>6650</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18380</x>
      <y>6610</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>steal_from_bitmap_to_front</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18390</x>
      <y>6680</y>
      <w>360</w>
      <h>260</h>
    </coordinates>
    <panel_attributes>1.如果bitmap_offset(offset bitmap page对齐的位置)刚好是info.offset
	要找相对前一点的bitmap_offset
2.通过tree_search_offset寻找包含bitmap_offset的bitmap
3.遍历bitmap.bitmap,找到离info.offset最近的没被分配的prev_j
4.如果前面没有free_space，返回false
5.如果整个bitmap全是空闲的
	bytes = (i + 1) * ctl-&gt;unit
	否则，空闲空间为
	bytes = (i - prev_j) * ctl-&gt;unit
6.扩充info前端
	info-&gt;offset -= bytes;
	info-&gt;bytes += bytes;
7.如果update_stat置上，通过bitmap_clear_bits将bitmap移动的free_space清掉
	否则通过__bitmap_clear_bits清
8.如果bitmap的free_space被清空，通过free_bitmap将其释放
9.返回true
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18490</x>
      <y>6640</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18320</x>
      <y>6580</y>
      <w>150</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17630</x>
      <y>6420</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17610</x>
      <y>6360</y>
      <w>200</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18070</x>
      <y>6360</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18810</x>
      <y>5890</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_find_space_cluster</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18400</x>
      <y>5840</y>
      <w>490</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18760</x>
      <y>5960</y>
      <w>410</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.设置cont1_bytes和min_bytes
2.如果block_group的free_space不够，返回ENOSPC
3.如果cluster.block_group还存在，返回0
4.setup_cluster_no_bitmap首先查找block_group中没有bitmap的
	free_space，并加入cluster中
5.如果没bitmap的，没有足够的空间，通过setup_cluster_bitmap查找不带bitmap的
注：setup_cluster_no_bitmap添加的free_space可能是不连续的entry，
	setup_cluster_bitmap只添加一个entry
6.遍历bitmaps链表，将其全部删除
7.如果成功返回0
	1.递增block_group-&gt;count
	2.将cluster-&gt;block_group_list加入block_group.cluster_list尾端
	3.cluster-&gt;block_group = block_group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18910</x>
      <y>5920</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18680</x>
      <y>6200</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>setup_cluster_no_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18780</x>
      <y>6170</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18610</x>
      <y>6260</y>
      <w>350</w>
      <h>390</h>
    </coordinates>
    <panel_attributes>1.通过tree_search_offset模糊搜寻offset，如果没搜到
2.不要bitmap，空间不能小于min_bytes，否则一直循环
	1.如果bitmap存在，并且entry.list没加入链表，通过
		list_add_tail将entry加入bitmaps链表
	2.遍历rb_next
3.继续遍历rb_next，找到符合条件的entry窗口
	1.如果存在bitmap，并且其没被加入到链表，将其加入bitmaps，并继续下一个循环
	2.如果entry空间不足，继续下一个循环
	3.记录last，并调整窗口
		last = entry;
		window_free += entry-&gt;bytes
	4.更新窗口的max_extent
4.如果窗口大小window_free小于要申请的内存，或者
	最大的max_extent低于cont1_bytes(这个要在一个extend中),返回ENOSPC
5.更新cluster
	1.cluster-&gt;window_start = first-&gt;offset
	2.循环将first~last从红黑树block_group中移除，并且加到cluster中
		1.检查bitmap不能存在，空间要大于min_bytes
		2.将entry从红黑树中删除
		3.tree_insert_offset将entry插入红黑树cluster-&gt;root中
			total_size += entry-&gt;bytes
		4.遍历rb_next
	3.cluster-&gt;max_size = max_extent
6.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18750</x>
      <y>6230</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19050</x>
      <y>6210</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>setup_cluster_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19000</x>
      <y>6270</y>
      <w>370</w>
      <h>180</h>
    </coordinates>
    <panel_attributes>1.如果block_group不存在bitmap，返回ENOSPC
2.如果bitmaps不为空，将entry赋值为其第一个node
3.如果entry不存在，或者其offset没和bitmap对齐
	1.tree_search_offset找到和offset对齐的带有bitmap的entry
	2.如果其没加入链表，将其头插至bitmaps
4.遍历bitmaps
	1.如果entry空间小于bytes，继续下一个
	2.btrfs_bitmap_cluster查看entry内的空间是否满足最后三个传参的要求
	3.如果成功，返回0，否则继续循环
5.返回ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19130</x>
      <y>6480</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_bitmap_cluster</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19030</x>
      <y>6540</y>
      <w>420</w>
      <h>380</h>
    </coordinates>
    <panel_attributes>1.如果entry.max_extent_size低于cont1_bytes，返回ENOSPC
2.again:
	1.从offset所在的bit遍历entry-&gt;bitmap
		1.find_next_zero_bit找到从i之后首个标记为0的位置
		2.如果其大小超过了min_bits
			1.更新found_bits，max_bits，并退出循环
		3.否则更新max_bits
		4.然后从next_zero+1开始遍历
	注：entry的连续free_space大小至少要大于min_bits
	2.如果没找到足够的空间容纳min_bits，返回ENOSPC
		entry-&gt;max_extent_size = (u64)max_bits * ctl-&gt;unit
	3.如果之前没记录total_found
		start = i;
		cluster-&gt;max_size = 0;
	4.total_found += found_bits
	5.更新cluster-&gt;max_size
	注：这个max_size不一定是entry的最大连续空间，只要满足2.1.2和2.6的要求即可
	6.如果total_found低于要求的空间，或者目前最大的连续空间max_size低于cont1_bytes
		从next_zero + 1，跳到again继续查找
3.更新cluster
	cluster-&gt;window_start = start * ctl-&gt;unit + entry-&gt;offset
4.将entry从block_group中删除，并通过tree_insert_offset插入cluster-&gt;root中
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19190</x>
      <y>6510</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19200</x>
      <y>6440</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19120</x>
      <y>6240</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19100</x>
      <y>6170</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19200</x>
      <y>5450</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>unclustered_alloc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19240</x>
      <y>5480</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19140</x>
      <y>5520</y>
      <w>350</w>
      <h>190</h>
    </coordinates>
    <panel_attributes>1.如果是从cluster中申请失败
	last_ptr-&gt;fragmented = 1;
2.如果block_group被cached，但是空间不足，查看是否
	要更新max_extent_size，然后跳到loop
3.btrfs_find_space_for_alloc在block_group中寻找free_space
4.如果没申请到(!offset),并且之前没有failed_alloc，block_group没被cached
	循环次数超过限制
	1.wait_block_group_cache_progress等待block_group cached对应的size
	2.failed_alloc = true
	3.跳到have_block_group
5.如果仅是申请失败，跳到loop遍历下一个block_group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19240</x>
      <y>5750</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_find_space_for_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19310</x>
      <y>5700</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19320</x>
      <y>5780</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19210</x>
      <y>5810</y>
      <w>380</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.find_free_space查找block_group中空间充足的entry(更新了offset和bytes_search)
2.如果entry有bitmap，通过bitmap_clear_bits将bit清掉，表示空间被占用，如果没剩余空间，free_bitmap将其释放
3.否则
	1.unlink_free_space将entry从红黑树中删除
	2.因为被占用，所以更新entry的offset和size
		entry-&gt;offset = offset + bytes;//这里的offset是对齐的
		entry-&gt;bytes -= bytes + align_gap_len
	3.如果entry没空间，将其释放，否则通过link_free_space重新加入红黑树
4.如果对齐过，将对齐没被申请的空间通过__btrfs_add_free_space加入红黑树
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19460</x>
      <y>6000</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19400</x>
      <y>6070</y>
      <w>340</w>
      <h>290</h>
    </coordinates>
    <panel_attributes>1.如果红黑树free_space_offset中没有free_space，返回NULL
2.tree_search_offset模糊查找bitmap对齐的offset，如果没找到entry，返回NULL
3.从entry开始以链表遍历红黑树
	1.如果entry空间不足，更新max_extent_size，并继续下一个循环
	2.申请空间要对齐，align_off是相对于entry.offset的位置，tmp是其对齐后的offset
		1.如果申请空间超过了align，需要对齐，否则不用对齐
	3.如果对齐后需要的空间超过了entry.bytes，更新max_extent_size，并继续下一个循环
	4.如果存在bitmap
		1.search_bitmap在bitmap找查找相应size的free_space
		2.如果成功，更新找到的offset和size，并返回entry
			*offset = tmp;
			*bytes = size;
		3.否则更新max_extent_size
		4.继续下一个循环
	5.否则，直接更新offset和size，并返回entry
		*offset = tmp;
		*bytes = entry-&gt;bytes - align_off
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19510</x>
      <y>6030</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19500</x>
      <y>5960</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19840</x>
      <y>5990</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_add_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19550</x>
      <y>5960</y>
      <w>390</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19750</x>
      <y>6060</y>
      <w>400</w>
      <h>170</h>
    </coordinates>
    <panel_attributes>1.申请free_space info
	info-&gt;offset = offset;
	info-&gt;bytes = bytes;
2.try_merge_free_space将info左右两端进行合并，如果合并成功，跳到link
3.否则，通过insert_into_bitmap将ctl(或者对应的private的cluster)中的bitmap释放
4.如果失败，直接返回，如果成功，返回0
5.link
	1.steal_from_bitmap进行bitmap的合并
	2.link_free_space将info加入到ctl中
	3.如果失败，释放info
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19930</x>
      <y>6020</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19820</x>
      <y>6260</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>insert_into_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19870</x>
      <y>6220</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19750</x>
      <y>6330</y>
      <w>430</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.ctl-&gt;op-&gt;use_bitmap
2.如果ctl-&gt;op指向free_space_op
	block_group = ctl-&gt;private
3.again
	1.如果block_group存在，并且其cluster_list链表上有cluster
		1.找到第一个cluster
		2.找到红黑树cluster-&gt;root的rb_first
		3.如果这个entry没有bitmap，跳到no_cluster_bitmap
		4.如果info和entry的bitmap offset相同
			1.通过add_bytes_to_bitmap置上相应的bytes
			2.更新info中没被释放的空间
				bytes -= bytes_added;
				offset += bytes_added;
		5.如果info都被释放，跳到out，返回1
4.no_cluster_bitmap：
	1.tree_search_offset搜寻offset对应的bitmap，如果没有跳到new_bitmap
	2.通过add_bytes_to_bitmap将info的空间加入bitmap
	3.更新没被释放的info空间
		bytes -= bytes_added;
		offset += bytes_added;
	4.如果info被完全释放，跳到out，返回1
	5.否则跳到again，重新搜寻bitmap
5.new_bitmap
	1.如果info.bitmap存在
		1.add_new_bitmap将info的free_space清空，加入到ctl中
		2.info置NULL,并跳到again
	2.否则
		1.如果info不存在，申请
		2.申请info-&gt;bitmap
		3.跳到again
6.out
	1.释放info，bitmap
	2.返回ret
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19860</x>
      <y>6290</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19690</x>
      <y>6610</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>add_bytes_to_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19760</x>
      <y>6570</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19610</x>
      <y>6680</y>
      <w>290</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.需要被bytes_to_set不能超过bitmap的end
2.bitmap_set_bits将offset~offset+bytes_to_set置上
3.info-&gt;max_extent_size = 0
4.返回被set的bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19760</x>
      <y>6640</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19940</x>
      <y>6610</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>add_new_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19990</x>
      <y>6570</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19910</x>
      <y>6680</y>
      <w>270</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.更新info(空间全部被占用)
	info-&gt;offset = offset_to_bitmap(ctl, offset);
	info-&gt;bytes = 0;
	INIT_LIST_HEAD(&amp;info-&gt;list);
2.link_free_space加入到ctl
	ctl-&gt;total_bitmaps++
3.ctl-&gt;op-&gt;recalc_thresholds
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19980</x>
      <y>6640</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19900</x>
      <y>5440</y>
      <w>100</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>checks
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19780</x>
      <y>5500</y>
      <w>410</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.如果offset在stripesize对齐后，其空间超过了block_group的空间
	1.btrfs_add_free_space将free_space归还
	2.跳到loop,继续下一个循环
2.将对其后不用的空间，通过btrfs_add_free_space释放给block_group
3.btrfs_update_reserved_bytes更新block_group和space_info的reserved
4.如果失败，btrfs_add_free_space释放free_space给block_group，并跳到loop，继续下一个循环
5.更新返回变量
	ins-&gt;objectid = search_start;
	ins-&gt;offset = num_bytes;
6.btrfs_release_block_group释放block_group，并退出循环
7.loop
	1.重置变量
		failed_cluster_refill = false;
		failed_alloc = false;
	2.btrfs_release_block_group释放block_group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20080</x>
      <y>5760</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_update_reserved_bytes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20140</x>
      <y>5710</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19940</x>
      <y>5470</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20160</x>
      <y>5830</y>
      <w>370</w>
      <h>300</h>
    </coordinates>
    <panel_attributes>1.如果不是RESERVE_FREE
	1.如果block_group是read_only,返回EAGAIN
	2.否则
		1.更新reserved
			cache-&gt;reserved += num_bytes;
			space_info-&gt;bytes_reserved += num_bytes;
		2.如果是RESERVE_ALLOC
			1.space_info-&gt;bytes_may_use -= num_bytes
		3.如果delalloc置上
			cache-&gt;delalloc_bytes += num_bytes
2.如果是RESERVE_FREE
	1.如果是read_only
		space_info-&gt;bytes_readonly += num_bytes
	2.更新reserved
		cache-&gt;reserved -= num_bytes;
		space_info-&gt;bytes_reserved -= num_bytes;
	3.如果delalloc置上
		cache-&gt;delalloc_bytes -= num_bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20210</x>
      <y>5790</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20720</x>
      <y>5390</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_join_transaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20600</x>
      <y>5520</y>
      <w>380</w>
      <h>700</h>
    </coordinates>
    <panel_attributes>1.如果fs_info的STATE_ERROR置上，报EROFS
2.如果current-&gt;journal_info存在
	1.更新journal_info
		h = current-&gt;journal_info;
		h-&gt;use_count++;
		h-&gt;orig_rsv = h-&gt;block_rsv;
		h-&gt;block_rsv = NULL;
	2.跳到got_it
3.如果存在num_items，并且root不是chunk_root
	1.btrfs_qgroup_reserve_meta更新reserved
	2.btrfs_calc_trans_metadata_size更新items需要的meta空间
	3.如果need_reserve_reloc_root
		1.num_bytes += root-&gt;nodesize;
			reloc_reserved = true;
	4.btrfs_block_rsv_add增加fs_info-&gt;trans_block_rsv
4.again
	1.申请trans_handle
	2.如果__TRANS_FREEZABLE置上，sb_start_intwrite申请信号量
	3.may_wait_transaction查看是否需要等待，如果需要，通过
		wait_current_trans等待
	4.循环使用join_transaction，如果期间返回EBUSY，通过wait_current_trans
		等待，但是type是TRANS_ATTACH，返回ENOENT
	5.获取join的cur_trans
		1.h-&gt;transid = cur_trans-&gt;transid;
			h-&gt;transaction = cur_trans;
			h-&gt;root = root;
			h-&gt;use_count = 1;
			h-&gt;type = type;
			h-&gt;can_flush_pending_bgs = true;
			INIT_LIST_HEAD(&amp;h-&gt;qgroup_ref_list);
			INIT_LIST_HEAD(&amp;h-&gt;new_bgs);
	6.如果状态在TRANS_STATE_BLOCKED之前，并且may_wait_transaction检查需要等待
		1.current-&gt;journal_info = h
		2.btrfs_commit_transaction提交h
		3.跳到again
	7.如果有reserved，
		h-&gt;block_rsv = &amp;root-&gt;fs_info-&gt;trans_block_rsv;
		h-&gt;bytes_reserved = num_bytes;
		h-&gt;reloc_reserved = reloc_reserved
5.got_it
	1.btrfs_record_root_in_trans
	2.如果不是在TRANS_USERSPACE，更新
		current-&gt;journal_info = h
	3.返回h
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20800</x>
      <y>5490</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20300</x>
      <y>6260</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_qgroup_reserve_meta</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20360</x>
      <y>6210</y>
      <w>330</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20370</x>
      <y>6290</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20240</x>
      <y>6320</y>
      <w>330</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.如果fs_info.quota_enabled没打开，或者不是is_fstree
	或者num_bytes为0，返回0
2.qgroup_reserve设置fs_info-&gt;qgroup_ulist链表中所有qgroup.reserved
3.root-&gt;qgroup_meta_rsv +=num_bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20300</x>
      <y>6430</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>is_fstree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20350</x>
      <y>6390</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20230</x>
      <y>6500</y>
      <w>330</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>1.如果是BTRFS_FS_TREE_OBJECTID
	或者在BTRFS_FIRST_FREE_OBJECTID范围内并且btrfs_qgroup_level存在
	返回1
2.否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20350</x>
      <y>6460</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20600</x>
      <y>6430</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>qgroup_reserve</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20580</x>
      <y>6500</y>
      <w>340</w>
      <h>270</h>
    </coordinates>
    <panel_attributes>1.不是is_fstree，或者没有num_bytes，返回0
2.如果没有fs_info-&gt;quota_root，返回0
3.find_qgroup_rb在root-&gt;root_key.objectid寻找qgroup
4.ulist_add将qgroup设置为相应node加入fs_info-&gt;qgroup_ulist的
	红黑树和链表中
5.遍历fs_info-&gt;qgroup_ulist.nodes链表
	1.获取node的qgroup
	2.如果LIMIT_MAX_RFER置上，并且其所要的空间(reserved+rfer+num_bytes)
		超过了max_rfer，返回EDQUOT
	3.如果LIMIT_MAX_EXCL置上，其空间(reserved+excl+num_bytes)超过了max_excl
		返回EDQUOT
	4.遍历qgroup所在的qgroup_list(groups),将glist-&gt;group添加到fs_info-&gt;qgroup_ulist中
	5.如果出错，直接返回
6.返回0
7.再次遍历fs_info-&gt;qgroup_ulist，给其中的每个qgroup
	qg-&gt;reserved += num_bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20650</x>
      <y>6460</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20570</x>
      <y>6800</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_qgroup_rb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20610</x>
      <y>6760</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20430</x>
      <y>6870</y>
      <w>360</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.遍历红黑树fs_info-&gt;qgroup_tree(按照qgroupid)
	找到对应的qgroupid
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20610</x>
      <y>6830</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20510</x>
      <y>6390</y>
      <w>150</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20730</x>
      <y>6280</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>need_reserve_reloc_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20720</x>
      <y>6350</y>
      <w>280</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.如果fs_info-&gt;reloc_ctl不能存在
	或者BTRFS_ROOT_REF_COWS没置上
	或者是BTRFS_TREE_RELOC_OBJECTID
	或者reloc_root存在
	返回false
2.否则返回true
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20810</x>
      <y>6310</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20810</x>
      <y>6210</y>
      <w>140</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21100</x>
      <y>6280</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_block_rsv_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21080</x>
      <y>6350</y>
      <w>220</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>1.如果不存在num_bytes，返回0
2.reserve_metadata_bytes
3.block_rsv_add_bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21180</x>
      <y>6310</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21280</x>
      <y>6450</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>block_rsv_add_bytes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21290</x>
      <y>6410</y>
      <w>80</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21270</x>
      <y>6520</y>
      <w>280</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.block_rsv-&gt;reserved += num_bytes
2.如果update_size置上
	block_rsv-&gt;size += num_bytes
3.update_size没置上，reserved超过了size
	block_rsv-&gt;full = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21380</x>
      <y>6480</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21040</x>
      <y>6450</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>reserve_metadata_bytes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21110</x>
      <y>6410</y>
      <w>90</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20940</x>
      <y>6210</y>
      <w>250</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20750</x>
      <y>5460</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>start_transaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20790</x>
      <y>5420</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20940</x>
      <y>6520</y>
      <w>320</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>1.如果要求BTRFS_RESERVE_FLUSH_ALL，但是不是本进程flush，但是其他进程在flush(space_info-&gt;flush)
	1.如果有journal_info，返回EAGAIN
	2.wait_event_killable等待space_info-&gt;flush被清掉
2.综合space_info被used的空间
3.如果还有剩余空间
	1.如果space_info还存在orig_bytes空间
		space_info-&gt;bytes_may_use += orig_bytes;
		ret=0
	2.否则
		num_bytes = orig_bytes;
4.如果空间不足
	num_bytes = used - space_info-&gt;total_bytes +
			(orig_bytes * 2);
5.如果空间不足，can_overcommit看是否能overcommit
	space_info-&gt;bytes_may_use += orig_bytes
	ret = 0
6.如果空间不足，并且不是BTRFS_RESERVE_NO_FLUSH，本进程要进行flush
	flushing = true;
	space_info-&gt;flush = 1
7.如果空间充足，并且是BTRFS_BLOCK_GROUP_METADATA
	1.used += orig_bytes
	2.如果没有log_root_recovering，并且need_do_async_reclaim，但是没有work_busy
		调度system_unbound_wq
8.如果空间充足，或者不用flush(BTRFS_RESERVE_NO_FLUSH)，跳到out
9.根据flush_state，通过flush_space进行flush
	flush_state++
10.如果是BTRFS_RESERVE_FLUSH_LIMIT，并且
	FLUSH_DELALLOC或者FLUSH_DELALLOC_WAIT
		flush_state = ALLOC_CHUNK
11.如果flush成功，跳到1
12.如果没成功，
	1.是BTRFS_RESERVE_FLUSH_LIMIT，或者BTRFS_RESERVE_FLUSH_ALL
		但是没有COMMIT_TRANS，跳到1
13.out:
	1.如果是ENOSPC，并且ORPHAN_CLEANUP_STARTED
		1.如果不是global_block_rsv，通过block_rsv_use_bytes
			递减block_rsv-&gt;reserved，如果能清掉block_rsv-&gt;full，返回0
	2.如果进程flushing，清除space_info-&gt;flush，并唤醒space_info-&gt;wait
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21100</x>
      <y>6480</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20890</x>
      <y>6840</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>can_overcommit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20800</x>
      <y>6910</y>
      <w>350</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.calc_global_rsv_need_space计算需要保留的空间(global_block_rsv&lt;&lt;1)
2.如果used+space_size超过了total_bytes，返回0
3.调整可控分配的free_chunk_space
	1.如果是DUP RAID1 RAID10,减小一半
	2.如果是BTRFS_RESERVE_FLUSH_ALL，减小到1/8
	3.否则减小一半
4.如果空间低于total_bytes + avail，返回1
5.否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20930</x>
      <y>6870</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20940</x>
      <y>6790</y>
      <w>40</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21580</x>
      <y>6270</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>may_wait_transaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20950</x>
      <y>6210</y>
      <w>730</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;710.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21510</x>
      <y>6340</y>
      <w>310</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.如果log_root_recovering置上，返回0，不用等待
2.等待条件(返回1)
	1.TRANS_USERSPACE
	2.TRANS_START，并且open_ioctl_trans为0
3.其他情况，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21640</x>
      <y>6300</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21900</x>
      <y>6260</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>wait_current_trans</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21840</x>
      <y>6330</y>
      <w>330</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.is_transaction_blocked检查running_transaction是否需要blocked
	如果需要
	1.递增cur_trans-&gt;use_count
	2.等待cur_trans-&gt;state或者cur_trans-&gt;aborted
	3.醒来之后释放use_count
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21970</x>
      <y>6290</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22250</x>
      <y>6260</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>join_transaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22200</x>
      <y>6330</y>
      <w>420</w>
      <h>380</h>
    </coordinates>
    <panel_attributes>1.如果fs_state的BTRFS_FS_STATE_ERROR置上返回EROFS
2.如果存在running_transaction
	1.如果存在aborted，返回aborted
	2.如果type满足state条件下的btrfs_blocked_trans_types，返回EBUSY
	3.递增use_count，num_writers，num_extwriters(TRANS_EXTWRITERS)
	4.返回0
3.如果type是TRANS_ATTACH，返回ENOENT
4.申请cur_trans，并初始化
	1.设置num_writers，num_extwriters
	2.初始化writer_wait，commit_wait，pending_wait
	3.cur_trans-&gt;state = TRANS_STATE_RUNNING
	4.设置use_count(2),pending_ordered(0),flags,start_time
	5.初始化delayed_refs
	6.初始化pending_snapshots，pending_chunks，switch_commits，dirty_bgs
		io_bgs，dropped_roots，cache_write_mutex
	7.设置dirty_bgs_lock，deleted_bgs，dropped_roots_lock，deleted_bgs，dropped_roots_lock
		cur_trans-&gt;num_dirty_bgs = 0;
	8.将其加入链表fs_info-&gt;trans_list
	9.初始化io_tree dirty_pages
	10.fs_info-&gt;generation++;
		cur_trans-&gt;transid = fs_info-&gt;generation;
		fs_info-&gt;running_transaction = cur_trans;
		cur_trans-&gt;aborted = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22300</x>
      <y>6290</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22810</x>
      <y>6260</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_commit_transaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22640</x>
      <y>6330</y>
      <w>440</w>
      <h>630</h>
    </coordinates>
    <panel_attributes>1.如果cur_trans-&gt;aborted，btrfs_end_transaction，并返回
2.btrfs_run_delayed_refs处理transaction-&gt;delayed_refs上的所有delayed_ref
3.btrfs_trans_release_metadata释放trans-&gt;bytes_reserved给trans-&gt;block_rsv
	trans-&gt;block_rsv = NULL
4.cur_trans-&gt;delayed_refs.flushing = 1
	1.如果trans-&gt;new_bgs不为空，btrfs_create_pending_block_groups创建extent_root中创建block_group
	2.btrfs_run_delayed_refs更新extent_ref
	3.如果BTRFS_TRANS_DIRTY_BG_RUN没置上
		1.将BTRFS_TRANS_DIRTY_BG_RUN置上
		2.btrfs_start_dirty_block_groups刷新cur_trans-&gt;dirty_bgs上的block_group
	4.如果cur_trans.state超过了TRANS_STATE_COMMIT_START
		1.btrfs_end_transaction
		2.wait_for_commit等待commit完成
		3.btrfs_put_transaction释放cur_trans
	5.cur_trans-&gt;state = TRANS_STATE_COMMIT_START
	6.唤醒fs_info-&gt;transaction_blocked_wait
	7. 在fs_info-&gt;trans_list上，cur_trans的prev_trans状态如果没有TRANS_STATE_COMPLETED
		1.递增prev_trans-&gt;use_count
		2.等待prev_trans TRANS_STATE_COMPLETED
		3.btrfs_put_transaction释放prev_trans
	8.extwriter_counter_dec根据type递减cur_trans.num_extwriters
	9.btrfs_start_delalloc_flush刷写所有的fs_info-&gt;delalloc_roots
	10.btrfs_run_delayed_items将fs_info-&gt;delayed_root上被delayed增删的item
		映射到磁盘上
	11.等待cur_trans.num_extwriters=0
	12.btrfs_run_delayed_items将fs_info-&gt;delayed_root上被delayed增删的item
		映射到磁盘上
	13.btrfs_wait_delalloc_flush等待fs_info-&gt;ordered_roots刷写完成
	14.btrfs_wait_pending_ordered等待cur_trans-&gt;pending_ordered为0
	15.btrfs_scrub_pause等待scrubs_paused和scrubs_running相同
	16.cur_trans-&gt;state = TRANS_STATE_COMMIT_DOING,等待
		cur_trans.num_writers变为1
	17.如果发现cur_trans-&gt;aborted，跳到scrub_continue
注：1.更新内存的操作
		1.delayed_ref delayed_item 
	这里写磁盘的操作有：
	1.cur_trans-&gt;dirty_bgs的inode item信息
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22870</x>
      <y>6290</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24780</x>
      <y>6220</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_record_root_in_trans</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24700</x>
      <y>6290</y>
      <w>400</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.如果root.state的BTRFS_ROOT_REF_COWS没置上，返回0
2.如果last_trans和当前trans相同，并且BTRFS_ROOT_IN_TRANS_SETUP没置上
	(置上表示正在被recorde)，返回0
3.record_root_in_trans
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24830</x>
      <y>6410</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>record_root_in_trans</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24730</x>
      <y>6480</y>
      <w>400</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.如果BTRFS_ROOT_REF_COWS置上，last_trans小于当前trans
	1.将root.state的BTRFS_ROOT_IN_TRANS_SETUP置上
	2.radix_tree_tag_set在radix数的路径中设置BTRFS_ROOT_TRANS_TAG
	3.root-&gt;last_trans = trans-&gt;transid
	4.btrfs_init_reloc_root
	5.清掉BTRFS_ROOT_IN_TRANS_SETUP
2.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24850</x>
      <y>6630</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_init_reloc_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24880</x>
      <y>6250</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24900</x>
      <y>6370</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24900</x>
      <y>6440</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24920</x>
      <y>6590</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24730</x>
      <y>6700</y>
      <w>440</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.如果存在root.reloc_root,更新trans，并返回0
	reloc_root-&gt;last_trans = trans-&gt;transid
2.如果fs_info-&gt;reloc_ctl.create_reloc_tree不存在
	或者root是BTRFS_TREE_RELOC_OBJECTID，返回0
3.如果trans不用reloc_reserved，使用rc-&gt;block_rsv进行4
4.create_reloc_root创建root.reloc_root
5.__add_reloc_root添加指向reloc_root的mapping_node到红黑树reloc_root_tree中
6.root-&gt;reloc_root = reloc_root
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24930</x>
      <y>6660</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24630</x>
      <y>6860</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>create_reloc_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24670</x>
      <y>6830</y>
      <w>120</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24530</x>
      <y>6930</y>
      <w>340</w>
      <h>360</h>
    </coordinates>
    <panel_attributes>1.申请root_item
2.如果objectid指向的是root
	1.btrfs_copy_root在BTRFS_TREE_RELOC_OBJECTID中复制一份root的eb
	2.设置root_item.last_snapshot=trans-&gt;transid - 1
3.否则直接通过btrfs_copy_root在BTRFS_TREE_RELOC_OBJECTID中指向root-&gt;node的eb
4.复制root_item，并更新
	1.root_item.bytenr=eb.start
	3.root_item.level=eb.btrfs_header.level
	3.root_item.gen=trans-&gt;transid
	4.如果root是要复制的objectid
		1.清空root_item.drop_progress
			root_item-&gt;drop_level = 0
		2.root_item.rtransid=last_snap
		3.root_item.otransid=trans-&gt;transid
5.free_extent_buffer释放对eb的索引
6.btrfs_insert_root插入reloc_root
	root_key.objectid = BTRFS_TREE_RELOC_OBJECTID;
	root_key.type = BTRFS_ROOT_ITEM_KEY;
	root_key.offset = objectid;
7.btrfs_read_fs_root再创建并读取reloc_root
	reloc_root-&gt;last_trans = trans-&gt;transid
8.返回reloc_root
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24670</x>
      <y>6890</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17110</x>
      <y>5400</y>
      <w>2170</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17110</x>
      <y>5400</y>
      <w>2850</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2830.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17110</x>
      <y>5380</y>
      <w>3700</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;30.0;3680.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20950</x>
      <y>6210</y>
      <w>1040</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1020.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20960</x>
      <y>6210</y>
      <w>1360</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1340.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20950</x>
      <y>6210</y>
      <w>1970</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1950.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20950</x>
      <y>6210</y>
      <w>3910</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3890.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15080</x>
      <y>4730</y>
      <w>2350</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2330.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17340</x>
      <y>4760</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_add_delayed_tree_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17260</x>
      <y>4830</y>
      <w>390</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.申请delayed_tree_ref，head_ref
	如果quota_enabled并且ref_root是is_fstree，申请record
	head_ref-&gt;extent_op = extent_op
2.add_delayed_ref_head将head_ref插入trans-&gt;transaction-&gt;delayed_refs
3.add_delayed_tree_ref插入ref插入head_ref
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17430</x>
      <y>4790</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17220</x>
      <y>4950</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>add_delayed_ref_head</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17170</x>
      <y>5020</y>
      <w>370</w>
      <h>310</h>
    </coordinates>
    <panel_attributes>1.根据action设置count_mod和must_insert_reserved
2.设置ref和其container head_ref
	ref-&gt;bytenr = bytenr;
	ref-&gt;num_bytes = num_bytes;
	ref-&gt;ref_mod = count_mod;
	ref-&gt;type  = 0;
	ref-&gt;action  = 0;
	ref-&gt;is_head = 1;
	ref-&gt;in_tree = 1;
	ref-&gt;seq = 0;
	head_ref = btrfs_delayed_node_to_head(ref);
	head_ref-&gt;must_insert_reserved = must_insert_reserved;
	head_ref-&gt;is_data = is_data;
	INIT_LIST_HEAD(&amp;head_ref-&gt;ref_list);
	head_ref-&gt;processing = 0;
	head_ref-&gt;total_ref_mod = count_mod;
	head_ref-&gt;qgroup_reserved = 0;
	head_ref-&gt;qgroup_ref_root = 0;
3.如果有qrecord
	1.如果有ref_root，reserved
		head_ref-&gt;qgroup_ref_root = ref_root;
		head_ref-&gt;qgroup_reserved = reserved;
	2.qrecord-&gt;bytenr = bytenr;
		qrecord-&gt;num_bytes = num_bytes;
		qrecord-&gt;old_roots = NULL;
	3.btrfs_qgroup_insert_dirty_extent将qrecord加入到红黑树dirty_extent_root中
4.htree_insert将head_ref插入到trans-&gt;transaction-&gt;delayed_refs中
5.如果head_ref之前存在
	1.通过update_existing_head_ref更新exting为ref内容，并释放head_ref
	2.head_ref = existing
6.如果正常插入
	1.如果is_data，并且count_mod小于0
		delayed_refs-&gt;pending_csums += num_bytes
	2.delayed_refs-&gt;num_heads++;
		delayed_refs-&gt;num_heads_ready++;
		atomic_inc(&amp;delayed_refs-&gt;num_entries);
		trans-&gt;delayed_ref_updates++;
7.返回head_ref
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17290</x>
      <y>4980</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17300</x>
      <y>4910</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17600</x>
      <y>4950</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>add_delayed_tree_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17560</x>
      <y>5020</y>
      <w>410</w>
      <h>290</h>
    </coordinates>
    <panel_attributes>1.action  BTRFS_ADD_DELAYED_EXTENT  --&gt;BTRFS_ADD_DELAYED_REF
2.如果是is_fstree，读取tree_mod_seq设置seq
3.设置ref和其container full_ref
	atomic_set(&amp;ref-&gt;refs, 1);
	ref-&gt;bytenr = bytenr;
	ref-&gt;num_bytes = num_bytes;
	ref-&gt;ref_mod = 1;
	ref-&gt;action = action;
	ref-&gt;is_head = 0;
	ref-&gt;in_tree = 1;
	ref-&gt;seq = seq;
	full_ref-&gt;parent = parent;
	full_ref-&gt;root = ref_root;
4.如果有parent，设置ref-&gt;type为BTRFS_SHARED_BLOCK_REF_KEY
	否则设置为BTRFS_TREE_BLOCK_REF_KEY
5.full_ref-&gt;level = level
6.add_delayed_ref_tail_merge将ref加入trans-&gt;transaction-&gt;delayed_refs中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17630</x>
      <y>4910</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17690</x>
      <y>4980</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18050</x>
      <y>5020</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>add_delayed_ref_tail_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18010</x>
      <y>5080</y>
      <w>410</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>1.如果href为空，直接跳到add_tail
2.否则取出最后一个prev
	1.如果type或者seq不一样，直接跳到add_tail
	2.如果type是BTRFS_TREE_BLOCK_REF_KEY或者BTRFS_SHARED_BLOCK_REF_KEY
		通过comp_tree_refs对比，不同跳到add_tail
	3.如果type是BTRFS_EXTENT_DATA_REF_KEY或者BTRFS_SHARED_DATA_REF_KEY
		通过comp_data_refs对比，不同跳到add_tail
	4.设置mod
		1.如果action相同，
			mod = ref-&gt;ref_mod
		2.如果exit&lt;ref
			exist-&gt;action = ref-&gt;action;
			mod = -exist-&gt;ref_mod;
			exist-&gt;ref_mod = ref-&gt;ref_mod;
		3.否则mod = -ref-&gt;ref_mod
		4.exist-&gt;ref_mod += mod
		5.如果ref_mod为0，drop_delayed_ref将href从红黑树或者链表中删除
3.add_tail
	1.将ref加入到href-&gt;ref_list链表中
	2.trans-&gt;delayed_ref_updates++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18140</x>
      <y>5050</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17960</x>
      <y>5020</y>
      <w>110</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;20.0;90.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15420</x>
      <y>4320</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>add_root_to_dirty_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15340</x>
      <y>4380</y>
      <w>430</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.如果root的BTRFS_ROOT_DIRTY置上，或者BTRFS_ROOT_TRACK_DIRTY没置上，直接返回
2.置上BTRFS_ROOT_DIRTY
	1.如果是BTRFS_EXTENT_TREE_OBJECTID，list_move_tail将root加入
		链表dirty_cowonly_roots的尾端
	2.否则list_move将其加入到dirty_cowonly_roots链表的前端
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15510</x>
      <y>4350</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15460</x>
      <y>4290</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16310</x>
      <y>4390</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>insert_ptr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16230</x>
      <y>4450</y>
      <w>380</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.如果插入的slot不是最后一个
	1.如果level不为0，tree_mod_log_eb_move记录log MOD_LOG_MOVE_KEYS
	2.memmove_extent_buffer将lower的item向后移动一个位置
2.如果level不为0，通过tree_mod_log_insert_key添加log MOD_LOG_KEY_ADD
3.btrfs_set_node_key设置第slot个item的key
4.btrfs_set_node_blockptr设置item的bytenr
5.btrfs_set_node_ptr_generation设置item generation(trans-&gt;transid)
6.lower.btrfs_header.nritems+=1
7.btrfs_mark_buffer_dirty标记lower dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16370</x>
      <y>4420</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16310</x>
      <y>3490</y>
      <w>580</w>
      <h>870</h>
    </coordinates>
    <panel_attributes>4.again
	1.如果slot在mid右边
		1.如果只有一个item，或者后半段使用空间+data_size超过eb大小
			1.如果slot超过nritems
				split = 0;//不做分割
			2.否则
				1.mid = slot;
				2.slot~nritems使用空间+data_size超过eb大小
					1.如果有data_size，并且不用tried_avoid_double(之前没跳过)，跳到push_for_double
					2.否则
						split = 2
	2.如果在mid左边
		1.左半段空间+data_size超过eb
			1.如果在slot 0之前(!extend)开始插入data_size
				split = 0//不做分割
			2.如果在slot中间插入，或者干脆不插入数据
				mid = 1
			3.否则
				1.mid = slot
				2.左半段没满，并且左半段空间插入数据后超过eb的长度
					1.如果有data_size，但是不用tried_avoid_double(之前没跳过)，跳到push_for_double
					2.否则split = 2
	3.如果split为0，通过btrfs_cpu_key_to_disk利用ins_key设置disk_key
		否则通过btrfs_item_key读取eb[mid]处的disk_key
	4.通过btrfs_alloc_tree_block申请eb right
		1.root_add_used递增root-&gt;root_item.bytes_used+=nodesize
		2.btrfs_header.nritems=1
			btrfs_header.level=0
			btrfs_header.bytenr=right-&gt;start
			btrfs_header.generation=trans-&gt;transid
			btrfs_header.flags=eb | BTRFS_MIXED_BACKREF_REV
			btrfs_header.owner= root-&gt;root_key.objectid
			btrfs_header.fsid=root-&gt;fs_info-&gt;fsid
			btrfs_header.chunk_tree_uuid=fs_info-&gt;chunk_tree_uuid
	5.如果split为0，将right和父节点和path关联
		1.如果在右半段
			1.btrfs_header.nritems=0
			2.insert_ptr在将right-&gt;start插入level 1的右半段(slots[1] + 1)
			3.free_extent_buffer释放node[0]
			4.更新path
				path-&gt;nodes[0] = right;
				path-&gt;slots[0] = 0;
				path-&gt;slots[1] += 1;
		2.如果在左半段
			1.btrfs_header.nritems=0
			2.insert_ptr在将right-&gt;start插入level 1的右半段(slots[1])
			3.free_extent_buffer释放node[0]
			4.path-&gt;nodes[0] = right;
				path-&gt;slots[0] = 0;
			5.如果right所在的slot为0，fixup_low_keys更新父节点中的key
		3.btrfs_mark_buffer_dirty标记right dirty，并返回
	6.copy_for_split对l进行分段，将mid~nritems分到right中
5.如果还需要split，递增num_doubles，跳到again
6.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16800</x>
      <y>4390</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>copy_for_split</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16660</x>
      <y>4460</y>
      <w>450</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>1.right.btrfs_header.nritems=nritems - mid
2.copy_extent_buffer复制mid~nritems的item到right
3.copy_extent_buffer复制mid~nritems的数据到right
4.循环更改right item中的offset
5.l.btrfs_header.nritems=mid
6.读取right的disk_key，并通过insert_ptr在parent中插入和right的关系(slot+1)
	并通过btrfs_mark_buffer_dirty标记right和l
7.如果slot在mid的右边
	1.释放原有的node[0]
	2.建立新的path关系
		path-&gt;nodes[0] = right;
		path-&gt;slots[0] -= mid;
		path-&gt;slots[1] += 1;
8.如果在mid左边，直接释放对right的引用
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16980</x>
      <y>3490</y>
      <w>360</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>7.push_for_double：
	1.push_for_double_split向左右两个leaf腾出data_size的空间
	2.tried_avoid_double = 1
	3.如果node[0]的free_space超过了data_size直接返回0
	4.否则跳到again
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17080</x>
      <y>3630</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>push_for_double_split</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17150</x>
      <y>3580</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16990</x>
      <y>3710</y>
      <w>380</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.如果slot在node[0]范围内，更新需要的space
	space_needed -=node[0] free_space
2.push_leaf_right向右压缩space_needed的空间，如果出错，直接返回
	如果成功压缩，progress++
3.只要所在的slot在0，或者最后一个，直接返回0，再做split
4.如果node[0]剩余空间超过了data_size，直接返回0
5.通过push_leaf_left再向左leaf压缩空间，如果成功progress++
6.如果有成功压缩过，返回0，否则返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17160</x>
      <y>3660</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16850</x>
      <y>4420</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16840</x>
      <y>4350</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16360</x>
      <y>4350</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14230</x>
      <y>3670</y>
      <w>950</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;930.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15500</x>
      <y>3370</y>
      <w>950</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;930.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15510</x>
      <y>3370</y>
      <w>1650</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1630.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19360</x>
      <y>2810</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_next_old_leaf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19260</x>
      <y>2880</y>
      <w>410</w>
      <h>890</h>
    </coordinates>
    <panel_attributes>1.如果node[0]不存在item，返回1
2.读取node[0]最后一个item的key
3.again
	1.btrfs_release_path释放path
	2.path-&gt;keep_locks = 1;
		path-&gt;leave_spinning = 1;
	3.如果存在time_seq，通过btrfs_search_old_slot查找key
		否则直接通过btrfs_search_slot查找
	4.path-&gt;keep_locks = 0
	5.所寻找的slot在 nritems - 1范围内
		1.如果段正好找到(ret=0),选取下一个slot
			path-&gt;slots[0]++
		2.如果返回1，因为在search_slot时选取的是前一个，所以当前slot[0]
			是next_leaf
	6.还有slot就在nritems - 1的情况没讨论，如果此时返回1，和3.5.2情况一致
	注：运行到这里只有一种情况，slot[0]在nritems-1上，但是ret=0
	7.循环path树，找到parent[right]
		1.如果没有父节点，说明这个leaf是最后一个，返回1
		2.如果right所在slot超过了parent c的nritems
			1.level++
			2.如果到达最大level，返回1，表示不存在
			3.否则continue
		3.如果存在next，先通过free_extent_buffer将其释放
		4.通过read_block_for_search读取c[slot],如果返回EAGAIN，说明有磁盘IO
			跳到again重新建立path，如果出错，释放path，并跳到done
		5.如果不能skip_locking
			1.通过btrfs_try_tree_read_lock上读锁
			2.如果出错
				1.如果有time_seq
					1.释放path和next，并跳到again
				2.如果没有
					1.通过btrfs_tree_read_lock上读锁
			3.next_rw_lock = BTRFS_READ_LOCK
		6.退出循环
	8.path-&gt;slots[level] = slot;
	9.向下循环，找到parent[right][0][0]...
		1.level--
		2.释放path-&gt;locks[level]
		3.释放对原有path.node的引用
		4.更新path
			path-&gt;nodes[level] = next;
			path-&gt;slots[level] = 0
		5.如果不能skip_locking
			path-&gt;locks[level] = next_rw_lock
		6.如果遍历到leaf，退出循环
		7.read_block_for_search查找next[0],如果返回EAGAIN，跳到again重新查找
			如果出错，释放path，并跳到done
		8.如果不能skip_locking
			1.通过btrfs_try_tree_read_lock对next上锁
			2.如果出错，通过btrfs_tree_read_lock上锁
		9.next_rw_lock = BTRFS_READ_LOCK
	10.返回0
4.done
	1.还原path-&gt;leave_spinning
	2.如果old_spinning没置上，btrfs_set_path_blocking
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19430</x>
      <y>2840</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19900</x>
      <y>2740</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>read_one_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19380</x>
      <y>2750</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_next_leaf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19430</x>
      <y>2780</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19760</x>
      <y>2820</y>
      <w>430</w>
      <h>380</h>
    </coordinates>
    <panel_attributes>1.读取dev_item中的devid，dev_uuid，fs_uuid
2.如果fs_uuid和fs_info-&gt;fsid不同，通过open_seed_devices获取
	fs_devices
3.btrfs_find_device遍历fs_info-&gt;fs_devices链表中fs_device.devices
	链表，找到devid和uuid相同的device
4.如果没找到
	1.如果MOUNT_DEGRADED没置上，返回EIO
	2.add_missing_dev申请device加入到fs_devices中
5.如果找到
	1.bdev不存在，并且MOUNT_DEGRADED没置上，返回EIO
	2.如果bdev不存在，并且missing没置上
		device-&gt;fs_devices-&gt;missing_devices++;
		device-&gt;missing = 1
	3.如果所在的fs_devices和指定的不同
		1.将其迁到指定的fs_devices
6.如果不是fs_info-&gt;fs_devices，当generation不同时，返回EINVAL
7.fill_device_from_item通过dev_item填充device
	device-&gt;in_fs_metadata = 1;
8.如果device的writeable置上，但是is_tgtdev_for_dev_replace没置上
	device-&gt;fs_devices-&gt;total_rw_bytes += device-&gt;total_bytes
	root-&gt;fs_info-&gt;free_chunk_space += device-&gt;total_bytes -
			device-&gt;bytes_used;
9.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19940</x>
      <y>2770</y>
      <w>40</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19760</x>
      <y>3230</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>open_seed_devices</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19810</x>
      <y>3190</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19810</x>
      <y>3260</y>
      <w>40</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19720</x>
      <y>3310</y>
      <w>370</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.遍历链表fs_info-&gt;fs_devices-&gt;seed，如果找到fsid相同的
	fs_devices，即返回
2.再次通过find_fsid遍历fs_uuids链表，看是否能找到对应的fs_devices
3.如果还没找到
	1.root的MOUNT_DEGRADED要置上
	2.alloc_fs_devices申请fs_devices，并返回
		fs_devices-&gt;seeding = 1;
		fs_devices-&gt;opened = 1;
4.如果能找到，通过clone_fs_devices复制一份fs_devices
5.__btrfs_open_devices打开链表fs_devices-&gt;devices中的device
6.如果不用seeding
	1.__btrfs_close_devices关闭链表fs_devices-&gt;devices中的所有device
	2.释放fs_device
	3.返回EINVAL
7.将fs_devices加入链表root-&gt;fs_info-&gt;fs_devices-&gt;seed
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19330</x>
      <y>3800</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_search_old_slot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19390</x>
      <y>3760</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19800</x>
      <y>3590</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>clone_fs_devices</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19840</x>
      <y>3550</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19850</x>
      <y>3620</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19730</x>
      <y>3660</y>
      <w>310</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.alloc_fs_devices申请fs_devices
	fs_devices-&gt;total_devices = orig-&gt;total_devices
2.遍历orig-&gt;devices
	1.btrfs_alloc_device申请device
	2.通过rcu_string_strdup指定device-&gt;name
	3.加入fs_devices-&gt;devices链表
		device-&gt;fs_devices = fs_devices;
		fs_devices-&gt;num_devices++;
3.返回fs_devices
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19810</x>
      <y>3850</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_alloc_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19860</x>
      <y>3810</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19720</x>
      <y>3910</y>
      <w>340</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.__alloc_device申请device
2.如果没指定devid，通过find_next_devid寻找最大devid+1
注：如果devid最大为-1，没做处理
3.dev-&gt;devid = tmp
4.设置dev-&gt;uuid
5.btrfs_init_work初始化dev-&gt;work
6.返回dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19860</x>
      <y>3880</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19820</x>
      <y>4050</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_next_devid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19860</x>
      <y>4020</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19870</x>
      <y>4080</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19730</x>
      <y>4110</y>
      <w>300</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.通过btrfs_search_slot找到nritms
2.btrfs_previous_item寻找最后一个DEV_ITEM
3.如果没找到
	devid_ret = 1
4.否则获取最后一个item的key
	devid_ret = found_key.offset + 1
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19830</x>
      <y>4250</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_previous_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19880</x>
      <y>4220</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19880</x>
      <y>4280</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19730</x>
      <y>4310</y>
      <w>360</w>
      <h>190</h>
    </coordinates>
    <panel_attributes>1.循环向前查找item
	1.如果leaf在slot 0，通过btrfs_prev_leaf获取prev_leaf
	2.否则直接path-&gt;slots[0]--
	3.如果leaf中nritems是0，返回1，表示不存在
	4.如果slots[0]是nritems
		path-&gt;slots[0]--
	5.获取该slot的key
		1.不能小于min_objectid
		2.type相同，直接返回0，表示找到
		3.如果是min_objectid，但是type小于预期值，直接退出循环
2.如果退出循环，返回1，表示没找到
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19840</x>
      <y>4520</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_prev_leaf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19890</x>
      <y>4490</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19900</x>
      <y>4550</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19750</x>
      <y>4580</y>
      <w>340</w>
      <h>260</h>
    </coordinates>
    <panel_attributes>1.读取slot 0的key
2.指定prev_leaf中的特征
	1.如果offset&gt;0
		offset--
	2.offset=0 type&gt;0
		key.type--;
		key.offset = (u64)-1;
	3.offset=0 type=0 objectid&gt;0
		key.objectid--;
		key.type = (u8)-1;
		key.offset = (u64)-1;
	4.否则返回1，表示没找到
3.btrfs_search_slot查找对应的key
4.获取prev_leaf的slot 0的key，通过comp_keys和查找的可以进行对比
	如果小于要查找的key，返回0，否则返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19250</x>
      <y>3870</y>
      <w>420</w>
      <h>440</h>
    </coordinates>
    <panel_attributes>1.如果search_commit_root没置上，直接通过btrfs_search_slot获取
2.again
	1.get_old_root获取&gt;=time_seq的最小的root，并上读锁
		p-&gt;locks[level] = BTRFS_READ_LOCK
	2.循环获取path
		1.p-&gt;nodes[level] = b
		2.btrfs_clear_path_blocking，btrfs_unlock_up_safe清锁
		3.key_search查找key
		4.如果不是leaf
			1.如果没找到offset，offset所在的slot是找到的slot-1
				dec = 1;
				slot -= 1;
			2.p-&gt;slots[level] = slot;
			3.如果到最低的level，复原slot，并跳到done
			4.read_block_for_search查找slot对应的eb
			5.如果返回EAGAIN，不在缓存中，跳到again
				如果出错，返回err，跳到done
			6.btrfs_tree_read_lock_atomic和btrfs_tree_read_lock给新的eb上读锁
			7.tree_mod_log_rewind对新eb进行回滚
			8.p-&gt;locks[level] = BTRFS_READ_LOCK;
				p-&gt;nodes[level] = b;
		5.如果是leaf，跳到done
			p-&gt;slots[level] = slot
	3.返回1
3.done
	1.如果leave_spinning没置上，btrfs_set_path_blocking
	2.如果出错，btrfs_release_path释放path
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19410</x>
      <y>3830</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19190</x>
      <y>4340</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>get_old_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18810</x>
      <y>4800</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__tree_mod_log_oldest_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18700</x>
      <y>4860</y>
      <w>360</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.如果没有time_seq，返回NULL
2.循环
	1.tree_mod_log_search_oldest在log的红黑树中寻找
		在&gt;=time_seq的范围内找最小的tm
	2.如果之前没loop，并且没找到tm，返回NULL
	3.如果此次没找到tm，退出循环
	4.如果记录log的操作不是MOD_LOG_ROOT_REPLACE，退出循环
	5.记录找到的tm
		found = tm;
		root_logical = tm-&gt;old_root.logical;
		looped = 1;
3.如果没found，如果op不对，还是记录found
3.返回found
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18760</x>
      <y>5110</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tree_mod_log_search_oldest</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18760</x>
      <y>5170</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__tree_mod_log_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18850</x>
      <y>5070</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18840</x>
      <y>5140</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18840</x>
      <y>5200</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18650</x>
      <y>5230</y>
      <w>400</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.遍历红黑树fs_info-&gt;tree_mod_log
	1.依次按start，min_seq进行查找
注：1.由__tree_mod_log_insert可知大值存在左边，小值存在右边
	2.smallest没置上，找seq最大的node；
		如果置上，找seq最小的node(不能小于min_seq)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18890</x>
      <y>4830</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18910</x>
      <y>4780</y>
      <w>240</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19100</x>
      <y>4410</y>
      <w>370</w>
      <h>380</h>
    </coordinates>
    <panel_attributes>1.btrfs_read_lock_root_node上读锁，获取root.node(eb_root)
2.__tree_mod_log_oldest_root寻找&gt;=time_seq最小的tm
	如果没找到，直接返回原来的eb_root
3.如果是MOD_LOG_ROOT_REPLACE
	old_root = &amp;tm-&gt;old_root;
	old_generation = tm-&gt;generation;
	logical = old_root-&gt;logical;
4.否则
	logical = eb_root-&gt;start
5.tree_mod_log_search搜寻&gt;=time_seq最大的seq
6.如果两次都找到正常的tm
	1.free_extent_buffer释放eb_root
	2.read_tree_block读取old_root
	3.如果old有uptodate，通过btrfs_clone_extent_buffer
		复制一份eb，并释放old
7.如果只是第一次正常，释放eb_root，alloc_dummy_extent_buffer申请eb
8.否则
	1.btrfs_clone_extent_buffer复制eb_root
	2.free_extent_buffer释放eb_root
9.如果没eb，返回NULL,否则extent_buffer_get递增eb计数
10.设置eb的header
11.__tree_mod_log_rewind从最大seq进行log回滚
12.返回eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19150</x>
      <y>4810</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_clone_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19220</x>
      <y>4780</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19220</x>
      <y>4840</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19070</x>
      <y>4880</y>
      <w>340</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.__alloc_extent_buffer申请eb
2.为eb循环申请page，并将eb和page关联
	attach_extent_buffer_page(new, p)
	SetPageUptodate(p);
	new-&gt;pages[i] = p
3.copy_extent_buffer复制src到new.page
4.将new的EXTENT_BUFFER_UPTODATE和EXTENT_BUFFER_DUMMY置上
	并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19380</x>
      <y>4780</y>
      <w>210</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19500</x>
      <y>4810</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__tree_mod_log_rewind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19430</x>
      <y>4880</y>
      <w>340</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.遍历tm红黑树链表
	1.进行tm.op的回滚
		1.如果是MOD_LOG_KEY_REMOVE恢复其key，blockptr，gen
			n++
		注：后面增加的item会在后续会有其他动作，比如move
		2.如果是MOD_LOG_KEY_REPLACE恢复其key，blockptr，gen
		3.如果是MOD_LOG_KEY_ADD
			n--
		4.如果是MOD_LOG_MOVE_KEYS，将item移回原来的slot
		5.如果是MOD_LOG_ROOT_REPLACE，不做处理
	2.遍历rb_next，如果index不同，退出循环
2.btrfs_set_header_nritems重新设置eb的nritems
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19580</x>
      <y>4840</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19230</x>
      <y>4370</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19240</x>
      <y>4300</y>
      <w>130</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21930</x>
      <y>2080</y>
      <w>370</w>
      <h>410</h>
    </coordinates>
    <panel_attributes>1.read_tree_block读取tree_root-&gt;node
2.btrfs_set_root_node设置tree_root-&gt;root_item
3.tree_root-&gt;commit_root=tree_root.node
4.tree_root-&gt;root_item.refs= 1
5.btrfs_read_roots读取tree_root中的extent，dev,csum,quota,uuid树
6.fs_info-&gt;generation = disk_super.generation;
	fs_info-&gt;last_trans_committed = disk_super.generation;
7.btrfs_recover_balance读取并设置fs_info-&gt;balance_ctl
8.btrfs_init_dev_stats读取DEV_STATS填充dev.dev_stat_values数组
9.btrfs_init_dev_replace设置fs_info-&gt;dev_replace
10.btrfs_close_extra_devices关闭fs_devices上的device
11.btrfs_sysfs_add_fsid初始化fs_devices.fsid_kobj()
12.btrfs_sysfs_add_device在fsid_kobj下创建device_dir_kobj(名称：devices)
13.btrfs_sysfs_add_mounted在fsid_kobj下添加文件夹及属性
14.btrfs_init_space_info添加space_info
15.btrfs_read_block_groups读取extent_root中存储的block_group
	信息，并和space_info关联
16.btrfs_calc_num_tolerated_disk_barrier_failures计算fs_info.num_tolerated_disk_barrier_failures
	如果missing_devices超过了这个数，并且sb不是readonly，报错
17.为tree_root开启两个线程fs_info-&gt;cleaner_kthread   fs_info-&gt;transaction_kthread
18.如果tree_root的MOUNT_SSD和MOUNT_NOSSD都没置上，并且不是rotating
	btrfs_set_opt(fs_info-&gt;mount_opt, SSD)
19.btrfs_apply_pending_changes根据pending_changes设置或者清除fs_info.mount_opt
	的INODE_MAP_CACHE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20770</x>
      <y>2540</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_read_roots</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20820</x>
      <y>2480</y>
      <w>1150</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1130.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20670</x>
      <y>2600</y>
      <w>360</w>
      <h>330</h>
    </coordinates>
    <panel_attributes>1.btrfs_read_tree_root在tree_root中搜索EXTENT_TREE
	1.设置root的BTRFS_ROOT_TRACK_DIRTY
	2.fs_info-&gt;extent_root = root
2.btrfs_read_tree_root搜索DEV_TREE
	1.设置root的BTRFS_ROOT_TRACK_DIRTY
	2.fs_info-&gt;dev_root = root
	3.btrfs_init_devices_late遍历fs_info-&gt;fs_devices链表
		设置device-&gt;dev_root = fs_info-&gt;dev_root
3.btrfs_read_tree_root搜索CSUM_TREE
	1.设置root的BTRFS_ROOT_TRACK_DIRTY
	2.fs_info-&gt;csum_root = root
4.btrfs_read_tree_root搜索QUOTA_TREE
	1.设置root的BTRFS_ROOT_TRACK_DIRTY
	2.fs_info-&gt;quota_enabled = 1;
		fs_info-&gt;pending_quota_state = 1;
		fs_info-&gt;quota_root = root;
5.btrfs_read_tree_root搜索UUID_TREE
	1.设置root的BTRFS_ROOT_TRACK_DIRTY
	2.fs_info-&gt;uuid_root = root
6.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20820</x>
      <y>2570</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20630</x>
      <y>2960</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_read_tree_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20690</x>
      <y>2920</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20680</x>
      <y>2990</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20510</x>
      <y>3020</y>
      <w>350</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_path申请path
2.btrfs_alloc_root申请root
	root-&gt;fs_info = fs_info
3.__setup_root初始化root
4.btrfs_find_root查找key对应的eb，并且
	设置root-&gt;root_item
5.read_tree_block根据root_item读取root所在的eb
	root-&gt;node
6.如果没有uptodate，释放root.node，并返回EIO
7.root-&gt;commit_root=root.node
8.返回root
9.find_fail：
	1.释放root，并返回错误
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20470</x>
      <y>3260</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_find_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20520</x>
      <y>3230</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20360</x>
      <y>3330</y>
      <w>350</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot搜寻search_key
2.如果offset对不上，直接跳到out，返回1
	如果是搜寻最大的
	path-&gt;slots[0]--;
	ret = 0;
3.如果搜寻的objectid不同，或者type不是BTRFS_ROOT_ITEM_KEY
	直接返回1
4.btrfs_read_root_item设置root_item
5.root_key返回found_key
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20510</x>
      <y>3290</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20430</x>
      <y>3520</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_read_root_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20360</x>
      <y>3590</y>
      <w>350</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>1.以btrfs_root_item的方式解析slot对应的数据，通过read_extent_buffer
	读取到item中
2.如果长度不够
	need_reset=1
3.generation和generation_v2不同
	need_reset = 1
4.如果need_reset置上
	1.将item.generation_v2的空间清空
	2.设置item-&gt;uuid
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20510</x>
      <y>3480</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20500</x>
      <y>3550</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21190</x>
      <y>2520</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_recover_balance</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21260</x>
      <y>2480</y>
      <w>810</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fs_info-&gt;balance_ctl</panel_attributes>
    <additional_attributes>790.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21080</x>
      <y>2590</y>
      <w>380</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_path申请path，并通过btrfs_search_slot在tree_root中
	查找BTRFS_BALANCE_OBJECTID，如果不为0，跳到out
2.申请bctl
	1.以btrfs_balance_item解析查找到的path数据
	2.bctl-&gt;fs_info = fs_info
		bctl-&gt;flags =item.flags |BTRFS_BALANCE_RESUME
	3.btrfs_balance_data读取item.data到disk_bargs
		并根据disk_bargs设置bctl-&gt;data
	4.btrfs_balance_meta和btrfs_disk_balance_args_to_cpu
		读取item.meta,并设置bctl-&gt;meta
	5.btrfs_balance_sys和btrfs_disk_balance_args_to_cpu
		读取item.sys,并依此设置bctl-&gt;sys
	6.set_balance_control设置
		fs_info-&gt;balance_ctl = bctl;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21250</x>
      <y>2550</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21510</x>
      <y>2520</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_init_dev_stats</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21540</x>
      <y>2480</y>
      <w>710</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fs_devices-&gt;devices</panel_attributes>
    <additional_attributes>690.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21580</x>
      <y>2550</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21470</x>
      <y>2590</y>
      <w>320</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_path申请path
2.遍历fs_devices-&gt;devices链表
	1.btrfs_search_slot查找对应devid
	2.如果没有正好找到
		1.__btrfs_reset_dev_stats重置dev_stat_values数组
		2.device-&gt;dev_stats_valid = 1;
		3.btrfs_release_path重置path，并continue
	3.根据slot的数据通过btrfs_dev_stat_set设置数组
		dev_stat_values，如果数据中没描述的通过btrfs_dev_stat_reset重置
	注：以btrfs_dev_stats_item方式解析数据，获取其中的values数组
	4.device-&gt;dev_stats_valid = 1;
	5.重置path
3.out:
	1.重置path，并返回ret（只有错误和0）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21360</x>
      <y>2850</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_reset_dev_stats</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21440</x>
      <y>2820</y>
      <w>80</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21350</x>
      <y>2910</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_dev_stat_set</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21420</x>
      <y>2880</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21260</x>
      <y>2970</y>
      <w>230</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.dev-&gt;dev_stat_values[index]=val
2.dev-&gt;dev_stats_ccnt++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21420</x>
      <y>2940</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21850</x>
      <y>2520</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_init_dev_replace</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21820</x>
      <y>2590</y>
      <w>340</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_path申请path，并通过btrfs_search_slot
	查找DEV_REPLACE
2.如果没找到合适的(no_valid_dev_replace_entry_found)
	1.重置fs_info-&gt;dev_replace
	2.跳到out
3.slot对应的数据通过btrfs_dev_replace_item解析
	1.size要完全相同
	2.设置fs_info-&gt;dev_replace
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21930</x>
      <y>2550</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21930</x>
      <y>2480</y>
      <w>320</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fs_info-&gt;dev_replace</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22290</x>
      <y>2510</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_sysfs_add_mounted</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22200</x>
      <y>2580</y>
      <w>350</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.btrfs_set_fs_info_ptr设置fs_info-&gt;fs_devices链表中的fs_info
2.btrfs_sysfs_add_device_link在device_dir_kobj下为fs_devices中的dev
	创建link
3.为fsid_kobj创建btrfs_attrs
4.sysfs_create_group在fsid_kobj下创建文件夹btrfs_feature_attr_group
5.addrm_unknown_feature_attrs在fsid_kobj下创建btrfs_feature_attrs
6.kobject_create_and_add在fsid_kobj下创建space_info_kobj
7.sysfs_create_files在space_info_kobj添加allocation_attrs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22360</x>
      <y>2540</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22250</x>
      <y>2480</y>
      <w>120</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sysfs</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22680</x>
      <y>2510</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_init_space_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22750</x>
      <y>2540</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22600</x>
      <y>2580</y>
      <w>370</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>1.获取fs_info-&gt;super_copy
2.如果没有root，返回1
3.如果其incompat_flags中BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS置上
	mixed = 1
4.update_space_info以BTRFS_BLOCK_GROUP_SYSTEM方式添加space_info
5.如果mixed
	1.update_space_info以METADATA |DATA的方式添加space_info
6.否则METADATA和DATA单独添加
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22500</x>
      <y>2760</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>update_space_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22550</x>
      <y>2720</y>
      <w>140</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22560</x>
      <y>2790</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22420</x>
      <y>2830</y>
      <w>320</w>
      <h>380</h>
    </coordinates>
    <panel_attributes>1.如果是DUP , RAID1,RAID10
	factor = 2
	否则
	factor = 1
2.__find_space_info遍历fs_info.space_info，找到
	flags相容的space_info
3.如果找到
	1.更新
		found-&gt;total_bytes += total_bytes;
		found-&gt;disk_total += total_bytes * factor;
		found-&gt;bytes_used += bytes_used;
		found-&gt;disk_used += bytes_used * factor;
	2.返回found，并返回0
4.如果没找到，申请并初始化
	found-&gt;flags = flags &amp; BTRFS_BLOCK_GROUP_TYPE_MASK;
	found-&gt;total_bytes = total_bytes;
	found-&gt;disk_total = total_bytes * factor;
	found-&gt;bytes_used = bytes_used;
	found-&gt;disk_used = bytes_used * factor;
5.kobject_init_and_add将found加入到space_info_kobj
6.返回found，并将其加入链表fs_info.space_info
7.如果BTRFS_BLOCK_GROUP_DATA置上
	info-&gt;data_sinfo = found;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23100</x>
      <y>2510</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_read_block_groups</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23000</x>
      <y>2580</y>
      <w>420</w>
      <h>820</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_path申请path
	path-&gt;reada = 1
2.need_clear置上的条件
	1.如果root的MOUNT_SPACE_CACHE置上，并且super_copy的gen和cache_gen相同
	2.或者MOUNT_CLEAR_CACHE置上
3.循环
	1.find_first_block_group搜寻第一个BLOCK_GROUP_ITEM
	2.如果没找到，退出循环，如果出错，跳到error
	3.根据找到的item的found_key，通过btrfs_create_block_group_cache创建cache
	4.如果need_clear，在MOUNT_SPACE_CACHE置上的情况
		cache-&gt;disk_cache_state = BTRFS_DC_CLEAR
	5.以cache-&gt;item的方式解析slots[0]的数据到cache-&gt;item
	6.cache-&gt;flags=cache-&gt;item.flags
	7.更新key.objectid
	8.btrfs_release_path重置path
	9.exclude_super_stripes统计cache中super的长度，如果失败
		1.free_excluded_extents清除freed_extents中的state
		2.btrfs_put_block_group释放cache
		3.跳到error
	10.如果cache已经全部被用
		1.cache-&gt;last_byte_to_unpin = (u64)-1;
			cache-&gt;cached = BTRFS_CACHE_FINISHED;
		2.free_excluded_extents清除freed_extents中state树
	11.如果cache完全没用
		1.cache-&gt;last_byte_to_unpin = (u64)-1;
			cache-&gt;cached = BTRFS_CACHE_FINISHED;
		2.add_new_free_space为block_group添加这段free_space
		3.free_excluded_extents清除freed_extents中state树
	12.btrfs_add_block_group_cache将block_group插入到红黑树中
		如果失败
		1.btrfs_remove_free_space_cache释放cache中的free_space
		2.btrfs_put_block_group释放cache
		3.跳到error
	13.update_space_info更新flags对应的space_info的长度信息
		cache-&gt;space_info = space_info
		cache-&gt;space_info-&gt;bytes_readonly += cache-&gt;bytes_super
		__link_block_group(space_info, cache)
	14.set_avail_alloc_bits设置fs_info-&gt;avail_data_alloc_bits
	15.如果是btrfs_chunk_readonly，inc_block_group_ro递增cache-&gt;ro
	16.如果cache完全没用
		1.btrfs_get_block_group递增cache
		2.list_add_tail将cache.bg_list连接到fs_info.unused_bgs
4.遍历fs_info-&gt;space_info
	1.检查space_info-&gt;flags)
	2.对space_info-&gt;block_groups中的BTRFS_RAID_RAID0和BTRFS_RAID_SINGLE
		两个bucket做inc_block_group_ro
5.init_global_block_rsv
	1.初始化block_rsv.space_info 
	2.初始化各个root-&gt;block_rsv
	3.update_global_block_rsv
6.释放path，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23170</x>
      <y>2540</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22140</x>
      <y>3470</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_first_block_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22210</x>
      <y>3390</y>
      <w>870</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>850.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22200</x>
      <y>3500</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22040</x>
      <y>3530</y>
      <w>350</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot寻找key
2.从path.slot[0]开始遍历slot
	1.如果超过了leaf的nritems，btrfs_next_leaf更新path到下一个leaf
	2.btrfs_item_key_to_cpu读取slot的found_key
	3.如果objectid&gt;=指定值，type是BLOCK_GROUP即找到，返回0跳到out
	4.path-&gt;slots[0]++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22420</x>
      <y>3470</y>
      <w>220</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_create_block_group_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22510</x>
      <y>3390</y>
      <w>750</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>730.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22520</x>
      <y>3500</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22420</x>
      <y>3530</y>
      <w>330</w>
      <h>180</h>
    </coordinates>
    <panel_attributes>1.申请cache，和cache.free_space_ctl,并初始化
	cache-&gt;key.objectid = start;
	cache-&gt;key.offset = size;
	cache-&gt;key.type = BTRFS_BLOCK_GROUP_ITEM_KEY;
	cache-&gt;sectorsize = root-&gt;sectorsize;
	cache-&gt;fs_info = root-&gt;fs_info;
	cache-&gt;full_stripe_len = btrfs_full_stripe_len(root,
					       &amp;root-&gt;fs_info-&gt;mapping_tree,
					       start);
	atomic_set(&amp;cache-&gt;count, 1);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22510</x>
      <y>3730</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_full_stripe_len</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22580</x>
      <y>3700</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22570</x>
      <y>3760</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22440</x>
      <y>3800</y>
      <w>310</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.lookup_extent_mapping搜寻logical所在的em
2.如果em.bdev的RAID56_MASK置上
	len = map-&gt;stripe_len * nr_data_stripes(map);
3.否则默认返回root-&gt;sectorsize
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22830</x>
      <y>3460</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>exclude_super_stripes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22900</x>
      <y>3390</y>
      <w>430</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22760</x>
      <y>3520</y>
      <w>330</w>
      <h>260</h>
    </coordinates>
    <panel_attributes>1.如果cache在BTRFS_SUPER_INFO_OFFSET之前
	1.记录cache在super中的长度
		cache-&gt;bytes_super += stripe_len
	2.add_excluded_extent将在super中的长度加入
		fs_info-&gt;freed_extents数组
2.循环读取super镜像
	1.btrfs_sb_offset获取super镜像的偏移
	2.btrfs_rmap_block计算sb的逻辑偏移
	3.遍历返回的logical数组
		1.其逻辑偏移不在cache范围内，这里stripe_len的含义不清楚(raid56放在一个磁盘上)
		2.计算在cache范围内的长度len
		3.统计super在cache中的长度
			1.cache-&gt;bytes_super += len
			2.add_excluded_extent设置freed_extents数组中的两颗state树
	4.释放logical
3.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22910</x>
      <y>3490</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22780</x>
      <y>3810</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_rmap_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22830</x>
      <y>3770</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22830</x>
      <y>3840</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22760</x>
      <y>3880</y>
      <w>320</w>
      <h>650</h>
    </coordinates>
    <panel_attributes>1.lookup_extent_mapping寻找chunk_start的em
2.根据em-&gt;bdev的类型设置length和rmap_len
	1.默认是
		length = em-&gt;len;
		rmap_len = map-&gt;stripe_len;
	2.如果是RAID10(分组)
		length/=map-&gt;num_stripes / map-&gt;sub_stripes（一组的strips的数量）
	3.RAID0
		length/= map-&gt;num_stripes
	4.如果是RAID56_MASK(奇偶校验)
		length/= nr_data_stripes
		rmap_len = map-&gt;stripe_len * nr_data_stripes
3.根据num_stripes申请buf
4.遍历num_stripes
	1.stripes的devid对不上，遍历下一个
	2.physical不在stripes范围内，遍历下一个
	3.计算不在physical在strip的那个磁盘上
		offset/stripe_len
	4.计算physical的逻辑偏移
		1.如果是raid10，其物理偏移/组数量
		2.如果是raid0，直接是其物理偏移
		3.如果是raid56，前面已经加在rmap_len上
	5.计算其物理偏移量
		bytenr = chunk_start + stripe_nr * rmap_len
	6.将pysical的逻辑偏移存在buf
		1.查看buf中是否有和bytenr相同的
		2.如果没有，保存
			buf[nr++] = bytenr
	注：这里既然已经找到了pysical，为什么不直接退出，还要继续查找，难道physical可以对应不同的strip？
5.变量返回
	*logical = buf;
	*naddrs = nr; 	
	*stripe_len = rmap_len;
6.释放em，并返回0
注：num_stripes表有多少块磁盘(ndevs * dev_stripes（每块raid磁盘中的小磁盘数）)
	sub_stripes表示raid1备份共用的strip
	stripe_len表示strip在(raid磁盘的小磁盘上的长度)
	length表示一条strip的长度
	raid5时，奇偶校验每个磁盘需要一个content，总共需要一个strip，所以一个磁盘可用长度为
	stripe_len * nr_data_stripes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23230</x>
      <y>3450</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>add_new_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23310</x>
      <y>3390</y>
      <w>30</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23280</x>
      <y>3480</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23110</x>
      <y>3510</y>
      <w>370</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.循环处理free_space
	1.find_first_extent_bit在pinned_extents从start开始找EXTENT_DIRTY | EXTENT_UPTODATE
		置上的state，如果没找到，退出循环
	2.如果是下面情况，更新start，继续下一次循环
		start = extent_end + 1;
	extend_start			extend_end
						start						end
	3.如果是下述情况，将不在pinned_extents中的部分通过btrfs_add_free_space
		加入到block_group,并更新start重新循环
			start = extent_end + 1;
		start							end
					extend_start				extend_end
	4.如果完全不在state范围内，退出循环(由find_first_extent_bit可知，start&lt;extend_end)
2.如果还存在长度，btrfs_add_free_space添加free_space到block_group中
3.返回添加的free_space的大小
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23110</x>
      <y>3790</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_first_extent_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23160</x>
      <y>3750</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23100</x>
      <y>3850</y>
      <w>320</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.如果有cached_state
	1.如果cache_state紧挨着start，并且在红黑树中
		1.遍历红黑树链表，如果有state相似的跳到got_it
		2.否则free_extent_state释放cache_state，跳到out
	2.否则free_extent_state释放cache_state，跳到out
2.find_first_extent_bit_state从start开始，在红黑树链表中
	找出和bits相似的state
3.got_it
	1.cache_state_if_flags 缓存state
	2.*start_ret = state-&gt;start;
		*end_ret = state-&gt;end;
		ret = 0;
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23160</x>
      <y>3820</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23150</x>
      <y>4090</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_first_extent_bit_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23230</x>
      <y>4060</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23230</x>
      <y>4120</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23100</x>
      <y>4150</y>
      <w>240</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.tree_search查找start
2.遍历红黑树链表
	1.如果找到state相似的，即返回
	2.否则rb_next
3.找不到，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23500</x>
      <y>3450</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_add_block_group_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23500</x>
      <y>3520</y>
      <w>260</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.遍历fs_info.block_group_cache_tree，
	如果block_group存在，返回EEXIST
2.插入红黑树
3.更新fs_info-&gt;first_logical_byte,返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23600</x>
      <y>3480</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23320</x>
      <y>3390</y>
      <w>310</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23820</x>
      <y>3440</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__link_block_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23890</x>
      <y>3470</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23770</x>
      <y>3510</y>
      <w>330</w>
      <h>170</h>
    </coordinates>
    <panel_attributes>1.get_block_group_index根据cache.flags获取存储的bucket
2.如果space_info-&gt;block_groups bucket为空
	first = true
3.将cache连接到bucket中
4.如果是first
	1.申请rkobj
		rkobj-&gt;raid_type = index
		rkobj-&gt;ktype = btrfs_raid_ktype
	2.kobject_add添加到space_info的sysfs下
	3.space_info-&gt;block_group_kobjs[index] = &amp;rkobj-&gt;kobj
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23400</x>
      <y>3390</y>
      <w>510</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;490.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24180</x>
      <y>3430</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_chunk_readonly</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24250</x>
      <y>3460</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24110</x>
      <y>3500</y>
      <w>330</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.lookup_extent_mapping在map_tree中查找chunk_offset
2.遍历em.bdev的stripes
	1.统计dev-&gt;missing
	2.如果有dev.writeable没置上，readonly置上，并直接返回
3.如果miss_ndevs超过了限值，readonly置上
4.释放em，并返回readonly
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24500</x>
      <y>3430</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>inc_block_group_ro</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24460</x>
      <y>3490</y>
      <w>330</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.确定space_info的min_allocable_bytes
2.如果cache.ro存在，直接递增cache-&gt;ro，并返回0
3.如果space_info需要保存的空间没超过total_bytes
	1.sinfo-&gt;bytes_readonly += num_bytes;
		cache-&gt;ro++;
	2.cache-&gt;ro_list连接到sinfo-&gt;ro_bgs
	3.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24570</x>
      <y>3460</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23400</x>
      <y>3390</y>
      <w>900</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;880.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23400</x>
      <y>3390</y>
      <w>1210</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22270</x>
      <y>2480</y>
      <w>530</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22270</x>
      <y>2480</y>
      <w>940</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23500</x>
      <y>2500</y>
      <w>330</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_calc_num_tolerated_disk_barrier_failures</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23460</x>
      <y>2570</y>
      <w>410</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.遍历链表fs_info-&gt;space_info，找到和type相同的space_info
2.遍历所有的sinfo-&gt;block_groups
	1.btrfs_get_block_group_info统计空间信息
	2.如果没有用，继续遍历下一个
	3.找到最小的btrfs_get_num_tolerated_disk_barrier_failures
		1.根据flags在btrfs_raid_array找到最小的tolerance
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23650</x>
      <y>2530</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22270</x>
      <y>2470</y>
      <w>1370</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;20.0;1350.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>28340</x>
      <y>1960</y>
      <w>360</w>
      <h>320</h>
    </coordinates>
    <panel_attributes>1.btrfs_read_qgroup_config读取并建立qgroup和之间的关系
2.如果disk_super.log_root不为0，btrfs_replay_log读取log
	恢复对应root中的数据
3.btrfs_find_orphan_roots在tree_root中查找所有的orphan root
4.如果sb不是MS_RDONLY
	1.btrfs_cleanup_fs_roots清除所有root中的不正确的orphan
	2.btrfs_recover_relocation
5.btrfs_read_fs_root_no_name查找BTRFS_FS_TREE_OBJECTID
	fs_info-&gt;fs_root
6.如果sb是MS_RDONLY，返回0
7.否则
	1.btrfs_orphan_cleanup清除fs_root和tree_root中不正确的orphan
	2.btrfs_resume_balance_async开启balance_kthread
	3.btrfs_resume_dev_replace_async开启btrfs_dev_replace_kthread
	4.btrfs_qgroup_rescan_resume在BTRFS_QGROUP_STATUS_FLAG_RESCAN
		置上时，将qgroup_rescan_work加入到qgroup_rescan_workers
	5.如果没有uuid_root，通过btrfs_create_uuid_tree常见
	6.如果uuid_root的RESCAN_UUID_TREE置上，或者gen和fs_info.gen不同
		btrfs_check_uuid_tree开启btrfs_uuid_rescan_kthread
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>26080</x>
      <y>2330</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_read_qgroup_config</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26160</x>
      <y>2270</y>
      <w>2260</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2240.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26000</x>
      <y>2360</y>
      <w>190</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读取status info limit</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>25840</x>
      <y>2400</y>
      <w>370</w>
      <h>450</h>
    </coordinates>
    <panel_attributes>1.如果quota_enabled没开启，返回0
2.ulist_alloc为fs_info-&gt;qgroup_ulist申请ulist
3.btrfs_alloc_path申请path
4.btrfs_search_slot_for_read优先搜寻大于key的path
5.循环
	1.如果找到的是BTRFS_QGROUP_STATUS_KEY
		1.以btrfs_qgroup_status_item的方式解析slot的数据
		2.检查ptr.version ptr.generation
		3.fs_info-&gt;qgroup_flags=ptr.flags
		4.rescan_progress=ptr.rescan
		5.跳到next1
	2.如果不是BTRFS_QGROUP_INFO_KEY 也不是 BTRFS_QGROUP_LIMIT_KEY
		跳到next1
	3.find_qgroup_rb查找found_key.offset，
		1.BTRFS_QGROUP_INFO_KEY不在红黑树
		2.BTRFS_QGROUP_LIMIT_KEY要在红黑树中
		3.这个函数要满足以上两个条件，否则BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT置上
	4.如果没找到，通过add_qgroup_rb将其添加至红黑树
	5.如果是BTRFS_QGROUP_INFO_KEY
		1.以btrfs_qgroup_info_item方式解析slot数据
		2.根据ptr设置rfer rfer_cmpr excl excl_cmpr
	6.如果是BTRFS_QGROUP_LIMIT_KEY
		1.以btrfs_qgroup_limit_item方式解析slot数据
		2.根据ptr设置lim_flags max_rfer max_excl rsv_rfer rsv_excl
	7.next1
		1.btrfs_next_item遍历下一个slot
		2.如果出错，跳到out。如果没有，退出循环
6.释放path
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25440</x>
      <y>2870</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_search_slot_for_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25530</x>
      <y>2840</y>
      <w>340</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25520</x>
      <y>2900</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>25390</x>
      <y>2940</y>
      <w>330</w>
      <h>360</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot搜寻key
2.如果正好找到，或者出错，直接返回
注；下面都是返回1，slot是大于key的
3.如果find_higher置上
	1.如果slot超过leaf的nritems
		1.btrfs_next_leaf查找下一个leaf
		2.如果是0，或者出错直接返回
		3.如果不用一定要返回slot，返回1
		4.否则清掉return_any find_higher后，释放path
			跳到1
4.如果find_higher没置上
	1.如果在slot 0
		1.btrfs_prev_leaf寻找prev_leaf(这里通过keysearch找到的是nritems)
		2.如果出错，直接返回
		3.如果能找到
			1.如果找到nritems
				p-&gt;slots[0]--
			2.返回0
		4.这里没找到
			1.如果没置return_any，直接返回1
			2.如果置上
				1.清掉return_any，更改find_higher，跳到1重试
	2.如果不在slot 0
		--p-&gt;slots[0]
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25830</x>
      <y>2840</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25770</x>
      <y>2880</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_qgroup_rb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>25730</x>
      <y>2950</y>
      <w>280</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.遍历fs_info-&gt;qgroup_tree，找到qgroupid
	相同的node，否则返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25830</x>
      <y>2910</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>26060</x>
      <y>2880</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>add_qgroup_rb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26090</x>
      <y>2840</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>26020</x>
      <y>2950</y>
      <w>300</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.遍历红黑树，如果找到qgroupid，直接返回
2.否则
	1.申请qgroup
		qgroup-&gt;qgroupid = qgroupid;
	2.插入到红黑树后，返回qgroup
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26110</x>
      <y>2910</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26170</x>
      <y>2360</y>
      <w>220</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读取qgroup relation</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>26220</x>
      <y>2400</y>
      <w>360</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot_for_read向上搜寻BTRFS_QGROUP_RELATION_KEY
2.循环
	1.要是BTRFS_QGROUP_RELATION_KEY
	2.子id(objectid)要小于父id(offset)
	3.add_relation_rb添加member和parent之间的list
	4.btrfs_next_item遍历下一个slot
3.out
	1.fs_info-&gt;qgroup_flags |= flags
	2.如果qgroup_flags的BTRFS_QGROUP_STATUS_FLAG_ON没置上
		fs_info-&gt;quota_enabled = 0;
		fs_info-&gt;pending_quota_state = 0;
	3.如果qgroup_flags的BTRFS_QGROUP_STATUS_FLAG_RESCAN置上
		并且之前遍历没出错，qgroup_rescan_init初始化
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>26240</x>
      <y>2650</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>add_relation_rb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26290</x>
      <y>2610</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>26220</x>
      <y>2710</y>
      <w>300</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.find_qgroup_rb找到member parent
2.申请btrfs_qgroup_list
	list-&gt;group = parent;
	list-&gt;member = member;
3.将list(next_group)添加到member-&gt;groups链表中
	将list(next_member)添加到parent-&gt;members链表中
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26300</x>
      <y>2680</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26540</x>
      <y>2610</y>
      <w>80</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>26550</x>
      <y>2650</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>qgroup_rescan_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>26530</x>
      <y>2710</y>
      <w>330</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.如果没有init_flags，BTRFS_QGROUP_STATUS_FLAG_RESCAN
	和BTRFS_QGROUP_STATUS_FLAG_ON要置上
2.如果有init_flags
	1.BTRFS_QGROUP_STATUS_FLAG_RESCAN不能置上
	2.BTRFS_QGROUP_STATUS_FLAG_ON要置上
	3.fs_info-&gt;qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_RESCAN
3.初始化
	1.fs_info-&gt;qgroup_rescan_progress=0
	2.fs_info-&gt;qgroup_rescan_progress.objectid = progress_objectid
	3.初始化qgroup_rescan_completion
	4.fs_info-&gt;qgroup_rescan_work=0
	5.btrfs_init_work初始化qgroup_rescan_work
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26620</x>
      <y>2680</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>30210</x>
      <y>2330</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_replay_log</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28660</x>
      <y>2270</y>
      <w>1620</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1600.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>30150</x>
      <y>2400</y>
      <w>350</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.fs_devices-&gt;rw_devices不能为0
2.btrfs_alloc_root申请root，并使用__setup_root依据
	tree_root设置log_tree_root
3.read_tree_block在tree_root中偏移为disk_super.log_root
	位置读取log_tree_root-&gt;node
4.btrfs_recover_log_trees利用log_tree_root中记录的log恢复
	其对应的root(id在log_root中为key.offset)
5.如果sb是read_only,btrfs_commit_super
6.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30270</x>
      <y>2360</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>30330</x>
      <y>2600</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_recover_log_trees</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30410</x>
      <y>2550</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>30220</x>
      <y>2680</y>
      <w>370</w>
      <h>700</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_path申请path
2.fs_info-&gt;log_root_recovering = 1
3.btrfs_start_transaction
	wc.trans = trans;
	wc.pin = 1;
4.walk_log_tree根据wc的方法处理log_root_tree的所有eb
5.again
	1.循环搜寻log
		1.btrfs_search_slot在log_root_tree查找BTRFS_TREE_LOG_OBJECTID
		2.如果没有正好找到
			1.如果找到的high是slot 0，退出循环
			2.否则
				path-&gt;slots[0]--
		3.找到的slot得是BTRFS_TREE_LOG_OBJECTID
		4.btrfs_read_fs_root根据找到的key再次读取root
		5.通过btrfs_read_fs_root_no_name读取wc.replay_dest
		注：found_key.objectid存储BTRFS_TREE_LOG_OBJECTID
			found_key.offset存储的是replay_root
		6.将两者root关联
			wc.replay_dest-&gt;log_root = log
		7.btrfs_record_root_in_trans更新 wc.replay_dest的last_trans
		8.walk_log_tree根据wc处理log
		9.如果处理完成，并且LOG_WALK_REPLAY_ALL
			1.fixup_inode_link_counts根据wc.replay_dest中的记录
				修复BTRFS_TREE_LOG_FIXUP_OBJECTID中所有对应的inode.i_nlink
		10.更新循环变量		
			key.offset = found_key.offset - 1;
			wc.replay_dest-&gt;log_root = NULL;
		11.释放log
6.如果wc.pin
	1.清除wc.pin
	2.更新wc
		wc.process_func = replay_one_buffer;
		wc.stage = LOG_WALK_REPLAY_INODES;
	3.跳到again
7.如果wc.stage没到LOG_WALK_REPLAY_ALL，更新wc.stage，跳到again
8.btrfs_commit_transaction
9.释放log_root_tree
	free_extent_buffer(log_root_tree-&gt;node);
	log_root_tree-&gt;log_root = NULL;
	fs_info-&gt;log_root_recovering = 0;
	kfree(log_root_tree);
10.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30400</x>
      <y>2630</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>27910</x>
      <y>3500</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>walk_log_tree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27960</x>
      <y>3370</y>
      <w>2340</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2320.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>27790</x>
      <y>3570</y>
      <w>340</w>
      <h>270</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_path申请path
2.根据log.node设置path
	path-&gt;nodes[level] = log-&gt;node;
	path-&gt;slots[level] = 0
3.循环，通过wc的方法处理log
	1.walk_down_log_tree根据wc处理path对应的首个leaf
		如果正确返回level应该为1
	2.walk_up_log_tree在循环遍历上一层level的其他slot
		以便通过3.1处理root的其他leaf
4.如果log没处理完
	1.wc-&gt;process_func处理root
	2.如果wc-&gt;free
		1.clean_tree_block清理dirty
		2.btrfs_wait_tree_block_writeback等待文件写完
		3.btrfs_free_and_pin_reserved_extent释放reserved
5.释放path，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27940</x>
      <y>3530</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>27200</x>
      <y>3870</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>walk_down_log_tree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27250</x>
      <y>3830</y>
      <w>590</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>570.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>27200</x>
      <y>3940</y>
      <w>350</w>
      <h>340</h>
    </coordinates>
    <panel_attributes>1.循环遍历level
	1.如果path遍历完node的slot，退出循环
	2.btrfs_find_create_tree_block查找slot对应的eb
	3.如果查找到了level 1，也就是现在子eb到了leaf
		1.wc-&gt;process_func根据wc处理eb
		2.path-&gt;slots[*level]++
		3.如果wc-&gt;free
			1.btrfs_read_buffer读取next
			2.如果存在trans
				1.clean_tree_block提交dirty的next
				2.btrfs_wait_tree_block_writeback等待next
			3.btrfs_free_and_pin_reserved_extent将段pin到pinned_extents
		4.释放next之后，继续下一个循环
	4.否则btrfs_read_buffer直接读取next
		path-&gt;nodes[*level-1] = next
	5.读取next的slot0，继续循环
		*level = btrfs_header_level(next);
		path-&gt;slots[*level] = 0;
2.最后leaf遍历完之后，其slot赋值为其nritems
	path-&gt;slots[*level] = btrfs_header_nritems(path-&gt;nodes[*level])
3.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27270</x>
      <y>3900</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23630</x>
      <y>4460</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>process_one_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23700</x>
      <y>4390</y>
      <w>1520</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>1500.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23690</x>
      <y>4490</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23570</x>
      <y>4530</y>
      <w>330</w>
      <h>180</h>
    </coordinates>
    <panel_attributes>1.如果disk_super的MIXED_GROUPS没置上，通过
	btrfs_read_buffer读取eb
2.如果wc-&gt;pin置上，btrfs_pin_extent_for_log_replay
	将eb的段从free_space移到pinned_extents
3.如果成功pinned，并且uptodate
	1.如果wc-&gt;pin，并且eb是leaf，通过btrfs_exclude_logged_extents
		将leaf数据中描述的log段释放，不能用于分配
	2.如果wc-&gt;write，通过btrfs_write_tree_block写eb
	3.如果wc-&gt;wait，通过btrfs_wait_tree_block_writeback
		等待eb写完
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22780</x>
      <y>4830</y>
      <w>230</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_pin_extent_for_log_replay</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22870</x>
      <y>4700</y>
      <w>750</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>730.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22870</x>
      <y>4860</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22710</x>
      <y>4900</y>
      <w>400</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.btrfs_lookup_block_group搜寻包含bytenr的cache
2.通过cache_block_group加载cache内(传参1，表示如果加载不进来不设置work)
3.pin_down_extent将段pinned到pinned_extents中
4.btrfs_remove_free_space清除free_space中的段
5.btrfs_put_block_group释放对cache的引用
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22680</x>
      <y>5030</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>pin_down_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22730</x>
      <y>4990</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22560</x>
      <y>5100</y>
      <w>380</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.调整cache和space_info中pinned计数
	cache-&gt;pinned += num_bytes;
	cache-&gt;space_info-&gt;bytes_pinned += num_bytes
2.如果reserved置上(是从reserved中pinned？)
	cache-&gt;reserved -= num_bytes;
	cache-&gt;space_info-&gt;bytes_reserved -= num_bytes;
3.set_extent_dirty将pinned_extents中的传入的段设置为dirty
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22730</x>
      <y>5060</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23010</x>
      <y>5030</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_remove_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23060</x>
      <y>4990</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22960</x>
      <y>5090</y>
      <w>380</w>
      <h>420</h>
    </coordinates>
    <panel_attributes>1.tree_search_offset在ctl中查找对应的offset，如果找不到
	再找offset对应的bitmap
2.如果info没有bitmap
	1.unlink_free_space将info从ctl中删除
	2.如果offset正好是info的偏移
		1.删除需要的free_space
			info-&gt;bytes -= to_free;
			info-&gt;offset += to_free;
		2.如果info还存在剩余空间，通过link_free_space将info连接到ctl中
			否则将info释放
		3.更新，再次查找下一个free_space
			offset += to_free;
			bytes -= to_free;
		4.跳到1重新查找
	3.如果offset在info的范围内
		1.link_free_space将info的前段连接到ctl中
		2.如果end&gt;old_end
			1.更新变量跳到again重新查找
				bytes -= old_end - offset;
				offset = old_end;
		3.如果end和old_end相同，直接跳到out_lock
		4.如果end&lt;old_end
			1.btrfs_add_free_space将info后端重新添加到block_group
		5.跳到out
3.remove_from_bitmap清除段中的bitmap
4.如果返回EAGAIN，跳到1重新查找其他段

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23090</x>
      <y>5060</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23050</x>
      <y>5540</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>remove_from_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23110</x>
      <y>5500</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23110</x>
      <y>5570</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22960</x>
      <y>5610</y>
      <w>390</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.search_bitmap查找从offset开始的bitmap段
2.如果没找到，或者start不是offset，返回EINVAL
3.bitmap_clear_bits将查找到的段清掉
4.更新循环变量
	*offset += search_bytes;
	*bytes -= search_bytes;
5.如果还有段需要清除
	1.读取bitmap_info的rb_next
	2.如果bitmap_info剩余空间不存在，通过free_bitmap将其释放
	3.如果没有next，返回EINVAL，如果next没有bitmap，返回EAGAIN
	4.再次通过search_bitmap以一小段尝试查找，如果没找到或者查找的start不同，返回EAGAIN
		(因为这里不知道是free_space还是bitmap，所以给caller决定)
	5.跳到1，重新循环
6.如果bitmap全部清空，free_bitmap将bitmap_info释放
7.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23380</x>
      <y>4840</y>
      <w>220</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_exclude_logged_extents</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23470</x>
      <y>4700</y>
      <w>400</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>380.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23480</x>
      <y>4870</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23360</x>
      <y>4910</y>
      <w>390</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.如果fs_info的MIXED_GROUPS没置上，返回0
2.循环读取eb中的slot
	1.读取slot的key
	2.如果不是BTRFS_EXTENT_DATA_KEY，继续下一个slot
	3.以btrfs_file_extent_item解析slot数据
	4.item.type是BTRFS_FILE_EXTENT_INLINE，继续下一个
	5.如果item.disk_byrenr是0，继续下一个
	6.设置key
		key.objectid =item.disk_bytenr
		key.offset = item.disk_num_bytes
	7.__exclude_logged_extent将段从block_group中预留
3.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23470</x>
      <y>5140</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__exclude_logged_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23540</x>
      <y>5100</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23550</x>
      <y>5170</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23370</x>
      <y>5210</y>
      <w>460</w>
      <h>190</h>
    </coordinates>
    <panel_attributes>1.btrfs_lookup_block_group查找block_group
2.cache_block_group缓存
3.如果不存在cache.caching_ctl，btrfs_remove_free_space将段从cache.free_space_ctl释放
4.如果存在
	1.如果段在caching_ctl-&gt;progress范围内，通过add_excluded_extent
		在freed_extents数组中设置该段为EXTENT_UPTODATE
	2.如果完全不在progress范围内，btrfs_remove_free_space将这段从cache.free_space_ctl删除
	3.否则
		1.btrfs_remove_free_space将progress之前的删除
		2.之后的add_excluded_extent在freed_extents数组中设置该段为EXTENT_UPTODATE
5.释放cache之后返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24050</x>
      <y>4790</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_write_tree_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23860</x>
      <y>4700</y>
      <w>270</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24050</x>
      <y>4860</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>filemap_fdatawrite_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24130</x>
      <y>4820</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24370</x>
      <y>4740</y>
      <w>240</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_wait_tree_block_writeback</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24490</x>
      <y>4770</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24370</x>
      <y>4810</y>
      <w>240</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>filemap_fdatawait_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24490</x>
      <y>4840</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24360</x>
      <y>4880</y>
      <w>330</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>1.__filemap_fdatawait_range
2.filemap_check_errors检查ENOSPC和EIO
	错误
3.检查ret的错误和2中的两种错误，返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24320</x>
      <y>4980</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__filemap_fdatawait_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24390</x>
      <y>4940</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24410</x>
      <y>5010</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24300</x>
      <y>5040</y>
      <w>360</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23870</x>
      <y>4700</y>
      <w>650</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;630.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>31680</x>
      <y>4330</y>
      <w>250</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_free_and_pin_reserved_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27450</x>
      <y>4270</y>
      <w>4350</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;4330.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>31700</x>
      <y>4400</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_free_reserved_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31800</x>
      <y>4360</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31800</x>
      <y>4430</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>31610</x>
      <y>4470</y>
      <w>420</w>
      <h>130</h>
    </coordinates>
    <panel_attributes>1.btrfs_lookup_block_group查找start所在的cache
2.如果pin置上，通过pin_down_extent将段空间设置到pinned_extents
3.否则
	1.如果root的DISCARD置上，通过btrfs_discard_extent
	2.btrfs_add_free_space将段释放给cache
	3.btrfs_update_reserved_bytes更新cache和space_info的reserved
4.释放block_group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>31570</x>
      <y>4620</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_discard_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31650</x>
      <y>4590</y>
      <w>90</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>31520</x>
      <y>4690</y>
      <w>340</w>
      <h>230</h>
    </coordinates>
    <panel_attributes>1.btrfs_map_block
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31650</x>
      <y>4650</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>31520</x>
      <y>4940</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_map_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>31510</x>
      <y>5000</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_map_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31580</x>
      <y>4910</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31570</x>
      <y>4970</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>31430</x>
      <y>5070</y>
      <w>380</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>1.通过lookup_extent_mapping搜索完全包含段的em
	如果没找到，返回EINVAL，如果logical不在em范围内，返回EINVAL
2.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31560</x>
      <y>5030</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>31980</x>
      <y>4630</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_update_reserved_bytes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31980</x>
      <y>4590</y>
      <w>130</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>31880</x>
      <y>4700</y>
      <w>430</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>1.如果不是RESERVE_FREE
	1.如果cache是readonly，返回EAGAIN
	2.reserve bytes
		cache-&gt;reserved += num_bytes;
		space_info-&gt;bytes_reserved += num_bytes;
	3.如果RESERVE_ALLOC
		space_info-&gt;bytes_may_use -= num_bytes
	4.如果delalloc
		cache-&gt;delalloc_bytes += num_bytes
2.如果是free
	1.如果cache是readonly
		space_info-&gt;bytes_readonly += num_bytes
	2.释放reserve
		cache-&gt;reserved -= num_bytes;
		space_info-&gt;bytes_reserved -= num_bytes;
	3.如果delalloc
		cache-&gt;delalloc_bytes -= num_bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32070</x>
      <y>4660</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>28380</x>
      <y>3870</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>walk_up_log_tree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28430</x>
      <y>3900</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>28270</x>
      <y>3940</y>
      <w>380</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.遍历level
	1.如果该level还有数据没处理完，返回0，让caller循环处理
	2.如果该level已经处理完
		1.wc-&gt;process_func处理该level上的eb
		2.如果wc-&gt;free
			1.clean_tree_block提交dirty_io
			2.btrfs_wait_tree_block_writeback等待
			3.btrfs_free_and_pin_reserved_extent释放reserved的bytes
		3.free_extent_buffer将本层eb释放
			path-&gt;nodes[*level] = NULL;
			*level = i + 1;
2.返回1，表示root的所有eb都处理完成
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>30070</x>
      <y>3510</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_read_fs_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30130</x>
      <y>3370</y>
      <w>180</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30110</x>
      <y>3540</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>29990</x>
      <y>3580</y>
      <w>320</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.btrfs_read_tree_root读取root
2.如果不是BTRFS_TREE_LOG_OBJECTID
	1.将root.state的BTRFS_ROOT_REF_COWS置上
	2.btrfs_check_and_init_root_item设置root_item
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>30770</x>
      <y>3520</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_read_fs_root_no_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30540</x>
      <y>3370</y>
      <w>350</w>
      <h>170</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30860</x>
      <y>3550</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>30650</x>
      <y>3670</y>
      <w>440</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.查看location-&gt;objectid是否是特定的root，如果是直接返回
2.again
	1.通过btrfs_lookup_fs_root根据rootid在fs_info-&gt;fs_roots_radix中查找
	2.如果找到
		1.如果需要check_ref，root_item.refs不能为0
		2.返回root
	3.否则通过btrfs_read_fs_root读取磁盘中的root信息，如果有check_ref，需要检查root_item.refs
	4.btrfs_init_fs_root初始化root
	5.btrfs_search_slot在tree_root中查找BTRFS_ORPHAN_OBJECTID，其offset指向rootid
		如果正好找到将root.state的BTRFS_ROOT_ORPHAN_ITEM_INSERTED置上
	6.btrfs_insert_fs_root将root插入fs_roots_radix中
3.返回root
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>30800</x>
      <y>3590</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_get_fs_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30860</x>
      <y>3620</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>30760</x>
      <y>3890</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_init_fs_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30800</x>
      <y>3860</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30810</x>
      <y>3920</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>30720</x>
      <y>3960</y>
      <w>340</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>1.申请root-&gt;free_ino_ctl，root-&gt;free_ino_pinned
	和root-&gt;subv_writers
2.btrfs_init_free_ino_ctl初始化free_ino_ctl和free_ino_pinned
	ctl-&gt;unit = 1
	ctl-&gt;op = &amp;free_ino_op
	pinned-&gt;unit = 1
	pinned-&gt;op = &amp;pinned_free_ino_op
3.获取root-&gt;anon_dev
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>31080</x>
      <y>3890</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_insert_fs_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31020</x>
      <y>3860</y>
      <w>150</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>31080</x>
      <y>3960</y>
      <w>330</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.radix_tree_preload查看内存池radix_tree_preloads是否
	需要申请内存
2.将root按照rootid插入到fs_roots_radix中
3.如果正确插入，将root.state的BTRFS_ROOT_IN_RADIX置上

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31160</x>
      <y>3920</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28060</x>
      <y>3830</y>
      <w>400</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>32880</x>
      <y>3540</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>fixup_inode_link_counts</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32980</x>
      <y>3570</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>32260</x>
      <y>3790</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_del_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32320</x>
      <y>3760</y>
      <w>650</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>630.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32330</x>
      <y>3820</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>32280</x>
      <y>3930</y>
      <w>320</w>
      <h>410</h>
    </coordinates>
    <panel_attributes>1.计算要删除的dsize
2.如果slot之后的没有全部删完
	1.memmove_extent_buffer将后面的数据移到删除的要删除的位置
	2.更新后面slot的offset
	3.memmove_extent_buffer将后面slot移到要删除的位置
注：这里处理后，相当于把要删除的部分平移到最后
3.btrfs_set_header_nritems重新设置leaf的nritems
4.如果leaf中的slot完全被删完
	1.如果leaf是root，将其level设置为0
	2.否则
		1.clean_tree_block处理dirty的eb
		2.btrfs_del_leaf
5.如果没删完
	1.如果是最slot 0开始删，通过fixup_low_keys根据最新的slot 0
		修复父node的key
	2.如果leaf所使用的空间不到1/3
		1.push_leaf_left将leaf的数据向左leaf迁移
		2.如果leaf还剩内容，通过push_leaf_right向右leaf迁移
		3.如果leaf被清空
			1.path-&gt;slots[1] = slot
			2.btrfs_del_leaf删除leaf
			3.free_extent_buffer释放leaf
			4.ret=0
		4.如果leaf还在path中，标记leaf dirty，并释放leaf
	3.否则，btrfs_mark_buffer_dirty标记leafdirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>32280</x>
      <y>3860</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_del_items</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32350</x>
      <y>3890</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>32350</x>
      <y>4370</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_del_leaf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32410</x>
      <y>4330</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>32780</x>
      <y>3610</y>
      <w>420</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.循环
	1.btrfs_search_slot循环搜寻BTRFS_TREE_LOG_FIXUP_OBJECTID
	2.根据返回值调整slot
	3.找到slot的objectid和type要和可以完全一致
	4.btrfs_del_item将path中的slot及其数据删除
	5.read_one_inode读取inode，inode号是找到slot的key.offset
	6.fixup_inode_link_count
	7.再次从后向前搜寻其他inode
2.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33160</x>
      <y>3760</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>33250</x>
      <y>3780</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>fixup_inode_link_count</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33350</x>
      <y>3810</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>33240</x>
      <y>3850</y>
      <w>420</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.count_inode_refs统计索引inode对应的BTRFS_INODE_REF_KEY
2.count_inode_extrefs统计inode对应的ext_ref
3.nlink为ref和ext_ref的和
4.如果nlink和inode-&gt;i_nlink不同
	1.set_nlink设置inode-&gt;i_nlink
	2.btrfs_update_inode
5.BTRFS_I(inode)-&gt;index_cnt = (u64)-1
6.如果inode-&gt;i_nlink为0
	1.如果是dir
		1.replay_dir_deletes删除root中的BTRFS_DIR_ITEM_KEY和BTRFS_DIR_INDEX_KEY
	2.insert_orphan_item插入一个空白的BTRFS_ORPHAN_ITEM_KEY
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>32750</x>
      <y>4100</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>count_inode_refs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32800</x>
      <y>4040</y>
      <w>540</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32800</x>
      <y>4130</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>32730</x>
      <y>4170</y>
      <w>280</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.循环向后查找inode对应ref的个数
	1.btrfs_search_slot根据inode号，搜索BTRFS_INODE_REF_KEY
		并根据ret调整slot
	2.process_slot：
		1.如果slot的key不是搜索的，退出循环
		2.循环处理slot对应的数据(btrfs_inode_ref+name)
			1.以btrfs_inode_ref方式解析数据
			2.统计数据中name的个数nlink
		3.如果key.offset为0，退出循环
		4.跳到process_slot，继续遍历这个offset对应的slot，直到slot遍历完成
			path-&gt;slots[0]--
		5.key.offset--
2.返回nlink
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>33030</x>
      <y>4100</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>count_inode_extrefs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33090</x>
      <y>4040</y>
      <w>260</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33100</x>
      <y>4130</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>33020</x>
      <y>4170</y>
      <w>290</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.循环从0向前开始查找inode对应extref的个数
	1.btrfs_find_one_extref查找inode对应的BTRFS_INODE_EXTREF_KEY
	2.统计slot数据对应extref个数
	3.offset递增，继续循环查找
2.返回nlink
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>33090</x>
      <y>4290</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_find_one_extref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33150</x>
      <y>4260</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33160</x>
      <y>4320</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>33060</x>
      <y>4360</y>
      <w>300</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot搜寻inode对应的BTRFS_INODE_EXTREF_KEY
2.循环
	1.如果leaf遍历完成，btrfs_next_leaf继续遍历下一个leaf
		如果遍历完成，退出循环
	2.slot对应的inode号和type要是规定的
	3.以btrfs_inode_extref方式解析slot对应的数据
		返回对应的extref和found_key.offset，并退出循环
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>33390</x>
      <y>4090</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_update_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33460</x>
      <y>4120</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>33350</x>
      <y>4160</y>
      <w>340</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>System
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33370</x>
      <y>4040</y>
      <w>110</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>33720</x>
      <y>4090</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>insert_orphan_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33640</x>
      <y>4040</y>
      <w>190</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33790</x>
      <y>4120</y>
      <w>100</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ino为offset</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>33730</x>
      <y>4160</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_insert_orphan_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33800</x>
      <y>4250</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>33740</x>
      <y>4220</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_insert_empty_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33810</x>
      <y>4190</y>
      <w>220</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
BTRFS_ORPHAN_OBJECTID</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>33740</x>
      <y>4290</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_insert_empty_items</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33820</x>
      <y>4320</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>33710</x>
      <y>4360</y>
      <w>300</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>1.统计要插入的total_data，以及total_size(total_data+管理结构)
2.btrfs_search_slot搜寻key
3.setup_items_for_insert将path中slot和数据区预留出来
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>33780</x>
      <y>4460</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>setup_items_for_insert</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33850</x>
      <y>4420</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33860</x>
      <y>4490</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>33700</x>
      <y>4530</y>
      <w>360</w>
      <h>210</h>
    </coordinates>
    <panel_attributes>1.如果要从slot 0开始插入，fixup_low_keys将第一个要插入的key向上修复
2.如果leaf的空间不足，bug
3.如果不是从最后一个item插入
	1.检查其插入的位置
	2.重新设置要移动item(slot之后的item)的offset
	3.memmove_extent_buffer向后移动slot之后的item
		并且也将其对应的数据也移动
4.设置插入item的offset和size
5.重新更新leaf的nritems
6.btrfs_mark_buffer_dirty标记leaf dirty
7.如果leaf的空间不足，报错
注：这里并没有更新数据
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30550</x>
      <y>3370</y>
      <w>2420</w>
      <h>190</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2400.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>25150</x>
      <y>4360</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>.wc-&gt;process_func
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25210</x>
      <y>4270</y>
      <w>2040</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2020.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25200</x>
      <y>4390</y>
      <w>2120</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>27240</x>
      <y>4430</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>replay_one_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>32280</x>
      <y>4440</y>
      <w>280</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.del_ptr删除leaf的父slot
2.root_sub_used更新root_item.size
3.extent_buffer_get递增leaf的计数
4.btrfs_free_tree_block释放leaf的空间
5.free_extent_buffer_stale释放leaf
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32400</x>
      <y>4400</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>32360</x>
      <y>4560</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_free_tree_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32410</x>
      <y>4520</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32420</x>
      <y>4590</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>32320</x>
      <y>4630</y>
      <w>460</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.如果不是BTRFS_TREE_LOG_OBJECTID，btrfs_add_delayed_tree_ref
	在trans中添加指向root中eb的ref(BTRFS_DROP_DELAYED_REF)
2.如果当前trans和eb.gen相同
	1.如果不是BTRFS_TREE_LOG_OBJECTID，check_ref_cleanup清除ref
		如果返回0，跳到out
	2.btrfs_lookup_block_group搜寻cache
	3.如果eb的BTRFS_HEADER_FLAG_WRITTEN置上
		1.pin_down_extent将段加入pinned_extents中
		2.释放cache后，跳到out
	4.btrfs_add_free_space将段添加到block_group的free_space
	5.btrfs_update_reserved_bytes释放段的reserved
	6.pin = 0
3.如果pin置上
	1.add_pinned_bytes增加对应space_info.total_bytes_pinned的计数
4.清除eb的EXTENT_BUFFER_CORRUPT标记
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>32500</x>
      <y>4900</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>check_ref_cleanup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32560</x>
      <y>4870</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32540</x>
      <y>4930</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>32410</x>
      <y>4970</y>
      <w>340</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.btrfs_find_delayed_ref_head在红黑树delayed_refs中找到对应的head_ref
2.如果head_ref不存在，或者为空，跳到out
3.如果存在extent_op
	1.如果must_insert_reserved没置上，跳到out
	2.btrfs_free_delayed_extent_op释放extent_op
		head-&gt;extent_op = NULL
4.将head_ref从红黑树中删除
	1.head-&gt;node.in_tree = 0;
	2.rb_erase
	3.delayed_refs-&gt;num_entries--
		delayed_refs-&gt;num_heads--
	4.processing为0时
		delayed_refs-&gt;num_heads_ready--
	5.head-&gt;processing = 0
5.如果must_insert_reserved置上，返回1，否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>32810</x>
      <y>4550</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>free_extent_buffer_stale</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>32800</x>
      <y>4620</y>
      <w>290</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.如果eb不存在，直接返回
2.将eb的EXTENT_BUFFER_STALE置上
3.如果eb.ref只有2个，并且不在io，EXTENT_BUFFER_TREE_REF置上
	1.EXTENT_BUFFER_TREE_REF清除
	2.递减eb.ref
4.release_extent_buffer释放eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32900</x>
      <y>4580</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32550</x>
      <y>4520</y>
      <w>370</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>27120</x>
      <y>4500</y>
      <w>390</w>
      <h>380</h>
    </coordinates>
    <panel_attributes>1.btrfs_read_buffer读取eb
2.如果不是leaf，直接返回0
3.遍历eb的所有slot
	1.如果type是BTRFS_INODE_ITEM_KEY，并且wc处于LOG_WALK_REPLAY_INODES
		1.以btrfs_inode_item方式解析slot数据(key.objectid存储ino)
		2.replay_xattr_deletes在log中没找到就删除replay_dest中的xattr，否则不做处理
		3.如果inode_item.mode是dir
			1.replay_dir_deletes对于log中没记录的，在wc-&gt;replay_dest中删除
			2.overwrite_item用eb中的数据覆盖root.key中的数据
		4.如果eb.inode_item是reg，insert_orphan_item插入一个item
		5.link_to_fixup_dir插入一个orphan_item指向inode
	2.如果key.type是BTRFS_DIR_INDEX_KEY，并且处于LOG_WALK_REPLAY_DIR_INDEX
		通过replay_one_dir_item遍历eb的slot i的
	3.如果没到LOG_WALK_REPLAY_ALL，继续下一个循环
	4.如果是LOG_WALK_REPLAY_ALL
		1.如果是BTRFS_XATTR_ITEM_KEY，通过overwrite_item用eb中的数据覆盖root中slot i的数据
		2.如果是BTRFS_INODE_REF_KEY，或者BTRFS_INODE_EXTREF_KEY
			add_inode_ref删除log中没记录的ref，并添加对应key的inode_ref和dir_item
		3.如果是BTRFS_EXTENT_DATA_KEY，通过replay_one_extent删除inode中重合的extent，使用log中的item
			并复制log_root中的checksum
		4.如果BTRFS_DIR_ITEM_KEY，replay_one_dir_item根据inode是否存在对di进行增删
			如果不是index，因为没name，所以删除di，但是会保留inode(inode是独立于dir，两者通过inode_ref连接)
4.释放path，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27290</x>
      <y>4460</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24800</x>
      <y>4920</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>replay_xattr_deletes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24880</x>
      <y>4870</y>
      <w>2280</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2260.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24700</x>
      <y>4990</y>
      <w>370</w>
      <h>300</h>
    </coordinates>
    <panel_attributes>1.again
	1.btrfs_search_slot查找ino对应的BTRFS_XATTR_ITEM_KEY
2.process_leaf
	1.从path的slot遍历leaf
		1.slot对应的ino和type要和查找的相同
		2.以btrfs_dir_item方式解析slot数据
		3.遍历slot的数据
			1.根据di.name_len申请name
			2.read_extent_buffer读取name(紧跟着di)
			3.btrfs_lookup_xattr在log中搜寻dir_item(hash索引)
			注：之前的slot是在root中，这里又在log_root中搜寻
			4.如果没找到di
				1.btrfs_lookup_xattr再次在root中搜寻
				2.释放name
				3.btrfs_delete_one_dir_name将对应的item删除
				4.更新search_key，跳到again再次查找
			5.释放name，遍历下一个btrfs_dir_item
	2.如果btrfs_next_leaf找到下一个leaf，跳到process_leaf继续处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24860</x>
      <y>4950</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24630</x>
      <y>5320</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_lookup_xattr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24700</x>
      <y>5280</y>
      <w>50</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24680</x>
      <y>5350</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24610</x>
      <y>5390</y>
      <w>340</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot查找btrfs_name_hash，要正好找到
2.btrfs_match_dir_item_name找到name相同的dir_item
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24630</x>
      <y>5480</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_match_dir_item_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24720</x>
      <y>5430</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24720</x>
      <y>5510</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24600</x>
      <y>5550</y>
      <w>360</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.以btrfs_dir_item方式解析slot数据
2.verify_dir_item验证出错，返回NULL
3.依次处理slot的数据，直到找到和name相同的dir_item
4.如果没找到，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24740</x>
      <y>5650</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>verify_dir_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24790</x>
      <y>5620</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24790</x>
      <y>5680</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24620</x>
      <y>5720</y>
      <w>340</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.如果dir_item.type大于限制，返回1
2.默认name_len是BTRFS_NAME_LEN，在BTRFS_FT_XATTR时
	XATTR_NAME_MAX
3.dir_item.name_len不能大于namelen，否则返回1
4.dir_item的data_len+name_len不能大于限制，否则返回1
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25000</x>
      <y>5310</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_delete_one_dir_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25040</x>
      <y>5280</y>
      <w>50</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25090</x>
      <y>5340</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24970</x>
      <y>5380</y>
      <w>350</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.如果slot数据的长度和di描述的长度一致，通过btrfs_del_item
	将这个slot删除
2.否则
	1.memmove_extent_buffer将超过di规定的数据长度覆盖
	2.btrfs_truncate_item
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25070</x>
      <y>5520</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_truncate_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25130</x>
      <y>5480</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24990</x>
      <y>5590</y>
      <w>340</w>
      <h>320</h>
    </coordinates>
    <panel_attributes>1.如果前后item的长度一致，直接返回
2.调整slot~nritems的offset
3.如果from_end置上，memmove_extent_buffer将slot~
	nritems的数据向后移
注：1.caller已经将slot剩余的数据前移了，这里只要连着slot
	的数据一起移动就好了
	2.from_end表示从后面开始截取，保留前面数据
		否则是从前面截取，保留后面数据
4.否则
	1.如果slot是BTRFS_EXTENT_DATA_KEY，要保留前面的数据
		1.以btrfs_file_extent_item方式解析slot数据，因为之前
			slot的offset已经调整过，现在将其调整到原来原来的位置
		2.如果fi.extent_type是BTRFS_FILE_EXTENT_INLINE
			将fi.bytenr之前的数据移到新的offset
	2.memmove_extent_buffer将(slot,nritem-1]的数据移到新的offset
	3.重新设置slot.key,如果是slot 0，还要通过fixup_low_keys修复
		上层的key
5.btrfs_set_item_size重新设置slot的size
6.btrfs_mark_buffer_dirty标记leaf dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25120</x>
      <y>5550</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25410</x>
      <y>4920</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>replay_dir_deletes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25460</x>
      <y>4870</y>
      <w>1730</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1710.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25460</x>
      <y>4950</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>25310</x>
      <y>4990</y>
      <w>370</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>1.read_one_inode读取inode，如果没找到返回0
2.again
	1.循环
		1.如果del_all，range_end=-1，否则通过find_dir_range
			确定range_end
		2.循环删除range_start~range_end
			1.btrfs_search_slot查找dirid(BTRFS_DIR_ITEM_KEY)
			2.如果不在该leaf，btrfs_next_leaf获取下一个leaf
			3.检查dirid和type，如果不对，跳到next_type
			4.不能超过range_end
			5.check_item_in_log对log中没有的inode，在root中做删除
			6.如果出错，跳到out
			7.如果遍历到最后，退出循环
			8.否则更新循环变量
				dir_key.offset = found_key.offset + 1
		3.如果rang_end到最后，退出循环
		4.否则更新range_end继续循环
			range_start = range_end + 1
3.next_type
	1.如果搜寻的是BTRFS_DIR_LOG_ITEM_KEY
		换成BTRFS_DIR_INDEX_KEY，跳到again，继续遍历
4.否则释放path，dir后返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25360</x>
      <y>5300</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_dir_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25410</x>
      <y>5260</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25410</x>
      <y>5330</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>25340</x>
      <y>5370</y>
      <w>310</w>
      <h>270</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot搜寻dirid，并根据ret调整slot
2.检查key.type和dirid
3.以btrfs_dir_log_item方式解析slot数据
4.如果key.offset&lt;start_ret&lt;item.log_end，跳到out，返回0
	*start_ret = key.offset;
	*end_ret =  item.log_end;
5.next
	1.如果slot不在当前leaf
		1.btrfs_next_leaf选取下一个leaf
	2.否则
		path-&gt;slots[0]++
	3.检查下一个slot的type和dirid
	4.以btrfs_dir_log_item方式解析数据，并返回
		*start_ret = key.offset;
		*end_ret = item.log_end;
6.如果找到，返回0，否则返回1，或者错误
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25700</x>
      <y>5290</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>check_item_in_log</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25630</x>
      <y>5260</y>
      <w>150</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25750</x>
      <y>5320</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>25660</x>
      <y>5360</y>
      <w>360</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>1.again
	1.遍历slot的数据区
		1.以btrfs_dir_item方式解析数据，verify_dir_item验证di
			如果出错，EIO跳到out
		2.根据di.name_len申请name，并通过read_extent_buffer
			将eb中的数据读到name中
		3.确定log_di
			1.如果dir是BTRFS_DIR_ITEM_KEY，btrfs_lookup_dir_item
				在log中读取
			2.如果是BTRFS_DIR_INDEX_KEY，通过btrfs_lookup_dir_index_item
				在log中读取(offset为其索引号)
		4.如果没有获取log_di，或者出错
			1.btrfs_dir_item_key_to_cpu读取di的key
			2.read_one_inode获取dir的inode(location.objectid为ino)
			3.link_to_fixup_dir在root中增加一个orphan_item
				inc_nlink(inode)
			4.btrfs_unlink_inode释放name对inode的引用
			5.如果正确返回，btrfs_run_delayed_items
			6.释放name，node
			7.再次查找dir_key,如果还有，跳到again，重新遍历
			8.否则跳到out，返回0
		5.如果出错，释放name，返回错误
		6.否则遍历下一个di
2.out，释放path，然后返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25420</x>
      <y>5670</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_lookup_dir_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25670</x>
      <y>5670</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_lookup_dir_index_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25470</x>
      <y>5630</y>
      <w>280</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25480</x>
      <y>5700</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>25350</x>
      <y>5740</y>
      <w>320</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot在root中搜索btrfs_name_hash
2.btrfs_match_dir_item_name遍历slot数据，找到
	name相同的dir_item
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25770</x>
      <y>5630</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25760</x>
      <y>5700</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>25680</x>
      <y>5740</y>
      <w>290</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot搜寻索引key.offset
2.btrfs_match_dir_item_name遍历slot获取
	name相同的dir_item
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25960</x>
      <y>5630</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>26020</x>
      <y>5650</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>link_to_fixup_dir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26070</x>
      <y>5680</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>25980</x>
      <y>5720</y>
      <w>310</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.btrfs_insert_empty_item在root的key处插入一个item
2.如果正确返回
	1.递增inode.i_nlink
	2.btrfs_update_inode
3.如果EEXIST，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>26360</x>
      <y>5650</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_unlink_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>26310</x>
      <y>5720</y>
      <w>310</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.__btrfs_unlink_inode删除name对应的indoe
2.如果成功，
	1.drop_nlink递减inode.i_nlink
	2.btrfs_update_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26420</x>
      <y>5680</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>26250</x>
      <y>5830</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_unlink_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26320</x>
      <y>5790</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26310</x>
      <y>5860</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>26170</x>
      <y>5900</y>
      <w>350</w>
      <h>260</h>
    </coordinates>
    <panel_attributes>1.btrfs_lookup_dir_item在root中找到dir的name_hash
2.btrfs_delete_one_dir_name将找到的di删除
3.如果存在inode.dir_index,通过btrfs_delayed_delete_inode_ref
	缓冲删除dir，如果正确返回，跳到skip_backref
4.btrfs_del_inode_ref删除dir_ino/ino下命名为name的ref
5.skip_backref
	1.btrfs_delete_delayed_dir_index
	2.btrfs_del_inode_ref_in_log删除在log中的node
	3.btrfs_del_dir_entries_in_log删除log中的name和index
6.err
	1.调整内存中的dir和inode
		btrfs_i_size_write(dir, dir-&gt;i_size - name_len * 2);
		inode_inc_iversion(inode);
		inode_inc_iversion(dir);
		inode-&gt;i_ctime = dir-&gt;i_mtime = dir-&gt;i_ctime = CURRENT_TIME;
	2.btrfs_update_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25400</x>
      <y>6190</y>
      <w>230</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_delayed_delete_inode_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25500</x>
      <y>6150</y>
      <w>740</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>720.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25500</x>
      <y>6220</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>25350</x>
      <y>6260</y>
      <w>350</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.如果log_root_recovering，返回EAGAIN
2.btrfs_get_or_create_delayed_node获取delayed_node
3.如果delayed_node的BTRFS_DELAYED_NODE_DEL_IREF置上，跳到
	release_node
4.将delayed的BTRFS_DELAYED_NODE_DEL_IREF置上
	delayed_node-&gt;count++;
	fs_info-&gt;delayed_root-&gt;items++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25390</x>
      <y>6410</y>
      <w>250</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_get_or_create_delayed_node</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25500</x>
      <y>6370</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25500</x>
      <y>6440</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>25340</x>
      <y>6480</y>
      <w>380</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.again
	1.btrfs_get_delayed_node获取inode，如果成功获取，返回
	2.申请inode，并通过btrfs_init_delayed_node初始化
		node.refs+=2
	3.radix_tree_preload填充线程池
	4.radix_tree_insert插入node
	5.返回node
		btrfs_inode-&gt;delayed_node = node;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25430</x>
      <y>6650</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_get_delayed_node</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25500</x>
      <y>6610</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25510</x>
      <y>6680</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>25330</x>
      <y>6720</y>
      <w>370</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.获取btrfs_inode-&gt;delayed_node，如果存在，直接返回
2.否则在delayed_nodes_tree中查找ino，如果找到
	1.如果delayed_node存在
		1.递增node-&gt;refs，并返回node
	2.如果不存在
		1.btrfs_inode-&gt;delayed_node = node;
		2.node.refs+=2
		3.返回node
3.返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25740</x>
      <y>6200</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_del_inode_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25810</x>
      <y>6150</y>
      <w>410</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25810</x>
      <y>6230</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>25730</x>
      <y>6270</y>
      <w>350</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot找ino指向ref的slot
2.如果返回1，search_ext_refs置上，跳到out
3.find_name_in_backref找指向inode并且name相同的ref
	如果没找到，search_ext_refs置上，并且跳到out
4.通过index返回ref.index
5.如果ref长度符合预期，通过btrfs_del_item将其删除，跳到out
6.否则将item的sub_item_len之后的数据截留
7.out
	1.如果search_ext_refs置上，通过btrfs_del_inode_extref
		查看是否有extref可以删除
注：如果是同一目录，通过offset=ref_id查找
	否则查找ext_ref,其parent_objectid和ref_id要一致
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25800</x>
      <y>6500</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_name_in_backref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25870</x>
      <y>6460</y>
      <w>50</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25870</x>
      <y>6530</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>25730</x>
      <y>6570</y>
      <w>350</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.遍历path中slot的数据，找到name相同的btrfs_inode_ref
	如果找到返回1，否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>26140</x>
      <y>6500</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_del_inode_extref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26030</x>
      <y>6460</y>
      <w>200</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>26110</x>
      <y>6570</y>
      <w>350</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot查找指向inode的btrfs_extref_hash
2.btrfs_find_name_in_ext_backref如果没找到对应的extref
	返回EROFS
3.index返回extref.index
4.如果size完全相同，通过btrfs_del_item将item删除，否则将item
	del_len后的数据截留
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26210</x>
      <y>6530</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>26180</x>
      <y>6710</y>
      <w>230</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_find_name_in_ext_backref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26270</x>
      <y>6670</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26290</x>
      <y>6740</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>26120</x>
      <y>6780</y>
      <w>370</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>1.遍历path的slot数据，以btrfs_inode_extref方式解析数据
	如果找到extref.parent_objectid相同，并且name相同的
	extref，返回1
2.否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>26380</x>
      <y>6190</y>
      <w>220</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_delete_delayed_dir_index</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26350</x>
      <y>6150</y>
      <w>160</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26490</x>
      <y>6220</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>26340</x>
      <y>6260</y>
      <w>340</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.btrfs_get_or_create_delayed_node获取delayed_inode
2.btrfs_delete_delayed_insertion_item删除已有的item，
	如果删除，跳到end
3.btrfs_alloc_delayed_item申请item
	item-&gt;key = item_key
4.btrfs_delayed_item_reserve_metadata更新item-&gt;bytes_reserved
5.__btrfs_add_delayed_deletion_item将item插入红黑树中
	action为BTRFS_DELAYED_DELETION_ITEM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>26510</x>
      <y>6430</y>
      <w>270</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_delete_delayed_insertion_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26620</x>
      <y>6390</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26630</x>
      <y>6460</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>26490</x>
      <y>6500</y>
      <w>360</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.__btrfs_lookup_delayed_insertion_item在delayed_node.ins_root
	中查找key对应的item
2.btrfs_delayed_item_release_metadata释放fs_info-&gt;delayed_block_rsv
	中的item.bytes_reserved
3.btrfs_release_delayed_item在红黑树中释放delayed_item
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>26860</x>
      <y>6180</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_del_inode_ref_in_log</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26950</x>
      <y>6210</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>26790</x>
      <y>6250</y>
      <w>320</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.如果logged_trans低于当前trans，返回0
2.join_running_log_trans递增log_writers
3.btrfs_del_inode_ref删除log对name ino的引用
4.btrfs_end_log_trans递减log_writers,如果没有了
	唤醒log_writer_wait
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>27230</x>
      <y>6180</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_del_dir_entries_in_log</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>27160</x>
      <y>6250</y>
      <w>380</w>
      <h>190</h>
    </coordinates>
    <panel_attributes>1.如果logged_trans低于当前trans，返回0
2.join_running_log_trans递增log_writers
3.btrfs_lookup_dir_item在inode找name_hash
4.btrfs_delete_one_dir_name将找到的di删除
5.btrfs_lookup_dir_index_item找offset为index的dir_index
	并通过btrfs_delete_one_dir_name将其删除
6.如果有删除数据
	1.btrfs_search_slot搜寻dir_ino对应的inode
	2.以btrfs_inode_item方式解析slot数据，调整inode.i_size
		btrfs_mark_buffer_dirty标记slot 0 dirty
7.btrfs_end_log_trans递减log_writers,并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27320</x>
      <y>6210</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26370</x>
      <y>6150</y>
      <w>610</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;590.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26380</x>
      <y>6150</y>
      <w>970</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;950.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25970</x>
      <y>5630</y>
      <w>470</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13070</x>
      <y>6390</y>
      <w>280</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.通过kmem_cache_alloc申请extent_state
2.初始化
	state-&gt;state = 0;
	state-&gt;private = 0;
	state-&gt;leak_list加入到链表states
	state-&gt;refs=1
	初始化state-&gt;wq
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11070</x>
      <y>3320</y>
      <w>4420</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;4400.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>11950</x>
      <y>3670</y>
      <w>2220</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2200.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9090</x>
      <y>2550</y>
      <w>10350</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10330.0;200.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>9100</x>
      <y>2550</y>
      <w>10880</w>
      <h>210</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10860.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4660</x>
      <y>1970</y>
      <w>17450</w>
      <h>130</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
retry_root_backup
设置</panel_attributes>
    <additional_attributes>10.0;10.0;17430.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>26390</x>
      <y>4920</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>overwrite_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26420</x>
      <y>4870</y>
      <w>790</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>770.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26440</x>
      <y>4950</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>26280</x>
      <y>4990</y>
      <w>420</w>
      <h>340</h>
    </coordinates>
    <panel_attributes>1.如果不是BTRFS_TREE_LOG_OBJECTID，将overwrite_root置上
2.btrfs_search_slot搜寻key
3.如果能正好找到
	1.如果root中的key和eb中slot size不一样，跳到insert
	2.如果eb的size是0，释放path，并返回0
	3.read_extent_buffer读取eb slot数据和root中key的数据
		将两者对比，如果完全相同，释放path并返回0
	4.如果key是inode_item
		1.以btrfs_inode_item方式解析root slot数据和eb slot数据
		2.根据root_item.nbytes设置eb_item.nbytes
		3.如果eb.item是dir，将eb_item.size设置为0
4.如果找到high
	1.设置eb_item.nbytes=0
	2.如果eb_item是dir，设置eb_item.size=0
5.insert
	1.btrfs_insert_empty_item在root中插入key的item
	2.如果exist，或者overflow
		1.根据其插入长度和已有的长度使用btrfs_truncate_item进行截断
			或者通过btrfs_extend_item进行扩展
		2.其他错误即返回
	3.如果是inode_item并且exist
		1.如果eb.slot.gen是0
			1.如果eb.slot和root.slot都是reg，并且eb.slot的inode.size不为0
				root.slot.item.ino_size=eb.slot.item.ino_size
			2.跳到no_copy
		2.如果overwrite_root，并且两者都是dir
			1.save_old_i_size置上
			2.saved_i_size获取dst_item.size
	4.copy_extent_buffer复制eb数据到root
	5.如果save_old_i_size，将dst_item使用原来的size
	6.如果是inode_item
		1.如果dst_item.gen是0，设置为当前的trans
6.no_copy
	1.释放path中的eb，path并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>26420</x>
      <y>5360</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_extend_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26480</x>
      <y>5320</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>26490</x>
      <y>5390</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>26300</x>
      <y>5430</y>
      <w>450</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.如果leaf没有足够的空间，报错
2.检查slot不能超过leaf的nritems
3.设置slot~nritem的slot.offset,并memmove_extent_buffer复制对应的slot数据
4.增加slot 扩充的size
5.如果没有足够的空间，报错
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>27360</x>
      <y>4940</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>replay_one_dir_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27420</x>
      <y>4970</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>27250</x>
      <y>5020</y>
      <w>420</w>
      <h>170</h>
    </coordinates>
    <panel_attributes>1.以btrfs_dir_item方式循环遍历eb.slot的数据
	1.verify_dir_item验证di
	2.replay_one_name检查root中的dir_item是否和eb，如果不一致
		对dir_item做添加或者删除
	3.更新循环变量
		ptr = (unsigned long)(di + 1);
		ptr += name_len
	4.如果做添加，并且di.type不是BTRFS_FT_DIR
		1.link_to_fixup_dir在root中添加orphan指向di_key.objectid
2.释放path，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>27400</x>
      <y>5220</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>replay_one_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27450</x>
      <y>5180</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27450</x>
      <y>5250</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>27290</x>
      <y>5290</y>
      <w>450</w>
      <h>440</h>
    </coordinates>
    <panel_attributes>1.read_one_inode读取inode
2.申请name，从eb中读取
3.btrfs_lookup_inode查找di中对应的key，只有返回0才找到
4.如果key.type是BTRFS_DIR_ITEM_KEY，通过btrfs_lookup_dir_item
	在root找查找dir/name的dst_di，否则如果是BTRFS_DIR_INDEX_KEY
	通过btrfs_lookup_dir_index_item在root中查找
5.如果出错
	1.如果不是BTRFS_DIR_INDEX_KEY，跳到out
	2.否则跳到insert
6.如果dst_di和eb.di完全一致，update_size置0，跳到out
7.如果不一致
	1.如果root中不存在eb.di，跳到out
	2.drop_one_dir_item在root中删除dst_di及对应的inode
	3.如果是BTRFS_DIR_INDEX_KEY，跳到insert
8.out
	1.如果正常安徽，update_size置上
		1.btrfs_i_size_write调整dir.i_size
		2.btrfs_update_inode
	2.释放name，dir
	3.正确，且需要name_added，返回1
9.inset
	1.如果在log_root中有name对应的log_key.objectid的ref和extref
		ret置0，update_size置false，跳到out
	2.insert_one_name插入dir_item和inode_ref
	3.如果不是ENOENT EEXIST，跳到out，返回错误
	4.如果正确，将name_added置上
	5.update_size置0，返回0，跳到out
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>27240</x>
      <y>5770</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_lookup_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>27190</x>
      <y>5840</y>
      <w>380</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot查找location
2.如果是BTRFS_ROOT_ITEM_KEY，需要查看low slot，如果找到和
	location的objectid和type一致，就返回0
3.直接返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27350</x>
      <y>5800</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>27640</x>
      <y>5760</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>drop_one_dir_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>27580</x>
      <y>5830</y>
      <w>370</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.获取di的location
2.读取di的name
3.read_one_inode读取location的inode
4.link_to_fixup_dir在root中添加一个orphan_item指向inode
5.btrfs_unlink_inode将name对应的dir/inode的link清掉
6.btrfs_run_delayed_items
7.释放name inode，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27730</x>
      <y>5790</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>28100</x>
      <y>5760</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>name_in_log_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28160</x>
      <y>5790</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>28030</x>
      <y>5830</y>
      <w>380</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.backref_in_log检查是否有name dirid相同的ref或者extref
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>28110</x>
      <y>5880</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>backref_in_log</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28160</x>
      <y>5850</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28160</x>
      <y>5910</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>28000</x>
      <y>5950</y>
      <w>410</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot在log中查找key
2.如果查找的是BTRFS_INODE_EXTREF_KEY，通过btrfs_find_name_in_ext_backref
	查找extref,如果找到置上match，跳到out
3.否则以btrfs_inode_ref循环解析path数据
	1.name_len和name相同时，match置上，跳到out
4.返回match
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>28080</x>
      <y>6090</y>
      <w>230</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_find_name_in_ext_backref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28180</x>
      <y>6050</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28180</x>
      <y>6120</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>28010</x>
      <y>6160</y>
      <w>320</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>1.以btrfs_inode_extref方式解析path对应的数据
	1.如果extref.parent_objectid和ref_id一致
	2.name一致
	3.通过extref_ret将extref返回，并返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>28620</x>
      <y>5760</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>insert_one_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28670</x>
      <y>5790</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>28530</x>
      <y>5830</y>
      <w>250</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.read_one_inode读取inode和dir
2.btrfs_add_link添加inode_ref和dir_item
3.释放inode和dir，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>28630</x>
      <y>5920</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_add_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28680</x>
      <y>5880</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28680</x>
      <y>5950</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>28530</x>
      <y>5990</y>
      <w>330</w>
      <h>380</h>
    </coordinates>
    <panel_attributes>1.确定key
	1.如果是BTRFS_FIRST_FREE_OBJECTID，key为root_key
	2.否则
		key.objectid = ino;
		key.type = BTRFS_INODE_ITEM_KEY;
		key.offset = 0;
2.增加ref
	1.如果是BTRFS_FIRST_FREE_OBJECTID，通过btrfs_add_root_ref添加
	2.如果add_backref置上，通过btrfs_insert_inode_ref添加
3.如果出错，即返回
4.btrfs_insert_dir_item插入dir_item
	1.如果EEXIST，EOVERFLOW，跳到fail_dir_item
	2.如果其他错，btrfs_abort_transaction，并返回
	3.btrfs_i_size_write调整parent的大小
	4.inode_inc_iversion递增parent version
	5.parent_inode-&gt;i_mtime = parent_inode-&gt;i_ctime = CURRENT_TIME
	6.btrfs_update_inode
	7.如果出错，btrfs_abort_transaction
	8.返回
5.fail_dir_item
	1.如果BTRFS_FIRST_FREE_OBJECTID，btrfs_del_root_ref删除ref
	2.如果add_backref，btrfs_del_inode_ref
	3.返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>28370</x>
      <y>6390</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_add_root_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>28640</x>
      <y>6400</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_insert_inode_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>28950</x>
      <y>6430</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_insert_dir_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28440</x>
      <y>6360</y>
      <w>140</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28420</x>
      <y>6420</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>28290</x>
      <y>6460</y>
      <w>310</w>
      <h>170</h>
    </coordinates>
    <panel_attributes>1.设置key (BTRFS_ROOT_BACKREF_KEY)
2.btrfs_insert_empty_item在tree_root中插入key
	大小为ref+name
3.以btrfs_root_ref方式解析slot数据
	1.设置ref.dirid ref.sequence ref.name_len
	2.write_extent_buffer填充name
	3.btrfs_mark_buffer_dirty标记leaf dirty
4.如果是BTRFS_ROOT_BACKREF_KEY
	1.调换objectid和offset，跳到1增加BTRFS_ROOT_REF_KEY
5.释放path，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28710</x>
      <y>6360</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28710</x>
      <y>6430</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>28620</x>
      <y>6470</y>
      <w>300</w>
      <h>410</h>
    </coordinates>
    <panel_attributes>1.设置key (BTRFS_INODE_REF_KEY)
2.插入item
	1.申请path，并设置
		path-&gt;leave_spinning = 1;
		path-&gt;skip_release_on_error = 1;
	2.btrfs_insert_empty_item在root中插入key，item长度是name+ref
	3.如果exist
		1.如果通过find_name_in_backref能在path中找到name，跳到out
		2.否则
			1.btrfs_extend_item调整增加item的len(此时old_data复制到了slot前面)
			2.根据参数设置新ref的name_len，index
				ptr指向新ref的name
	4.如果出错
		1.如果是EOVERFLOW
			1.find_name_in_backref如果能找到ref返回EEXIST，否则返回EMLINK
		2.跳到out
	5.如果正确
		1.设置ref的name_len,index 调整ptr指向name
	6.write_extent_buffer向ptr写name，btrfs_mark_buffer_dirty标记其dirty
3.out
	1.释放path
	2.如果返回EMLINK
		1.如果disk_super的BTRFS_FEATURE_INCOMPAT_EXTENDED_IREF置上
			通过btrfs_insert_inode_extref添加extref
	3.返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>28670</x>
      <y>6910</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_insert_inode_extref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28750</x>
      <y>6870</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28750</x>
      <y>6940</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>28600</x>
      <y>6980</y>
      <w>350</w>
      <h>270</h>
    </coordinates>
    <panel_attributes>1.插入item
	1.设置key BTRFS_INODE_EXTREF_KEY
	2.申请path
		path-&gt;leave_spinning = 1
	3.btrfs_insert_empty_item插入extref，
	4.如果返回EEXIST
		1.btrfs_find_name_in_ext_backref如果能找到name，跳到out
		2.否则btrfs_extend_item扩充item
			ret=0
	5.如果其他错误，跳到out
	6.extref指向扩充的数据
		1.设置extref.name_len index parent_objectid
		2.write_extent_buffer设置name
		3.btrfs_mark_buffer_dirty标记leaf dirty
2.out
	1.释放path，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28790</x>
      <y>6360</y>
      <w>250</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29020</x>
      <y>6460</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>28940</x>
      <y>6500</y>
      <w>330</w>
      <h>230</h>
    </coordinates>
    <panel_attributes>1.插入dir_item
	1.设置key BTRFS_DIR_ITEM_KEY
	2.申请path
		path-&gt;leave_spinning = 1
	3.insert_with_overflow插入dir_item
	4.如果返回EEXIST，跳到second_insert，否则跳到out_free
2.设置dir_item.location type data_len（0） name_len transid
3.通过write_extent_buffer写入name，btrfs_mark_buffer_dirty
	标记dirty
4.second_insert：
	1.如果root是tree_root，返回0，跳到out_free
	2.否则btrfs_insert_delayed_dir_index在delayed_inode中添加delayed_item
5.释放path，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>29050</x>
      <y>6760</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>insert_with_overflow</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29110</x>
      <y>6720</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29120</x>
      <y>6790</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>28970</x>
      <y>6830</y>
      <w>350</w>
      <h>130</h>
    </coordinates>
    <panel_attributes>1.btrfs_insert_empty_item插入item
2.如果返回EEXIST
	1.通过btrfs_match_dir_item_name找到path内name相同的di
	2.如果能找到，返回EEXIST，否则btrfs_extend_item增加data_size
		的item长度
3.如果出错，返回错误
4.返回插入的btrfs_dir_item
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>29390</x>
      <y>6760</y>
      <w>250</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_insert_delayed_dir_index</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>29340</x>
      <y>6830</y>
      <w>380</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.btrfs_get_or_create_delayed_node获取dir.delayed_node
2.btrfs_alloc_delayed_item申请并初始化delayed_item
3.设置delayed_item.key BTRFS_DIR_INDEX_KEY
4.设置delayed_item-&gt;data的transid data_len name_len type name
5.btrfs_delayed_item_reserve_metadata更新bytes_reserved
6.__btrfs_add_delayed_insertion_item选择delayed_node.ins_root插入delayed_item
	action为BTRFS_DELAYED_INSERTION_ITEM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29190</x>
      <y>6720</y>
      <w>330</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29510</x>
      <y>6790</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27310</x>
      <y>5720</y>
      <w>100</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27500</x>
      <y>5720</y>
      <w>240</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27510</x>
      <y>5720</y>
      <w>670</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27510</x>
      <y>5720</y>
      <w>1170</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27340</x>
      <y>4870</y>
      <w>90</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>28140</x>
      <y>4910</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>add_inode_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>28040</x>
      <y>4990</y>
      <w>320</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>1.根据key.type确定parent(ref在key.offset中，extref在data.parent_objectid)
	和inode_objectid = key-&gt;objectid;
	如果是extref，将log_ref_ver置上
2.read_one_inode读取parent和inode
3.遍历slot的数据
	1.如果是log_ref_ver
		1.extref_get_fields获取name，index parent_objextid
		2.如果没有dir，通过read_one_inode获取
	2.否则通过ref_get_fields获取name index
	3.inode_in_dir检查inode不在dir内
		1.如果不是search_done，通过__add_inode_ref删除inode_ref和dir_item
		2.btrfs_add_link在root中添加inode_ref和dir_item
		3.btrfs_update_inode
	4.更新循环变量
4.overwrite_item利用eb.slot中的数据覆盖root.key中对应slot的数据
5.释放path，name，dir，inode，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28190</x>
      <y>4940</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>27780</x>
      <y>5310</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>extref_get_fields</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27830</x>
      <y>5260</y>
      <w>340</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>27760</x>
      <y>5380</y>
      <w>290</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.以btrfs_inode_extref方式解析数据，
2.读取并返回其name，index和其parent_objextid

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27820</x>
      <y>5340</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>28160</x>
      <y>5300</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>inode_in_dir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28190</x>
      <y>5260</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>28080</x>
      <y>5370</y>
      <w>370</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.btrfs_lookup_dir_index_item查找指向index的dir_item
2.如果正确找到，如果dir_item的objectid和指定的不同，跳到out，
	如果出错，直接跳到out
3.btrfs_lookup_dir_item查找指向namehash的dir_item
4.如果正确找到，如果dir_item的objectid和指定的不同，跳到out
	如果出错，直接跳到out
5.如果通过index和namehash都能找到，将match置上
6.out：释放path，并返回match	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28210</x>
      <y>5330</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>28570</x>
      <y>5290</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__add_inode_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28630</x>
      <y>5320</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>28490</x>
      <y>5360</y>
      <w>360</w>
      <h>330</h>
    </coordinates>
    <panel_attributes>1.again
	1.btrfs_search_slot查找inode-&gt;parent的inode_ref
	2.如果正好找到
		1.如果找到root，直接返回1
		2.以btrfs_inode_ref方式遍历slot数据
			1.read_extent_buffer读取ref的name
			2.backref_in_log如果检查到log_root中没有name相同的node_ref
				1.inc_nlink递增inode.i_nlink
				2.btrfs_unlink_inode解除name对inode的link
				3.btrfs_run_delayed_items
				4.设置search_done，跳到again
			3.调整ptr
		3.设置search_done
		
	3.通过btrfs_lookup_inode_extref查找是name的extref
	4.如果找到
		1.以btrfs_inode_extref方式遍历path的数据
			1.如果parent_objectid不一致，跳到next
			2.read_extent_buffer读取extref的name
			3.如果backref_in_log检查到extref在log_root中不存在
				1.read_one_inode读取parent
				2.如果找到parent
					1.inc_nlink递增inode.i_nlink
					2.btrfs_unlink_inode接触name对inode的link
					3.btrfs_run_delayed_items
					4.设置search_done，跳到again
			4.next,遍历下一个extref
		2.置上search_done
注：上面会因为一个ref而检查整个slot的数据是否在log中
	5.btrfs_lookup_dir_index_item查找指向ref_index的di
		如果正确找到，通过drop_one_dir_item删除di
	6.通过btrfs_lookup_dir_item查找指向namehash的di
		如果正确找到，通过drop_one_dir_item删除di
2.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28300</x>
      <y>5260</y>
      <w>340</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>30820</x>
      <y>4880</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>replay_one_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30890</x>
      <y>4910</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>30720</x>
      <y>4950</y>
      <w>410</w>
      <h>610</h>
    </coordinates>
    <panel_attributes>1.以btrfs_file_extent_item方式解析eb.slot
2.查看item.type
	1.如果是BTRFS_FILE_EXTENT_REG或者BTRFS_FILE_EXTENT_PREALLOC
		1.读取item.num_bytes--&gt;nbytes
		2.extent_end = key-&gt;offset + nbytes
		3.如果item.disk_bytenr是0，nbytes = 0
	2.如果是BTRFS_FILE_EXTENT_INLINE
		1.nbytes=item.ram_bytes
		2.extent_end=key.offset+btrfs_file_extent_inline_len
	3.其他直接返回0
3.read_one_inode读取inode
4.btrfs_lookup_file_extent查找root下inode中偏移为start的BTRFS_EXTENT_DATA_KEY
5.如果正好找到，并且是BTRFS_FILE_EXTENT_REG 或者 BTRFS_FILE_EXTENT_PREALLOC
	1.以btrfs_file_extent_item解析path对应的数据
	2.对比root中的数据existing和eb中的数据cmp2，如果相等直接跳到out
6.否则
	1.btrfs_drop_extents删除inode记录的em，并且删除其在磁盘中extent的管理信息
	2.如果是BTRFS_FILE_EXTENT_REG或者BTRFS_FILE_EXTENT_PREALLOC
		1.btrfs_insert_empty_item插入一个item key
		2.copy_extent_buffer复制eb中item的数据到新加的item
		3.如果ins有效
			1.btrfs_lookup_data_extent查找objectid偏移为offser的BTRFS_EXTENT_ITEM_KEY
			2.如果正好找到，通过btrfs_inc_extent_ref添加ref BTRFS_ADD_DELAYED_REF
			3.否则通过btrfs_alloc_logged_file_extent添加item ins并申请extent
		4.根据item.compression确定csum_start csum_end
		5.btrfs_lookup_csums_range在log_root中csum_start~csum_end中的checksum
			信息链入到ordered_sums
		6.遍历ordered_sums
			1.对链表中的每个sums
				1.btrfs_del_csums删除fs_info-&gt;csum_root中的checksum信息
				2.btrfs_csum_file_blocks将sums中的数据写入到fs_info-&gt;csum_root中
				3.将sums脱链并释放
	3.如果是BTRFS_FILE_EXTENT_INLINE，只是通过overwrite_item用eb中的slot
		覆盖掉root中对应key的数据
	4.inode_add_bytes递增inode-&gt;i_bytes，并通过btrfs_update_inode更新inode
7.释放inode，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>29040</x>
      <y>5670</y>
      <w>230</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_file_extent_inline_len</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29130</x>
      <y>5700</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>29030</x>
      <y>5740</y>
      <w>320</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.如果item.compression encryption other_encoding都为0
	长度为slot.size-item.disk_bytenr之前的长度
2.否则为item.ram_bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>29770</x>
      <y>5670</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_drop_extents</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>29710</x>
      <y>5810</y>
      <w>400</w>
      <h>260</h>
    </coordinates>
    <panel_attributes>1.如果drop_cache置上，通过btrfs_drop_extent_cache释放inode中
	start~end的em
2.如果start超过了盘上的数据大小(disk_i_size),并且不用replace_extent
	将modify_tree清掉(不用做cow)
3.循环处理记录的BTRFS_EXTENT_DATA_KEY管理信息，将要删除的extent的管理信息删除
	1.btrfs_lookup_file_extent寻找inode偏移为search_start的BTRFS_EXTENT_DATA_KEY
	2.如果出错退出循环，如果返回1，在最开始搜寻时，调整slot
	3.leafs_visited++;
	4.next_slot
		1.如果当前leaf没有key
			1.btrfs_next_leaf转移到path到下一个leaf
			2.如果出错或者找不到退出循环，找不到返回0
			3.如果正确找到
				leafs_visited++;
				recow = 1
		2.如果path的key.objectid超过了ino，退出循环
		3.如果slot的key小于要求值，path-&gt;slots[0]++
			跳到next_slot
		4.如果slot的key超过了预期，退出循环
		5.如果正确
			1.以btrfs_file_extent_item方式解析slot数据
			2.根据fi.type确定extent_end
			3.如果extend没数据，并且在搜索范围内，跳到delete_extent_item
			4.如果extent不在搜索范围，递增slot，跳到next_slot
			5.found = 1;
			6.如果需要recow，或者不需要操作tree(!modify_tree)
				置上modify_tree，并继续下一个循环
			7.如果段完全在extent范围内（从start开始截断成两个item）
				1.BTRFS_FILE_EXTENT_INLINE，返回EOPNOTSUPP，退出循环
				2.如果返回EAGAIN，继续循环，如果出错，退出村换
				3.设置old_item.num_bytes
				4.设置new_item.offset numbytes
				5.btrfs_mark_buffer_dirty标记leaf dirty
				6.如果update_refs，并且有disk_bytenr，通过btrfs_inc_extent_ref
			8.如果start在key.offset之前
				1.如果BTRFS_FILE_EXTENT_INLINE，返回EOPNOTSUPP，退出循环
				2.从end将extend截断
					1.给path设置new_key,并通过btrfs_set_item_key_safe将key写入slot
						new_key.offset = end
					2.设置后段slot的fi.offset num_bytes
					3.btrfs_mark_buffer_dirty标记leaf dirty
					4.如果update_refs，并且有disk_bytenr，
						inode_sub_bytes递减inode-&gt;i_blocks inode-&gt;i_bytes
				3.退出循环
			9.前面两者需要更新search_start，后面两个情况是通过递增slot
				search_start = extent_end;
			10.如果start在slot范围内，但是end不在
				1.如果BTRFS_FILE_EXTENT_INLINE，返回EOPNOTSUPP，退出循环
				2.重新设置slot中fi.num_bytes,通过btrfs_mark_buffer_dirty
					标记leaf dirty
				3.如果update_refs，并且有disk_bytenr，
					inode_sub_bytes递减inode-&gt;i_blocks inode-&gt;i_bytes
				4.如果到达了end，退出循环
				5.否则递增slot，跳到next_slot
			11.如果slot完全在段的范围内
				1.统计要删的slot
					1.如果没指定del_slot
						del_slot = path-&gt;slots[0];
						del_nr = 1;
					2.否则只递增del_nr
				2.如果update_refs并且BTRFS_FILE_EXTENT_INLINE
					1.inode_sub_bytes递减inode-&gt;i_blocks inode-&gt;i_bytes
				3.如果disk_bytenr，并且存在disk_bytenr
					1.btrfs_free_extent
					2.inode_sub_bytes递减inode-&gt;i_blocks inode-&gt;i_bytes
				4.如果到达end，退出循环
				5.如果leaf没有遍历完，递增slot，跳到next_slot
				6.否则通过btrfs_del_items将从del_slot的del_nr个slot给删除
				7.如果出错，btrfs_abort_transaction
				8.清空del_nr del_slot path，继续下一个循环
4.如果正确返回，并且存在del_nr，通过btrfs_del_items将记录要删除的slot删除
5.如果正确返回，replace_extent置上，leaf_visited置上，leaf被lock，有足够的空间
	1.如果没del_nr，并且slot没到头
		1.如果key大于slot的key，递增slot
	2.setup_items_for_insert插入key对应的item，并预留出数据区
	3.将key_inserted置上
6.确定drop_end，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29830</x>
      <y>5700</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>29760</x>
      <y>5740</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_drop_extents</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29830</x>
      <y>5770</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>29560</x>
      <y>6100</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_drop_extent_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29630</x>
      <y>6060</y>
      <w>180</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>29410</x>
      <y>6170</y>
      <w>410</w>
      <h>400</h>
    </coordinates>
    <panel_attributes>1.如果没指定end，len设置为-1，并且将testend清掉
2.循环释放start~end的em
	1.alloc_extent_map申请split和split2，如果其中一个没申请到
		将no_splits置1
	2.lookup_extent_mapping在inode.extent_tree中查找包含start的em
	3.如果skip_pinned，并且em的EXTENT_FLAG_PINNED置上
		1.如果testend置上，end在em的范围内时，释放em并退出循环
		2.否则更新start len,释放em后继续循环
	4.将em的EXTENT_FLAG_PINNED和EXTENT_FLAG_LOGGING清掉
	5.如果no_splits置上，跳到next
	6.如果start在em中间
		1.将em在start之前的赋给split
			1.设置start len
			2.设置orig_start block_start block_len orig_block_len ram_bytes
			3.设置generation bdev flags compress_type
		2.replace_extent_mapping用split替换红黑树中的em
		3.释放split
			split = split2;
			split2 = NULL
	7.如果testend置上，并且end在em中间
		1.设置split的start len bdev flags compress_type generation
			orig_block_len ram_bytes orig_start block_len block_start
		2.如果em在红黑树中，通过replace_extent_mapping用split将em释放
			否则通过add_extent_mapping将split将em加入em_tree
		3.释放split
			split = NULL
	8.next
		1.如果em在红黑树中，通过remove_extent_mapping将红黑树中删除
		2.free_extent_map将em释放两次(一次是lookup_extent_mapping，一次是红黑树中的引用)
3.释放split和split2	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29660</x>
      <y>6130</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>29440</x>
      <y>6600</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>replace_extent_mapping</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29520</x>
      <y>6560</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>29390</x>
      <y>6670</y>
      <w>270</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.如果cur的EXTENT_FLAG_LOGGING置上，将其从链表中删除
2.rb_replace_node让new替换cur
3.setup_extent_mapping重新设置new的关系
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29520</x>
      <y>6630</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>29890</x>
      <y>6100</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_duplicate_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29970</x>
      <y>6060</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>29840</x>
      <y>6170</y>
      <w>400</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.setup_leaf_for_split给leaf腾出item的空间
2.调整path.slot[0]（查到现有item的后面），并通过setup_items_for_insert
	腾出slot和数据区域
3.memcpy_extent_buffer复制之前item中的数据到新slot
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29980</x>
      <y>6130</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>29910</x>
      <y>6290</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>setup_leaf_for_split</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29970</x>
      <y>6250</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>29840</x>
      <y>6360</y>
      <w>350</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.如果leaf有足够的空间，返回0
2.如果slot.key是BTRFS_EXTENT_DATA_KEY，以btrfs_file_extent_item
	方式解析slot数据，获取fi.num_bytes
3.btrfs_search_slot搜索key(lock取消了，所以再搜一遍？)
	path-&gt;keep_locks = 1;
	path-&gt;search_for_split = 1;
4.如果返回1，返回EAGAIN，如果出错，返回错误
5.如果item_size和传进来的path不同，跳到err，返回EAGAIN
	如果没有足够的空间，跳到err，返回EAGAIN
	如果fi.num_bytes不同，跳到err，返回EAGAIN
6.split_leaf将leaf中腾出足够的空间
7.path-&gt;keep_locks = 0,并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29970</x>
      <y>6320</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>30340</x>
      <y>6100</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_inc_extent_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>30270</x>
      <y>6170</y>
      <w>380</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.如果object低于BTRFS_FIRST_FREE_OBJECTID，通过
	btrfs_add_delayed_tree_ref添加到transaction-&gt;delayed_refs中
2.否则通过btrfs_add_delayed_data_ref添加
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30400</x>
      <y>6130</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>30330</x>
      <y>6260</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_add_delayed_data_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30420</x>
      <y>6220</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30410</x>
      <y>6290</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>30240</x>
      <y>6330</y>
      <w>390</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.申请ref和headref
2.quota_enabled并且ref_root是is_fstree，需要申请record
3.head_ref-&gt;extent_op = extent_op
4.add_delayed_ref_head将head_ref添加到transaction-&gt;delayed_refs
5.add_delayed_data_ref设置ref，添加到headref
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30000</x>
      <y>6060</y>
      <w>440</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>30770</x>
      <y>6090</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_free_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30820</x>
      <y>6120</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>30660</x>
      <y>6160</y>
      <w>360</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.如果boot的dummy_boot置上，返回0
2.add_pinned_bytes递增total_bytes_pinned
3.如果是BTRFS_TREE_LOG_OBJECTID，btrfs_pin_extent
	将段在pinned_extents中记录
4.如果低于BTRFS_FIRST_FREE_OBJECTID，通过btrfs_add_delayed_tree_ref
	在transaction-&gt;delayed_refs中添加BTRFS_DROP_DELAYED_REF
5.否则通过btrfs_add_delayed_data_ref添加BTRFS_DROP_DELAYED_REF
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30020</x>
      <y>6060</y>
      <w>810</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;790.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>31230</x>
      <y>5640</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_alloc_logged_file_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>31150</x>
      <y>5710</y>
      <w>360</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.如果fs_info的MIXED_GROUPS没置上，通过__exclude_logged_extent
	将段从对应的free_space中预留
2.btrfs_lookup_block_group找到对应的block_group
3.btrfs_update_reserved_bytes更新block_group和space_info的reserved
4.alloc_reserved_file_extent插入ins BTRFS_EXTENT_DATA_REF_KEY
	向block_group申请extent(减小reserved)
5.btrfs_put_block_group释放block_group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31310</x>
      <y>5670</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>31220</x>
      <y>5870</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>alloc_reserved_file_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31310</x>
      <y>5820</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31300</x>
      <y>5900</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>31140</x>
      <y>5940</y>
      <w>390</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.根据parent选择item.type
2.btrfs_extent_inline_ref_size根据type选择要插入的类型
3.btrfs_insert_empty_item插入一个ins，长度为size的item
4.设置最初的extent_item.refs gen flags|BTRFS_EXTENT_FLAG_DATA
5.设置其后的btrfs_extent_inline_ref.type
6.如果是parent大于0，设置inline_ref.offset 和btrfs_shared_data_ref.count
	否则设置btrfs_extent_data_ref.root objectid offset count
7.btrfs_mark_buffer_dirty标记leaf dirty
8.update_block_group向block_group申请段
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>31110</x>
      <y>6130</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_extent_inline_ref_size</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31190</x>
      <y>6090</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31190</x>
      <y>6160</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>31030</x>
      <y>6200</y>
      <w>370</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.如果是BTRFS_TREE_BLOCK_REF_KEY BTRFS_SHARED_BLOCK_REF_KEY
	选择btrfs_extent_inline_ref
2.如果是BTRFS_SHARED_DATA_REF_KEY
	选择btrfs_shared_data_ref + btrfs_extent_inline_ref
3.如果是BTRFS_EXTENT_DATA_REF_KEY
	选择btrfs_extent_data_ref +btrfs_extent_inline_ref
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>31450</x>
      <y>6130</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>update_block_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31500</x>
      <y>6090</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31520</x>
      <y>6160</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>31420</x>
      <y>6200</y>
      <w>410</w>
      <h>350</h>
    </coordinates>
    <panel_attributes>1.更新super_copy.bytes_used
2.循环更新段所在的cache
	1.通过btrfs_lookup_block_group找到cache
	2.如果是DUP RAID1 RAID10,factor设置为2
		否则设置为1
	3.如果是要删除(!alloc)，并且没被缓存，通过
		cache_block_group进行缓存
	4.如果root的SPACE_CACHE置上，并且状态低于BTRFS_DC_CLEAR
		cache-&gt;disk_cache_state = BTRFS_DC_CLEAR
	5.要更新的长度不能超过cache的容量
	6.根据alloc更新cache.item.used cache.reserved cache.space_info.bytes_reserved bytes_used disk_used
		如果要删除，通过set_extent_dirty设置pinned_extents
	7.如果cache-&gt;dirty_list是空，将cache加到transaction-&gt;dirty_bgs，并递增cache的计数
		trans-&gt;transaction-&gt;num_dirty_bgs++;
	8.如果是删除，并且cache已经完全被释放
		1.如果cache-&gt;bg_list没链入链表
			1.btrfs_get_block_group获取cache
			2.将cache加入到fs_info.unused_bgs链表中
	9.释放cache，并更新循环变量
		total -= num_bytes;
		bytenr += num_bytes;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>31800</x>
      <y>5620</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_lookup_csums_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>31710</x>
      <y>5690</y>
      <w>390</w>
      <h>420</h>
    </coordinates>
    <panel_attributes>1.申请path，如果search_commit
	path-&gt;skip_locking = 1;
	path-&gt;reada = 2;
	path-&gt;search_commit_root = 1;
2.btrfs_search_slot查找BTRFS_EXTENT_CSUM_KEY
	如果返回1，检查key和size成功后将slot--
3.循环处理
	1.如果slot超过了nritems，btrfs_next_leaf
	2.检查key满足搜索条件，并且不超过end
	3.start不能小于offset
	4.cum_end不能超过start，否则继续遍历下一个slot
		csum_end = key.offset + (size / csum_size) * root-&gt;sectorsize
	5.遍历start~csum_end
		1.申请csum的管理结构btrfs_ordered_sum及其checksum空间
		2.设置管理结构
			sums-&gt;bytenr = start;
			sums-&gt;len = (int)size;
		3.read_extent_buffer读取checksum
		4.更新循环变量，并且将sums.list加入链表tmplist
			start += root-&gt;sectorsize * size;
	6.集训遍历下一个slot
4.返回0
5.fail
	1.如果出错，并且tmplist不为空，将链表中的sums脱链并释放
	2.list_splice_tail将list和templist合并
	3.释放path后返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31900</x>
      <y>5650</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>32270</x>
      <y>5610</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_del_csums</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>32160</x>
      <y>5680</y>
      <w>350</w>
      <h>310</h>
    </coordinates>
    <panel_attributes>1.循环删除段
	1.btrfs_search_slot从end_byte开始搜寻，并根据返回值调整slot
		path-&gt;leave_spinning = 1
	2.fitler，不通过退出循环
		1.slot.key的objextid和type要和指定的相同
		2.offset不能大于end_byte
	3.如果slot完全在段的范围内，通过btrfs_del_item将slot删除
		如果其offset到达了start，退出循环
	4.如果段完全在slot的范围内
		1.通过memset_extent_buffer将段在slot.item中的数据完全清0
		2.btrfs_split_item从offset开始将path分为两个slot
			key.offset = bytenr
		3.如果出错(不是EAGAIN)，btrfs_abort_transaction，跳到out
		4.接着继续循环搜索，直到段完全在slot的范围内(1.3)，或者截断(1.5)
			key.offset = end_byte - 1
	5.否则
		1.通过truncate_one_csum将在slot范围内的段截断，
		2.如果其offset低于start，退出循环
		3.否则继续循环
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>32160</x>
      <y>6020</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_split_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32330</x>
      <y>5640</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32200</x>
      <y>5980</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>32110</x>
      <y>6090</y>
      <w>280</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.通过setup_leaf_for_split腾出充足的空间
2.split_item将path数据区从split_offset分开
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32200</x>
      <y>6050</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>32190</x>
      <y>6160</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>split_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32240</x>
      <y>6120</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>32080</x>
      <y>6230</y>
      <w>330</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.通过read_extent_buffer将path中的数据读取到申请的buf中
2.memmove_extent_buffer将slot之后的所有item向后移
3.设置腾出来的newslot,和原来的item
	1.newslot设置key，offset(原来的)，size(item_size - split_offset)
	2.item改变offset( orig_offset + item_size - split_offset)
		和size(split_offset)
	注：1.split_offset为要分出来的空间，从后开始算
		2.这里offset小的newitem为什么排在后面？是因为数据区是从后向前的
4.调整header中的nritems
5.将buf中的数据分别通过write_extent_buffer写入两个slot区域
6.btrfs_mark_buffer_dirty标记leaf dirty，释放buf后返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32240</x>
      <y>6190</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>32470</x>
      <y>6020</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>truncate_one_csum</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32490</x>
      <y>5980</y>
      <w>50</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>32400</x>
      <y>6090</y>
      <w>330</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.如果段的前半部分在slot范围内，通过btrfs_truncate_item将
	item的后面截断，存留new_size
2.如果段的后半部分在slot返回内
	1.btrfs_truncate_item存留后半部分
	2.btrfs_set_item_key_safe更改path的key
		key-&gt;offset = end_byte
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32530</x>
      <y>6050</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>32870</x>
      <y>5610</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_csum_file_blocks</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>32760</x>
      <y>5680</y>
      <w>430</w>
      <h>680</h>
    </coordinates>
    <panel_attributes>1.again
	1.btrfs_lookup_csum搜索bytenr对应的管理结构item
	2.如果正确找到，算出其item_end，跳到found
	3.如果不是EFBIG ENOENT，返回错误
	4.如果是EFBIG，
		1.如果item的长度早已超过了MAX_CSUM_ITEMS，跳到insert
	5.如果是ENOENT，查找next slot
		1.如果slot大于nritems，btrfs_next_leaf寻找下一个leaf
			1.如果没找到，found_next置上
			2.如果出错或者没找到，跳到insert
		2.如果slot的key和指定的不同，置上found_next，跳到insert
		3.否则复制next_offset，置上found_next，跳到insert
			next_offset = found_key.offset
	6.如果是EFBIG
		2.btrfs_search_slot查找file_key，并根据返回值，调整slot
		3.如果key不同，或者bytenr超过了MAX_CSUM_ITEMS，跳到insert
		4.如果byrenr刚好是最后一个
			1.如果剩余的空间不足容纳2*sum_size，跳到insert
			2.算出item能容纳的csum的个数，并通过btrfs_extend_item对item扩充
			3.跳到csum
				ret=0
2.insert
	1.计算插入item的大小ins_size
		1.如果有found_next,其大小是min(sums中csum的个数，next_offset-key.offset)
		2.否则只有一个csum_size
	2.置上path-&gt;leave_spinning，并通过btrfs_insert_empty_item插入file_key
3.csum
	1.确定cusm的起始item，和结束item_end
4.found
	1.要插入item的长度不能超过找到item的长度和sums规定的长度
	2.write_extent_buffer从sums.sums[index]开始向找到的slot复制数据
	3.更新循环变量
		ins_size /= csum_size;
		total_bytes += ins_size * root-&gt;sectorsize;
		index += ins_size;
	4.btrfs_mark_buffer_dirty标记leaf dirty
	5.如果sums没有遍历完
		1.释放path
		2.cond_resched
		3.跳到again
5.out
	1.释放path，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32950</x>
      <y>5640</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>32890</x>
      <y>6390</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_lookup_csum</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32960</x>
      <y>6350</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>32940</x>
      <y>6420</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>32870</x>
      <y>6460</y>
      <w>300</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot搜寻从bytenr开始的BTRFS_EXTENT_CSUM_KEY
	如果返回1，调整slot，并检查type和长度
	1.如果item长度刚好为要寻找的csum_offset，返回EFBIG
	2.如果item长度不够offset，返回ENOENT
2.返回bytenr指向的btrfs_csum_item
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27340</x>
      <y>4870</y>
      <w>890</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;870.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27470</x>
      <y>4870</y>
      <w>3430</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3410.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29140</x>
      <y>5550</y>
      <w>1730</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1710.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>29830</x>
      <y>5550</y>
      <w>1040</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1020.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30900</x>
      <y>5550</y>
      <w>450</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>30930</x>
      <y>5550</y>
      <w>990</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;970.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31010</x>
      <y>5550</y>
      <w>1330</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1310.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>31050</x>
      <y>5550</y>
      <w>1930</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1910.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>27190</x>
      <y>2360</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_find_orphan_roots</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27260</x>
      <y>2270</y>
      <w>1160</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1140.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27270</x>
      <y>2390</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>27050</x>
      <y>2430</y>
      <w>470</w>
      <h>270</h>
    </coordinates>
    <panel_attributes>1.循环遍历所有的orphan root
	1.btrfs_search_slot在tree_root中查找BTRFS_ORPHAN_ITEM_KEY
		如果大于nritems，btrfs_next_leaf跳到下一个leaf
	2.检查key要和指定的相同，其offset存储root_key.objectid
	3.btrfs_read_fs_root在tree_root中读取root_key
	4.如果出错，退出循环，
	5.如果是ENOENT
		1.btrfs_join_transaction
		2.btrfs_del_orphan_item删除tree_root中对应的BTRFS_ORPHAN_ITEM_KEY
		3.btrfs_end_transaction
	6.如果找到
		1.btrfs_init_fs_root初始化读到的root
		2.将root.state的BTRFS_ROOT_ORPHAN_ITEM_INSERTED置上
		3.btrfs_insert_fs_root将root插入radix_tree
		4.如果root.root_item.refs是0，btrfs_add_dead_root
			将root.root_list插入fs_info-&gt;dead_roots链表
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23450</x>
      <y>0</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>device_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23500</x>
      <y>30</y>
      <w>170</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_scan_one_device</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23440</x>
      <y>80</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>fs_devices</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21760</x>
      <y>160</y>
      <w>90</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>sb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21800</x>
      <y>110</y>
      <w>1720</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_fill_super</panel_attributes>
    <additional_attributes>1700.0;10.0;11.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23180</x>
      <y>150</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tree_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24570</x>
      <y>170</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>chunk_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23230</x>
      <y>110</y>
      <w>290</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
open_ctree</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23500</x>
      <y>110</y>
      <w>1160</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
open_ctree</panel_attributes>
    <additional_attributes>10.0;10.0;1140.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23490</x>
      <y>110</y>
      <w>1600</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_read_dev_super</panel_attributes>
    <additional_attributes>10.0;10.0;1580.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24970</x>
      <y>140</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>super_copy/disk_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24940</x>
      <y>210</y>
      <w>310</w>
      <h>180</h>
    </coordinates>
    <panel_attributes>存储root信息
1.nodesize，sectorsize
2.chunk_root和tree_root的偏移
3.log_root的偏移
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25050</x>
      <y>170</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24410</x>
      <y>250</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>BTRFS_DEV_ITEM_KEY</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24680</x>
      <y>250</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>BTRFS_CHUNK_ITEM_KEY</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24490</x>
      <y>200</y>
      <w>160</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_read_chunk_tree</panel_attributes>
    <additional_attributes>130.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24630</x>
      <y>200</y>
      <w>170</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_read_chunk_tree</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22080</x>
      <y>180</y>
      <w>1160</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_read_roots</panel_attributes>
    <additional_attributes>1140.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22030</x>
      <y>220</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>extent_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22420</x>
      <y>250</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>dev_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23200</x>
      <y>250</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>quota_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23490</x>
      <y>240</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>uuid_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22700</x>
      <y>250</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>csum_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22480</x>
      <y>180</y>
      <w>770</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_read_roots</panel_attributes>
    <additional_attributes>750.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22750</x>
      <y>180</y>
      <w>500</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_read_roots</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23220</x>
      <y>180</y>
      <w>150</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_read_roots</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23230</x>
      <y>180</y>
      <w>330</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_read_roots</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23690</x>
      <y>240</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>fs_info-&gt;balance_ctl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23230</x>
      <y>180</y>
      <w>540</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_recover_balance
BTRFS_BALANCE_OBJECTID</panel_attributes>
    <additional_attributes>10.0;10.0;520.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22320</x>
      <y>280</y>
      <w>180</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_init_dev_stats</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22240</x>
      <y>330</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>BTRFS_DEV_STATS_KEY</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22490</x>
      <y>330</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>fs_info-&gt;dev_replace</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22430</x>
      <y>280</y>
      <w>210</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_init_dev_replace
BTRFS_DEV_REPLACE_KEY</panel_attributes>
    <additional_attributes>60.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21730</x>
      <y>300</y>
      <w>260</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>BTRFS_BLOCK_GROUP_ITEM_KEY</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21820</x>
      <y>250</y>
      <w>280</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_read_block_groups
block_group_cache_tree</panel_attributes>
    <additional_attributes>260.0;10.0;18.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22870</x>
      <y>330</y>
      <w>240</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>BTRFS_QGROUP_STATUS_KEY</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23150</x>
      <y>330</y>
      <w>250</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>BTRFS_QGROUP_INFO_KEY</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23460</x>
      <y>330</y>
      <w>220</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>BTRFS_QGROUP_LIMIT_KEY</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22970</x>
      <y>280</y>
      <w>300</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_read_qgroup_config</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23260</x>
      <y>280</y>
      <w>190</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_read_qgroup_config</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23260</x>
      <y>280</y>
      <w>300</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_read_qgroup_config</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23970</x>
      <y>240</y>
      <w>110</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>log_tree_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23250</x>
      <y>180</y>
      <w>780</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_replay_log</panel_attributes>
    <additional_attributes>10.0;10.0;760.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>27170</x>
      <y>2730</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_del_orphan_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27250</x>
      <y>2690</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>27040</x>
      <y>2800</y>
      <w>400</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot搜索对应root的BTRFS_ORPHAN_ITEM_KEY
2.btrfs_del_item将path对应slot的数据删除
3.out：释放path，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27250</x>
      <y>2760</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>33840</x>
      <y>2350</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_cleanup_fs_roots</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>33610</x>
      <y>2740</y>
      <w>400</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.radix_tree_for_each_slot从first_index开始遍历root
	1.如果没有找到slot，继续下一个index
	2.如果result满了，退出循环
2.返回找到的个数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33910</x>
      <y>2380</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>33620</x>
      <y>2850</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>radix_tree_next_chunk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33690</x>
      <y>2810</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>33550</x>
      <y>2920</y>
      <w>350</w>
      <h>430</h>
    </coordinates>
    <panel_attributes>1.RADIX_TREE_ITER_TAGGED如果置上，root_tag_get需要
	检查root.gfp_mask,不通过返回NULL
2.如果next_index为0，但是index不为0，返回NULL
3.获取root.rnode
	1.如果index为0，返回root
		iter-&gt;index = 0;
		iter-&gt;next_index = 1;
		iter-&gt;tags = 1;
4.restart
	1.在radix_tree中的offset不能超过slot的max，否则返回NULL
	2.循环
		1.如果检查到tag不同，或者不存在slots[offset]，检查到hole
			1.如果flag要求遇到hole就停止，返回NULL
			2.如果检查tag，通过radix_tree_find_next_bit查找从offset+1
				开始tag相同的offset
			3.否则遍历slots，找到有slot的offset
			4.根据offset获取新的index
				1.如果index为0，返回NULL,overflow
				2.如果offset是RADIX_TREE_MAP_SIZE，跳到restart
		2.如果是leaf(shift为0)，退出循环
		3.更新循环变量(node,shift,offset)再次循环
	3.更新iter-&gt;index，next_index(整个leaf)
	4.如果检查tag
		1.iter-&gt;tags是index之后这个long的tag
		2.iter-&gt;next_index = index + BITS_PER_LONG
5.返回node-&gt;slots + offset
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33690</x>
      <y>2880</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>33980</x>
      <y>2850</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>radix_tree_next_slot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33980</x>
      <y>2810</y>
      <w>90</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>33920</x>
      <y>2920</y>
      <w>320</w>
      <h>270</h>
    </coordinates>
    <panel_attributes>1.如果有设置tag
	1.如果iter.tags下一位满足要求
		iter-&gt;index++;
		return slot + 1;
	2.否则
		1.如果看到hole不停，并且还存在tags
			1.__ffs找到iter.tags中置上的位
			2.iter-&gt;tags &gt;&gt;= offset;
				iter-&gt;index += offset + 1;
				return slot + offset + 1;
2.如果没设置tag
	1.遍历next_index-index
		1.递增slot，如果slot存在数据，即返回
		2.如果遇到hole停止，next_index设为0，退出循环
		3.否则继续寻找
3.如果没找到或者退出循环，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34070</x>
      <y>2880</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>28670</x>
      <y>2270</y>
      <w>5260</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;5240.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>33690</x>
      <y>2420</y>
      <w>430</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.从root 0开始循环，清除orphan root	
	1.radix_tree_gang_lookup搜索fs_roots_radix，从root_objectid
		开始，直到找到8个为止
	2.遍历找到的gang
		1.如果其中root.root_item.refs为0
			gang[i] = NULL
		2.btrfs_grab_fs_root递增root的计数
	3.再次遍历gang
		1.如果root为空，继续循环
		2.btrfs_orphan_cleanup清除所有的不正确的orphan
		3.btrfs_put_fs_root释放root
	4.更新循环变量，gang中最后一个roorid+1
2.最后查看gang是否还有root，如果有，通过btrfs_put_fs_root释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>33710</x>
      <y>2670</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>radix_tree_gang_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33790</x>
      <y>2630</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>33790</x>
      <y>2700</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>34270</x>
      <y>2670</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_orphan_cleanup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34030</x>
      <y>2630</y>
      <w>340</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34360</x>
      <y>2700</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>34250</x>
      <y>2740</y>
      <w>390</w>
      <h>630</h>
    </coordinates>
    <panel_attributes>1.设置root.orphan_cleanup_state为ORPHAN_CLEANUP_STARTED
	如果之前不是0，返回0
2.申请path
	path-&gt;reada = -1;
3.循环所有的orphan
	1.btrfs_search_slot从最后查找BTRFS_ORPHAN_ITEM_KEY
		并根据ret，调整slot
	2.检查slot的objectid和type
	3.如果找到和last_objectid相同，报错EINVAL，跳到out
	4.btrfs_iget获取key.offset对应的inode
	5.如果返回ESTALE，并且是tree_root，处理orphan root
		1.遍历fs_info-&gt;dead_roots
			1.如果root_key.objectid和找到的objectid相同，退出循环
				is_dead_root = 1
		2.如果找到dead_root,更新key.offset，继续下一次循环
			key.offset = found_key.objectid - 1
	6.如果返回ESTALE(inode已经被删，但是还有orphan)，处理所有orphan
		1.btrfs_start_transaction
		2.btrfs_del_orphan_item删除对应的orphan
		3.btrfs_end_transaction
		4.继续循环
	7.如果正确找到inode
		1.将inode.runtime_flags的BTRFS_INODE_HAS_ORPHAN_ITEM置上
			并递增root-&gt;orphan_inodes
		2.如果存在inode-&gt;i_nlink
			1.inode要是reg
			2.nr_truncate++
			3.btrfs_start_transaction
			4.btrfs_orphan_add迁移reserved
			5.btrfs_end_transaction
			6.btrfs_truncate将BTRFS_EXTENT_DATA_KEY之前的item删掉
			7.如果错误，btrfs_orphan_del删除orphan
		3.如果不存在i_nlink,递增nr_unlink
		4.释放inode，如果出错，跳到out
4.root-&gt;orphan_cleanup_state = ORPHAN_CLEANUP_DONE
5.如果有orphan_block_rsv，btrfs_block_rsv_release释放所有的bytes
6.如果orphan_block_rsv，或者root的BTRFS_ROOT_ORPHAN_ITEM_INSERTED置上
	btrfs_join_transaction
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>34180</x>
      <y>3450</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_orphan_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>34070</x>
      <y>3520</y>
      <w>390</w>
      <h>320</h>
    </coordinates>
    <panel_attributes>1.如果没有root-&gt;orphan_block_rsv，btrfs_alloc_block_rsv
	为其申请一个
2.置上BTRFS_INODE_HAS_ORPHAN_ITEM，如果
	inode.runtime_flags的BTRFS_INODE_HAS_ORPHAN_ITEM之前没置上
	insert = 1;
	atomic_inc(&amp;root-&gt;orphan_inodes)
3.将inode.runtime_flags的BTRFS_INODE_ORPHAN_META_RESERVED
	置上，如果之前没置上，置上reserve
4.如果存在reserve，btrfs_orphan_reserve_metadata迁移reserved
5.如果需要insert
	1.btrfs_insert_orphan_item为inode添加orphan item
	2.递减root-&gt;orphan_inodes
	3.如果reserve
		1.清除inode.runtime_flags的BTRFS_INODE_ORPHAN_META_RESERVED
		2.btrfs_orphan_release_metadata释放reserved
		3.如果出了除EEXIST的错
			1.将BTRFS_INODE_HAS_ORPHAN_ITEM清掉
			2.btrfs_abort_transaction，并返回
6.如果还需要insert，继续通过btrfs_insert_orphan_item插入orphan item
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34240</x>
      <y>3480</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>34090</x>
      <y>3870</y>
      <w>230</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_orphan_reserve_metadata</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>34030</x>
      <y>3940</y>
      <w>340</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.btrfs_calc_trans_metadata_size计算需要reserve的长度
2.block_rsv_migrate_bytes将reserved从get_block_rsv
	迁移到root-&gt;orphan_block_rsv
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34190</x>
      <y>3900</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34190</x>
      <y>3830</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>34630</x>
      <y>3450</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_truncate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>34510</x>
      <y>3520</y>
      <w>420</w>
      <h>440</h>
    </coordinates>
    <panel_attributes>1.btrfs_wait_ordered_range执行flush
2.btrfs_alloc_block_rsv申请block_rsv
	rsv-&gt;size = min_size;
	rsv-&gt;failfast = 1;
3.btrfs_start_transaction
4.btrfs_block_rsv_migrate将fs_info-&gt;trans_block_rsv的
	空间移到rsv
5.将inode.runtime_flags的BTRFS_INODE_NEEDS_FULL_SYNC
	置上
6.trans-&gt;block_rsv = rsv
7.循环
	1.btrfs_truncate_inode_items清除大于BTRFS_EXTENT_DATA_KEY
		的所有item，其extend保持不变(因为new_size是inode.i_size)
		如果不是ENOSPC EAGAIN，退出循环
	2.btrfs_update_inode
	3.btrfs_end_transaction
	4.btrfs_btree_balance_dirty
	5.btrfs_start_transaction
	6.btrfs_block_rsv_migrate将min_size迁移到trans_block_rsv
		trans-&gt;block_rsv = rsv
8.如果正确返回，并且有i_nlink,btrfs_orphan_del
9.如果有trans
	1.btrfs_update_inode
	2.btrfs_end_transaction
	3.btrfs_btree_balance_dirty
10.out
	1.btrfs_free_block_rsv释放rsv，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34680</x>
      <y>3480</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>34100</x>
      <y>4070</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_wait_ordered_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34190</x>
      <y>3950</y>
      <w>400</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>380.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>34030</x>
      <y>4140</y>
      <w>380</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>1.确定orig_end，不能超过INT_LIMIT
	orig_end = start + len - 1
2.btrfs_fdatawrite_range执行写IO,
3.filemap_fdatawait_range等待写完成
4.循环
	1.btrfs_lookup_first_ordered_extent在inode.ordered_tree
		中查找end
	2.如果没找到，退出循环
	3.如果大于orig_end或者小于start，btrfs_put_ordered_extent将ordered
		释放，退出循环
	4.btrfs_start_ordered_extent再次进行刷写
	5.更新end
	6.如果ordered的BTRFS_ORDERED_IOERR置上，返回EIO
	7.释放ordered
	8.如果出错，或者到达start，退出循环
	9.end--
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34170</x>
      <y>4100</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>34910</x>
      <y>4050</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_truncate_inode_items</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34900</x>
      <y>3950</y>
      <w>100</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34560</x>
      <y>4080</y>
      <w>470</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>34420</x>
      <y>4140</y>
      <w>400</w>
      <h>420</h>
    </coordinates>
    <panel_attributes>1.如果不是btrfs_is_free_space_inode，并且root的cows置上
	be_nice = 1
2.btrfs_alloc_path申请path
	path-&gt;reada = -1
3.如果root的cow置上，并且是tree_root,btrfs_drop_extent_cache
	将new_size之后的段从inode.extent_tree中删除
4.如果min_type是0，并且root是inode.root，通过btrfs_kill_delayed_inode_items
5.search_again
	1.如果be_nice,并且bytes_deleted超过32M,btrfs_should_end_transaction
	2.btrfs_search_slot查找指向ino，根据ret调整slot
		path-&gt;leave_spinning = 1
	3.循环
		1.objectid要和ino相同，type不能小于min_type
		2.如果是BTRFS_EXTENT_DATA_KEY
			1.以btrfs_file_extent_item方式解析slot数据fi
			2.如果fi.type不是BTRFS_FILE_EXTENT_INLINE
				item_end+=fi.num_bytes
			3.如果fi.type是BTRFS_FILE_EXTENT_INLINE
				item_end += btrfs_file_extent_inline_len
			4.item_end--
		3.如果大于min_type,将del_item置上
		4.如果等于min_type
			1.如果item_end在new_size内，退出循环
			2.如果完全不在new_size内，del_item置上
		5.如果不是BTRFS_EXTENT_DATA_KEY，跳到delete
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>34510</x>
      <y>4590</y>
      <w>230</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_kill_delayed_inode_items</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>34420</x>
      <y>4660</y>
      <w>370</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.btrfs_get_delayed_node在root-&gt;delayed_nodes_tree中
	获取指向inode的delay_inode
2.__btrfs_kill_delayed_node删除delayed_inode
3.btrfs_release_delayed_node释放delayed_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34590</x>
      <y>4620</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>34320</x>
      <y>4770</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_kill_delayed_node</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34420</x>
      <y>4730</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>34240</x>
      <y>4840</y>
      <w>330</w>
      <h>210</h>
    </coordinates>
    <panel_attributes>1.__btrfs_first_delayed_insertion_item获取红黑树delayed_node-&gt;ins_root
	链表中的第一个
2.循环
	1.btrfs_delayed_item_release_metadata释放curr_item.bytes_reserved
	2.__btrfs_next_delayed_item遍历下一个
	3.btrfs_release_delayed_item将delayed_item释放
3.如果delayed_inode的BTRFS_DELAYED_NODE_DEL_IREF置上
	btrfs_release_delayed_iref清掉BTRFS_DELAYED_NODE_DEL_IREF
	并递减delayed_node-&gt;count--
4.如果delayed_inode的BTRFS_DELAYED_NODE_INODE_DIRTY置上
	1.btrfs_delayed_inode_release_metadata释放delayed_inode.bytes_reserved
	2.btrfs_release_delayed_inode释放delayed_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34400</x>
      <y>4800</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>34880</x>
      <y>4610</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>truncate_inline_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34960</x>
      <y>4640</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>34830</x>
      <y>4680</y>
      <w>320</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.以btrfs_file_extent_item方式解析slot
2.如果有compression，通过btrfs_truncate_page
3.否则
	1.fi.ram_bytes=new_size-offset
	2.btrfs_truncate_item将item size之后的内容清空
	3.如果root的cow置上，inode_sub_bytes递减
	item_end + 1 - new_size
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>34890</x>
      <y>4850</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_truncate_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34960</x>
      <y>4810</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>34850</x>
      <y>4140</y>
      <w>450</w>
      <h>440</h>
    </coordinates>
    <panel_attributes>6.如果是BTRFS_EXTENT_DATA_KEY
	1.确定last_size
		1.如果del_item置上，为found_key.offset
			否则为new_size
	2.如果fi.type不是BTRFS_FILE_EXTENT_INLINE
		1.如果不用del_item
			1.重新设置fi.num_bytes为在new_size中的长度
			2.如果root的cows置上，并且fi.disk_bytenr不为0
				inode_sub_bytes将inode-&gt;i_bytes减去不在new_size
				中的长度
			3.btrfs_mark_buffer_dirty标记leaf dirty
		2.如果需要全删
			1.确定extent_num_bytes，extent_offset(这里extent_offset
				为什么用inode的offset-?)
			2.如果fi.disk_bytenr不为0
				1.found_extent = 1
				2.如果root的cows置上，inode_sub_bytes将
				inode-&gt;i_bytes减去不在new_size中的长度
	3.如果是BTRFS_FILE_EXTENT_INLINE
		1.如果不全删，fi.encryption,encoding都为0
			1.没有compression，并且存在pending_del_nr
				1.btrfs_del_items将对应的item删除
				2.pending_del_nr=0
			2.truncate_inline_extent
		2.否则
			1.如果root的cow置上，inode_sub_bytes递减
				item_end + 1 - new_size
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>35330</x>
      <y>4140</y>
      <w>420</w>
      <h>500</h>
    </coordinates>
    <panel_attributes>	7.delete
		1.如果del_item
			1.如果没有pending_del_nr，确定起始的pending_del_slot
				和pending_del_nr
			2.向前紧挨着pending_del_slot
				pending_del_nr++;
				pending_del_slot = path-&gt;slots[0]
		2.否则退出循环
		3.如果found_extent，root的cows置上，并且root是tree_root
			1.更新bytes_deleted
			2.btrfs_free_extent
			3.如果btrfs_should_throttle_delayed_refs
				btrfs_async_run_delayed_refs
			4.如果be_nice,通过truncate_space_check添加reserved
				should_end = 1
			5.如果btrfs_should_throttle_delayed_refs
				should_throttle = 1;
		4.如果found_type是BTRFS_INODE_ITEM_KEY，退出循环
		5.如果到头了，或者del存在hole，或者should_throttle，或者should_end
			1.btrfs_del_items删除记录的item
			2.如果should_throttle，并且updates，btrfs_run_delayed_refs
			3.如果should_end，返回EAGAIN，跳到error
			4.跳到search_again
		6.否则循环前一个slot
			path-&gt;slots[0]--
4.out
	1.如果还存在pending_del_nr，btrfs_del_items
5.error
	1.如果不是BTRFS_TREE_LOG_OBJECTID，btrfs_ordered_update_i_size
	2.如果be_nice，并且bytes_deleted超过32M,btrfs_run_delayed_refs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>35000</x>
      <y>4080</y>
      <w>40</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>35000</x>
      <y>4080</y>
      <w>480</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
delete</panel_attributes>
    <additional_attributes>10.0;10.0;460.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34600</x>
      <y>4550</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34950</x>
      <y>4570</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>35940</x>
      <y>4050</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_orphan_del</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>35790</x>
      <y>4120</y>
      <w>430</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.如果inode.runtime_flags的BTRFS_INODE_HAS_ORPHAN_ITEM置上，将其清掉
	delete_item = 1
2.如果inode.runtime_flags的BTRFS_INODE_ORPHAN_META_RESERVED置上，将其清掉
	release_rsv = 1
3.如果del_item
	1.递减root-&gt;orphan_inodes
	2.btrfs_del_orphan_item将orphan释放
4.如果release_rsv
	1.btrfs_orphan_release_metadata释放reserved
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>35990</x>
      <y>4080</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34890</x>
      <y>3950</y>
      <w>1140</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1120.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34240</x>
      <y>3360</y>
      <w>180</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34450</x>
      <y>3360</y>
      <w>260</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24140</x>
      <y>240</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>fs_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23240</x>
      <y>180</y>
      <w>970</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
open_ctree</panel_attributes>
    <additional_attributes>10.0;10.0;950.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>27870</x>
      <y>2360</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_create_uuid_tree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27960</x>
      <y>2270</y>
      <w>470</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>27800</x>
      <y>2430</y>
      <w>260</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.btrfs_start_transaction
2.btrfs_create_tree创建uuid_root
	fs_info-&gt;uuid_root = uuid_root
3.btrfs_commit_transaction
4.开启thread btrfs_uuid_scan_kthread
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27960</x>
      <y>2390</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>27810</x>
      <y>2570</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_create_tree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27870</x>
      <y>2530</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27850</x>
      <y>2600</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>27670</x>
      <y>2640</y>
      <w>380</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_root申请root，并通过__setup_root设置为tree_root的性质
2.root-&gt;root_key.objectid = objectid;
	root-&gt;root_key.type = BTRFS_ROOT_ITEM_KEY;
	root-&gt;root_key.offset = 0;
3.btrfs_alloc_tree_block申请一个leaf
4.设置leaf
	1.重置btrfs_header，并设置header.bytenr gen flags owner
	2.root-&gt;node = leaf;
	3.write_extent_buffer写header.fsid chunk_tree_uuid
	4.btrfs_mark_buffer_dirty标记leaf dirty
5.root-&gt;commit_root=root.node
6.root.state的BTRFS_ROOT_TRACK_DIRTY置上
7.设置root.root_item
8.btrfs_insert_root在磁盘上创建root
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>27790</x>
      <y>2910</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_insert_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27840</x>
      <y>2870</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27840</x>
      <y>2940</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>27660</x>
      <y>3050</y>
      <w>350</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>1.btrfs_insert_empty_item插入一个cpu_key的item
2.write_extent_buffer将data写入item，并标记leaf dirty
3.释放path，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>27780</x>
      <y>2980</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_insert_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>27820</x>
      <y>3010</y>
      <w>210</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置root_item.generation_v2</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4660</x>
      <y>1950</y>
      <w>23860</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
retry_root_backup
设置</panel_attributes>
    <additional_attributes>10.0;30.0;23840.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4640</x>
      <y>1850</y>
      <w>560</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>540.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3230</x>
      <y>1230</y>
      <w>110</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_fs_type</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3180</x>
      <y>1200</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>type-&gt;mount
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3170</x>
      <y>1120</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>mount_fs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3230</x>
      <y>1150</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3190</x>
      <y>1050</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>vfs_kern_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3220</x>
      <y>1080</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3280</x>
      <y>990</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>do_new_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3230</x>
      <y>1020</y>
      <w>110</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3370</x>
      <y>1050</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>do_add_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3330</x>
      <y>1020</y>
      <w>110</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13380</x>
      <y>7860</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_read_locked_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13480</x>
      <y>7820</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13230</x>
      <y>7930</y>
      <w>460</w>
      <h>670</h>
    </coordinates>
    <panel_attributes>1.通过btrfs_fill_inode查看内存中是否有delayed_node填充，如果有
	filled = true
2.btrfs_lookup_inode查找inode.location
3.如果filled,跳到cache_index
4.以btrfs_inode_item方式解析slot数据
	1.根据inode_item设置inode.i_mode i_nlink uid gid i_size i_atime i_mtime
		i_ctime i_otime i_bytes generation last_trans  i_version flags
5.cache_index
	1.如果inode.last_trans和fs_info.gen不同，将inode.runtime_flags
		的BTRFS_INODE_NEEDS_FULL_SYNC置上
	2.inode.last_unlink_trans=inode.last_trans
	3.path-&gt;slots[0]++
	4.以下跳到cache_acl
		1.inode.i_nlink不是1
		2.slot超过了leaf的nritems
		3.slot的ino和inode不同
	5.如果是BTRFS_INODE_REF_KEY 或者BTRFS_INODE_EXTREF_KEY
		1.设置inode.dir_index=ref.index
6.cache_acl
	1.acls_after_inode_item查找是否有xattr
	2.如果找到xattr，btrfs_load_inode_props处理xattr数据
	3.如果maybe_acls，通过cache_no_acl
		inode-&gt;i_acl = NULL;
		inode-&gt;i_default_acl = NULL;
	4.查看inode-&gt;i_mode
		1.如果是S_IFREG
			inode-&gt;i_mapping-&gt;a_ops = &amp;btrfs_aops;
			BTRFS_I(inode)-&gt;io_tree.ops = &amp;btrfs_extent_io_ops;
			inode-&gt;i_fop = &amp;btrfs_file_operations;
			inode-&gt;i_op = &amp;btrfs_file_inode_operations;
		2.如果是S_IFDIR
			inode-&gt;i_fop = &amp;btrfs_dir_file_operations;
			inode-&gt;i_op=&amp;btrfs_dir_ro_inode_operations; //tree_root
							btrfs_dir_inode_operations
		3.如果是S_IFLNK
			inode-&gt;i_op = &amp;btrfs_symlink_inode_operations;
			inode-&gt;i_mapping-&gt;a_ops = &amp;btrfs_symlink_aops;
		4.default
			inode-&gt;i_op = &amp;btrfs_special_inode_operations;
			init_special_inode(inode, inode-&gt;i_mode, rdev)
	5.btrfs_update_iflags更新inode.flags,并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13450</x>
      <y>7890</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13220</x>
      <y>8640</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>acls_after_inode_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13330</x>
      <y>8590</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13290</x>
      <y>8670</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13130</x>
      <y>8710</y>
      <w>350</w>
      <h>300</h>
    </coordinates>
    <panel_attributes>1.指定xattr_access xattr_default
2.slot++
3.遍历slot~nritems
	1.如果ino不同，直接返回0
	2.如果type是BTRFS_XATTR_ITEM_KEY
		1.返回第一个slot 
			first_xattr_slot = slot
		2.如果offset是xattr_access或者xattr_default
			返回1
	3.如果type超过BTRFS_XATTR_ITEM_KEY，返回0
	4.更新循环变量
		slot++;
		scanned++;
	5.最多值遍历8次
4.如果没有first_xattr_slot
	first_xattr_slot = slot
5.nritems遍历完或者次数达到限制，返回1
注：只有肯定没有xattr，才返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13540</x>
      <y>8640</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_load_inode_props</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13490</x>
      <y>9230</y>
      <w>370</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.执行 handler-&gt;apply
2.如果正确，将inode.runtime_flags的BTRFS_INODE_HAS_PROPS
	置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13620</x>
      <y>8590</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13620</x>
      <y>8670</y>
      <w>150</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode_prop_iterator</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13530</x>
      <y>8710</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>iterate_object_props</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13610</x>
      <y>8740</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13490</x>
      <y>8780</y>
      <w>390</w>
      <h>350</h>
    </coordinates>
    <panel_attributes>1.循环
	1.如果slot超过了leaf的nritems，btrfs_next_leaf到下一个leaf
	2.要是ino和BTRFS_XATTR_ITEM_KEY
	3.find_prop_handlers_by_hash在prop_handlers_ht中获取handler
		如果没有，跳到next_slot
	4.循环以btrfs_dir_item方式解析slot数据
		1.如果name小于XATTR_BTRFS_PREFIX_LEN
			或者不是XATTR_BTRFS_PREFIX，跳到next_dir_item
		2.更新name_buf和name_buf_len
		3.read_extent_buffer读取name到name_buf
		4.find_prop_handler查找处理xattr的handler
		5.更新value_buf和value_buf_len，并通过read_extent_buffer
			读取数据
		6.iterator处理value
		7.next_dir_item：
			1.更新循环变量
				cur += this_len;
				di = (struct btrfs_dir_item *)((char *) di + this_len)
	5.更新循环变量
		path-&gt;slots[0]++
2.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13600</x>
      <y>9160</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>iterator
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13650</x>
      <y>9190</y>
      <w>150</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode_prop_iterator</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13650</x>
      <y>9120</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>12870</x>
      <y>9490</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_op-&gt;create
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12920</x>
      <y>9520</y>
      <w>190</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_dir_inode_operations</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>12870</x>
      <y>9560</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>12760</x>
      <y>9630</y>
      <w>390</w>
      <h>300</h>
    </coordinates>
    <panel_attributes>1.btrfs_start_transaction
2.btrfs_find_free_ino查找空闲的ino
3.btrfs_new_inode在磁盘创建inode_item ref并对
	其进行初始化
4.inode-&gt;i_fop = &amp;btrfs_file_operations;
	inode-&gt;i_op = &amp;btrfs_file_inode_operations;
	inode-&gt;i_mapping-&gt;a_ops = &amp;btrfs_aops;
5.btrfs_init_inode_security初始化acl xattr
6.btrfs_update_inode
7.btrfs_add_nondir利用btrfs_add_link创建dir_item
8.BTRFS_I(inode)-&gt;io_tree.ops = &amp;btrfs_extent_io_ops
9.unlock_new_inode清除inode.i_state中的I_NEW
10.d_instantiate关联dentry和inode
11.out_unlock
	1.btrfs_end_transaction
	2.如果出错，释放inode
	3.btrfs_balance_delayed_items
	4.btrfs_btree_balance_dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12910</x>
      <y>9590</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>12540</x>
      <y>9950</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_find_free_ino</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12630</x>
      <y>9920</y>
      <w>170</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>12440</x>
      <y>10020</y>
      <w>370</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.如果root的INODE_MAP_CACHE没置上，通过btrfs_find_free_objectid查找
2.again
	1.btrfs_find_ino_for_alloc在free_ino_ctl中查找ino
		如果找到，直接返回0
	2.否则
		1.start_caching在free_ino_ctl中加载空闲的free_ino
		2.wait_event等待BTRFS_CACHE_FINISHED或者有free_space
	3.如果条件不满足，返回ENOSPC
	4.否则跳到again重新查找
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12580</x>
      <y>9980</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>12260</x>
      <y>10200</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_find_free_objectid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12320</x>
      <y>10170</y>
      <w>210</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>12150</x>
      <y>10270</y>
      <w>380</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.如果root-&gt;highest_objectid小于BTRFS_FIRST_FREE_OBJECTID
	通过btrfs_find_highest_objectid设置
2.如果highest_objectid超过了BTRFS_LAST_FREE_OBJECTID
	返回ENOSPC
3.递增root-&gt;highest_objectid，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12330</x>
      <y>10230</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>12250</x>
      <y>10400</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_find_highest_objectid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12310</x>
      <y>10360</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12320</x>
      <y>10430</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>12130</x>
      <y>10470</y>
      <w>400</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot查找低于BTRFS_LAST_FREE_OBJECTID的path
	返回值一定大于1
2.调整slot
	1.如果slot大于0，返回slot的objectid
	2.否则返回( BTRFS_FIRST_FREE_OBJECTID - 1)无效值
3.释放path，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>12610</x>
      <y>10210</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_find_ino_for_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12680</x>
      <y>10170</y>
      <w>90</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>12540</x>
      <y>10280</y>
      <w>380</w>
      <h>270</h>
    </coordinates>
    <panel_attributes>1.free_ino_ctl.free_space_offset为空，跳到out，返回0
2.获取红黑树free_space_offset链表第一个
	1.如果不是bitmap
		1.ino = entry-&gt;offset
		2.更新红黑树中entry
			unlink_free_space(ctl, entry);
			entry-&gt;offset++;
			entry-&gt;bytes--
		3.如果空间被用完，将entry释放，否则通过link_free_space
			链入到红黑树中
	2.如果是bitmap
		1.search_bitmap获取1个free_bit的offset
		2.ino = offset
		3.bitmap_clear_bits清除对应的bi
		4.如果entry空间用完，通过free_bitmap将其释放
3.返回ino
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12690</x>
      <y>10240</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13040</x>
      <y>10200</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>start_caching</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>12780</x>
      <y>10170</y>
      <w>330</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13090</x>
      <y>10230</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>12950</x>
      <y>10270</y>
      <w>390</w>
      <h>170</h>
    </coordinates>
    <panel_attributes>1.如果root的INODE_MAP_CACHE没置上，直接返回
2.如果root.ino_cache_state已经缓存，直接返回
3.root-&gt;ino_cache_state = BTRFS_CACHE_STARTED
4.load_free_ino_cache获取free_ino对应的free_space
注：free_ino对应的offset是0，block_group对应的是其key.offset
5.如果返回1，返回
	root-&gt;ino_cache_state = BTRFS_CACHE_FINISHED
6.否则通过btrfs_find_free_objectid查找free_ino
	如果正确找到，通过__btrfs_add_free_space将该段加入到free_ino_ctl
7.开启thread caching_kthread
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13100</x>
      <y>10460</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>load_free_ino_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13190</x>
      <y>10430</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>12990</x>
      <y>10530</y>
      <w>380</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.如果root没置上INODE_MAP_CACHE，直接返回0
2.如果btrfs_fs_closing，直接返回0
3.lookup_free_ino_inode获取包含free_ino的inode
4.__load_free_space_cache将inode中的free_space
	加载到root-&gt;free_ino_ctl中
5.释放inode，path，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13170</x>
      <y>10490</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13080</x>
      <y>10680</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lookup_free_ino_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13140</x>
      <y>10630</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13150</x>
      <y>10710</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>12990</x>
      <y>10750</y>
      <w>360</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.如果有root-&gt;ino_cache_inode，获取这个inode，并返回
2.__lookup_free_space_inode查找offset为0的free_space ino
3.如果没有btrfs_fs_closing，设置root-&gt;ino_cache_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13510</x>
      <y>9960</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_new_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13400</x>
      <y>10030</y>
      <w>390</w>
      <h>640</h>
    </coordinates>
    <panel_attributes>1.new_inode获取一个inode(没去磁盘读取，btrfs_iget会从磁盘中获取)
2.如果没指定name，将inode.i_nlink设为0
3.inode-&gt;i_ino = objectid
4.如果父dir和子name都存在
	1.btrfs_set_inode_index获取index
5.如果没有name，但是有dir
	index=0
6.初始化inode
	inode-&gt;index_cnt = 2;
	inode-&gt;dir_index = *index
	inode-&gt;root = root
	inode-&gt;generation = trans-&gt;transid;
	inode.runtime_flags|=BTRFS_INODE_NEEDS_FULL_SYNC
7.设置inode.location
	location-&gt;objectid = objectid;
	location-&gt;offset = 0;
	location-&gt;type = BTRFS_INODE_ITEM_KEY;
8.btrfs_insert_inode_locked将inode插入到hash中
9.btrfs_insert_empty_items向root中插入BTRFS_INODE_ITEM_KEY
	和BTRFS_INODE_REF_KEY(name存在使)
	path-&gt;leave_spinning = 1
	注：此时path获取的是item插入的位置，不是ref
10.inode_init_owner初始化inode.i_uid i_gid i_mode
	inode_set_bytes设置i_blocks i_bytes为0
	设置i_mtime i_atime i_ctime i_otime
11.以btrfs_inode_item方式解析slot数据
	1.将inode_item清0
	2.根据inode的信息填充磁盘上的inode_item
12.如果有name，以btrfs_inode_ref解析path+1
	1.填充ref.name_len index name
13.标记path leaf dirty
14.设置inode的flags
	1.btrfs_inherit_iflags承袭父dir的flags
	2.根据root的状态设置flags
15.inode_tree_add将其插入红黑树root.inode_tree中
16.btrfs_set_inode_last_trans设置inode.last_trans last_sub_trans last_log_commit
17.btrfs_update_root_times设置root_item.ctransid ctime
18.btrfs_inode_inherit_props查看是否承袭dir的props
19.返回inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13550</x>
      <y>9990</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13370</x>
      <y>10710</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_set_inode_index</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13450</x>
      <y>10660</y>
      <w>70</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13440</x>
      <y>10740</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13370</x>
      <y>10780</y>
      <w>320</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.如果dir.index_cnt没初始化
	1.通过btrfs_inode_delayed_dir_index_count进行初始化
	2.如果出错，btrfs_set_inode_index_count从磁盘上获取指向ino的index
3.*index = BTRFS_I(dir)-&gt;index_cnt;
	BTRFS_I(dir)-&gt;index_cnt++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13180</x>
      <y>10900</y>
      <w>280</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_inode_delayed_dir_index_count</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13290</x>
      <y>10860</y>
      <w>150</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13290</x>
      <y>10930</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13170</x>
      <y>10970</y>
      <w>340</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.获取inode的delayed_inode
2.如果delayed_inode.index_cnt为0，btrfs_release_delayed_node
	释放delayed_inode，并返回EINVAL
3.否则
	1.inode.index_cnt = delayed_node-&gt;index_cnt
	2.释放delayed_inode，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13590</x>
      <y>10900</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_set_inode_index_count</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13630</x>
      <y>10860</y>
      <w>70</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13530</x>
      <y>10970</y>
      <w>370</w>
      <h>130</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot从后查找指向ino的BTRFS_DIR_INDEX_KEY
	不能正好找到
2.如果找到slot 0(说明没有index)，跳到out
	inode.index_cnt=2
3.调整slot，并检查slot的ino和type
4.如果通过
	ndex_cnt = found_key.offset + 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13700</x>
      <y>10930</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13990</x>
      <y>10700</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_insert_inode_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13990</x>
      <y>10770</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>insert_inode_locked4</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14080</x>
      <y>10730</y>
      <w>120</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_find_actor</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13920</x>
      <y>10840</y>
      <w>370</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.遍历inode_hashtable中的bucket
	1.sb要相同
	2.location和root要相同(test:btrfs_find_actor)
	3.状态不在I_FREEING|I_WILL_FREE
2.如果没找到
	1.inode-&gt;i_state |= I_NEW
	2.hlist_add_head将inode链入到hash表
	3.返回0
3.如果在hash表中找到了inode
	1.__iget增加inode的计数
	2.wait_on_inode等待inode的__I_NEW置上
	3.醒来之后发现不在hash表中，将其释放，并返回EBUSY
4.释放inode，跳到1继续查找
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14070</x>
      <y>10800</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13740</x>
      <y>10660</y>
      <w>330</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13080</x>
      <y>9920</y>
      <w>510</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;490.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14240</x>
      <y>9520</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_op-&gt;lookup
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14300</x>
      <y>9550</y>
      <w>190</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_dir_inode_operations</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14250</x>
      <y>9590</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14130</x>
      <y>9660</y>
      <w>290</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.btrfs_lookup_dentry在dir中查询dentry
2.d_splice_alias关联dentry和inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14300</x>
      <y>9620</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14000</x>
      <y>9730</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_lookup_dentry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14070</x>
      <y>9700</y>
      <w>140</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14050</x>
      <y>9760</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13870</x>
      <y>9800</y>
      <w>400</w>
      <h>260</h>
    </coordinates>
    <panel_attributes>1.如果name的长度超过了BTRFS_NAME_LEN，返回ENAMETOOLONG
2.btrfs_inode_by_name根据dentry查找location
	1.如果出错，即返回
	2.如果找到objectid为0，返回ENOENT
	3.如果找到的是BTRFS_INODE_ITEM_KEY，通过btrfs_iget
		获取inode，并返回
3.要是BTRFS_ROOT_ITEM_KEY
	1.fixup_tree_root_location获取新root下location
	2.如果出错
		1.如果不是ENOENT，直接返回错误
		2.否则new_simple_dir简单初始化inode
	3.否则，btrfs_iget获取新的inode
	4.如果inode找到，并且dir和ino的root不同
		1.如果inode不是MS_RDONLY，btrfs_orphan_cleanup
			清除sub_root中不正确的orphan
4.返回inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>13860</x>
      <y>10090</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_inode_by_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13920</x>
      <y>10050</y>
      <w>90</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13930</x>
      <y>10120</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>13800</x>
      <y>10160</y>
      <w>390</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.btrfs_lookup_dir_item根据name_hash在磁盘中找到对应di
2.获取di中的key给到location
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14280</x>
      <y>10090</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>fixup_tree_root_location</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14220</x>
      <y>10050</y>
      <w>160</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14370</x>
      <y>10120</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14220</x>
      <y>10160</y>
      <w>350</w>
      <h>190</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot查找执行root的BTRFS_ROOT_REF_KEY
2.以btrfs_root_ref方式解析slot数据
	1.ref.dirid要和dir相同
	2.ref.name_len要和dentry的name相同
	3.比较ref.name和dentry.name要相同
3.根据location读取dentry对应的root
	sub_root = new_root
4.更新新的location
	location-&gt;objectid =root_item.root_dirid
	location-&gt;type = BTRFS_INODE_ITEM_KEY;
	location-&gt;offset = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14690</x>
      <y>10080</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>new_simple_dir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14610</x>
      <y>10150</y>
      <w>370</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.new_inode在s下创建一个inode
2.初始化inode
	inode-&gt;i_ino = BTRFS_EMPTY_SUBVOL_DIR_OBJECTID;
	inode-&gt;i_op = &amp;btrfs_dir_ro_inode_operations;
	inode-&gt;i_fop = &amp;simple_dir_operations;
	inode-&gt;i_mode = S_IFDIR | S_IRUGO | S_IWUSR | S_IXUGO;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14750</x>
      <y>10110</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14230</x>
      <y>10050</y>
      <w>520</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14570</x>
      <y>9740</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>d_splice_alias</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14430</x>
      <y>9810</y>
      <w>370</w>
      <h>210</h>
    </coordinates>
    <panel_attributes>1.如果不是inode，__d_instantiate将dentry和NULL关联
2.如果inode是dir
	1.获取inode.i_dentry链表中的第一个dentry
	2.如果能找到
		1.如果d_ancestor检查到new是dentry的一个parent
			返回ELOOP
		2.如果new不是root，__d_unalias
		3.否则__d_move
		4.返回new
3.否则__d_instantiate关联inode和dentry，返回NULL
4.d_rehash重排dentry
5.返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14620</x>
      <y>9770</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14380</x>
      <y>9700</y>
      <w>260</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15440</x>
      <y>9850</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;write_iter
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15420</x>
      <y>9920</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_file_write_iter</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15490</x>
      <y>9880</y>
      <w>150</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_file_operations</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15470</x>
      <y>9590</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>sys_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15470</x>
      <y>9650</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>vfs_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15460</x>
      <y>9710</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__vfs_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15460</x>
      <y>9780</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>new_sync_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15520</x>
      <y>9620</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15510</x>
      <y>9680</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15510</x>
      <y>9740</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15500</x>
      <y>9810</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15280</x>
      <y>9990</y>
      <w>480</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>1.generic_write_checks检查要写的长度是否在限制范围内
2.file_remove_privs移除file权限
3.如果fs_state的BTRFS_FS_STATE_ERROR，返回EROFS
4.update_time_for_write
5.如果pos超过了inode.i_size,btrfs_cont_expand
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15190</x>
      <y>10300</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>generic_write_checks</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15100</x>
      <y>10370</y>
      <w>300</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.如果要写的字节数为0，返回0
2.如果需要IOCB_APPEND
	iocb-&gt;ki_pos=inode.i_size
3.如果ki_pos超过了limit，返回EFBIG
	否则iov_iter_truncate使写入的长度不超过limit
4.检查ki_pos和count是否超过MAX_NON_LFS
5.ki_pos和count不能超过s_maxbytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15250</x>
      <y>10330</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15510</x>
      <y>10300</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_cont_expand</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15450</x>
      <y>10370</y>
      <w>360</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.btrfs_truncate_page截留oldsize的长度
2.size在oldsize范围内，返回0
3.循环
	1.btrfs_lookup_ordered_range查找冲hole_start~block_end
		段重叠的ordered
	2.btrfs_start_ordered_extent等待ordered落盘
	3.直到找不到ordered
4.循环
	1.btrfs_get_extent获取oldsize~size的em
	2.如果em的EXTENT_FLAG_PREALLOC没置上
		1.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15580</x>
      <y>10330</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>34770</x>
      <y>4920</y>
      <w>460</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>1.如果整页需要删，跳到out
2.btrfs_delalloc_reserve_space
3.again
	1.find_or_create_page
	2.如果page没有uptodate，btrfs_readpage
	3.wait_on_page_writeback
	4.set_page_extent_mapped
	5.如果btrfs_lookup_ordered_extent还能在inode中找到要截断的ordered
		btrfs_start_ordered_extent写入要截断的段，并且wait
		之后跳到again
	6.clear_extent_bit
	7.btrfs_set_extent_delalloc
	8.根据front将page前端清0，或者将后端清0
	9.set_page_dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>34960</x>
      <y>4880</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15320</x>
      <y>10640</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_get_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15370</x>
      <y>10610</y>
      <w>170</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15180</x>
      <y>10710</y>
      <w>400</w>
      <h>510</h>
    </coordinates>
    <panel_attributes>1.lookup_extent_mapping在extent_tree中查找包含段的em
2.如果em找到
	1.start不在em范围内，或者block_start在EXTENT_MAP_INLINE，并且page存在
		free_extent_map释放em
	2.跳到out
3.alloc_extent_map申请em
4.btrfs_lookup_file_extent在磁盘中寻找指向ino的extent_data,
	并根据返回值调整slot
5.如果ino不同或者不是extent_data_type，跳到next
	extent_end = start
6.根据item type计算extent_end
7.next
	1.如果start超过了extent_end
		1.递增slot，如果超过了nritems，btrfs_next_leaf
		2.检查slot
			1.ino和type不同，查找段的长度低于found_key.offset
				跳到not_found
			2.如果start还是超过了offset，跳到next继续遍历下一个slot
		3.确定em，跳到not_found_em
			em-&gt;start = start;
			em-&gt;orig_start = start;
			em-&gt;len = found_key.offset - start;
	2.如果在低于extent_end
		1.btrfs_extent_item_to_extent_map初始化em为其extent的长度
		2.如果是BTRFS_FILE_EXTENT_REG BTRFS_FILE_EXTENT_PREALLOC
			直接跳到insert
		3.如果是BTRFS_FILE_EXTENT_INLINE
			1.如果new_inline，跳到out
			2.
		4.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15370</x>
      <y>10670</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>7800</x>
      <y>3260</y>
      <w>380</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.如果trans和running_transaction或者generation不同，报警
2.如果不用should_cow_block，直接返回0
3.__btrfs_cow_block
注：search_start是extent的逻辑地址buf-&gt;start按G对齐
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7850</x>
      <y>3220</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>7890</x>
      <y>3370</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_cow_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>7680</x>
      <y>3440</y>
      <w>480</w>
      <h>520</h>
    </coordinates>
    <panel_attributes>1.如果cow_ret指向buf，将unlock_orig置上
2.获取buf slot0的key
3.确定parent_start
	1.只有在root_key是BTRFS_TREE_RELOC_OBJECTID，并且存在parent时
		parent_start = parent-&gt;start
	2.否则
		parent_start = 0
4.btrfs_alloc_tree_block申请cow
5.copy_extent_buffer将buf中的数据复制到cow
	1.重新设置cow_header.bytenr gen backref_rev flag owner fsid 
6.update_ref_for_cow更新buf下的ref(如果不在buf.owner下更新cow，也更新cow下的)
7.如果BTRFS_ROOT_REF_COWS置上，btrfs_reloc_cow_block
8.如果buf是root
	1.如果是BTRFS_TREE_RELOC_OBJECTID或者buf.backref_rev低于BTRFS_MIXED_BACKREF_REV
		使用full_ref，
	2.使用cow替换buf
		1.extent_buffer_get递增cow计数
		2.tree_mod_log_set_root_pointer记录替换root的log
		3.root-&gt;node=cow
	3.btrfs_free_tree_block和free_extent_buffer释放对buf的索引
	3.add_root_to_dirty_list将root.dirty_list添加到对应链表
9.如果不是root
	1.如果是BTRFS_TREE_RELOC_OBJECTID，使用full_ref
	2.修改cow中(block,gen)
		1.tree_mod_log_insert_key记录log MOD_LOG_KEY_REPLACE
		2.设置parent的(cow-&gt;start,trans-&gt;transid)
		3.标记parent dirty
	3.如果是last_ref，tree_mod_log_free_eb记录log 释放buf
		btrfs_free_tree_block释放对buf的引用
10.free_extent_buffer_stale
11.btrfs_mark_buffer_dirty标记cow dirty
12.*cow_ret = cow
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7950</x>
      <y>3330</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7950</x>
      <y>3400</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7450</x>
      <y>3950</y>
      <w>310</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7460</x>
      <y>4050</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>6720</x>
      <y>4470</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_lookup_extent_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6810</x>
      <y>4430</y>
      <w>520</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>500.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>6790</x>
      <y>4500</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>6610</x>
      <y>4540</y>
      <w>370</w>
      <h>300</h>
    </coordinates>
    <panel_attributes>1.如果是meta，但是不是skinny，调整offset为nodesize,
	然后搜索data
2.search_again
	1.btrfs_search_slot根据meta查询key，如果不是0，表示没找到
		1.meta可以向data退
		2.以btrfs_extent_item方式解析slot数据
			num_refs=ei.ref
			extent_flags=ei.flags
	2.如果没找到
		num_refs = 0;
		extent_flags = 0;
		ret = 0;
3.如果有trans
	1.btrfs_find_delayed_ref_head获取head
	2.mutex_trylock
	3.extent_flags |= head-&gt;extent_op-&gt;flags_to_set
	4.num_refs += head-&gt;node.ref_mod
4.将num_refs和extent_flags返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>7110</x>
      <y>4490</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_inc_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>7110</x>
      <y>4560</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_mod_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7160</x>
      <y>4520</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7160</x>
      <y>4590</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>7260</x>
      <y>4090</y>
      <w>450</w>
      <h>350</h>
    </coordinates>
    <panel_attributes>1.如果btrfs_block_can_be_shared，通过btrfs_lookup_extent_info
	统计磁盘和ram(delay_head)中的引用
2.如果不是shared,根据情况值flags
	refs=1
3.如果有多余一个的引用
	1.如果owner和root相同，或则和reloc+!full_backref,
		1.通过btrfs_inc_ref递增对原有buf下block和extend的引用(full)
		2.如果root是BTRFS_TREE_RELOC_OBJECTID
			1.btrfs_dec_ref递减对buf下的引用(!full，这里进行修复)
			2.btrfs_inc_ref递增对cow的引用(full)
		3.new_flags |= BTRFS_BLOCK_FLAG_FULL_BACKREF
	2.否则
		1.通过btrfs_inc_ref递增对cow的引用，如果是BTRFS_TREE_RELOC_OBJECTID
			以full_backref方式递增
	3.如果有new_flags，通过btrfs_set_disk_extent_flags设置head_ref的extent_op
4.如果只有一个ref
	1.btrfs_inc_ref递增cow下的引用(如果是BTRFS_TREE_RELOC_OBJECTID，则full_backref)
	2.btrfs_dec_ref递减buf下的引用(full_backref)
	3.clean_tree_block在dirty时，写io
		last_ref=1//表示是最后一个ref，之后要做释放
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>7390</x>
      <y>4020</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>update_ref_for_cow</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>7010</x>
      <y>4630</y>
      <w>440</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.如果btrfs_test_is_dummy_root，返回0
2.如果buf是leaf，并且root的BTRFS_ROOT_REF_COWS没置上，返回0
3.确定process_func和parent
4.遍历buf的nritems
	1.如果是leaf
		1.type要是BTRFS_EXTENT_DATA_KEY
		2.以btrfs_file_extent_item方式解析slot数据
			1.fi.type要是BTRFS_FILE_EXTENT_INLINE
			2.fi.disk_bytenr不是0
		3.通过process_func处理ref
	2.如果不是leaf，通过process_func操作其下的每个slot中的block的ref
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7170</x>
      <y>4430</y>
      <w>180</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>7500</x>
      <y>4470</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_set_disk_extent_flags</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7590</x>
      <y>4430</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>7470</x>
      <y>4540</y>
      <w>300</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_delayed_extent_op申请extent_op
	extent_op-&gt;flags_to_set = flags;
	extent_op-&gt;update_flags = 1;
	extent_op-&gt;update_key = 0;
	extent_op-&gt;is_data = is_data ? 1 : 0;
	extent_op-&gt;level = level;
2.btrfs_add_delayed_extent_op更新extent_op
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7580</x>
      <y>4500</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>7500</x>
      <y>4690</y>
      <w>230</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_add_delayed_extent_op</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7600</x>
      <y>4650</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7590</x>
      <y>4720</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>7460</x>
      <y>4760</y>
      <w>330</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.申请head_ref
2.add_delayed_ref_head添加BTRFS_UPDATE_DELAYED_HEAD
	更新head_ref
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>7990</x>
      <y>4040</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_reloc_cow_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8080</x>
      <y>3950</y>
      <w>30</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>7860</x>
      <y>4110</y>
      <w>450</w>
      <h>290</h>
    </coordinates>
    <panel_attributes>1.如果没有reloc_ctl，直接返回0
2.如果root是BTRFS_TREE_RELOC_OBJECTID，并且buf是root
	__update_reloc_root更改红黑树reloc_root_tree中的bytenr
3.如果buf.gen低于root_item.last_snapshot,置上first_cow
4.如果是BTRFS_TREE_RELOC_OBJECTID，并且create_reloc_tree，更新backref_node
	1.drop_node_buffer释放rc-&gt;backref_cache.path
	2.extent_buffer_get递增cow
		node-&gt;eb = cow;
		node-&gt;new_bytenr = cow-&gt;start
	3.如果node.pending没置上
		1.list_move_tail将node添加到链表rc-&gt;backref_cache.pending[level]尾端
		2.node-&gt;pending = 1
	4.如果first_cow，__mark_block_processed标记node.processed
	5.如果不是leaf进行first_cow
		rc-&gt;nodes_relocated += buf-&gt;len
5.如果是leaf进行first_cow，并且rc.stage在UPDATE_DATA_PTRS
	通过replace_file_extents
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8060</x>
      <y>4070</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>7860</x>
      <y>4440</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__update_reloc_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7930</x>
      <y>4390</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>7810</x>
      <y>4510</y>
      <w>330</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.tree_search在reloc_root_tree寻找root.node.start
2.如果找到将其从reloc_root_tree红黑树中删除
3.更改node,并且通过tree_insert重新插入红黑树reloc_root_tree中
	node-&gt;bytenr = new_bytenr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>7930</x>
      <y>4470</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>8190</x>
      <y>4440</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__mark_block_processed</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>8160</x>
      <y>4510</y>
      <w>320</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.如果是leaf，或者node在rc-&gt;block_group中
	1.mark_block_processed将processed_blocks中对应的段标记为EXTENT_DIRTY
2.node-&gt;processed = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8270</x>
      <y>4470</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8270</x>
      <y>4390</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8300</x>
      <y>4390</y>
      <w>360</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>8570</x>
      <y>4420</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>replace_file_extents</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>8500</x>
      <y>4490</y>
      <w>370</w>
      <h>420</h>
    </coordinates>
    <panel_attributes>1.如果rc.stage不在UPDATE_DATA_PTRS，直接返回0
2.如果是BTRFS_TREE_RELOC_OBJECTID，使用full_backref
	prent为leaf-&gt;start，否则为0
3.遍历leaf的nritems
	1.slot要是BTRFS_EXTENT_DATA_KEY
	2.以btrfs_file_extent_item方式解析slot数据,只有在以下情况才做处理
		1.fi.type不能是BTRFS_FILE_EXTENT_INLINE
		2.fi.disk_bytenr不能是0，并且要在rc-&gt;block_group中
	3.如果root不是BTRFS_TREE_RELOC_OBJECTID
		1.如果是第一个slot，find_next_inode找到root.inode_tree
			红黑树链表中的不小于key.objectid的inode
		2.如果有inode，并且低于当前slot的ino
			1.btrfs_add_delayed_iput将inode添加到delayed_iputs
			2.find_next_inode寻找不小于slot ino的inode
		3.如果找到的inode和slot ino相同
			1.try_lock_extent将inode.io_tree中该段锁上
			2.btrfs_drop_extent_cache将inode.extent_tree中slot对应的段删除
			3.unlock_extent
	4.get_new_location获取其在rc.data_inode上的new_bytenr
	5.重新设置fi.disk_bytenr=new_bytenr
	6.btrfs_inc_extent_ref在root中递增对new_bytenr的引用，
		btrfs_free_extent释放对bytenr的引用
		key.offset -= btrfs_file_extent_offset(leaf, fi)
4.如果修改过leaf，标记leaf dirty
5.将最后一个遍历的inode通过btrfs_add_delayed_iput
	加入到delayed_iputs链表
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8640</x>
      <y>4450</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>8420</x>
      <y>4950</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_add_delayed_iput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8490</x>
      <y>4900</y>
      <w>40</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>8310</x>
      <y>5020</y>
      <w>350</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.atomic_add_unless在inode.i_count不是-1时，递增
	否则直接返回
2.申请delayed
	delayed-&gt;inode = inode
3.将delayed.list添加到链表fs_info-&gt;delayed_iputs尾端
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8490</x>
      <y>4980</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>8790</x>
      <y>4950</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>get_new_location</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8840</x>
      <y>4900</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>8670</x>
      <y>5020</y>
      <w>350</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.btrfs_lookup_file_extent再root中找到指向ino的bytenr
	bytenr -= BTRFS_I(reloc_inode)-&gt;index_cnt
2.以btrfs_file_extent_item方式解析path数据
	1.fi.disk_num_bytes和要求的长度不同，返回EINVAL
	2.否则返回reloc中的fi.disk_bytenr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>41940</x>
      <y>2480</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>balance_kthread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>41630</x>
      <y>2620</y>
      <w>420</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>1.如果btrfs_fs_closing，或者有balance_pause_req，或者balance_cancel_req
	返回EINVAL
2.如果super_copy的BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS置上
	将mixed置上
3.allowed = BTRFS_BALANCE_DATA | BTRFS_BALANCE_METADATA
4.如果mixed，并且bctl被allowed，在以下三个条件不满足时，报EINVAL
	1.如果bctl的BTRFS_BALANCE_DATA没置上
	2.或者BTRFS_BALANCE_METADATA没置上
	3.或者data和meta相同
5.如果有btrfs_dev_replace_is_ongoing
	fs_info-&gt;fs_devices-&gt;num_devices--
6.根据num_devices，确定allowed的raid类型
7.validate_convert_profile验证bctl-&gt;data，meta，sys是否allowed
8.如果是dup，只能在mixed的模式下
9.检查avail_system_alloc_bits和bctl-&gt;sys，检查avail_metadata_alloc_bits和bctl-&gt;meta
10.如果BTRFS_BALANCE_ARGS_CONVERT置上
	设置fs_info-&gt;num_tolerated_disk_barrier_failures
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>41940</x>
      <y>2540</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_balance</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>41980</x>
      <y>2510</y>
      <w>150</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fs_info-&gt;balance_ctl</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>41790</x>
      <y>2570</y>
      <w>230</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>42000</x>
      <y>2570</y>
      <w>230</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>42070</x>
      <y>2620</y>
      <w>410</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>11.insert_balance_item在tree_root中根据bctl添加balance_item
12.如果bctl的BTRFS_BALANCE_RESUME没置上，set_balance_control
	设置fs_info-&gt;balance_ctl = bctl
13.如果置上，通过update_balance_args更新bctl.data.flags
	bctl.meta.flags  bctl.sys.flags
14.__btrfs_balance
15.如果bctl-&gt;sys的BTRFS_BALANCE_ARGS_CONVERT置上，再次设置
	fs_info-&gt;num_tolerated_disk_barrier_failures 
16.如果有bargs，将其先清0，update_ioctl_balance_args将bctl中
	的数据放入bargs
17.如果出错，或者balance_need_close
	__cancel_balance
18.唤醒fs_info-&gt;balance_wait_q，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>42080</x>
      <y>2870</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>insert_balance_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>41960</x>
      <y>2940</y>
      <w>380</w>
      <h>180</h>
    </coordinates>
    <panel_attributes>1.btrfs_start_transaction
2.btrfs_insert_empty_item在root中插入BTRFS_BALANCE_ITEM_KEY
3.设置slot数据
	1.memset_extent_buffer将数据区清0
	2.将bctl-&gt;data写入btrfs_balance_item.data
		将bctl-&gt;meta写入btrfs_balance_item.meta
		将bctl-&gt;sys写入btrfs_balance_item.sys
		将bctl-&gt;flags写入btrfs_balance_item.sysflags
4.标记leaf dirty
5.btrfs_commit_transaction，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>42140</x>
      <y>2830</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>42140</x>
      <y>2900</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>42410</x>
      <y>2870</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_balance</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>42460</x>
      <y>2830</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>42360</x>
      <y>2940</y>
      <w>330</w>
      <h>230</h>
    </coordinates>
    <panel_attributes>1.遍历链表fs_info-&gt;fs_devices-&gt;devices，对每个device腾出足够空间
	1.size_to_free在total_bytes的基础上不能大于1M
	2.如果不能writeable，没有足够空间size_to_free，或者is_tgtdev_for_dev_replace
		遍历下一个device
	3.btrfs_shrink_device
	4.btrfs_start_transaction
	5.btrfs_grow_device
	6.btrfs_end_transaction
2.将bctl-&gt;stat清0
3.again
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>42470</x>
      <y>2900</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>42230</x>
      <y>3180</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_shrink_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>42290</x>
      <y>3160</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>42120</x>
      <y>3250</y>
      <w>360</w>
      <h>470</h>
    </coordinates>
    <panel_attributes>1.如果is_tgtdev_for_dev_replace，返回EINVAL
2.device.total_bytes=new_size
3.如果writeable
	1.device-&gt;fs_devices-&gt;total_rw_bytes -= diff
	2.root-&gt;fs_info-&gt;free_chunk_space -= diff
4.again
	1.btrfs_search_slot搜寻指向device-&gt;devid的BTRFS_DEV_EXTENT_KEY
	2.btrfs_previous_item查看path前一个slot
		1.devid要和key.objectid相等
		2.以btrfs_dev_extent方式解析slot数据
		3.如果slot描述的段在new_size范围内退出循环
		4.btrfs_relocate_chunk重定位dev_extent.chunk_offset
		5.如果出错，跳到done，如果是ENOSPC
			failed++
	3.跳到again，重新遍历前一个slot
		key.offset--
5.如果failed，并且没有retried，清failed，置retried，跳到again
	如果failed，并且retried，返回ENOSPC，跳到done
6.btrfs_start_transaction
7.如果没有checked_pending_chunks
	1.
8.device.total_bytes=new_size
9.将device-&gt;resized_list挂入到链表fs_info-&gt;fs_devices-&gt;resized_devices之后
10.super_copy.total_bytes=old_total - diff
11.btrfs_update_device
12.btrfs_end_transaction
13.done
	1.如果出错，恢复device.total_bytes   fs_devices-&gt;total_rw_bytes
		fs_info-&gt;free_chunk_space
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>42290</x>
      <y>3210</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>41950</x>
      <y>3740</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_relocate_chunk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>42020</x>
      <y>3710</y>
      <w>150</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>42510</x>
      <y>3730</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_update_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>42430</x>
      <y>3710</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>42240</x>
      <y>3750</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>contains_pending_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>42310</x>
      <y>3710</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>41920</x>
      <y>3810</y>
      <w>310</w>
      <h>340</h>
    </coordinates>
    <panel_attributes>System
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>42010</x>
      <y>3770</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24640</x>
      <y>7320</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_copy_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24520</x>
      <y>7390</y>
      <w>370</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.获取buf slot0的key
2.btrfs_alloc_tree_block申请eb cow
	1.btrfs_alloc_tree_block复制buf的数据到cow
	2.设置cow.btrfs_header.bytenr(硬件偏移) gen backref_rev（BTRFS_MIXED_BACKREF_REV）
	3.将cow.btrfs_header.flag的BTRFS_HEADER_FLAG_WRITTEN |BTRFS_HEADER_FLAG_RELOC清掉
	4.如果new_root_objectid是BTRFS_TREE_RELOC_OBJECTID
		1.将cow.btrfs_header.flag的BTRFS_HEADER_FLAG_RELOC置上
	5.否则设置cow.btrfs_header.owner=new_root_objectid
	6.设置cow.btrfs_header.fsid
	7.btrfs_inc_ref递增对cow的引用，如果是BTRFS_TREE_RELOC_OBJECTID
		以full_backref方式递增
3.btrfs_mark_buffer_dirty标记cow dirty，并返回cow
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24680</x>
      <y>7350</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25030</x>
      <y>6870</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__add_reloc_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25090</x>
      <y>6830</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24920</x>
      <y>6940</y>
      <w>350</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.申请mapping_node
	node-&gt;bytenr = root-&gt;node-&gt;start;
	node-&gt;data = root;
2.tree_insert将mapping_node插入到reloc_root_tree
3.将root.root_list挂入到fs_info-&gt;reloc_ctl.reloc_roots中
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25090</x>
      <y>6900</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>8830</x>
      <y>4980</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>36080</x>
      <y>2290</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_recover_relocation</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>35960</x>
      <y>2360</y>
      <w>400</w>
      <h>480</h>
    </coordinates>
    <panel_attributes>1.循环得到tree_root下所有的reloc_root
	1.btrfs_search_slot读取reloc的root_item,并根据返回值调整path.slot
	2.slot的key要满足要求
	3.btrfs_read_fs_root读取reloc_root，并将其加入reloc_roots链表(root_list)
	4.如果reloc_root有索引
		1.read_fs_root读取reloc_root指向的root(reloc_root-&gt;root_key.offset)
		2.如果返回ENOENT，mark_garbage_root更新root_item
	5.更新循环变量key.offset--（等于0退出循环）
2.如果reloc_roots不为空
	1.alloc_reloc_control申请rc
		rc-&gt;extent_root = root-&gt;fs_info-&gt;extent_root
	2.set_reloc_control绑定fs_info
		fs_info-&gt;reloc_ctl = rc
3.btrfs_join_transaction
4.rc-&gt;merge_reloc_tree = 1
5.遍历链表reloc_roots，建立rc，root和reloc_root的关系
	1.将reloc_root从链表中删除
	2.如果其不被引用，加入到rc-&gt;reloc_roots链表，并继续循环
	3.read_fs_root读取reloc_root指向的root，通过__add_reloc_root
		申请mapping_node添加到红黑树rc-&gt;reloc_root_tree和链表reloc_roots
		fs_root-&gt;reloc_root = reloc_root
6.btrfs_commit_transaction
7.merge_reloc_roots将rc.reloc_roots链表上所有的reloc_root中超过last_snapshot的slot
	merge到其对应的root中
8.unset_reloc_control将fs_info-&gt;reloc_ctl = NULL
9.btrfs_join_transaction，并btrfs_commit_transaction
10.释放rc
11.如果reloc_roots不为空，通过free_reloc_roots将链表中的reloc_root全部删除
12.如果没有错误，通过read_fs_root读取BTRFS_DATA_RELOC_TREE_OBJECTID
	并通过btrfs_orphan_cleanup将其中的不正确的orphan全部删除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>36170</x>
      <y>2320</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>35260</x>
      <y>2880</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>mark_garbage_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>36020</x>
      <y>2920</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>alloc_reloc_control</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>37950</x>
      <y>2870</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>merge_reloc_roots</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>35330</x>
      <y>2830</y>
      <w>660</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>640.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>35140</x>
      <y>2950</y>
      <w>290</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.btrfs_start_transaction
2.将root_item.drop_progress清0
	root-&gt;root_item.drop_level = 0
3.root_item.refs=0
4.btrfs_update_root更新磁盘中root_item
5.btrfs_end_transaction
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>35310</x>
      <y>2910</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>35190</x>
      <y>3090</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_update_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>35250</x>
      <y>3050</y>
      <w>120</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
root-&gt;root_key
root-&gt;root_item</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>35060</x>
      <y>3160</y>
      <w>370</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot查找root_key
2.如果磁盘中item的长度小于要更新的长度
	1.btrfs_search_slot再次搜索，此次ins设置为-1，表示删除
	2.btrfs_del_item删除path所在的slot
	3.btrfs_insert_empty_item插入新item的size
	4.并重新调整leaf，slot,ptr
3.item.generation_v2=item.generation
4.write_extent_buffer写入ptr写入新的item
5.标记leaf dirty，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>35240</x>
      <y>3120</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>36090</x>
      <y>2830</y>
      <w>40</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>35960</x>
      <y>2990</y>
      <w>240</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>1.申请rc
2.初始化reloc_roots   backref_cache
	reloc_root_tree   processed_blocks
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>36080</x>
      <y>2950</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>36280</x>
      <y>2830</y>
      <w>1750</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1730.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>38010</x>
      <y>2900</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>37930</x>
      <y>2940</y>
      <w>310</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.again
	1.访问的是rc.extent_root
	2.list_splice_init将rc.reloc_roots添加到reloc_roots
	3.遍历reloc_roots
		1.如果reloc_root-&gt;root_item.refs存在
			1.read_fs_root读取其指向的root
			2.merge_reloc_root将reloc_root中超过last_snapshot的slot换到root中
		2.如果没有refs，通过list_del_init将reloc_root从链表中删除
		3.btrfs_drop_snapshot
	4.如果遍历了reloc_roots，将found清掉，并跳到again
2.out
	1.如果出错
		1.btrfs_std_error
		2.如果链表reloc_roots不为空，free_reloc_roots将链表中的reloc_root释放
		3.free_reloc_roots将rc-&gt;reloc_roots链表中的reloc_root释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>36980</x>
      <y>3220</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>merge_reloc_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>38920</x>
      <y>3220</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_drop_snapshot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>37040</x>
      <y>3180</y>
      <w>980</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>960.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>38140</x>
      <y>3180</y>
      <w>880</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;860.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>37020</x>
      <y>3250</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>36840</x>
      <y>3290</y>
      <w>400</w>
      <h>580</h>
    </coordinates>
    <panel_attributes>1.如果reloc_root.root_item.drop_progress.objectid是0，选取root的slot0
	level = btrfs_root_level(root_item);
	path-&gt;nodes[level] = reloc_root-&gt;node;
	path-&gt;slots[level] = 0;
2.否则
	1.path-&gt;lowest_level =root_item-&gt;drop_level
	2.btrfs_search_slot查找drop_progress后将lowest_level清掉
3.循环
	1.btrfs_block_rsv_refill让rc-&gt;block_rsv有min_reserved
	2.btrfs_start_transaction
	3.walk_down_reloc_tree在path中存储gen超过reloc_root.root_item.last_snapshot的路径
	4.将key较大的slot从reloc_root移到root中，从左到右进行替换
		1.find_next_key查找path中下一个slot的key，如果next_key&gt;key，ret=0
		2.如果没找到，或者next_key&lt;key,replace_path，通过replace_path交换key下的blockptr索引
			(将reloc_root.root_item.last_snapshot之后的key换到root中)并找到root中的next_key
		3.如果有移动
			1.将key设置为移动后reloc_root中的key(同一层level)
			2.replaced = 1
	5.walk_up_reloc_tree查找下一个gen超过last_snapshot的slot和下一步的max_level
		1.将该slot的key赋值给drop_progress
		2.所在的level赋值给drop_level
	6.btrfs_end_transaction_throttle
	7.btrfs_btree_balance_dirty
	8.如果发生了replaced，并且rc处于UPDATE_DATA_PTRS，invalidate_extent_cache将
		key和next_key之间inode对应的extent删除
4.对root.node做btrfs_cow_block
5.out
	1.如果没报错，
		1.将drop_progress和drop_level清空
		2.将root_item.refs=0
		3.btrfs_update_reloc_root
	2.如果有trans，btrfs_end_transaction_throttle
	3.btrfs_btree_balance_dirty
	4.如果有replaced，并且rc处于UPDATE_DATA_PTRS，通过invalidate_extent_cache
		删除key~next_key之间inode对应的extent
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>36370</x>
      <y>3920</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>walk_down_reloc_tree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>36280</x>
      <y>3990</y>
      <w>390</w>
      <h>190</h>
    </coordinates>
    <panel_attributes>1.遍历整个path树
	1.遍历path.node找到gen超过root_item.last_snapshot的slot
	2.如果在eb中没找到
		1.如果是要遍历的start_level，退出循环
		2.否则返回没有的上一层level(i+1)，并返回0
	3.如果找到
		1.如果level 1，返回1，并返回0
		2.否则read_tree_block读取下一层的eb
			path-&gt;nodes[i - 1] = eb;
			path-&gt;slots[i - 1] = 0;
2.如果没找到，返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>36440</x>
      <y>3950</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>36760</x>
      <y>3920</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_next_key</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>36680</x>
      <y>3990</y>
      <w>320</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.从level向上遍历path
	1.如果查找到头(eb不存在)，退出循环
	2.如果path.slot+1超过了nritems，遍历上一层level
	3.读取path.slot +1的key
	4.返回0
2.如果没找到，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>36810</x>
      <y>3950</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>37060</x>
      <y>3920</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>replace_path</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>37100</x>
      <y>3950</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>37020</x>
      <y>3990</y>
      <w>320</w>
      <h>660</h>
    </coordinates>
    <panel_attributes>1.again
	1.读取dst_root的level，如果低于lowest_level
		将其释放，并返回0
	2.如果需要cow，通过btrfs_cow_block对dest.root做cow
	注：如果eb不是root，一定要传参parent
	3.如果存在next_key，将其设置为-1
	4.parent=eb
	5.循环
		1.btrfs_bin_search在parent中查找key所在的slot
			并根据返回值调整slot
		2.如果要求next_key，将slot+1的key放置到next_key中
		3.如果parernt所在的level低于max_level
			1.new_bytenr和new_ptr_gen为path中对应level的值
		4.否则new_bytenr和new_ptr_gen为0
		5.new_bytenr有效时，不能和old_bytenr相同，否则退出循环
		6.1)如果new_bytenr无效，
		  2)或者key对应parent中的slot.gen在上次last_snapshot之后
		  3.或者parent.slot的key和path中对应level的可以不相同
		  满足以上三个条件中的一个，遍历parent下一层eb
		  1.如果level低于lowest_level，返回0，退出循环
		  2.read_tree_block读取parent.slot指向的eb
		  3.如果需要cow，对parent.slot指向的eb做cow
		  4.更新parent
			free_extent_buffer(parent);
			parent = eb;
		7.如果不需要cow，释放parent，将cow置上，跳到again
		注：上述是检查其中是否有对应于path的有效的parent slot key，如果一直没有，就不用cow
		8.btrfs_search_slot再次在src中搜寻key，这次将path做cow
		9.交换parent和path的blockptr和gen
			1.设置parent
				1.parent.slot.blockptr=new_bytenr
				2.parent.slot.gen=new_ptr_gen
				3.标记parent dirty
			2.设置path
				1.path.node.slot.blockptr=old_bytenr
				2.path.node.slot.blockptr=old_ptr_gen
				3.标记path.node dirty
			3.btrfs_inc_extent_ref递增dest中new_bytenr的引用，btrfs_free_extent删除dest对old_bytenr的引用
				对src也做类似的操作
		10.返回level，退出循环
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>37420</x>
      <y>3910</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>walk_up_reloc_tree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>37360</x>
      <y>3980</y>
      <w>310</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.获取root_item.last_snapshot
2.将level之前的path释放
3.向上遍历path的level，每层level向slot +1遍历
	直到找到slot.gen大于last_snapshot，将level
	返回
4.如果找到返回0，否则返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>37480</x>
      <y>3940</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>37770</x>
      <y>3910</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>invalidate_extent_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>37690</x>
      <y>3980</y>
      <w>400</w>
      <h>400</h>
    </coordinates>
    <panel_attributes>1.循环
	1.cond_resched，醒来之后释放inode的索引
	2.objectid不能超过max
	3.find_next_inode在root中查找不能大于objectid的inode
		也不能大于max
	4.更新循环变量
		objectid = ino + 1;
	5.inode要是reg
	6.确定start
		1.如果ino是min
			1.type不能大于BTRFS_EXTENT_DATA_KEY
			2.如果小于BTRFS_EXTENT_DATA_KEY，start=0
			3.如果等于，start = min_key-&gt;offset
		2.否则start=0
	7.确定end
		1.如果ino是max
			1.type不能低于BTRFS_EXTENT_DATA_KEY
			2.如果大于BTRFS_EXTENT_DATA_KEY，end=-1
			3.如果相同
				1.如果max_key.offset为0，继续下一个循环
				2.end = max_key-&gt;offset-1
		2.否则end为-1
	8.通过btrfs_drop_extent_cache将inode的start~end段删除
2.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>37850</x>
      <y>3940</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>38170</x>
      <y>3900</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_update_reloc_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>38120</x>
      <y>3970</y>
      <w>320</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.如果root.reloc_root不存在，直接返回0
2.如果reloc_ctl-&gt;merge_reloc_tree 置上，
	并且reloc_root.root_ite.refs为0，将
		reloc_root通过__del_reloc_root删除
3.如果reloc_root.commit_root和其node不同
	1.利用reloc_root-&gt;node设置root_item
	2.reloc_root-&gt;commit_root=reloc_root.node
4.btrfs_update_root更新reloc_root的root_item
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>38250</x>
      <y>3930</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>36440</x>
      <y>3860</y>
      <w>540</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>36810</x>
      <y>3860</y>
      <w>180</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>37020</x>
      <y>3860</y>
      <w>120</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>37100</x>
      <y>3860</y>
      <w>390</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>37110</x>
      <y>3860</y>
      <w>750</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;730.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>37110</x>
      <y>3860</y>
      <w>1150</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>38800</x>
      <y>3290</y>
      <w>450</w>
      <h>610</h>
    </coordinates>
    <panel_attributes>1.btrfs_start_transaction
2.确定path
	1.如果不存在drop_progress
		1.将path设置为root.node的slot0(BTRFS_WRITE_LOCK_BLOCKING)
		2.将wc-&gt;update_progress清0
	2.如果存在
		1.wc-&gt;update_progress=root_item-&gt;drop_progress
		2.btrfs_search_slot在root中搜寻drop_progress
			path-&gt;lowest_level=drop_level
		3.循环设置root.node.level~drop_level
			1.btrfs_lookup_extent_info设置path-&gt;nodes[level]每一层meta
				的refs(wc-&gt;refs[level])和flags(wc-&gt;flags[level])
			2.最后一层drop_level设置
				path-&gt;locks[level] = BTRFS_WRITE_LOCK_BLOCKING
3.设置wc
	wc-&gt;level = level;
	wc-&gt;shared_level = -1;
	wc-&gt;stage = DROP_REFERENCE;
	wc-&gt;update_ref = update_ref;
	wc-&gt;keep_locks = 0;
	wc-&gt;for_reloc = for_reloc;
	wc-&gt;reada_count = BTRFS_NODEPTRS_PER_BLOCK(root);
4.循环
	1.walk_down_tree
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>38980</x>
      <y>3250</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>38530</x>
      <y>3970</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>walk_down_tree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>38460</x>
      <y>4040</y>
      <w>350</w>
      <h>300</h>
    </coordinates>
    <panel_attributes>1.遍历level
	1.walk_down_proc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>38580</x>
      <y>4000</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>38310</x>
      <y>4380</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>walk_down_proc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>38190</x>
      <y>4450</y>
      <w>380</w>
      <h>310</h>
    </coordinates>
    <panel_attributes>1.如果wc处于UPDATE_BACKREF，并且eb不在root下，返回1
2.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>38360</x>
      <y>4410</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19050</x>
      <y>9220</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_run_delayed_refs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18930</x>
      <y>9290</y>
      <w>400</w>
      <h>210</h>
    </coordinates>
    <panel_attributes>1.如果trans-&gt;aborted，返回0
2.extent_root--&gt;tree_root
3.如果count为0
	count=delayed_refs-&gt;num_entries*2
4.again
	1.__btrfs_run_delayed_refs处理transaction-&gt;delayed_refs
		默认是遍历2遍
	2.如果run_all(要将所有head都遍历完)
		1.如果trans-&gt;new_bgs不为空，在磁盘中创建对new_bgs结构
		2.遍历delayed_refs-&gt;href_root
			1.如果是head，跳到again继续处理
		3.跳到again继续处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19100</x>
      <y>9250</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18250</x>
      <y>9540</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_run_delayed_refs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18330</x>
      <y>9490</y>
      <w>690</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>670.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18130</x>
      <y>9600</y>
      <w>440</w>
      <h>640</h>
    </coordinates>
    <panel_attributes>1.循环
	1.如果没有locked_ref
		1.如果count超过了nr，退出循环
		2.btrfs_select_ref_head找到一个没有processing的btrfs_delayed_ref_head
			如果没找到，退出循环
		3.如果locked_ref上锁失败，递增count，并继续循环
	2.btrfs_merge_delayed_refs合并head链表中所有ref.ref_mod
	3.select_delayed_ref在locked_ref中找到的ref(优先选action为BTRFS_ADD_DELAYED_REF)
	4.如果找到ref，并且ref.seq高于tree_mod_seq_list.first_elem.seq
		1.locked_ref-&gt;processing = 0;
			delayed_refs-&gt;num_heads_ready++
		2.清空locked_ref，递增count，继续循环
	5.locked_ref-&gt;must_insert_reserved = 0
		locked_ref-&gt;extent_op = NULL
	6.如果链表上没有ref
			1.如果有must_insert_reserved，将extent_op释放
			2.如果还有extent_op
				1.run_delayed_extent_op将extent_op更新到磁盘上
				2.将extent_op释放，继续循环遍历locked_ref
				3.如果出错，将must_insert_reserved恢复，并将locked_ref-&gt;processing = 0
					之后返回
			3.如果locked_ref不为空，或者还有extent_op，解锁后继续循环locked_ref
			4.将locked_ref从红黑树中删除
				ref-&gt;in_tree = 0;
				delayed_refs-&gt;num_heads--;
	7.如果locked_ref还有ref
		actual_count++;
		ref-&gt;in_tree = 0
	8.递减delayed_refs-&gt;num_entries
	9.如果ref不是head，将ref_mod更新到locked_ref-&gt;node.ref_mod上
	10.run_one_delayed_ref处理对应的delayed_ref,如果出错，清除locked_ref-&gt;processing = 0后返回
	11.如果ref是head，并且is_data，并且total_ref_mod&lt;0
		1.delayed_refs-&gt;pending_csums -= ref-&gt;num_bytes;
		2.清空locked_ref，遍历下一个head
	12.btrfs_put_delayed_ref释放ref
		count++
	注：如果ref不是head，会继续循环locked_ref
2.如果actual_count，更新fs_info-&gt;avg_delayed_ref_runtime
3.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18330</x>
      <y>9570</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16860</x>
      <y>10290</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_select_ref_head</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16930</x>
      <y>10230</y>
      <w>1250</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1230.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16750</x>
      <y>10360</y>
      <w>410</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.again
	1.find_ref_head在红黑树delayed_refs中查找run_delayed_start
	2.如果没找到并且没有loop
		1.设置run_delayed_start为0，find_ref_head再次查找，并设置loop
		2.如果还没找到，返回NULL
	3.如果没找到，并且loop置上，返回NULL
2.循环直到找到head-&gt;processing没被置上的
	1.如果没找到
		1.如果loop置上，返回NULL
		2.否则将run_delayed_start置0，loop置上，跳到again再次查找
3.head-&gt;processing = 1
4.delayed_refs-&gt;num_heads_ready--;
	delayed_refs-&gt;run_delayed_start = head-&gt;node.bytenr +
		head-&gt;node.num_bytes
5.返回btrfs_delayed_ref_head
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16930</x>
      <y>10320</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17220</x>
      <y>10290</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_merge_delayed_refs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17310</x>
      <y>10230</y>
      <w>870</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>850.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17310</x>
      <y>10320</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17200</x>
      <y>10360</y>
      <w>330</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.如果head为空，直接返回
2.如果head-&gt;is_data置上，直接返回
3.如果fs_info-&gt;tree_mod_seq_list不为空，获取首个elem.seq
4.遍历head-&gt;ref_list链表
	1.如果存在seq，只能处理seq之前的ref
	2.merge_ref将ref和head中的其他ref进行ref_mod的合并，如果ref
		被删除
		1.如果head-&gt;ref_list链表为空，退出循环
		2.从链表头在重新开始，continue
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17260</x>
      <y>10550</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>merge_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17310</x>
      <y>10510</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17140</x>
      <y>10620</y>
      <w>430</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>1.遍历head，如果ref.ref_mod减到0就退出
	1.next不能是ref
	2.next.seq要低于seq
	3.next和ref.type要想等
	4.如果是BTRFS_TREE_BLOCK_REF_KEY或者BTRFS_SHARED_BLOCK_REF_KEY
		comp_tree_refs检查两者的btrfs_delayed_tree_ref要完全相同
	5.如果是BTRFS_EXTENT_DATA_REF_KEY或者BTRFS_SHARED_DATA_REF_KEY
		comp_data_refs检查两者的btrfs_delayed_data_ref要相同
	6.确定mod
		1.如果两者的action相同
			mod = next-&gt;ref_mod
		2.ref.mode会大于next.mode，如果小于，done置上
		3.mod = -next-&gt;ref_mod
	7.drop_delayed_ref将next删除，将next的action放置到ref
		ref-&gt;ref_mod += mod;
	8.如果ref的ref.ref_mod减到0，drop_delayed_ref释放ref，并设置done
2.返回done，表示ref是否被完全合并
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17310</x>
      <y>10580</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17220</x>
      <y>10940</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>drop_delayed_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17270</x>
      <y>10890</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17100</x>
      <y>11010</y>
      <w>410</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.如果是ref是head，将其从红黑树delayed_refs-&gt;href_root中删除
	否则将其从链表中删除
2.ref-&gt;in_tree = 0;
3.btrfs_put_delayed_ref递减ref的引用
4.递减delayed_refs-&gt;num_entries
5.trans-&gt;delayed_ref_updates--
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17260</x>
      <y>10970</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17640</x>
      <y>10280</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>run_delayed_extent_op</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17570</x>
      <y>10350</y>
      <w>360</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.如果trans-&gt;aborted，返回0
2.如果fs_info的SKINNY_METADATA没置上，将metadata清掉
3.设置key
4.again
	1.btrfs_search_slot在extent_root中查找key
	2.如果返回1
		1.如果是meta
			1.如果slot&gt;0
				1.path.slot--
				2.获取slot的key，如果满足extent，ret=0
			2.如果ret&gt;0,清掉meta，跳到again查找extent，
		2.否则返回EIO
5.如果正好找到
	1.__run_delayed_extent_op解析slot数据btrfs_extent_item
6.标记leaf dirty，并返回	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17710</x>
      <y>10310</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17640</x>
      <y>10630</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__run_delayed_extent_op</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17720</x>
      <y>10590</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17720</x>
      <y>10660</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17580</x>
      <y>10700</y>
      <w>330</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.如果有extent_op-&gt;update_flags，将其设置到extent中
2.如果extent_op-&gt;update_key，将extent_op-&gt;key写道
	ei之后
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17710</x>
      <y>10230</y>
      <w>470</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19050</x>
      <y>10260</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>run_one_delayed_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18750</x>
      <y>10330</y>
      <w>690</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>1.如果trans-&gt;aborted
	1.如果insert_reserved，将node的段添加到pinned_extents
	2.返回0
2.如果node是head
	1.如果insert_reserved
		1.将node放到pinned_extents
		2.如果head-&gt;is_data，btrfs_del_csums删除对应段的checksum
	2.btrfs_qgroup_free_delayed_ref将对应qgroup加入到fs_info-&gt;qgroup_ulist
	3.返回
3.如果不是head
	1.如果是BTRFS_TREE_BLOCK_REF_KEY和BTRFS_SHARED_BLOCK_REF_KEY，run_delayed_tree_ref
		处理node中对应的extent_ref
	2.如果是BTRFS_EXTENT_DATA_REF_KEY和BTRFS_SHARED_DATA_REF_KEY，run_delayed_data_ref
		处理node中对应的extent_ref（和run_delayed_tree_ref只是key.type不一样）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19110</x>
      <y>10290</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18000</x>
      <y>10630</y>
      <w>220</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_qgroup_free_delayed_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18080</x>
      <y>10560</y>
      <w>820</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>800.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18100</x>
      <y>10660</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17990</x>
      <y>10700</y>
      <w>220</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_qgroup_free_refroot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18100</x>
      <y>10730</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17930</x>
      <y>10770</y>
      <w>360</w>
      <h>170</h>
    </coordinates>
    <panel_attributes>1.以下情况直接返回
	1.如果不是is_fstree
	2.如果没有num_bytes
	3.如果没有fs_info-&gt;quota_root
2.find_qgroup_rb在qgroup_tree中查询ref_root所在的qgroup
3.ulist_add将qgroup添加到fs_info-&gt;qgroup_ulist
4.遍历fs_info-&gt;qgroup_ulist
	1.将其中每个qgroup.reserved -= num_bytes
	2.再次遍历qgroup.groups链表，将其中所有的qgroup放置到
		fs_info-&gt;qgroup_ulist
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19110</x>
      <y>10620</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>run_delayed_tree_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18350</x>
      <y>10680</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>alloc_reserved_tree_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18430</x>
      <y>10650</y>
      <w>770</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
BTRFS_ADD_DELAYED_REF&amp;&amp;
insert_reserved</panel_attributes>
    <additional_attributes>750.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18300</x>
      <y>10750</y>
      <w>340</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.如果不是skinny_metadata，四则添加block_info
2.如果没申请到path，btrfs_free_and_pin_reserved_extent暂时添加到pinned
3.btrfs_insert_empty_item在extent_root中添加ins
	1.btrfs_extent_item解析slot数据，并设置其refs，gen ， flags
	2.如果不是skinny_metadata，设置block_info的key level
	3.设置iref的type offset
	4.标记leaf dirty
5.update_block_group在block_group中申请ins对应的段
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18440</x>
      <y>10710</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18750</x>
      <y>10650</y>
      <w>480</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
BTRFS_ADD_DELAYED_REF</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18700</x>
      <y>10690</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_inc_extent_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18650</x>
      <y>10760</y>
      <w>340</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.insert_inline_extent_backref在磁盘中操作extent_item的ref
2.如果返回EAGAIN
	1.设置ei.refs
	2.__run_delayed_extent_op设置block_info
	3.标记leaf dirty
	4.通过insert_extent_backref添加ref
注：这个extent_ref既可以存在在slot extent_item下
	也可以单独成为一个slot
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18780</x>
      <y>10720</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18560</x>
      <y>10930</y>
      <w>220</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>insert_inline_extent_backref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18660</x>
      <y>10890</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18650</x>
      <y>10960</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18490</x>
      <y>11000</y>
      <w>360</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.lookup_inline_extent_backref搜寻bytenr所在的extent_item
2.如果找到，通过update_inline_extent_backref更新ref
3.如果没找到，setup_inline_extent_backref在磁盘中建立索引
	（如果没找到extent_item，返回EIO,不会进到这个函数）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18110</x>
      <y>11100</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lookup_inline_extent_backref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18210</x>
      <y>11070</y>
      <w>320</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18190</x>
      <y>11130</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18050</x>
      <y>11170</y>
      <w>340</w>
      <h>380</h>
    </coordinates>
    <panel_attributes>1.根据owner parent确定extent_type
2.根据inset确定extra_size
3.again
	1.btrfs_search_slot搜寻key(根据skinny_metadata确定搜索类型)
	2.需要正好找到，如果有skinny_metadata，可以换成extent，跳到again重新查找
	3.如果ei.flags的BTRFS_EXTENT_FLAG_TREE_BLOCK置上，并且不用skinny_metadata
		跳过btrfs_tree_block_info
4.循环遍历item中的inline_ref数据
	1.如果ei之后遍历完成，退出循环
	2.以btrfs_extent_inline_ref方式解析ptr
		1.iref.type不能大于extent_type
		2.如果小于，跳过这个inline_ref
	3.如果iref.type是BTRFS_EXTENT_DATA_REF_KEY
		1.match_extent_data_ref对比iref的data和目标，如果相同退出循环
		2.如果不同，如果slot的hash低于目标hash，退出循环，返回ENOENT
	4.否则
		1.比较parent或者objectid与ref_offset，如果相等，退出循环，返回0
		2.如果大于，退出循环，返回ENOENT
	5.更新循环变量ptr
5.如果没找到，并且要insert
	1.如果要插入的空间不足，返回EAGAIN
	2.如果next_key.type低于BTRFS_BLOCK_GROUP_ITEM_KEY，返回EAGAIN
6.ref_ret为最后退出的ptr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18520</x>
      <y>11110</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>update_inline_extent_backref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18610</x>
      <y>11070</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18430</x>
      <y>11180</y>
      <w>320</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.调整ei.refs
2.__run_delayed_extent_op调整block_info
3.调整iref(inline_ref)中的refs，如果减到0，将
	这个iref删除(btrfs_truncate_item)
4.标记leaf dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18600</x>
      <y>11140</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18870</x>
      <y>11100</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>setup_inline_extent_backref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18800</x>
      <y>11070</y>
      <w>190</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18810</x>
      <y>11170</y>
      <w>380</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.btrfs_extend_item将extent_item扩展btrfs_extent_inline_ref_size的大小
2.修改ei.refs
3.__run_delayed_extent_op修改block_info
4.memmove_extent_buffer将slot数据左移size长度
5.根据传入的数据和对应的type修改inline_ref
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18970</x>
      <y>11130</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19430</x>
      <y>10920</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>insert_extent_backref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19310</x>
      <y>10950</y>
      <w>240</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
&lt;BTRFS_FIRST_FREE_OBJECTID</panel_attributes>
    <additional_attributes>190.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19250</x>
      <y>10980</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>insert_tree_block_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19320</x>
      <y>11010</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19200</x>
      <y>11050</y>
      <w>270</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.btrfs_insert_empty_item插入block_ref，
	根据parent确认type和offset
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19510</x>
      <y>10950</y>
      <w>220</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否则</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19600</x>
      <y>10980</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>insert_extent_data_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19660</x>
      <y>11010</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19510</x>
      <y>11050</y>
      <w>340</w>
      <h>180</h>
    </coordinates>
    <panel_attributes>1.1.btrfs_insert_empty_item插入data_ref，
	根据parent确认type和offset
2.如果有parent，调整btrfs_shared_data_ref.count
3.如果没有
	1.循环插入直到data_ref完全相同
		1.如果match_extent_data_ref和要插入的完全相同，退出循环
		2.否则调整key.offset++，继续btrfs_insert_empty_item
	2.如果之前不存在，设置ref.root objectid offset count
	3.否则修改ref.count
4.标记leaf dirty，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18920</x>
      <y>10890</y>
      <w>610</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;590.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19190</x>
      <y>10640</y>
      <w>880</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
BTRFS_DROP_DELAYED_REF</panel_attributes>
    <additional_attributes>10.0;20.0;860.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19990</x>
      <y>10670</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_free_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19910</x>
      <y>10740</y>
      <w>460</w>
      <h>460</h>
    </coordinates>
    <panel_attributes>1.lookup_extent_backref查找是否有对应的ref(exten_item和slot中两者)
	1.如果找到
		1.向前遍历slot
			1.如果objectid不同，跳出循环
			2.如果都相同(extent_item或者metadata_item)，置上found_extent，跳出循环
			3.如果距path超过了5个slot，退出循环
			4.递减slot
		2.如果没有found_extent(因为找到，所以这里ref是单独的slot形式存在)
			1.remove_extent_backref调整slot数据对应的ref
			2.btrfs_search_slot查找ref对应的extent或者metadata
				1.如果是找meta，如果没找到，允许向前找extent
	2.如果没找到，报错
注：这里path已经换成ref对应的extent或者metadata
2.以btrfs_extent_item方式解析path数据
	1.ei.refs不能小于refs_to_drop
		refs -= refs_to_drop
	2.如果还存在refs
		1.__run_delayed_extent_op更新block_info
		2.如果是以slot形式存在的iref
			1.更新ei.refs
			2.标记leaf dirty
		3.如果found_extent(在extent_item中)，通过remove_extent_backref
			递减iref中的refs
		4.add_pinned_bytes递减space_info-&gt;total_bytes_pinned
	3.如果不存在refs
		1.btrfs_del_items删除2个slot
		2.如果is_data，通过btrfs_del_csums删除该段对应的csums
		3.update_block_group删除block_group对extent的引用
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20070</x>
      <y>10700</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19860</x>
      <y>11230</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lookup_extent_backref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19820</x>
      <y>11300</y>
      <w>360</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.lookup_inline_extent_backref查找对应的extent_item和其中的ref
2.如果返回ENOENT
	1.如果低于BTRFS_FIRST_FREE_OBJECTID，通过lookup_tree_block_ref
		查找block_ref
	2.否则通过lookup_extent_data_ref查找data_ref
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19930</x>
      <y>11260</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19710</x>
      <y>11430</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lookup_tree_block_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19780</x>
      <y>11390</y>
      <w>150</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19620</x>
      <y>11500</y>
      <w>310</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot查找block_ref，根据parent选择type offset
2.如果ret大于0，返回ENOENT
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19780</x>
      <y>11460</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20020</x>
      <y>11430</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lookup_extent_data_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20100</x>
      <y>11390</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20100</x>
      <y>11460</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19950</x>
      <y>11500</y>
      <w>350</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.根据parent选择data_ref的type和offset
2.again
	1.btrfs_search_slot搜索key
	2.如果有parent，ret为0，返回0，否则返回err
	3.循环
		1.如果path.slot超过了nritems
			1.btrfs_next_leaf遍历下一个slot
			2.将recow置上
		2.slot和指定的objectid和type要相同
		3.match_extent_data_ref比较数据要相同
			1.如果相同，并且cow置上，跳到again重新查找
			2.如果不同，遍历下一个slot
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20370</x>
      <y>11230</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>remove_extent_backref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20300</x>
      <y>11300</y>
      <w>400</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.如果存在iref，通过update_inline_extent_backref递减extent_item中的iref.refs
2.如果is_data置上，通过remove_extent_data_ref
3.否则
	1.将last_ref置上
	2.btrfs_del_item将path对应的item删除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20490</x>
      <y>11260</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20340</x>
      <y>11440</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>remove_extent_data_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20420</x>
      <y>11390</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20420</x>
      <y>11470</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20310</x>
      <y>11510</y>
      <w>370</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.根据可以的类型，解析修改path.slot数据，获取num_refs
2.num_refs -= refs_to_drop
3.如果减到0，通过btrfs_del_item将其删除
4.否则修改slot数据对应的ref_count
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19940</x>
      <y>11190</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20300</x>
      <y>11190</y>
      <w>170</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19180</x>
      <y>10560</y>
      <w>40</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18550</x>
      <y>10230</y>
      <w>600</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;580.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18830</x>
      <y>9540</y>
      <w>260</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_create_pending_block_groups</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18940</x>
      <y>9490</y>
      <w>80</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18690</x>
      <y>9610</y>
      <w>370</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.trans-&gt;can_flush_pending_bgs = false
2.遍历trans-&gt;new_bgs中block_group
	1.如果出错，跳到next?
	2.获取其block_group-&gt;item block_group-&gt;key
		通过btrfs_insert_item在extent_root插入block_group
	3.btrfs_finish_chunk_alloc在extent_root中插入段对应的
		BTRFS_CHUNK_ITEM_KEY
	4.将block_group从链表中删除
3.恢复trans-&gt;can_flush_pending_bgs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18910</x>
      <y>9570</y>
      <w>40</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18730</x>
      <y>9800</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_finish_chunk_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18810</x>
      <y>9760</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18810</x>
      <y>9830</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18650</x>
      <y>9880</y>
      <w>390</w>
      <h>280</h>
    </coordinates>
    <panel_attributes>1.lookup_extent_mapping在mapping_tree查找chunk_offset
	如果不正好找到，返回EINVAL
2.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21220</x>
      <y>9070</y>
      <w>250</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_start_dirty_block_groups</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21150</x>
      <y>9140</y>
      <w>410</w>
      <h>470</h>
    </coordinates>
    <panel_attributes>1.将cur_trans-&gt;dirty_bgs放到dirty
2.again
	1.btrfs_create_pending_block_groups在磁盘中建立trans-&gt;new_bgs
	2.遍历dirty链表
		1.如果cache正在IO
			1.将cache.io_list从链表中删除
			2.btrfs_wait_cache_io刷写cache对应的inode
		2.将cache.dirty_list从链表中删除
			should_put = 1
		3.cache_save_setup查找并创建管理cache.free_space的inode
			并预留充足的空间
		4.如果disk_cache_state在BTRFS_DC_SETUP
			1.cache-&gt;io_ctl.inode = NULL
			2.btrfs_write_out_cache将cache的free_space信息写入inode，并写入磁盘
			3.如果写成功
				1.num_started++;
				2.should_put = 0;
				3.将cache加入到链表cur_trans-&gt;io_bgs后面
			4.否则将ret置0
		5.如果ret为0
			1.write_one_cache_group更新磁盘上的cache.item
			2.如果没找到cache，重新将cache加入cur_trans-&gt;dirty_bgs链表
			3.如果其他错，btrfs_abort_transaction
		6.如果cache不在io_list上，将cache释放
		7.如果出错，退出循环
3.btrfs_run_delayed_refs处理transaction-&gt;delayed_refs上的所有delayed_ref
4.如果正确返回，并且之前没被执行，再次检查cur_trans-&gt;dirty_bgs
	如果链表上还有cache，跳到again继续清理
5.释放path，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21320</x>
      <y>9100</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19310</x>
      <y>9650</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_wait_cache_io</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19140</x>
      <y>9720</y>
      <w>500</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.如果io_ctl-&gt;inode不存在，直接返回0
2.如果存在block_group，root=tree_root
3.flush_dirty_cache刷鞋inode
4.update_cache_item以io_ctl中的参数更新block_group对应的free_space_objectid
5.out
	1.io_ctl_free释放io_ctl
	2.btrfs_update_inode更新inode
	3.如果存在block_group
		1.如果正确刷写，并且block_group-&gt;dirty_list为空
			block_group-&gt;disk_cache_state = BTRFS_DC_WRITTEN
		2.如果出错
			block_group-&gt;disk_cache_state = BTRFS_DC_ERROR
		3.iput释放inode
			io_ctl-&gt;inode = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23830</x>
      <y>340</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>BTRFS_INODE_ITEM_KEY</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23920</x>
      <y>270</y>
      <w>300</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_fill_super</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24080</x>
      <y>340</y>
      <w>250</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>BTRFS_FREE_SPACE_OBJECTID</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24190</x>
      <y>270</y>
      <w>390</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
free_ino_ctl
__lookup_free_space_inode
获取free_ino的offset是0
获取block_group的offset是block_group的起始地址objectid</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24110</x>
      <y>420</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_free_space_header
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24190</x>
      <y>370</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23940</x>
      <y>370</y>
      <w>190</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;70.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23890</x>
      <y>420</y>
      <w>110</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>free_space
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23940</x>
      <y>370</y>
      <w>190</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
__load_free_space_cache</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20250</x>
      <y>9660</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>cache_save_setup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20150</x>
      <y>9730</y>
      <w>450</w>
      <h>310</h>
    </coordinates>
    <panel_attributes>1.如果block_group的大小低于100M,直接返回0
	block_group-&gt;disk_cache_state = BTRFS_DC_WRITTEN
2.如果trans.aborted，返回0
3.again
	1.lookup_free_space_inode查找管理block_group free_space
		的inode
	2.如果是ENOENT
		1.递增retries
		2.如果block_group是read_only,跳到out_free
		3.create_free_space_inode创建指向inode的free_space和inode
			然后跳到again，重新查找
	3.如果cache_generation是当前的gen，并且inode.i_size存在，跳到out_free
		dcs = BTRFS_DC_SETUP
	4.btrfs_update_inode更新inode_item
		BTRFS_I(inode)-&gt;generation = 0
	5.如果inode.i_size存在
		1.btrfs_check_trunc_cache_free_space检查global_block_rsv是否有足够的空间
		2.btrfs_truncate_free_space_cache将inode的空间清空
		3.跳到out_put
	6.如果BTRFS_TRANS_CACHE_ENOSPC置上，返回ENOSPC，跳到out_put
	7.btrfs_check_data_free_space
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19840</x>
      <y>10070</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>create_free_space_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19760</x>
      <y>10140</y>
      <w>390</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.btrfs_find_free_objectid查找一个free_ino
2.__create_free_space_inode创建指向block_group的free_space和inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19940</x>
      <y>10100</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19950</x>
      <y>10030</y>
      <w>290</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19800</x>
      <y>10210</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__create_free_space_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19880</x>
      <y>10170</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19890</x>
      <y>10240</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19740</x>
      <y>10280</y>
      <w>390</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>1.btrfs_insert_empty_inode创建一个ino的inode_item
2.以btrfs_inode_item方式解析slot数据
	1.清空inode_item
	2.设置inode_item.gen size nbytes uid gid mode(S_IFREG | 0600) flags(BTRFS_INODE_NOCOMPRESS | BTRFS_INODE_PREALLOC | BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW)
		nlink=1 transid block_group=offset
3.btrfs_insert_empty_item插入BTRFS_FREE_SPACE_OBJECTID
	1.将btrfs_free_space_header清空
	2.将header.key设置为inode_item的key
4.标记leaf dirty，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20220</x>
      <y>10070</y>
      <w>250</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_truncate_free_space_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20300</x>
      <y>10030</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20330</x>
      <y>10100</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20180</x>
      <y>10140</y>
      <w>390</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.如果有block_group
	1.如果block_group-&gt;io_list不为空
		1.将block_group从io_list中删除
		2.btrfs_wait_cache_io
		3.btrfs_put_block_group释放block_group
	2.block_group-&gt;disk_cache_state = BTRFS_DC_CLEAR
2.btrfs_i_size_write将inode.i_size设置为0，并通过truncate_pagecache
	将inode的page截断
3.btrfs_truncate_inode_items清除大于BTRFS_EXTENT_DATA_KEY
	的所有item
4.btrfs_update_inode更新inode_item
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20750</x>
      <y>10060</y>
      <w>240</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_check_data_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20580</x>
      <y>10120</y>
      <w>240</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_alloc_data_chunk_ondemand</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20940</x>
      <y>10120</y>
      <w>230</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_qgroup_reserve_data</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20680</x>
      <y>10090</y>
      <w>160</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20870</x>
      <y>10090</y>
      <w>200</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20670</x>
      <y>10150</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20590</x>
      <y>10190</y>
      <w>380</w>
      <h>300</h>
    </coordinates>
    <panel_attributes>1.如果inode是管理free_space的，将need_commit清0
2.如果没有fs_info-&gt;data_sinfo，跳到alloc
3.again
	1.如果需要用的bytes超过了data_sinfo-&gt;total_bytes
		1.如果data_sinfo没有full
			1.ata_sinfo-&gt;force_alloc = CHUNK_ALLOC_FORCE
			2.alloc
				1.btrfs_get_alloc_profile确定在root下允许的flag
				2.btrfs_join_transaction
				3.do_chunk_alloc申请raid虚拟磁盘
				4.btrfs_end_transaction
			4.跳到again再次检查space_info
		2.如果full
			1.查看space_info pinned的空间是否足够have_pinned_space
			2.commit_trans
				1.如果need_commit，并且不用open_ioctl_trans
					1.need_commit--
					2.如果还需要commit，btrfs_wait_ordered_roots等待root被flush
					3.btrfs_wait_ordered_roots
					4.如果have_pinned_space，或者trans BTRFS_TRANS_HAVE_FREE_BGS 或者need_commit
						1.btrfs_commit_transaction进行提交
						2.跳到again重新检查
					5.否则btrfs_end_transaction，并返回ENOSPC
4.data_sinfo-&gt;bytes_may_use += bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20570</x>
      <y>10520</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>do_chunk_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20450</x>
      <y>10590</y>
      <w>420</w>
      <h>370</h>
    </coordinates>
    <panel_attributes>1.如果trans.allocating_chunk，返回ENOSPC
2.__find_space_info找到满足flags的space_info,如果没找到，通过
	update_space_info将flags更新到info-&gt;space_info中
3.again
	1.force的等级不能小于space_info-&gt;force_alloc
	2.如果space_info-&gt;full，should_alloc_chunk需要申请chunk，
		返回ENOSPC,否则返回0
	3.如果没有full
		1.如果不需要should_alloc_chunk，返回0
		2.如果space_info-&gt;chunk_alloc
			wait_for_alloc = 1
		3.否则将space_info-&gt;chunk_alloc置上
4.如果wait_for_alloc置上，将其清掉，然后跳到again重新检测
5.trans-&gt;allocating_chunk = true
6.如果申请data_chunk,并且需要metadata_ratio
	1.fs_info-&gt;data_chunk_allocations++
	2.如果meta不够，通过force_metadata_allocation通过fs_info中的meta_spaceinfo
		申请meta
7.check_system_chunk看是否更新sys_spaceinfo
8.btrfs_alloc_chunk在extent_root下申请chunk
	trans-&gt;allocating_chunk = false
9.如果ENOSPC，将space_info-&gt;full = 1，否则返回1
10.out
	1.space_info-&gt;chunk_alloc = 0
	2.如果有can_flush_pending_bgs，并且chunk_bytes_reserved超过了2M
		1.btrfs_create_pending_block_groups创建can_flush_pending_bgs的block_group
		2.btrfs_trans_release_chunk_metadata清除can_flush_pending_bgs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20610</x>
      <y>10480</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20610</x>
      <y>10550</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20420</x>
      <y>10990</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>should_alloc_chunk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20490</x>
      <y>10950</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20490</x>
      <y>11020</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20410</x>
      <y>11050</y>
      <w>350</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.如果CHUNK_ALLOC_FORCE，返回1
2.如果在CHUNK_ALLOC_LIMITED，space_info alloc
	之后的free_space低于1%total_bytes，返回1，
	表示需要申请
3.如果要申请的大小+2M低于1/8space_info的大小，
	返回0，表示不需要申请
4.否则返回1，表示需要申请
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20830</x>
      <y>10990</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>check_system_chunk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20830</x>
      <y>10950</y>
      <w>80</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20900</x>
      <y>11020</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20780</x>
      <y>11050</y>
      <w>370</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.__find_space_info找到sys_space_info
2.如果sys_spaceinfo的大小低于thresh(raid决定num_dev，决定最小thresh)
	通过btrfs_alloc_chunk申请chunk
3.如果正确返回，btrfs_block_rsv_add递增fs_info-&gt;chunk_block_rsv
	trans-&gt;chunk_bytes_reserved
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21220</x>
      <y>10980</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_alloc_chunk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21170</x>
      <y>11050</y>
      <w>300</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.find_next_chunk查找不在emtree中的end
2.__btrfs_alloc_chunk在各个dev中申请空间，
	并组成raid磁盘
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21280</x>
      <y>11010</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21080</x>
      <y>11160</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_next_chunk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21130</x>
      <y>11120</y>
      <w>100</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20940</x>
      <y>11230</y>
      <w>320</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.获取mapping_tree红黑树链表中的最后一个em
2.返回em的end
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21120</x>
      <y>11190</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21340</x>
      <y>11170</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_alloc_chunk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21390</x>
      <y>11120</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21270</x>
      <y>11240</y>
      <w>380</w>
      <h>780</h>
    </coordinates>
    <panel_attributes>1.如果fs_devices-&gt;alloc_list，返回ENOSPC
2.__get_raid_index获取raid的类型和raid参数
3.根据type获取的数据类型设置max_stripe_size max_chunk_size devs_max
	max_chunk_size不能大于0.1total_rw_bytes
4.申请devices_info
5.遍历fs_devices-&gt;alloc_list，对所有btrfs_device剩余空间信息hole进行统计
	1.更新循环变量
		cur = cur-&gt;next
	2.如果不能device-&gt;writeable，遍历下一个
	3.如果device不能in_fs_metadata，或者is_tgtdev_for_dev_replace，遍历下一个
	4.算出total_avail=total_bytes-bytes_used，如果不存在，遍历下一个
	5.find_free_dev_extent在device中查找max_stripe_size * dev_stripes长度的extent
	6.如果能找到(返回0)，其长度设置为要找的长度(有可能大于)
	7.如果遍历的ndevs超过了rw_devices，退出循环
	8.更新device_innfo（都保存着满足要求的hole）
		devices_info[ndevs].dev_offset = dev_offset;
		devices_info[ndevs].max_avail = max_avail;
		devices_info[ndevs].total_avail = total_avail;
		devices_info[ndevs].dev = device;
		++ndevs;
6.sort对device_info数组按照btrfs_cmp_device_info方式进行从大到小的排序
7.ndevs对	devs_increment向下取整
	ndevs不能低于devs_increment(*sub_stripes)和devs_min，否则返回ENOSPC
			并且不能高于devs_max
8.data_strip的长度不能大于max_chunk_size，以此调整stripe_size(但是这里不清楚为什么使用max_avail*ndevs * dev_stripes
	DUP不算在dev里面吗？)，stripe_size在对raid_stripe_len向下取整
9.申请map_lookup
	1.map-&gt;num_stripes = num_stripes;//这里一个strip在几个磁盘上
		map-&gt;stripes[s].dev  map-&gt;stripes[s].physical，一个磁盘上的strip是紧挨着的
		map-&gt;sector_size = extent_root-&gt;sectorsize;
	map-&gt;stripe_len = raid_stripe_len;.//每个磁盘在strip上的长度
	map-&gt;io_align = raid_stripe_len;
	map-&gt;io_width = raid_stripe_len;
	map-&gt;type = type;
	map-&gt;sub_stripes = sub_stripes;
10.alloc_extent_map申请em
	set_bit(EXTENT_FLAG_FS_MAPPING, &amp;em-&gt;flags);
	em-&gt;bdev = (struct block_device *)map;
	em-&gt;start = start;
	em-&gt;len = num_bytes;//data_strip的长度
	em-&gt;block_start = 0;
	em-&gt;block_len = em-&gt;len;
	em-&gt;orig_block_len = stripe_size;一个磁盘上用于做整个raid的长度
11.add_extent_mapping将em加入红黑树mapping_tree中，并加入
	链表transaction-&gt;pending_chunks尾端
12.btrfs_make_block_group创建cache，并建立起free_space 和space_info的关系
13.更新map-&gt;stripes[i].dev-&gt;bytes_used fs_info-&gt;free_chunk_space
14.check_raid56_incompat_flag
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21380</x>
      <y>11200</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21010</x>
      <y>12040</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_free_dev_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20980</x>
      <y>12110</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_free_dev_extent_start</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21070</x>
      <y>12070</y>
      <w>270</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
search_start从高于1M的alloc_start开始</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21070</x>
      <y>12010</y>
      <w>260</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20900</x>
      <y>12180</y>
      <w>430</w>
      <h>510</h>
    </coordinates>
    <panel_attributes>1.如果device的search_start超过了end，或者is_tgtdev_for_dev_replace
	返回ENOSPC
2.btrfs_search_slot查询指向device的BTRFS_DEV_EXTENT_KEY
	path-&gt;reada = 2;
	path-&gt;search_commit_root = 1;
	path-&gt;skip_locking = 1;
3.如果返回值是1，通过btrfs_previous_item将path变换到前一个slot
4.循环找到空闲没被记录的extent(hole)
	1.如果slot超过了nritem，通过btrfs_next_leaf遍历下一个slot
	2.如果objectid低于devid，跳到next；如果大于devid，退出循环
		如果type不是BTRFS_DEV_EXTENT_KEY，跳到next
	3.如果offset在search_start之后
		1.contains_pending_extent查看search_start~offset是否又被pinned，
			如果有会更新search_start
			1.如果offset还是大雨search_start,更新hole_size
			2.否则hole_size设置为0
		2.如果hole_size超过了max_hole_size-
			max_hole_start = search_start;
			max_hole_size = hole_size;
		3.如果hole_size超过了所需要的num_bytes，返回0，跳到out
	4.否则更新循环变量search_start到extent_end
		path-&gt;slots[0]++
5.如果遍历到最后(否则在4.3.3就跳到out了)
	1.contains_pending_extent查看search_start~search_end是否有被pinned
		如果有，跳到1，重新查找
	2.如果没有更新
		max_hole_start = search_start;
		max_hole_size = hole_size;
6.如果找到最大hole低于num_bytes，返回ENOSPC，否则返回0
7.out
	1.根据max_hole_start max_hole_size设置start和len，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21050</x>
      <y>12140</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20830</x>
      <y>12720</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>contains_pending_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20910</x>
      <y>12680</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20750</x>
      <y>12790</y>
      <w>340</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.如果没有trans，遍历fs_info-&gt;pinned_chunks
	佛足额遍历trans.pending_chunks
2.again
	1.遍历链表中的em
		1.以map_lookup方式解析em.bdev
		2.遍历其num_stripes
			1.strip.dev要是device
			2.如果要申请的段完全不在strip的范围内，继续循环
			3.更新start应该所处的位置，并返回1
				*start=map-&gt;stripes[i].physical + em-&gt;orig_block_len
	2.如果pinned_chunks，链表换成pinned_chunks，跳到again
		继续遍历(这里需要更新start)=
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20890</x>
      <y>12750</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21410</x>
      <y>12050</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>sort</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21350</x>
      <y>12120</y>
      <w>370</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.确定swap_func
2.从倒数第二层开始遍历(2r+size是左节点，2r+2size是右节点)，最大堆
	1.c指向左右节点中较大的
	2.如果cmp_func发现c大于r，就通过swap_func将两者进行交换
3.将最大堆中最大的值从后向前方，并更新i之前的最大堆
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21470</x>
      <y>12080</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21840</x>
      <y>12040</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_make_block_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21750</x>
      <y>12110</y>
      <w>440</w>
      <h>260</h>
    </coordinates>
    <panel_attributes>1.btrfs_set_log_full_commit设置last_trans_log_full_commit
2.btrfs_create_block_group_cache申请一个纸箱chunk_offset的cache
	并设置cache.item
3.exclude_super_stripes将cahce在super中的段排除掉
4.add_new_free_space将不在pinned_extents中的部分加入到cache中
5.free_excluded_extents释放3中的exclude
6.update_space_info根据cache.flag更新space_info
7.btrfs_add_block_group_cache将cache加入红黑树block_group_cache_tree中
8.update_space_info
9.update_global_block_rsv
10.更新cache关系
	1.cache-&gt;space_info-&gt;bytes_readonly += cache-&gt;bytes_super;
	2.__link_block_group将cache加入space_info bucket
	3.将cache链入到trans-&gt;new_bgs链表后面
	4.set_avail_alloc_bits根据type设置alloc_bits
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21900</x>
      <y>12070</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21450</x>
      <y>12010</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21580</x>
      <y>12010</y>
      <w>340</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20830</x>
      <y>10950</y>
      <w>460</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20560</x>
      <y>10030</y>
      <w>320</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20320</x>
      <y>9690</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19140</x>
      <y>10000</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>flush_dirty_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19050</x>
      <y>10070</y>
      <w>320</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.btrfs_wait_ordered_range刷写整个inode
2.如果出错，通过clear_extent_bit将整个inode的
	EXTENT_DIRTY | EXTENT_DELALLOC清掉
注：为什么出错清，不应该是正确返回在清吗？
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19200</x>
      <y>10030</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19420</x>
      <y>10000</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>update_cache_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19480</x>
      <y>10030</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19390</x>
      <y>10070</y>
      <w>360</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot查找block_group的BTRFS_FREE_SPACE_OBJECTID
	如果出错，clear_extent_bit将inode所有的段EXTENT_DIRTY | EXTENT_DELALLOC
	清掉，并跳到fail
2.如果返回1，调整slot，如果不满足要求，通过clear_extent_bit
	将inode所有段的EXTENT_DIRTY | EXTENT_DELALLOC清掉，跳到fail
3.以btrfs_free_space_header方式解析slot数据
	1.BTRFS_I(inode)-&gt;generation = trans-&gt;transid;
	2.设置header entries bitmaps gen
4.标记leaf dirty，并返回0，错误返回-1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19200</x>
      <y>9960</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19480</x>
      <y>9960</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19370</x>
      <y>9680</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21370</x>
      <y>9660</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_write_out_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21260</x>
      <y>9730</y>
      <w>430</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.如果disk_cache_state低于BTRFS_DC_SETUP，返回0
2.lookup_free_space_inode查找管理block_group的indoe
3.__btrfs_write_out_cache更新inode中free_space_entry bitmap
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21460</x>
      <y>9690</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21420</x>
      <y>9830</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_write_out_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21500</x>
      <y>9780</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21490</x>
      <y>9860</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21390</x>
      <y>9910</y>
      <w>350</w>
      <h>310</h>
    </coordinates>
    <panel_attributes>1.如果inode.i_size是0，返回EIO
2.io_ctl_init初始化io_ctl
3.如果block_group是BTRFS_BLOCK_GROUP_DATA
	1.如果有delalloc_bytes
		1.block_group-&gt;disk_cache_state = BTRFS_DC_WRITTEN
		2.置上must_iput，返回0，跳到out
4.io_ctl_prepare_pages查找inode的page
5.io_ctl_set_generation设置io_ctl.page中的gen(inode中存储的是free_space_entry)
6.write_cache_extent_entries将ctl中的free_space管理结构写入io_ctl.page
7.write_pinned_extent_entries将pinned_extents中block_group对应的段写入io_ctl
8.write_bitmap_entries将free_space的bitmap写入io_ctl
9.io_ctl_zero_remaining_pages清0剩余的page，并计算crc
10.btrfs_dirty_pages标记inode的page dirty，执行写io
11.io_ctl_drop_pages将所有io_ctl中的page释放
12.通过io_ctl的free_space_entry和bitmap的数量
	io_ctl-&gt;entries = entries;
	io_ctl-&gt;bitmaps = bitmaps;
13.btrfs_fdatawrite_range写inode，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21090</x>
      <y>10270</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>io_ctl_set_generation</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20980</x>
      <y>10340</y>
      <w>370</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.io_ctl_map_page更新io_ctl.page
2.如果需要check_crcs需要将cur和siz而排出掉crc的长度
3.将gen写入page，并调整cur
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21160</x>
      <y>10210</y>
      <w>260</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21170</x>
      <y>10300</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21420</x>
      <y>10270</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>write_cache_extent_entries</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21480</x>
      <y>10210</y>
      <w>260</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21500</x>
      <y>10300</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21380</x>
      <y>10340</y>
      <w>390</w>
      <h>200</h>
    </coordinates>
    <panel_attributes>1.如果block_group在cluster中，获取其cluster
2.如果free_space_offset位空，选取cluster.root
3.遍历2中选取的红黑树，以btrfs_free_space解析
	1.记录free_space的个数entries
	2.io_ctl_add_entry在io_ctl的page中添加free_space_entry
	3.如果需要bitmap，将entry添加到bitmap_list
		*bitmaps += 1;
	4.更新循环变量node，如果不存在，再找cluster.root
4.遍历链表ctl-&gt;trimming_ranges，通过io_ctl_add_entry将其对应的entry
	填充到io_ctl.page
		*entries += 1
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21460</x>
      <y>10570</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>io_ctl_add_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21400</x>
      <y>10660</y>
      <w>370</w>
      <h>130</h>
    </coordinates>
    <panel_attributes>1.如果io_ctl-&gt;cur不存在，返回ENOSPC
2.将free_space解析成btrfs_free_space_entry，填充cur
	并调整cur size
3.如果空间充足，返回0
4.io_ctl_set_crc计算整页的crc，并释放cur
5.如果超过了io_ctl的page数，返回0
6.否则通过io_ctl_map_page map到下一个page，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21500</x>
      <y>10530</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21510</x>
      <y>10600</y>
      <w>30</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21460</x>
      <y>10820</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>io_ctl_set_crc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21500</x>
      <y>10780</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21500</x>
      <y>10850</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21390</x>
      <y>10880</y>
      <w>370</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.如果不用check_crcs，io_ctl_unmap_page将cur释放，并返回
2.否则计算orig的crc放在page[0]，并io_ctl_unmap_page释放cur
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21830</x>
      <y>10260</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>write_pinned_extent_entries</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21790</x>
      <y>10330</y>
      <w>360</w>
      <h>180</h>
    </coordinates>
    <panel_attributes>1.如果没有block_group，返回0
2.遍历整个block_group的空间
	1.find_first_extent_bit查找pinned_extents中被标记dirty的block_group段
	2.如果没有返回0
	3.计算被pinned的长度
	4.io_ctl_add_entry将该段添加到io_ctl.page中
		*entries += 1
	5.更新循环变量start
		start = extent_end
3.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21940</x>
      <y>10290</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22260</x>
      <y>10250</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>write_bitmap_entries</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22180</x>
      <y>10320</y>
      <w>330</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.遍历链表bitmap_list，以btrfs_free_space方式解析
	1.io_ctl_add_bitmap
	2.将entry从链表中删除
2.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22330</x>
      <y>10280</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22270</x>
      <y>10430</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>io_ctl_add_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22330</x>
      <y>10390</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22160</x>
      <y>10500</y>
      <w>330</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.如果没有io_ctl-&gt;cur，返回ENOSPC
2.如果cur和orig不同
	1.io_ctl_set_crc设置orig的crc
	2.如果超过了num_pages，返回ENOSPC
	3.io_ctl_map_page重新map到下一个page
3.将bitmap储存到cur，并通过io_ctl_set_crc设置crc
4.如果还没到num_pages，通过io_ctl_map_page
	重新map到下一个page
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22330</x>
      <y>10460</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22640</x>
      <y>10250</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>io_ctl_zero_remaining_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22560</x>
      <y>10320</y>
      <w>340</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.如果cur和orig不同，通过io_ctl_set_crc计算orig的crc
	否则通过io_ctl_unmap_page清理cur
2.遍历剩下的page
	1.io_ctl_map_page重新map page，并清0
	2.io_ctl_set_crc计算清0page的crc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22730</x>
      <y>10280</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23060</x>
      <y>10250</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_dirty_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22930</x>
      <y>10320</y>
      <w>360</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.对起始和长度对sectorsize取整
2.btrfs_set_extent_delalloc在inode.io_tree中标记该段
	EXTENT_DELALLOC | EXTENT_UPTODATE
3.将pages中的每个page SetPageUptodate  set_page_dirty
4.如果inode.i_size发生改变，通过i_size_write调整
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23110</x>
      <y>10280</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21710</x>
      <y>10210</y>
      <w>230</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21710</x>
      <y>10210</y>
      <w>630</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21720</x>
      <y>10210</y>
      <w>1030</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1010.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21720</x>
      <y>10210</y>
      <w>1410</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1390.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24690</x>
      <y>7280</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21790</x>
      <y>9620</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>write_one_cache_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21710</x>
      <y>9700</y>
      <w>330</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.write_one_cache_group在extent_root中搜寻cache
2.更新cache.item，并标记leaf dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21870</x>
      <y>9650</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21430</x>
      <y>9600</y>
      <w>40</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21460</x>
      <y>9600</y>
      <w>430</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20300</x>
      <y>9600</y>
      <w>970</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>950.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22170</x>
      <y>9030</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_start_delalloc_flush</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22260</x>
      <y>9060</y>
      <w>150</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FLUSHONCOMMIT</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22180</x>
      <y>9100</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_start_delalloc_roots</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22120</x>
      <y>9170</y>
      <w>430</w>
      <h>150</h>
    </coordinates>
    <panel_attributes>1.如果fs_info处于BTRFS_FS_STATE_ERROR，返回EROFS
2.获取fs_info-&gt;delalloc_roots，并遍历nr个
	1.将root移到fs_info-&gt;delalloc_roots末尾
	2.__start_delalloc_inodes刷鞋root-&gt;delalloc_inodes中的inode
	3.nr -= ret
3.递增fs_info-&gt;async_submit_draining
4.等待fs_info-&gt;nr_async_submits  fs_info-&gt;async_delalloc_pages完成
5.out：如果splice还有剩下的root，将其重新加入fs_info-&gt;delalloc_roots
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22290</x>
      <y>9130</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22070</x>
      <y>9350</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__start_delalloc_inodes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22130</x>
      <y>9310</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22150</x>
      <y>9380</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22050</x>
      <y>9420</y>
      <w>360</w>
      <h>180</h>
    </coordinates>
    <panel_attributes>1.遍历root-&gt;delalloc_inodes
	1.将binode移到root-&gt;delalloc_inodes尾端
	2.btrfs_alloc_delalloc_work申请btrfs_delalloc_work，并初始化
		用btrfs_run_delalloc_work处理
	3.将work添加到链表works，fs_info-&gt;flush_workers
	4.递增ret++，直到达到nr
2.out
	1.遍历works链表
		1.work脱链
		2.btrfs_wait_and_free_delalloc_work等待work处理完成
	2.如果splice没处理完，再将其放到root-&gt;delalloc_inodes尾端
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22160</x>
      <y>9640</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_add_delayed_iput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22230</x>
      <y>9590</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22220</x>
      <y>9670</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22080</x>
      <y>9710</y>
      <w>250</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.在inode.i_count不是1的情况下递减
2.如果i_cout为0
	1.申请delayed_iput
		delayed-&gt;inode = inode
	2.添加到fs_info-&gt;delayed_iputs尾端
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22700</x>
      <y>9030</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_run_delayed_items</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22780</x>
      <y>9060</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22700</x>
      <y>9110</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_run_delayed_items</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22780</x>
      <y>9140</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22630</x>
      <y>9190</y>
      <w>420</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.btrfs_get_delayed_root获取fs_info-&gt;delayed_root
2.btrfs_first_delayed_node获取delayedd_root.node_list上的第一个node
3.如果在允许的nr个node范围内
	1.__btrfs_commit_inode_delayed_items将被delayed增删的item映射到磁盘
	2.btrfs_next_delayed_node获取下一个node
	3.btrfs_release_delayed_node释放commit的node
4.btrfs_release_delayed_node释放cur_node
5.释放path
	trans-&gt;block_rsv = block_rsv
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22560</x>
      <y>9390</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_next_delayed_node</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22650</x>
      <y>9340</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22640</x>
      <y>9420</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22490</x>
      <y>9470</y>
      <w>370</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.如果node的BTRFS_DELAYED_NODE_IN_LIST没置上
	1.如果delayed_root-&gt;node_list为空，跳到out
	2.否则选取delayed_root-&gt;node_list.next
2.如果node在tree中，选取
	p = node-&gt;n_list.next
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23420</x>
      <y>9390</y>
      <w>260</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_commit_inode_delayed_items</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23010</x>
      <y>9340</y>
      <w>540</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;520.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23260</x>
      <y>9420</y>
      <w>310</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将delayed_node-&gt;ins_root上的item插入root中</panel_attributes>
    <additional_attributes>230.0;10.0;70.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23220</x>
      <y>9450</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_insert_delayed_items</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23720</x>
      <y>9460</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_delete_delayed_items</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24090</x>
      <y>9460</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_update_delayed_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23560</x>
      <y>9420</y>
      <w>290</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将delayed_node-&gt;del_root对应的item删除</panel_attributes>
    <additional_attributes>70.0;10.0;210.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23620</x>
      <y>9420</y>
      <w>550</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;530.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23220</x>
      <y>9520</y>
      <w>330</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.do_again
	1.__btrfs_first_delayed_insertion_item获取delayed_node-&gt;ins_root
		红黑树链表上的第一个delayed_itme
	2.如果没找到，跳到insert_end
	3.btrfs_insert_delayed_item在root中插入delayed_item
	4.__btrfs_next_delayed_item更新循环变量delayed_item
	5.如果cur和next满足btrfs_is_continuous_delayed_item
		1.递增path slot
		2.btrfs_batch_insert_items将continuous的item一起插入root中
	6.btrfs_release_delayed_item释放prev
	7.标记node[0] dirty
	8.释放path，并跳到do_again
2.insert_end:返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23310</x>
      <y>9480</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23050</x>
      <y>9770</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_insert_delayed_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22940</x>
      <y>9840</y>
      <w>380</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.通过btrfs_insert_empty_item插入一个delayed_item-&gt;key
2.将delayed_item-&gt;data写入slot数据区
3.标记leaf dirty
4.btrfs_delayed_item_release_metadata释放item-&gt;bytes_reserved
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23110</x>
      <y>9800</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23360</x>
      <y>9770</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_batch_insert_items</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23340</x>
      <y>9840</y>
      <w>400</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.如果leaf有足够的空间容纳btrfs_delayed_item，循环处理
	1.递增total_data_size total_size
	2.将next.tree_list加入head链表
	3.__btrfs_next_delayed_item选取下一个item
		nitems++
	4.如果和下一个item不满足btrfs_is_continuous_delayed_item，退出循环
2.如果head中没有item，返回0
3.申请key数组和data_size数组，并遍历head数据将key和data_len加入到数组中
4.setup_items_for_insert在leaf中腾出key数组的空间
5.遍历head
	1.向slot写curr.data
	2.更新循环变量slot++
	3.btrfs_delayed_item_release_metadata释放item-&gt;bytes_reserved
	4.将其从链表中删除，并通过btrfs_release_delayed_item将curr释放
6.释放申请的数组，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23430</x>
      <y>9800</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23670</x>
      <y>9530</y>
      <w>390</w>
      <h>190</h>
    </coordinates>
    <panel_attributes>1.do_again
	1.__btrfs_first_delayed_deletion_item找到delayed_node-&gt;del_root
		红黑树链表上的第一个delayed_item
	2.如果没找到，返回
	3.通过btrfs_search_slot查找item.key,如果出错，直接返回
	4.如果返回1，表示没找到
		1.__btrfs_next_delayed_item查找下一个item
		2.btrfs_release_delayed_item将prev释放
		3.如果下一个找到了，跳到do_again，否则返回
	5.如果找到了，通过btrfs_batch_delete_items将curr以及其continuouts删除，
		并跳到do_again
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23810</x>
      <y>9490</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>23840</x>
      <y>9760</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_batch_delete_items</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23910</x>
      <y>9710</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23760</x>
      <y>9830</y>
      <w>370</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>1.如果slot超过了nritem，返回ENOENT
2.比较item.key和slot.key，如果相同
	1.将item加入head
		nitems++;
	2.__btrfs_next_delayed_item获取到下一个item
		并且检查btrfs_is_continuous_delayed_item，如果不成立，退出循环
	3.更新循环变量slot i，不能超过nritems
	4.获取slot i的key
3.如果head中没有item，返回0
4.btrfs_del_items将连续的nritems个slot删除
5.遍历head
	1.btrfs_delayed_item_release_metadata释放item-&gt;bytes_reserved
	2.将curr从链表中删除
	3.btrfs_release_delayed_item释放curr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23910</x>
      <y>9790</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24080</x>
      <y>9530</y>
      <w>390</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.如果node的BTRFS_DELAYED_NODE_INODE_DIRTY没置上，返回0
2.否则__btrfs_update_delayed_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24220</x>
      <y>9490</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24210</x>
      <y>9610</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_update_delayed_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24270</x>
      <y>9570</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24150</x>
      <y>9680</y>
      <w>390</w>
      <h>260</h>
    </coordinates>
    <panel_attributes>1.如果node的BTRFS_DELAYED_NODE_DEL_IREF置上，mode=-1
	否则mod=1
2.btrfs_lookup_inode查找node指向的BTRFS_INODE_ITEM_KEY
	1.如果返回1，返回ENOENT
	2.如果出错，返回错误
3.将node-&gt;inode_ite写入到slot数据
4.标记leaf dirty
5.如果不是BTRFS_DELAYED_NODE_DEL_IREF，返回
注：add_ref通过递增ref，而不是通过递增item？
6.否则
	1.递增path.slot
	2.slot如果超过了nritems，跳到search
	3.again
		1.对比slot的objectid type(要是ref或者extref)，如果不对，跳到out
		2.btrfs_del_item将inode_ref删除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24290</x>
      <y>9640</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>22420</x>
      <y>9640</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_run_delalloc_work</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>22350</x>
      <y>9710</y>
      <w>430</w>
      <h>170</h>
    </coordinates>
    <panel_attributes>1.如果需要delalloc_work-&gt;wait，通过btrfs_wait_ordered_range
	等待inode刷写完成
2.否则
	1.通过filemap_flush进行刷写
	2.如果inode.runtimeflags的BTRFS_INODE_HAS_ASYNC_EXTENT置上
		再次通过filemap_flush进行刷鞋
3.释放inode
	1.如果delay_iput，将inode通过btrfs_add_delayed_iput添加到delayed_iputs
	2.否则通过iput直接释放
4.递增delalloc_work-&gt;completion.done
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23440</x>
      <y>9730</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23170</x>
      <y>9730</y>
      <w>90</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22510</x>
      <y>9670</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22340</x>
      <y>9590</y>
      <w>160</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24800</x>
      <y>9070</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_wait_delalloc_flush</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24880</x>
      <y>9100</y>
      <w>150</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FLUSHONCOMMIT</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24790</x>
      <y>9140</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_wait_ordered_roots</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24710</x>
      <y>9210</y>
      <w>380</w>
      <h>100</h>
    </coordinates>
    <panel_attributes>1.遍历fs_info-&gt;ordered_roots，直到处理nr个
	1.获取root，移到fs_info-&gt;ordered_roots
	2.btrfs_wait_ordered_extents
	3.调整nr
2.将没处理完的splice，重新加入fs_info-&gt;ordered_roots
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24880</x>
      <y>9170</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>24790</x>
      <y>9340</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_wait_ordered_extents</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24870</x>
      <y>9300</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>24870</x>
      <y>9370</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>24700</x>
      <y>9410</y>
      <w>380</w>
      <h>180</h>
    </coordinates>
    <panel_attributes>1.遍历nr个root-&gt;ordered_extents上的ordered
	1.获取ordered，并重新加入root-&gt;ordered_extents
	2.初始化ordered-&gt;flush_work，并加入链表works
	3.btrfs_queue_work将work分配到fs_info-&gt;flush_workers中
	4.调整nr，并记录处理的ordered
2.将splice中没处理完放到root-&gt;ordered_extents
3.遍历works链表
	1.将ordered脱链
	2.wait_for_completion等待每个ordered完成，之后将其释放
4.返回处理的ordered
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>23120</x>
      <y>6320</y>
      <w>540</w>
      <h>350</h>
    </coordinates>
    <panel_attributes>1.create_pending_snapshots
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19370</x>
      <y>9600</y>
      <w>1890</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1870.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25370</x>
      <y>9060</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>create_pending_snapshots</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>25460</x>
      <y>9090</y>
      <w>260</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历transaction-&gt;pending_snapshots</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>25380</x>
      <y>9140</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>create_pending_snapshot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15080</x>
      <y>12730</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__filemap_fdatawrite_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15160</x>
      <y>12690</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15010</x>
      <y>12800</y>
      <w>380</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.根据参数设置wbc
2.mapping_cap_writeback_dirty检查bdev的BDI_CAP_NO_WRITEBACK
	没置上，返回0
3.do_writepages写page后返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15160</x>
      <y>12760</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15130</x>
      <y>12910</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>do_writepages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15180</x>
      <y>12870</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15180</x>
      <y>12940</y>
      <w>30</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15020</x>
      <y>12970</y>
      <w>420</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.如果nr_to_write&lt;0，返回0
2.如果mapping有方法，通过mapping-&gt;a_ops-&gt;writepages写page
	否则直接通过generic_writepages写
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15050</x>
      <y>13060</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;writepages
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15310</x>
      <y>13060</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>generic_writepages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15140</x>
      <y>13020</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15390</x>
      <y>13020</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14950</x>
      <y>13090</y>
      <w>210</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btree_aops</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14890</x>
      <y>13130</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btree_writepages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14780</x>
      <y>13200</y>
      <w>320</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.如果sync_mode是NONE
	1.如果for_kupdate存在，返回0
	2.dirty_metadata_bytes要超过限制，否则返回0
2.btree_write_cache_pages
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14950</x>
      <y>13160</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14860</x>
      <y>13310</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btree_write_cache_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14950</x>
      <y>13270</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14950</x>
      <y>13340</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14730</x>
      <y>13380</y>
      <w>420</w>
      <h>260</h>
    </coordinates>
    <panel_attributes>System
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15200</x>
      <y>13090</y>
      <w>220</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_aops</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15340</x>
      <y>13130</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_writepages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15390</x>
      <y>13160</y>
      <w>130</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode.io_tree
btrfs_get_extent</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15330</x>
      <y>13200</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>extent_writepages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15220</x>
      <y>13260</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>extent_write_cache_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15520</x>
      <y>13260</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>flush_epd_write_bio</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15300</x>
      <y>13230</y>
      <w>110</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15410</x>
      <y>13230</y>
      <w>220</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15170</x>
      <y>13340</y>
      <w>420</w>
      <h>490</h>
    </coordinates>
    <panel_attributes>1.如果inode在I_FREEING |I_WILL_FREE，返回0
2.确定写的范围
	1.如果wbc-&gt;range_cyclic置上，从上次回写开始(wbc-&gt;range_cyclic)到-1
	2.否则
		1.从wbc-&gt;range_start ~wbc-&gt;range_end
		2.scanned = 1
3.根据sync_mode设置tag
	1.WB_SYNC_ALL----&gt;PAGECACHE_TAG_TOWRITE
	2.否则PAGECACHE_TAG_DIRTY
4.retry
	1.如果sync_mode是sync_all，tag_pages_for_writeback检查mapping-&gt;page_tree中
		PAGECACHE_TAG_DIRTY置上的时候，将其PAGECACHE_TAG_TOWRITE置上（最多4069个page）
	2.如果没有done，并且没有nr_to_write_doneindex满足要求，
		pagevec_lookup_tag能找到要写的page（tag满足要求）
		1.遍历找到要写的page
			1.如果page被lock，通过flush_fn方法去刷写
			2.如果page的mappinf发生改变，跳过这个page
			3.如果不是range_cyclic，并且遍历到end
				1.将done置上
				2.继续遍历数组中的下一个page
			4.如果不是WB_SYNC_NONE
				1.page的writeback置上，通过flush_fn进行刷写
				2.wait_on_page_writeback等待PG_writeback
			5.如果page的writeback置上或者clear_page_dirty_for_io发现page之前没有dirty
				就跳过这个page
			6.通过writepage方法写page
			7.AOP_WRITEPAGE_ACTIVATE--&gt;0
			8.如果没有nr_to_write，将nr_to_write_done置上
5.如果scanned没置上，并且此次没有done，并且没错，将scanned置上，调整index=0
	跳到retry重头开始遍历
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15300</x>
      <y>13290</y>
      <w>150</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
__extent_writepage
flush_write_bio</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15100</x>
      <y>12660</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_cont_expand</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14730</x>
      <y>13920</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tag_pages_for_writeback</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>14680</x>
      <y>13990</y>
      <w>240</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>radix_tree_range_tag_if_tagged</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14470</x>
      <y>14050</y>
      <w>250</w>
      <h>140</h>
    </coordinates>
    <panel_attributes>1.检查首尾index
2.要是iftag的leaf数量(nr_to_tag)为0,
	(不需要检查)，直接返回0
3.如果root的iftag没置上，返回0
	first_indexp = last_index + 1
4.如果没height，因为之前检查了root，
	root_tag_set将settag置上，并返回1
	first_indexp = last_index + 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14570</x>
      <y>14020</y>
      <w>240</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>14770</x>
      <y>14050</y>
      <w>380</w>
      <h>290</h>
    </coordinates>
    <panel_attributes>5.循环遍历radix_tree
	1.如果有效slot的iftag没置上，跳到next
	2.如果没到leaf(shift不为0)，继续更新shift，继续向下遍历
	3.如果到达了leaf
		1.找到一个leaf，将slot[offset]的settag置上
			tagged++
		2.循环向上设置parent的settag，直到设置到root或者parent的settag已经置上了
		3.next
			1.获取下一个index
				index = ((index &gt;&gt; shift) + 1) &lt;&lt; shift(leaf的时候，shift为0)
			2.检查index的有效性
			3.检查是否设置了nr_to_tag个leaf
			4.如果检查到了最后一个，向上遍历
				slot = slot-&gt;parent;
				shift += RADIX_TREE_MAP_SHIFT;
6.如果有设置tagged，将root的settag置上
7.返回设置到的index，并返回设置的tagged的数量
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14850</x>
      <y>14020</y>
      <w>90</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14800</x>
      <y>13950</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15270</x>
      <y>13920</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>pagevec_lookup_tag</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15270</x>
      <y>13990</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_get_pages_tag</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15330</x>
      <y>13950</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15170</x>
      <y>14060</y>
      <w>360</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.如果不用找page，直接返回0
2.restart
	1.遍历mapping-&gt;page_tree中所有tag置上的page
		1.repeat
			1.fitler
				1.如果page不存在，遍历下一个slot
				2.如果radix_tree_exception或者radix_tree_deref_retry
					在重新遍历，或者遍历下一个
				3.如果没有page_cache_get_speculative，重新遍历
				4.page不在slot中，重新遍历
			2.找到page，如果达到nr_pages，退出循环
				pages[ret++] = page;
3.返回最后一个page的index+1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15330</x>
      <y>14020</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15600</x>
      <y>13920</y>
      <w>100</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>flush_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15650</x>
      <y>13950</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15600</x>
      <y>13990</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>flush_write_bio</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15650</x>
      <y>14020</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15560</x>
      <y>14060</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>flush_epd_write_bio</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15630</x>
      <y>13320</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>submit_one_bio</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15610</x>
      <y>13290</y>
      <w>110</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15770</x>
      <y>13980</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__extent_writepage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15810</x>
      <y>13910</y>
      <w>100</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>writepage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15850</x>
      <y>13940</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15840</x>
      <y>14010</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15730</x>
      <y>14050</y>
      <w>320</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>1.设置write_flags
	1.WB_SYNC_ALL--&gt;WRITE_SYNC
	2.否则为WRITE
2.如果page超过了inode.size，通过mapping-&gt;a_ops-&gt;invalidatepage
	将page设置为无效
3.如果到达了inode的最后一个页面
	1.将inode.i_size之外的空间清0
4.set_page_extent_mapped设置page private
5.writepage_delalloc对delalloc的数据进行cow
	如果返回1，表示page已经被写到磁盘的buffer，跳到done_unlocked
6.__extent_writepage_io
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15660</x>
      <y>14320</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>writepage_delalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15540</x>
      <y>14390</y>
      <w>340</w>
      <h>210</h>
    </coordinates>
    <panel_attributes>1.如果extent_locked置上，或者没有tree.ops-&gt;fill_delalloc
	直接返回0
2.最多只能申请一个页面，循环申请空间
	1.find_lock_delalloc_range查找被dealloc的段并lock，返回在io_tree中段的数目
	2.如果没找到，调整delalloc_start(从之前的delalloc_end开始)重新查找
	3.tree-&gt;ops-&gt;fill_delalloc对delalloc的段做cow(分配新的extent)
	4.更新变量delalloc_to_write，delalloc_start
3.更新wbc-&gt;nr_to_write
	1.如果delalloc_to_write超过了16k，不能超过8k
	2.否则不能超过delalloc_to_write
4.如果将数据写入inode，递减wbc-&gt;nr_to_write，并返回1
5.否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15720</x>
      <y>14350</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15460</x>
      <y>14650</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_lock_delalloc_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15550</x>
      <y>14590</y>
      <w>30</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15380</x>
      <y>14730</y>
      <w>380</w>
      <h>340</h>
    </coordinates>
    <panel_attributes>1.again
	1.find_delalloc_range寻找io_tree中被标记为delalloc，并且
		满足条件的段
	2.如果没找到，或者找到的delalloc_end低于start
		1.返回找到的start end，释放cache_state
		2.返回0
	3.如果找到的delalloc_start低于start
		delalloc_start = *start
	4.如果找到的长度超过了max_bytes，调整delalloc_end到长度为max_bytes
2.lock_delalloc_pages将delalloc_start~delalloc_end范围内的page lock
3.如果返回EAGAIN
	1.free_extent_state释放cache_state
		cached_state = NULL
	2.如果loop没置上，将其置上，跳到again
		max_bytes = PAGE_CACHE_SIZE
	3.否则将found置0，跳到out_failed
4.lock_extent_bits将io_tree中的delalloc_start~delalloc_end设置EXTENT_LOCKED
5.test_range_bit检查该段的EXTENT_DELALLOC是否置上
	1.如果没置上，将extent_locked和page_lock清除
	2.然后跳到again
6.返回段的范围，及在io_tree中段的数量
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15540</x>
      <y>14680</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15320</x>
      <y>15110</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_delalloc_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15380</x>
      <y>15060</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15260</x>
      <y>15180</y>
      <w>320</w>
      <h>380</h>
    </coordinates>
    <panel_attributes>1.tree_search在io_tree中查找cur_start，如果没找到，跳到out
	end=-1
2.循环
	1.如果之前找到其中的段，当前的段的start和要找的cur_start不同
		或者相同但是EXTENT_BOUNDARY置上，跳到out
	2.如果state的EXTENT_DELALLOC没置上，跳到out
		1.如果之前没有found到段
			end = state-&gt;end
	3.此时找到EXTENT_DELALLOC置上的段
		1.如果是第一个state，更新start
			*start = state-&gt;start;
			*cached_state = state;
			atomic_inc(&amp;state-&gt;refs)
		2.递增found
		3.更新end
			*end = state-&gt;end;
		4.调整循环变量
			1.更新cur_start
				cur_start = state-&gt;end + 1;
			2.更新找到的段的长度total_bytes
			3.如果超过了max_bytes，退出循环
			4.如果next_node不存在退出循环
3.out：返回找到段的数目
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15380</x>
      <y>15140</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15640</x>
      <y>15110</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lock_delalloc_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15600</x>
      <y>15180</y>
      <w>410</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.如果delalloc的段就是当前locked_page，直接返回0
2.遍历delalloc的page
	1.find_get_pages_contig查找page_tree中page,直到全部找到，或者检查到hole
	2.如果没找到，返回EAGAIN，跳到done
	3.遍历所有找到的page
		1.如果不是locked_page
			1.lock_page
			2.如果page没有dirty或者不在inode内，返回EAGAIN，跳到done
		2.记录所有被locked的page(pages_locked)
	4.更新还要被locked的page
		nrpages -= ret;
		index += ret;
3.done：
	1.如果出错，并且有page被locked，__unlock_for_delalloc将被locked的page解锁
	2.返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15750</x>
      <y>15460</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>find_get_pages_contig</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15820</x>
      <y>15420</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15640</x>
      <y>15530</y>
      <w>390</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.如果不用找page(!nr_pages)，返回0
2.radix_tree_for_each_contig遍历mapping-&gt;page_tree
	直到检查到hole()
	1.filter
		1.如果没找到page，退出循环
		2.如果radix_tree_exception
			1.如果radix_tree_deref_retry，跳到2重新遍历
			2.否则退出循环
		3.如果不能page_cache_get_speculative，退出循环
		4.如果page不在slot，跳到2重新遍历
		5.如果page.mapping不存在，或者其index不同，退出循环
	2.获取page,如果达到了nr_pages，退出循环
		pages[ret++] = page;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15810</x>
      <y>15490</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15720</x>
      <y>15140</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15690</x>
      <y>15060</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16220</x>
      <y>14660</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tree-&gt;ops-&gt;fill_delalloc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16300</x>
      <y>14690</y>
      <w>150</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_extent_io_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16140</x>
      <y>14800</y>
      <w>400</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.run_delalloc_nocow申请ordered，em(段内没有csum可以不做cow)
	BTRFS_INODE_NODATACOW(没有defrag)，force置上
	BTRFS_INODE_PREALLOC（没有defrag），force不置
注：inline不用申请，直接将数据填入extent_data_key
2.如果不用inode_need_compress，通过cow_file_range段段进行cow
注：这里无论如何都会重新分配extent(不管这个段是否在inode的范围内)
3.否则
	1.将inode.runtime_flags的BTRFS_INODE_HAS_ASYNC_EXTENT置上
	2.cow_file_range_async进行异步的cow
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16230</x>
      <y>14730</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>run_delalloc_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16300</x>
      <y>14760</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15950</x>
      <y>14970</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>need_force_cow</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15990</x>
      <y>14950</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16000</x>
      <y>15000</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>15930</x>
      <y>15040</y>
      <w>310</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.BTRFS_INODE_NODATACOW或者BTRFS_INODE_PREALLOC至少有一个置上
2.存在inode.defrag_bytes，并且io_tree中段的EXTENT_DEFRAG置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16290</x>
      <y>14970</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>inode_need_compress</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16360</x>
      <y>14950</y>
      <w>50</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16350</x>
      <y>15000</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16250</x>
      <y>15040</y>
      <w>290</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.需要compress，返回1
	1.root的FORCE_COMPRESS置上
	2.root的COMPRESS置上
	3.inode的BTRFS_INODE_COMPRESS置上
	4.inode的force_compress置上
2.其他情况返回0 （inode的BTRFS_INODE_NOCOMPRESS置上）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16640</x>
      <y>14970</y>
      <w>160</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>run_delalloc_nocow</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17830</x>
      <y>14980</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>cow_file_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18470</x>
      <y>14990</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>cow_file_range_async</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16550</x>
      <y>15040</y>
      <w>360</w>
      <h>780</h>
    </coordinates>
    <panel_attributes>1.如果没申请到path，通过extent_clear_unlock_delalloc清除段的状态
2.如果不是free_space_ino --&gt;btrfs_join_transaction_nolock
	否则使用btrfs_join_transaction
3.trans-&gt;block_rsv=fs_info-&gt;delalloc_block_rsv
4.循环
	1.btrfs_lookup_file_extent查找指向ino，偏移为cur_offset的extent_data
	2.如果出错，跳到error，如果返回1，如果slot-1满足条件，调整slot
	3.将check_prev清掉
	4.next_slot
		1.如果slot到达了nritems，通过btrfs_next_leaf遍历下一个slot
		2.获取slot的key
			1.objectid不能超过ino
			2.如果低于BTRFS_EXTENT_DATA_KEY，slot++，跳到next_slot
			3.如果高于cur_offset,跳到out_check
				extent_end = found_key.offset
	5.如果完全满足要求，通过btrfs_file_extent_item解析
		1.如果fi.type是BTRFS_FILE_EXTENT_REG或者BTRFS_FILE_EXTENT_PREALLOC
			1.filter
				1.如果extend_end低于start，slot++,跳到next_slot
				2.跳到out_check
					1.disk_bytenr为0
					2.compression
					3.encryption
					4.other_encoding
					5.如果是BTRFS_FILE_EXTENT_REG，但是不需要force
					6.btrfs_extent_readonly
					7.btrfs_cross_ref_exist
			2.计算在磁盘上的偏移disk_bytenr，和其长度num_bytes
			注：extent_offset表示found_key.offset相对disk_bytenr的偏移(在磁盘上的偏移)
				cur_offset - found_key.offset表示要找的段相对于found_key的偏移
			3.如果有lock，通过btrfs_start_write_no_snapshoting，如果返回0，跳到out_check
			4.csum_exist_in_range查找要映射的段内是否有csum，如果存在，跳到out_check
			5.置上nocow(只有在包含要写文件，并且没有csum时，才不用cow)
		2.如果是BTRFS_FILE_EXTENT_INLINE，确定extent_end（extent_data_item end）
	6.out_check
		1.如果需要cow，cow_file_range对段做cow(也添加了ordered IO)
		2.如果不需要，只是添加ordered
5.如果段没遍历完，将其做cow（重新分配extent）
	cow_start = cur_offset;
	cur_offset = end;
6.将还没cow的段，通过cow_file_range做cow
注：1.如果是inline，直接插入到extent_data中(cow)
	2.如果不是，删除原有的em，重新申请em，并申请ordered IO
7.error
	1.btrfs_end_transaction
	2.如果出错，并且段没遍历完
		1.extent_clear_unlock_delalloc
	3.释放path，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16700</x>
      <y>15000</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16340</x>
      <y>15850</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>extent_clear_unlock_delalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16420</x>
      <y>15810</y>
      <w>200</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16230</x>
      <y>15920</y>
      <w>380</w>
      <h>300</h>
    </coordinates>
    <panel_attributes>1.clear_extent_bit将段的bits清除
2.如果不存在page_ops，返回0
3.如果page_ops的PAGE_SET_ERROR置上，并且有page
	将inode.i_mapping的AS_EIO置上
4.遍历nr_pages
	1.find_get_pages_contig查找段内的page，遇到hole停止
	2.遍历page
		1.page_ops的PAGE_SET_PRIVATE2置上，SetPagePrivate2
		2.跳到locked_page
		3.PAGE_CLEAR_DIRTY--&gt;clear_page_dirty_for_io
		4.PAGE_SET_WRITEBACK--&gt;set_page_writeback
		5.PAGE_SET_ERROR--&gt;SetPageError
		6.PAGE_END_WRITEBACK--&gt;end_page_writeback
		7.PAGE_UNLOCK--&gt;unlock_page
	3.继续遍历
		nr_pages -= ret;
		index += ret;
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16400</x>
      <y>15880</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16720</x>
      <y>15860</y>
      <w>230</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_start_write_no_snapshoting</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16640</x>
      <y>15930</y>
      <w>430</w>
      <h>120</h>
    </coordinates>
    <panel_attributes>1.如果root-&gt;will_be_snapshoted，返回0
2.递增root-&gt;subv_writers-&gt;counter
3.再次检查will_be_snapshoted，如果置上
	1.通过btrfs_end_write_no_snapshoting递减root-&gt;subv_writers-&gt;counter
		并唤醒root-&gt;subv_writers-&gt;wait
	2.返回0
4.否则返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16830</x>
      <y>15810</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16820</x>
      <y>15890</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17170</x>
      <y>15840</y>
      <w>130</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>out_check
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17220</x>
      <y>15870</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17090</x>
      <y>15910</y>
      <w>400</w>
      <h>630</h>
    </coordinates>
    <panel_attributes>1.如果这个extent_data低于要找的start，递增slot，并跳到next_slot
2.如果需要cow
	1.如果没指定cow_start，将其赋为cur_offset
	2.调整cur_offset
		cur_offset = extent_end
	3.如果超过了end，退出循环
	4.否则递增slot，跳到next_slot
3.如果nocow
	1.如果有cow_start，将之前的cow_start先cow
		1.cow_file_range先将cow_start~found_key进行cow
		2.cow_start = (u64)-1
	2.如果extent_data的type是BTRFS_FILE_EXTENT_PREALLOC
		1.alloc_extent_map申请em
			em-&gt;start = cur_offset;
			em-&gt;orig_start = found_key.offset - extent_offset;
			em-&gt;len = num_bytes;
			em-&gt;block_len = num_bytes;
			em-&gt;block_start = disk_bytenr;
			em-&gt;orig_block_len = disk_num_bytes;
			em-&gt;ram_bytes = ram_bytes;
			em-&gt;bdev = root-&gt;fs_info-&gt;fs_devices-&gt;latest_bdev;
			em-&gt;mod_start = em-&gt;start;
			em-&gt;mod_len = em-&gt;len;
			set_bit(EXTENT_FLAG_PINNED, &amp;em-&gt;flags);
			set_bit(EXTENT_FLAG_FILLING, &amp;em-&gt;flags);
			em-&gt;generation = -1;
		2.循环直到通过add_extent_mapping将em加入em_tree
		3.type = BTRFS_ORDERED_PREALLOC
	3.否则
		type = BTRFS_ORDERED_NOCOW
4.btrfs_add_ordered_extent将map的extent信息加入到ordered_tree中
注：extent_data_key中存储的是以inode为主体的硬盘的使用情况
	extent_item_key存储的是以extent为主体的，inode对extent的引用
	ordered_tree中存储的是需要刷写的extent
5.如果inode.root是BTRFS_DATA_RELOC_TREE_OBJECTID
	通过btrfs_reloc_clone_csums将reloc_csum链入到ordered中
6.extent_clear_unlock_delalloc清掉extent lock，并置上page flag
7.更新offset
	cur_offset = extent_end
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16890</x>
      <y>16570</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_add_ordered_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16970</x>
      <y>16530</y>
      <w>170</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16970</x>
      <y>16600</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>16850</x>
      <y>16640</y>
      <w>190</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__btrfs_add_ordered_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16960</x>
      <y>16670</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>16820</x>
      <y>16710</y>
      <w>420</w>
      <h>300</h>
    </coordinates>
    <panel_attributes>1.申请btrfs_ordered_extent_cache，并初始化
	entry-&gt;file_offset = file_offset;
	entry-&gt;start = start;
	entry-&gt;len = len;
	entry-&gt;disk_len = disk_len;
	entry-&gt;bytes_left = len;
	entry-&gt;inode = igrab(inode);
	entry-&gt;compress_type = compress_type;
	entry-&gt;truncated_len = (u64)-1;
2.entry.flags
	1.如果type不是BTRFS_ORDERED_IO_DONE BTRFS_ORDERED_COMPLETE
		直接设置
	2.如果dio置上，将BTRFS_ORDERED_DIRECT置上
3.初始化entry的链表
4.tree_insert插入inode.ordered_tree中
5.将entry.root_extent_list加入到root-&gt;ordered_extents后面
	1.root-&gt;nr_ordered_extents++
	2.如果root只有这一个order_extent,将root-&gt;ordered_roo加入到fs_info.ordered_roots中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17310</x>
      <y>16580</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_reloc_clone_csums</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17400</x>
      <y>16530</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17400</x>
      <y>16610</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17270</x>
      <y>16650</y>
      <w>360</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.btrfs_lookup_ordered_extent在inode.ordered_tree中查找
	file_pos对应的ordered
2.btrfs_lookup_csums_range查找盘上段内的csum段
注:index_cnt在create_reloc_inode中被赋值为block_group的偏移
3.如果该段内存在csum
	1.将sums脱链
	2.算出sums在ordered中的偏移
		sums-&gt;bytenr = new_bytenr
	3.btrfs_add_ordered_sum将sums链入到ordered.list链表中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1880</x>
      <y>1500</y>
      <w>10</w>
      <h>0</h>
    </coordinates>
    <panel_attributes>btrfs_add_inode_defrag</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1870</x>
      <y>1530</y>
      <w>10</w>
      <h>0</h>
    </coordinates>
    <panel_attributes>__need_auto_defrag</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1860</x>
      <y>1540</y>
      <w>20</w>
      <h>0</h>
    </coordinates>
    <panel_attributes>1.返回0
	1.root的AUTO_DEFRAG没置上
	2.btrfs_fs_closing
2.否则返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1910</x>
      <y>1500</y>
      <w>10</w>
      <h>0</h>
    </coordinates>
    <panel_attributes>cow_file_range_inline</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1900</x>
      <y>1550</y>
      <w>10</w>
      <h>0</h>
    </coordinates>
    <panel_attributes>insert_inline_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1960</x>
      <y>1500</y>
      <w>20</w>
      <h>0</h>
    </coordinates>
    <panel_attributes>get_extent_allocation_hint</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1950</x>
      <y>1510</y>
      <w>30</w>
      <h>0</h>
    </coordinates>
    <panel_attributes>1.search_extent_mapping查找段对应的em
2.如果找到
	1.默认使用em.block_start作为hint，
	2.如果block_start无效，查找first_block.block_start
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17710</x>
      <y>15050</y>
      <w>440</w>
      <h>630</h>
    </coordinates>
    <panel_attributes>1.如果是btrfs_is_free_space_inode，返回EINVAL
2.如果cow的长度小于64k，并且要写的范围在disk_i_size范围内
	通过btrfs_add_inode_defrag申请defrag加入红黑树fs_info-&gt;defrag_inodes中
3.如果start为0
	1.cow_file_range_inline将start~end段进行cow(__btrfs_drop_extents中在search_slot
		的时候会将cow置上)
	2.如果正确返回
		1.extent_clear_unlock_delalloc将段的lock去掉，并且置上page的flag
		2.更新nr_written，置上page_started，跳到out
	3.如果出错，跳到out_unlock
4.get_extent_allocation_hint获取extent在block的最小位置
5.btrfs_drop_extent_cache删除段在inode中的em
6.循环获取disk_num_bytes大小的extent
	1.btrfs_reserve_extent从block_group中获取extent
	2.alloc_extent_map申请em，并初始化
		em-&gt;start = start;
		em-&gt;orig_start = em-&gt;start;//orig_start为disk_bytenr在file中的偏移
		ram_size = ins.offset;
		em-&gt;len = ins.offset;
		em-&gt;mod_start = em-&gt;start;
		em-&gt;mod_len = em-&gt;len;
		em-&gt;block_start = ins.objectid;
		em-&gt;block_len = ins.offset;
		em-&gt;orig_block_len = ins.offset;
		em-&gt;ram_bytes = ram_size;
		em-&gt;bdev = root-&gt;fs_info-&gt;fs_devices-&gt;latest_bdev;
		set_bit(EXTENT_FLAG_PINNED, &amp;em-&gt;flags);
		em-&gt;generation = -1;
	3.循环通过add_extent_mapping将em加入到inode.extent_tree中，直到成功
	4.btrfs_add_ordered_extent向inode.ordered_tree中添加需要io的段
	5.如果在BTRFS_DATA_RELOC_TREE_OBJECTID中，需要通过btrfs_reloc_clone_csums
	6.如果申请的空间超过了disk_num_bytes，退出循环
	7.extent_clear_unlock_delalloc解锁extent，并置上page的flag
	8.更新循环变量
		disk_num_bytes -= cur_alloc_size;
		num_bytes -= cur_alloc_size;
		alloc_hint = ins.objectid + ins.offset;
		start += cur_alloc_size;
注：如果不是inline，这里并没有添加extent_data，extent_data是在btrfs_finish_ordered_io
	中完成的
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17660</x>
      <y>15720</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_add_inode_defrag</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17730</x>
      <y>15670</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17730</x>
      <y>15750</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17580</x>
      <y>15790</y>
      <w>390</w>
      <h>160</h>
    </coordinates>
    <panel_attributes>1.如果不用__need_auto_defrag，返回0
2.如果inode.runtime_flags的BTRFS_INODE_IN_DEFRAG置上，返回0
3.申请btrfs_inode_defrag_cachep
	defrag-&gt;ino = btrfs_ino(inode);
	defrag-&gt;transid = transid;
	defrag-&gt;root = root-&gt;root_key.objectid;
4.如果inode.runtime_flags的BTRFS_INODE_IN_DEFRAG没置上
	通过__btrfs_add_inode_defrag插入到红黑树fs_info-&gt;defrag_inodes中
5.否则释放defrag
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17590</x>
      <y>15990</y>
      <w>140</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__need_auto_defrag</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17660</x>
      <y>15940</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17640</x>
      <y>16020</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17530</x>
      <y>16060</y>
      <w>220</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.返回0
	1.root的AUTO_DEFRAG没置上
	2.btrfs_fs_closing
2.否则返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18000</x>
      <y>15720</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>cow_file_range_inline</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18080</x>
      <y>15670</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18070</x>
      <y>15750</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17980</x>
      <y>15790</y>
      <w>370</w>
      <h>380</h>
    </coordinates>
    <panel_attributes>1.默认data_len为在start~end中在i_size范围内的长度
	如果存在compressed_size，则为compressed_size
2.以下条件直接返回1，不做处理
	1.start不为0
	2.actual_end超过1页
	3.datalen超过node_size
	4.在没有compressed_size的情况下，actual_end按sectorsize对齐
	5.end没超过i_size
	6.data_len超过了max_inline
3.btrfs_alloc_path
4.btrfs_join_transaction
	trans-&gt;block_rsv = &amp;root-&gt;fs_info-&gt;delalloc_block_rsv
5.确定extent_item_size
6.__btrfs_drop_extents删除start~aligned_end对应的extent_data
	并通过尝试插入一个extent_item_size的extent_data
注：在__btrfs_drop_extents中有通过inode_sub_bytes更改i_blocks i_bytes
7.insert_inline_extent填充其extet_data_key的数据(inline数据在这个key对应的buffer)
8.将inode.runtime_flags的BTRFS_INODE_NEEDS_FULL_SYNC置上
9.btrfs_delalloc_release_metadata释放reserve meta
10.btrfs_drop_extent_cache将start~aligned_end对应的em删除
11.out
	1.btrfs_qgroup_free_data
	2.释放path，btrfs_end_transaction，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>17910</x>
      <y>16210</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>insert_inline_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18000</x>
      <y>16160</y>
      <w>30</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17970</x>
      <y>16240</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>17810</x>
      <y>16280</y>
      <w>400</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.cur_size默认是size，如果有compressed_size，将其更新为这个size
2.inode_add_bytes递增inode.i_bytes i_blocks
3.如果之前没有插入item(!extent_inserted),通过btrfs_insert_empty_item
	插入BTRFS_EXTENT_DATA_KEY
4.以btrfs_file_extent_item方式解析slot数据
	1.填充fi.gen type encryption other_encoding ram_bytes
	2.inline要将数据写入extent_data_key中，并设置extent_compression
		1.如果是compress，循环将compressed_pages中的数据写入到extent中
		2.否则将start对应的page写入到extent中(inline要在1页之内)
	3.标记leaf dirty
5.btrfs_update_inode更新inode
	BTRFS_I(inode)-&gt;disk_i_size = inode-&gt;i_size
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18460</x>
      <y>15710</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>get_extent_allocation_hint</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18390</x>
      <y>15780</y>
      <w>320</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.search_extent_mapping查找段对应的em
2.如果找到
	1.默认使用em.block_start作为hint，
	2.如果block_start无效，查找first_block.block_start
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18560</x>
      <y>15740</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>17880</x>
      <y>15010</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18100</x>
      <y>15670</y>
      <w>450</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16870</x>
      <y>15810</y>
      <w>360</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16490</x>
      <y>14950</y>
      <w>250</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18360</x>
      <y>15060</y>
      <w>450</w>
      <h>400</h>
    </coordinates>
    <panel_attributes>1.clear_extent_bit将inode.io_tree的start~end的EXTENT_LOCKED清掉
2.遍历整个段
	1.申请async_cow
		1.初始化
			async_cow-&gt;inode = igrab(inode);
			async_cow-&gt;root = root;
			async_cow-&gt;locked_page = locked_page;
			async_cow-&gt;start = start;
		2.如果inode.flag的BTRFS_INODE_NOCOMPRESS置上，并且root的FORCE_COMPRESS没置
			cur_end = end
			否则如果要compress，其大小不能超过512K
		async_cow-&gt;end = cur_end
	2.btrfs_init_work初始化async_cow-&gt;work
		work-&gt;func = async_cow_start;
		work-&gt;ordered_func = async_cow_submit;
		work-&gt;ordered_free = async_cow_free;
	3.计算段的page大小nr_pages,并加到fs_info-&gt;async_delalloc_pages
	4.将async_cow加入到fs_info-&gt;delalloc_workers
	5.如果async_delalloc_pages超过10M,等待其减少至limit
	6.循环等待async_delalloc_pages变为0(在async_submit_draining的情况下)
	7.更新循环变量
		nr_written += nr_pages;
		start = cur_end + 1;
3.置上page_start，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>18540</x>
      <y>15020</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16500</x>
      <y>14950</y>
      <w>1420</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1400.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>16510</x>
      <y>14950</y>
      <w>2060</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2040.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15800</x>
      <y>14590</y>
      <w>490</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19120</x>
      <y>14330</y>
      <w>180</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>__extent_writepage_io</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19030</x>
      <y>14400</y>
      <w>360</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.tree-&gt;ops-&gt;writepage_start_hook如果在page状态不对，将其加到队列处理
	如果状态不对
	1.如果返回EBUSY，queue会处理
		wbc-&gt;pages_skipped++
	2.否则redirty_page_for_writepage
	3.update_nr_written更新nr_to_write writeback_index，忽略此次的更新
	4.跳到done_unlocked，返回1
2.update_nr_written更新nr_to_write writeback_index
3.如果写的pag额超过了inode.i_size,tree-&gt;ops-&gt;writepage_end_io_hook
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19210</x>
      <y>14360</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18910</x>
      <y>14650</y>
      <w>240</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tree-&gt;ops-&gt;writepage_start_hook
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19030</x>
      <y>14610</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19010</x>
      <y>14680</y>
      <w>150</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_extent_io_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18950</x>
      <y>14720</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_writepage_start_hook</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19030</x>
      <y>14750</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18890</x>
      <y>14790</y>
      <w>340</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.如果PagePrivate2置上，返回0
2.如果正在PageChecked,返回EAGAIN
3.SetPageChecked
4.初始化fixup-&gt;work(btrfs_writepage_fixup_worker)
	fixup-&gt;page = page
5.返回EBUSY
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18970</x>
      <y>14930</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_writepage_fixup_worker</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19050</x>
      <y>14890</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19070</x>
      <y>14960</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18890</x>
      <y>15000</y>
      <w>410</w>
      <h>240</h>
    </coordinates>
    <panel_attributes>1.获取fixup page
2.如果page.mapping不存在， page没有dirty，page不在checked
	跳到out_page
3.lock_extent_bits在inode中将page锁住
4.如果PagePrivate2，跳到out
5.btrfs_lookup_ordered_extent在ordered_tree中查找page
	如果找到
	1.btrfs_start_ordered_extent刷写ordered，并等待page刷写完成
	2.btrfs_put_ordered_extent将ordered释放，并跳到again
6.如果没找到
	1.btrfs_delalloc_reserve_space
	2.btrfs_set_extent_delalloc将该段设置为delalloc
	3.ClearPageChecked，并且set_page_dirty
7.out:解锁，并且释放fixup
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19240</x>
      <y>14650</y>
      <w>240</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>tree-&gt;ops-&gt;writepage_end_io_hook
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19330</x>
      <y>14610</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19340</x>
      <y>14680</y>
      <w>150</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_extent_io_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19290</x>
      <y>14720</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_writepage_end_io_hook</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19300</x>
      <y>14790</y>
      <w>360</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.ClearPagePrivate2
2.btrfs_dec_test_ordered_pending检查段没被IO完成，返回0
3.如果段被IO完成
	1.初始化ordered_extent-&gt;work(finish_ordered_fn)
	2.根据是否是free_space_inode将其加入到
	endio_freespace_worker/endio_write_workers队列
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19420</x>
      <y>14750</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19320</x>
      <y>14930</y>
      <w>230</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_dec_test_ordered_pending</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19420</x>
      <y>14890</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19420</x>
      <y>14960</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19310</x>
      <y>15000</y>
      <w>360</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>1.如果有cached，不需要查找跳到have_entry
	否则tree_search在inode.order_tree中查找file_offset
2.have_entry
	1.如果offset不在entry的范围内，返回1
	2.如果需要的io_size超过了entry.bytes_left,报错
	3.entry-&gt;bytes_left -= io_size
	4.如果extent没有uptodate，将entry的BTRFS_ORDERED_IOERR置上
	5.如果没有bytes_left
		1.将entry的BTRFS_ORDERED_IO_DONE置上
		注：只有此次entry被完全IO_DONE，才返回0
		2.如果存在entry.wait，唤醒entry.wait
	6.否则直接返回1
3.out
	1.如果entry被完全IO_DONE，缓存entry，并递增其ref
	2.如果此次检查被完全IO_DONE，返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19710</x>
      <y>14930</y>
      <w>120</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>finish_ordered_fn</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19690</x>
      <y>15000</y>
      <w>170</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_finish_ordered_io</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19570</x>
      <y>14890</y>
      <w>220</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19760</x>
      <y>14960</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19770</x>
      <y>15030</y>
      <w>260</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没有cow，更新inode_item后退出</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19680</x>
      <y>15070</y>
      <w>440</w>
      <h>220</h>
    </coordinates>
    <panel_attributes>1.如果是btrfs_is_free_space_inode，就nolock
2.如果BTRFS_ORDERED_IOERR置上，返回EIO
3.btrfs_free_io_failure_record将io_failure_tree中之前错误的段删除
4.如果ordered的BTRFS_ORDERED_TRUNCATED置上
	1.将truncated置上
	2.logical_len设置为truncated_len，如果为0，跳到out
5.如果ordered的BTRFS_ORDERED_NOCOW置上
	1.btrfs_qgroup_free_data将ordered释放
	2.btrfs_ordered_update_i_size更新disk_i_size
	3.btrfs_join_transaction
		trans-&gt;block_rsv = &amp;root-&gt;fs_info-&gt;delalloc_block_rsv
	4.btrfs_update_inode_fallback更新inode
	5.跳到out
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19580</x>
      <y>15370</y>
      <w>210</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_free_io_failure_record</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>19670</x>
      <y>15400</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19510</x>
      <y>15440</y>
      <w>370</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>1.find_first_extent_bit_state在io_failure_tree中查找start对应
	EXTENT_DIRTY置上的state
2.循环处理释放state
	1.如果state超过了end，退出循环
	2.通过next_state获取next
	3.将state.private对应的failrec释放，并释放state
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>19980</x>
      <y>15370</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_ordered_update_i_size</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>19900</x>
      <y>15440</y>
      <w>410</w>
      <h>350</h>
    </coordinates>
    <panel_attributes>1.获取要处理的offset
	1.如果指定了ordered，offset是ordered的end
	2.否则为指定的offset对sectorsize取整
2.如果disk_i_size超过i_size,返回0
	BTRFS_I(inode)-&gt;disk_i_size = i_size
3.如果disk_i_size和i_size相同，返回1
4.如果处理的offset在disk_i_size范围内，并且outstanding_isize在disk_i_size
	范围内，返回1
5.找到offset或者ordered之前的prev
6.向前遍历红黑树链表，如果之前还有超过disk_i_size的test，将update转换到test
	1.如果test的BTRFS_ORDERED_UPDATED_ISIZE置上，不做处理
	2.如果test在disk_i_size范围内，退出循环
	3.如果test完全不在inode的范围内，退出循环
	4.如果test部分在disk_i_size范围内
		1.更新test-&gt;outstanding_isize(offset ordered-&gt;outstanding_isize)
		2.跳到out，暂时不做处理
7.如果之前没有超过disk_i_size的ordered，调整disk_i_size到offset
	或者outstanding_isize，并返回0
8.out
	1.如果有ordered，标记ordered已经被BTRFS_ORDERED_UPDATED_ISIZE
	2.返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20070</x>
      <y>15400</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20410</x>
      <y>15050</y>
      <w>510</w>
      <h>250</h>
    </coordinates>
    <panel_attributes>6.lock_extent_bits锁住ordered对应的段
7.test_range_bit查看ordered对应的段是否完全将EXTENT_DEFRAG置上
	1.如果完全置上，通过clear_extent_bit将该段的EXTENT_DEFRAG清掉
8.btrfs_join_transaction
	trans-&gt;block_rsv = &amp;root-&gt;fs_info-&gt;delalloc_block_rsv
9.BTRFS_ORDERED_COMPRESSED --&gt;compress_type
10.如果ordered的BTRFS_ORDERED_PREALLOC置上，通过btrfs_mark_extent_written
	将ordered对应的extent_data更改为BTRFS_FILE_EXTENT_REG
11.否则，通过insert_reserved_file_extent
注：在cow_file_range中ordered_extent-&gt;start存储的是extent的硬盘偏移
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20530</x>
      <y>15350</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>btrfs_mark_extent_written</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20330</x>
      <y>15420</y>
      <w>370</w>
      <h>470</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot查找ino段对应的extent_data,根据返回
	调整slot
2.如果start=offset,end&lt;extent_end
	1.extent_mergeable查看前一个slot是否合并,如果能合并
		1.将path改成end~extent_end
			1.更新path的key
				new_key.offset = end
			2.更改extent_data 
				fi.generation=transid
				fi.nem_bytes=extent_end-end
				fi.offset=end-orig_offset(disk_bytenr在inode中的逻辑偏移)
		2.将slot-1变成合并的extent_data
			1.更新extent_data
				fi.generation=transid
				fi.num_bytes=end-other_start
		3.标记leaf dirty，并跳到out
3.如果offset&lt;start,extent_end=end
	1.extent_mergeable查看后一个slot是否可以合并，如果可以合并
		1.path变成改成offset~start
			fi.num_bytes=start-offset
			fi.generation=transid
		2.将start之后的赋给slot++
			1.更新slot+1的key
				new_key.offset = start
			2.更新slot+1的数据
				fi.generation=transid
				fi.num_bytes=ohter_end-start
				fi.offset=start-orig_offset
		3.标记leaf dirty，并跳到out
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20470</x>
      <y>15380</y>
      <w>180</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>20340</x>
      <y>15920</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>extent_mergeable</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20390</x>
      <y>15880</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20390</x>
      <y>15950</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20240</x>
      <y>15990</y>
      <w>380</w>
      <h>190</h>
    </coordinates>
    <panel_attributes>1.如果slot不在leaf的范围内，返回0
2.slot的objectid要是ino，type要是BTRFS_EXTENT_DATA_KEY
3.以btrfs_file_extent_item方式解析slot数据
	1.filter，不通过返回0
		1.要是extent_reg
		2.disk_bytenr和对应的逻辑offset相同
		3.不能有compression encryption other_encoding
	2.如果指定了start和end，要和其逻辑偏移相同，否则返回0
	3.如果满足，返回1
		*start = key.offset;
	*end = extent_end
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>20730</x>
      <y>15420</y>
      <w>460</w>
      <h>780</h>
    </coordinates>
    <panel_attributes>4.将段在offset~extend_end范围内extend_data截取处理(注：前面的btrfs_search_slot
	保证了offset不可能比start大，但是end呢？如果比extent_end大会导致item出现负值
	这里只能依靠caller来保证段的安全性)
	1.如果start和offset重合，将extent_data从end处split，否则先从start处split
	2.btrfs_duplicate_item复制一个item
		new_key.offset = split
	3.重新设置item
		1.slot-1
			1.fi.gen=transid
				fi.num_bytes=split-key.offset
		2.slot
			1.fi.gen=transid
				fi.offset=split-orig_offset
				fi.num_bytes=extent_end-split(随机调用可能出错)
	4.标记leaf dirty
	5.btrfs_inc_extent_ref增加对整个disk_bytenr的引用
	6.选取段所在的extent_data,再次循环进行split
		1.如果从start开始分割
			key.offset = start
		2.如果从end开始分割
			path-&gt;slots[0]--;
			extent_end = end
	7.置上recow
5.将段所在的extent_data通过extent_mergeable向后合并，如果合并成功
	1.如果recow，跳到1，重新查找extent
	2.否则统计要删的slot
		extent_end = other_end;//更新要保留的end
		del_slot = path-&gt;slots[0] + 1;
		del_nr++;
	3.btrfs_free_extent释放对disk_bytenr的引用
6.extent_mergeable尝试向前进行merge
	1.如果需要recow，跳到1重新查找
	2.统计要删的slot
		key.offset = other_start;//更新保留的offset
		del_slot = path-&gt;slots[0];//更新起始的slot
		del_nr++;
	3.btrfs_free_extent释放对disk_bytenr的引用
7.如果没有要删的slot，更新段对应的fi
	1.fi.type=BTRFS_FILE_EXTENT_REG
		fi.generation=transid
	2.标记leaf dirty
8.如果有要删除的slot
	1.fi.type=BTRFS_FILE_EXTENT_REG
		fi.generation=transid
		fi.numbytes-extent_end - key.offset
	2.标记leaf dirty
	3.btrfs_del_items删除对应的slot
9.out：释放path，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>20620</x>
      <y>15380</y>
      <w>230</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>21320</x>
      <y>15340</y>
      <w>200</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>insert_reserved_file_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>21230</x>
      <y>15410</y>
      <w>450</w>
      <h>300</h>
    </coordinates>
    <panel_attributes>1.__btrfs_drop_extents删除inode段对应的extent_data（做cow）
2.如果没有插入extent_data的item，通过btrfs_insert_empty_item
	添加一个item
	ins.objectid = btrfs_ino(inode);
	ins.offset = file_pos;
	ins.type = BTRFS_EXTENT_DATA_KEY;
	path-&gt;leave_spinning = 1;
3.填充插入的btrfs_file_extent_item，并标记leaf dirty
4.inode_add_bytes更新i_blocks i_bytes(drop中会删除之前的)
5.btrfs_alloc_reserved_file_extent
	ins.objectid = disk_bytenr;
	ins.offset = disk_num_bytes;
	ins.type = BTRFS_EXTENT_ITEM_KEY;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>21410</x>
      <y>15370</y>
      <w>30</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
</diagram>
