<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram program="umlet" version="14.2">
  <zoom_level>1</zoom_level>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>795</x>
      <y>0</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__user_walk
（返回0说明正常）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>615</x>
      <y>38</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>620</x>
      <y>3</y>
      <w>183</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1810.0;10.0;10.0;350.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>643</x>
      <y>38</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>649</x>
      <y>3</y>
      <w>154</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1520.0;10.0;10.0;350.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>836</x>
      <y>13</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>800</x>
      <y>3</y>
      <w>44</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1281</x>
      <y>14</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>putname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>802</x>
      <y>3</y>
      <w>485</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放name slab</panel_attributes>
    <additional_attributes>10.0;10.0;4830.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>616</x>
      <y>46</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>nd-&gt;last_type = LAST_ROOT
nd-&gt;flags = flags;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>625</x>
      <y>41</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>641</x>
      <y>47</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>walk_init_root
（返回1说明继续查找
返回0说明不用继续）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>647</x>
      <y>41</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果通过根目录寻址</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>657</x>
      <y>47</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nd-&gt;mnt = mntget(current-&gt;fs-&gt;pwdmnt);
nd-&gt;dentry = dget(current-&gt;fs-&gt;pwd);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>647</x>
      <y>41</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果通过当前目录寻址</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>619</x>
      <y>50</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果current-&gt;fs-&gt;altroot不为空
!(nd-&gt;flags &amp; LOOKUP_NOALT)
并且规定不在altroot上寻址</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>587</x>
      <y>62</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>nd-&gt;mnt = mntget(current-&gt;fs-&gt;altrootmnt);
nd-&gt;dentry = dget(current-&gt;fs-&gt;altroot);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>595</x>
      <y>57</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>617</x>
      <y>64</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__emul_lookup_dentry
（返回0说明存在问题）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>620</x>
      <y>57</y>
      <w>8</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>638</x>
      <y>60</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nd-&gt;mnt = mntget(current-&gt;fs-&gt;rootmnt);
nd-&gt;dentry = dget(current-&gt;fs-&gt;root);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>643</x>
      <y>50</y>
      <w>26</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
表示在系统的根目录下开始寻址</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>601</x>
      <y>74</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk
（返回非0说明存在问题）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>609</x>
      <y>67</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>623</x>
      <y>67</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果path_walk正常</panel_attributes>
    <additional_attributes>30.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>674</x>
      <y>16</y>
      <w>171</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果‘/’之后name结束</panel_attributes>
    <additional_attributes>1690.0;10.0;10.0;380.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>670</x>
      <y>54</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>681</x>
      <y>55</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode = nd-&gt;dentry-&gt;d_inode
if (current-&gt;link_count)
		lookup_flags = LOOKUP_FOLLOW;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>689</x>
      <y>16</y>
      <w>156</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1540.0;10.0;10.0;390.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>713</x>
      <y>16</y>
      <w>132</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查看目录的权限</panel_attributes>
    <additional_attributes>1300.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>707</x>
      <y>56</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>permission(inode, MAY_EXEC)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>730</x>
      <y>55</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>this.name = name;
this.len = name - (const char *) this.name;
this.hash = end_name_hash(hash)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>739</x>
      <y>16</y>
      <w>106</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1040.0;10.0;10.0;390.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>758</x>
      <y>56</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>last_component
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>762</x>
      <y>16</y>
      <w>83</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
最后一个节点最后一个字符是‘\0’
就是文件</panel_attributes>
    <additional_attributes>810.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>774</x>
      <y>56</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>last_with_slashes
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>778</x>
      <y>16</y>
      <w>68</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
最后一个节点最后一个如果是‘\’
就是目录</panel_attributes>
    <additional_attributes>660.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>797</x>
      <y>16</y>
      <w>48</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
第一个字符如果是'.'</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>788</x>
      <y>55</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果长度只有1个
找到当前目录
就跳出本次循环</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>786</x>
      <y>62</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>continue
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>796</x>
      <y>55</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
长度为2</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>797</x>
      <y>61</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有两个'.'</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>780</x>
      <y>73</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>follow_dotdot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>794</x>
      <y>73</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode = nd-&gt;dentry-&gt;d_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>805</x>
      <y>61</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果只有一个‘.’
另一个是其他字符
解析为普通文件名</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>785</x>
      <y>67</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>797</x>
      <y>67</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>812</x>
      <y>68</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>break
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>796</x>
      <y>55</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
长度如果更长
则不是特殊
解析为普通文件名</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>822</x>
      <y>64</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>break
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>725</x>
      <y>80</y>
      <w>60</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
nd-&gt;dentry == current-&gt;fs-&gt;root
&amp;&amp;nd-&gt;mnt == current-&gt;fs-&gt;rootmnt
如果是根目录，上层就是本目录
</panel_attributes>
    <additional_attributes>580.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>721</x>
      <y>87</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>break
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>761</x>
      <y>80</y>
      <w>28</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
	//mnt_root是设备的mount目录
nd-&gt;dentry != nd-&gt;mnt-&gt;mnt_root
如果不是本设备的根目录，就向上找parent</panel_attributes>
    <additional_attributes>220.0;10.0;50.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>757</x>
      <y>92</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //nd-&gt;dentry-&gt;d_parent是目录的parent
dentry = dget(nd-&gt;dentry-&gt;d_parent);
dput(nd-&gt;dentry);
nd-&gt;dentry = dentry;
break;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>782</x>
      <y>76</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
死循环</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>797</x>
      <y>95</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>parent=nd-&gt;mnt-&gt;mnt_parent
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>782</x>
      <y>80</y>
      <w>27</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
本设备的父设备
即设备安装在父设备上</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>782</x>
      <y>80</y>
      <w>50</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
parent == nd-&gt;mnt
如果是系统根目录
不向上查找，直接退出</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>823</x>
      <y>94</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>break;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>845</x>
      <y>91</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>mntget(parent);
dentry=dget(nd-&gt;mnt-&gt;mnt_mountpoint);
dput(nd-&gt;dentry);
nd-&gt;dentry = dentry;
mntput(nd-&gt;mnt);
nd-&gt;mnt = parent;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>782</x>
      <y>80</y>
      <w>69</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
运行到这里是
当前目录是当前设备的根目录
但是存在父设备，所以在父设备中查找
父设备中的安装目录和当前设备的根目录
是同一个节点，所以这里不退出，直接通过死循环
继续前面的过程查找</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>842</x>
      <y>16</y>
      <w>26</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 nd-&gt;dentry-&gt;d_op-&gt;d_hash
 如果文件系统存在计算哈希值的函数
 就让文件系统自己计算哈希值</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>830</x>
      <y>56</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_hash(nd-&gt;dentry, &amp;this)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>873</x>
      <y>51</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cached_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>843</x>
      <y>16</y>
      <w>38</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在内存中搜索当前节点对应的dentry结构
nd-&gt;dentry, &amp;this, LOOKUP_CONTINUE</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;350.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>862</x>
      <y>61</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>867</x>
      <y>54</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
parent，this</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>839</x>
      <y>72</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>844</x>
      <y>64</y>
      <w>24</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
parent hash
dentry_hashtable
将父节点加入哈希值的计算
可以有效减少hash表的链表长度
比如不同目录中有相同的目录名
但是这也只是上升了一层，因为
全路径的计算代价太大</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>874</x>
      <y>70</y>
      <w>52</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.因为此时的hash是经过原来的hash经过变换得到的，所以需要比较原来的hash
	dentry-&gt;d_name.hash == hash
2.查看父节点是否相同dentry-&gt;d_parent = parent
3.查看名字是否相同（因为同一目录下允许有name相同的文件）
	如果文件系统提供了d_compare就通过文件系统本身的去比较
	d_compare(parent, &amp;dentry-&gt;d_name, name)
	如果没提供，就比较name的长度和名字
	dentry-&gt;d_name.len = len
	memcmp(dentry-&gt;d_name.name, str, len)
4.如果在hash表中找到了dentry就返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>861</x>
      <y>64</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果向下找到了dentry_hashtable的头
就返回NULL</panel_attributes>
    <additional_attributes>60.0;10.0;180.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>876</x>
      <y>92</y>
      <w>41</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>memcmp：
	"repe\n\t"	////重复ecx次，每次ecx减1，直到ecx=0或者zf=0
	"cmpsb\n\t" //将esi和edi的字符比较，直到两者不相同	
					//相同时zf=1，不同时zf=0			
	"je 1f\n\t" //如果相同，res为0直接返回（cf=1）
	"sbbl %0,%0\n\t" //-cf
	"orb $1,%b0\n" //res=0xFFFFFFFF
	"1:"
	//esi=cs edi=ct __res是返回值 ecx=count
	:"=a" (__res), "=&amp;S" (d0), "=&amp;D" (d1), "=&amp;c" (d2)
	:"0" (0), "1" (cs), "2" (ct), "3" (count));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>893</x>
      <y>87</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>878</x>
      <y>54</y>
      <w>70</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果文件系统存在重新认证这个dentry的函数
就通过d_revalidate重新认证（例如NFS,会判断访问时间）
然后通过d_invalidate断开连接</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>942</x>
      <y>68</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput(dentry);
			dentry = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>843</x>
      <y>16</y>
      <w>144</w>
      <h>51</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果内存中没找到
就要到磁盘中查找</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;300.0;1420.0;490.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>978</x>
      <y>65</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>real_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>931</x>
      <y>68</y>
      <w>53</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;370.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>918</x>
      <y>105</y>
      <w>23</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>down(&amp;dir-&gt;i_sem)
	//因为前面可能因为down而sleep
	//所以这里醒来之后需要查看一下
	//dentry是否在内存中
d_lookup(parent, name)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>956</x>
      <y>68</y>
      <w>28</w>
      <h>43</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果还是没找到</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;410.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>948</x>
      <y>108</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>942</x>
      <y>112</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>929</x>
      <y>115</y>
      <w>18</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请dentry结构</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>920</x>
      <y>123</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>945</x>
      <y>115</y>
      <w>3</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>934</x>
      <y>126</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>930</x>
      <y>121</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
name-&gt;len &gt; DNAME_INLINE_LEN-1
如果name的长度过长，就从通用cache中
申请内存
16字节对齐</panel_attributes>
    <additional_attributes>160.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>949</x>
      <y>126</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>str = dentry-&gt;d_iname
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>942</x>
      <y>121</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否则就用dentry中的name结构</panel_attributes>
    <additional_attributes>40.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>968</x>
      <y>124</y>
      <w>38</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>memcpy(str, name-&gt;name, name-&gt;len);
str[name-&gt;len] = 0;

atomic_set(&amp;dentry-&gt;d_count, 1);
dentry-&gt;d_flags = 0;
dentry-&gt;d_inode = NULL;
dentry-&gt;d_parent = NULL;
dentry-&gt;d_sb = NULL;
dentry-&gt;d_name.name = str;
dentry-&gt;d_name.len = name-&gt;len;
dentry-&gt;d_name.hash = name-&gt;hash;
dentry-&gt;d_op = NULL;
dentry-&gt;d_fsdata = NULL;
	//如果dentry有安装在某个节点，这里是安装信息
INIT_LIST_HEAD(&amp;dentry-&gt;d_vfsmnt);
	//这个链接在hash表中
INIT_LIST_HEAD(&amp;dentry-&gt;d_hash);
	//如果没被用到，链接在unused_dentry中
INIT_LIST_HEAD(&amp;dentry-&gt;d_lru);
	//其子目录链接在下面，链表头
INIT_LIST_HEAD(&amp;dentry-&gt;d_subdirs);
	//如果一个inode有多个dentry，这个链接在inode的链表中
INIT_LIST_HEAD(&amp;dentry-&gt;d_alias);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>946</x>
      <y>115</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化dentry</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1007</x>
      <y>127</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>dentry-&gt;d_parent = dget(parent);
 //继承父节点的super_block
dentry-&gt;d_sb = parent-&gt;d_sb;
list_add(&amp;dentry-&gt;d_child, &amp;parent-&gt;d_subdirs);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>948</x>
      <y>115</y>
      <w>76</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注意找到节点的dentry会放到父目录下的d_subdirs
有可能目录的显示就是通过遍历这个链表
</panel_attributes>
    <additional_attributes>10.0;10.0;740.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1012</x>
      <y>121</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果该节点有父目录</panel_attributes>
    <additional_attributes>100.0;10.0;40.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1041</x>
      <y>128</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>INIT_LIST_HEAD(&amp;dentry-&gt;d_child)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1020</x>
      <y>121</y>
      <w>28</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没有</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1067</x>
      <y>128</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry_stat.nr_dentry++;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>947</x>
      <y>115</y>
      <w>136</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;750.0;40.0;1340.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1028</x>
      <y>155</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>956</x>
      <y>108</y>
      <w>145</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果分配好了dentry内存结构
就通过文件系统的函数到磁盘中查找</panel_attributes>
    <additional_attributes>10.0;10.0;1430.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1090</x>
      <y>117</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_op-&gt;lookup
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1032</x>
      <y>120</y>
      <w>76</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_dir_inode_operations
</panel_attributes>
    <additional_attributes>670.0;10.0;480.0;230.0;10.0;350.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>957</x>
      <y>108</y>
      <w>163</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1610.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1109</x>
      <y>112</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
result有error
没找到，释放dentry</panel_attributes>
    <additional_attributes>90.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1111</x>
      <y>117</y>
      <w>9</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>dput(dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1117</x>
      <y>112</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到了</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1121</x>
      <y>117</y>
      <w>11</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>result = dentry;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1133</x>
      <y>117</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>up(&amp;dir-&gt;i_sem);
		return result;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1117</x>
      <y>112</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
退出</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>981</x>
      <y>68</y>
      <w>45</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在之前的d_lookup中
找到了dentry，如果文件系统有要求
需要认证</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;290.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1020</x>
      <y>97</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput(dentry);
			dentry = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>881</x>
      <y>158</y>
      <w>154</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>1520.0;10.0;10.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>869</x>
      <y>188</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry-&gt;d_name.len &gt; EXT2_NAME_LEN
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>904</x>
      <y>188</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_find_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>908</x>
      <y>158</y>
      <w>127</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将父目录的内容读取到内存中
存在bh为管理单元的缓冲区中
并找到对应（name inode）项</panel_attributes>
    <additional_attributes>1250.0;10.0;10.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>930</x>
      <y>185</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>933</x>
      <y>158</y>
      <w>102</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据inode号找到要找目录的inode</panel_attributes>
    <additional_attributes>1000.0;10.0;10.0;270.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1093</x>
      <y>189</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1032</x>
      <y>158</y>
      <w>67</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;310.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1084</x>
      <y>197</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_instantiate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1103</x>
      <y>196</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_rehash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1097</x>
      <y>192</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1087</x>
      <y>192</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1075</x>
      <y>205</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>if (inode)
	//将dentry加入到inode的链表中
	list_add(&amp;entry-&gt;d_alias, &amp;inode-&gt;i_dentry);
 //指明dentry中的d_inode
entry-&gt;d_inode = inode;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1085</x>
      <y>200</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1108</x>
      <y>205</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>list = d_hash(entry-&gt;d_parent, entry-&gt;d_name.hash)
list_add(&amp;entry-&gt;d_hash, list);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1103</x>
      <y>199</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将新申请的dentry链接到hash中</panel_attributes>
    <additional_attributes>40.0;10.0;160.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>817</x>
      <y>210</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>*res_dir = NULL
sb = dir-&gt;i_sb
filter：namelen &gt; EXT2_NAME_LEN
memset (bh_use, 0, sizeof (bh_use))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>830</x>
      <y>191</y>
      <w>80</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
NAMEI_RA_SIZE：预读的size</panel_attributes>
    <additional_attributes>780.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>861</x>
      <y>191</y>
      <w>51</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过ext2_getblk填充
bh_use和bh_read
</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>843</x>
      <y>211</y>
      <w>41</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.block是读取目录inode的第block块
2.预读的大小不能大于目录的size
	(block &lt;&lt; EXT2_BLOCK_SIZE_BITS (sb)) &gt;= dir-&gt;i_size
		break；
	这里可知，目录的i_size是以bit为单位
3.通过ext2_getblk填充预读的buffer_head bh_use
4.如果这个buffer没从磁盘读进来（bh &amp;&amp; !buffer_uptodate(bh)），
	就将bh_read[toread++] = bh
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>886</x>
      <y>216</y>
      <w>61</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.采取流水线预读：处理0 block的时候，所有没到内存中的block
  都通过ll_rw_block读到内存中，在读到第4个block的时候，再将
  第8~12个block中没到内存中的读到内存中，以此类推。因为cpu处理buffer
  与从硬盘中读取是异步操作，这样就可以使在操作buffer的时候就可以同步的从
  硬盘中读取数据，如果这个过程合理，wait_on_buffer就可能不需要有任何的等待
2.错误处理：如果当前的size没有内容，就不处理，并将offset加上s_blocksize
	如果数据没有更新到内存中，那么直接退出，返回NULL
3.ext2的每个目录项都是和block对齐的，并且不能跨block。所以这里依次取出block
	中的目录项通过ext2_match比较name，和ext2_check_dir_entry进行检查，如果都通过
	了就将其他的bh释放，返回当前的bh。如果没找到，就遍历下一个目录项（de+de-&gt;rec_len），
	这里注意ext2的目录项是大小是不定的。
4.如果遍历完整个block没找到，就将当前的bh释放，并看block + NAMEI_RA_SIZE有没有超过
	dir的size，如果超过了，就不需要对其就行预读，否者需要通过ext2_getblk将bh读进来，
	并判断是否要预读，以便形成流水线的操作。
5.如果遍历完整个dir没找到，就返回NULL。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>905</x>
      <y>191</y>
      <w>22</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
block指的是读取的block，
但是在bh_use中的额位置是
block % NAMEI_RA_SIZE

offset是目录项在dir中的偏移</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;250.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>944</x>
      <y>192</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iget4</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>934</x>
      <y>188</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
超级块
inode号</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>930</x>
      <y>203</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>924</x>
      <y>195</y>
      <w>37</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在hash表inode_hashtable中查找
1.是否有inode号和超级块和当前查找的inode相同的inode，
2.如果有find_actor，则通过find_actor进行比较</panel_attributes>
    <additional_attributes>250.0;10.0;110.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>963</x>
      <y>206</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__iget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>949</x>
      <y>195</y>
      <w>20</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在内存中找到</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>951</x>
      <y>209</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果之前又被引用</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>947</x>
      <y>216</y>
      <w>19</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;inode-&gt;i_count)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>967</x>
      <y>215</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;inode-&gt;i_count)
 //如果dirty，这个链表会连在s_dirty
 //如果不是dirty，且count为0，则连在inode_unused
if !I_DIRTY
	将inode从原来的链表中删除，并且
	添加到inode_in_use中
inodes_stat.nr_unused--
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>968</x>
      <y>209</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没被引用</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1032</x>
      <y>209</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_new_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>949</x>
      <y>195</y>
      <w>91</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在内存中没找到</panel_attributes>
    <additional_attributes>10.0;10.0;890.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>953</x>
      <y>232</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>957</x>
      <y>212</y>
      <w>84</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>820.0;10.0;350.0;150.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>970</x>
      <y>234</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>975</x>
      <y>212</y>
      <w>66</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为前面有spinlock
所以此时内存中可能已经存在了inode</panel_attributes>
    <additional_attributes>640.0;10.0;10.0;220.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>984</x>
      <y>236</y>
      <w>20</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>__iget(old);//增加inode计数
 //因为内存中已经存在inode
 //所以将新申请的inode释放
 //如果inode的dirty_buffer中
 //存在成员，应该报错
destroy_inode(inode);
inode = old;
wait_on_inode(inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>994</x>
      <y>212</y>
      <w>47</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
内存中存在inode</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;240.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1038</x>
      <y>212</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
内存中还是不存在inode
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1023</x>
      <y>220</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化inode</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1010</x>
      <y>229</y>
      <w>40</w>
      <h>46</h>
    </coordinates>
    <panel_attributes>inodes_stat.nr_inodes++;
list_add(&amp;inode-&gt;i_list, &amp;inode_in_use);
list_add(&amp;inode-&gt;i_hash, head);
inode-&gt;i_sb = sb;
inode-&gt;i_dev = sb-&gt;s_dev;
inode-&gt;i_ino = ino;
inode-&gt;i_flags = 0;
atomic_set(&amp;inode-&gt;i_count, 1);
inode-&gt;i_state = I_LOCK;

 //注意clean_inode中的empty的操作
 //这些申明是static是保存在data段
 //没经初始化，是NULL,所以这里全部初始化为NULL
clean_inode
	memset(&amp;inode-&gt;u, 0, sizeof(inode-&gt;u));
	inode-&gt;i_sock = 0;
	inode-&gt;i_op = &amp;empty_iops;
	inode-&gt;i_fop = &amp;empty_fops;
	inode-&gt;i_nlink = 1;
	atomic_set(&amp;inode-&gt;i_writecount, 0);
	inode-&gt;i_size = 0;
	inode-&gt;i_generation = 0;
	memset(&amp;inode-&gt;i_dquot, 0, sizeof(inode-&gt;i_dquot));
	inode-&gt;i_pipe = NULL;
	inode-&gt;i_bdev = NULL;
	inode-&gt;i_data.a_ops = &amp;empty_aops;
	inode-&gt;i_data.host = inode;
	inode-&gt;i_mapping = &amp;inode-&gt;i_data;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1127</x>
      <y>226</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_state &amp;= ~I_LOCK;
wake_up(&amp;inode-&gt;i_wait);
return inode;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1042</x>
      <y>220</y>
      <w>96</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
当从硬盘中读到inode
并将进程唤醒</panel_attributes>
    <additional_attributes>10.0;10.0;940.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1085</x>
      <y>228</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;read_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1042</x>
      <y>220</y>
      <w>52</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
利用具体文件系统的方法
将inode读取到内存</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1102</x>
      <y>236</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_read_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1093</x>
      <y>231</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 ext2_sops</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1051</x>
      <y>246</y>
      <w>66</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.检查inode号
	如果小于EXT2_FIRST_INO，但是不是EXT2_ROOT_INO EXT2_ACL_IDX_INO EXT2_ACL_DATA_INO
	如果inode号大于最大的inode---s_inodes_count
2.检查block_group( (inode-&gt;i_ino - 1) / EXT2_INODES_PER_GROUP )
`大于最大的group号s_groups_count
3.inode号被分为3段，最低的一段为offset（有些许不同，offset为其字节数）
	中间一段为group的号desc。最高的一段为group_desc
	首先在group_desc中存储的信息存在在buffer中，通过s_group_desc[group_desc]取出（不能为空）
	其次拿到inode所在组的block偏移s_group_desc[group_desc][desc].bg_inode_table
	最后将其加上inode在组内偏移的block号offset&gt;&gt;EXT2_BLOCK_SIZE_BITS
	即为inode的block号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1077</x>
      <y>239</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1125</x>
      <y>247</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1107</x>
      <y>239</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1108</x>
      <y>239</y>
      <w>46</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将offset对blocksize取余
这里的blocksize应该是2的整数次幂
offset &amp;= (EXT2_BLOCK_SIZE(inode-&gt;i_sb) - 1)</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1145</x>
      <y>247</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>raw_inode=bh-&gt;b_data + offset
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1109</x>
      <y>239</y>
      <w>69</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据raw_inode中的数据
对inode进行填充
包括inode-&gt;u.ext2_i.i_data</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1172</x>
      <y>246</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>inode：
	VFS
	ext2_inode_info
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1109</x>
      <y>239</y>
      <w>97</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将文件系统的操作方法
和VFS链接</panel_attributes>
    <additional_attributes>10.0;10.0;950.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1194</x>
      <y>243</y>
      <w>34</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>ACL：不做处理
S_ISREG：
inode-&gt;i_op = &amp;ext2_file_inode_operations;
inode-&gt;i_fop = &amp;ext2_file_operations;
inode-&gt;i_mapping-&gt;a_ops = &amp;ext2_aops;

S_ISDIR：
inode-&gt;i_op = &amp;ext2_dir_inode_operations;
inode-&gt;i_fop = &amp;ext2_dir_operations;

S_ISLNK：
if (!inode-&gt;i_blocks)
	inode-&gt;i_op = &amp;ext2_fast_symlink_inode_operations;
else {
	inode-&gt;i_op = &amp;page_symlink_inode_operations;
	inode-&gt;i_mapping-&gt;a_ops = &amp;ext2_aops;
}

特殊文件：
init_special_inode(inode, inode-&gt;i_mode,
				   le32_to_cpu(raw_inode-&gt;i_block[0]));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1239</x>
      <y>250</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_attr_flags
inode-&gt;i_flags
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1108</x>
      <y>238</y>
      <w>140</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据inode-&gt;u.ext2_i.i_flag
设置</panel_attributes>
    <additional_attributes>10.0;20.0;1220.0;20.0;1380.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>980</x>
      <y>54</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>d_mountpoint(dentry) 
&amp;&amp; __follow_down(&amp;nd-&gt;mnt, &amp;dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>844</x>
      <y>16</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查当前节点是否是安装节点</panel_attributes>
    <additional_attributes>10.0;10.0;970.0;280.0;1480.0;380.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1061</x>
      <y>42</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>842</x>
      <y>16</y>
      <w>224</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2220.0;220.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1065</x>
      <y>45</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
最多嵌套调用8次</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1024</x>
      <y>56</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>UPDATE_ATIME
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1030</x>
      <y>51</y>
      <w>39</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1084</x>
      <y>54</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry-&gt;d_inode-&gt;i_op-&gt;follow_link
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1066</x>
      <y>51</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1071</x>
      <y>57</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_fast_symlink_inode_operations</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1066</x>
      <y>66</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1071</x>
      <y>73</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1073</x>
      <y>69</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
此时data中存储的路径名</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1077</x>
      <y>80</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__vfs_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1080</x>
      <y>75</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1067</x>
      <y>83</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果符号链接到根目录</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1056</x>
      <y>87</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放当前节点</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1050</x>
      <y>90</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1035</x>
      <y>97</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput(nd-&gt;dentry)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1057</x>
      <y>97</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mntput(nd-&gt;mnt)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1039</x>
      <y>93</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1054</x>
      <y>93</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1074</x>
      <y>97</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1079</x>
      <y>83</y>
      <w>20</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查找符号链接对应的inode</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1120</x>
      <y>92</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>name = __getname();
strcpy(name, nd-&gt;last.name);
nd-&gt;last.name = name;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1082</x>
      <y>83</y>
      <w>49</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
看不懂，last.name为什么直接指向
原来的name，而需要新建一个
需要之后看这个的应用场景</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1083</x>
      <y>83</y>
      <w>29</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;link_count
|| res //有错
|| nd-&gt;last_type!=LAST_NORM
这里因为有link_count,所以推出</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1103</x>
      <y>98</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return res
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1062</x>
      <y>37</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
follow_link
符号链接</panel_attributes>
    <additional_attributes>20.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1065</x>
      <y>40</y>
      <w>5</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1067</x>
      <y>40</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1081</x>
      <y>42</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>dput(dentry)
inode = nd-&gt;dentry-&gt;d_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1063</x>
      <y>37</y>
      <w>57</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
普通的inode</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1108</x>
      <y>42</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>dput(nd-&gt;dentry);
nd-&gt;dentry = dentry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1196</x>
      <y>23</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>last_component
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1150</x>
      <y>23</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>last_with_slashes
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1131</x>
      <y>42</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>continue
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1063</x>
      <y>37</y>
      <w>75</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
继续循环查找</panel_attributes>
    <additional_attributes>10.0;10.0;730.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1138</x>
      <y>31</y>
      <w>40</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1155</x>
      <y>26</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是链接目录
要到所在的链接对象</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1190</x>
      <y>26</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
LOOKUP_PARENT
要找的是父节点</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1183</x>
      <y>32</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_parent
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1150</x>
      <y>40</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>nd-&gt;last = this
nd-&gt;last_type = LAST_NORM //普通名称
nd-&gt;last_type = LAST_DOT //‘.’
nd-&gt;last_type = LAST_DOTDOT //'..'
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1162</x>
      <y>35</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1186</x>
      <y>40</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果是'..'，通过follow_dotdot，
	然后返回节点
2.如果是'.',直接返回
3,，如果是其他名称，继续查找inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1196</x>
      <y>26</y>
      <w>17</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
解析最后一个名称</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1216</x>
      <y>41</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>nd-&gt;dentry-&gt;d_op-&gt;d_hash
cached_lookup
real_lookup

d_mountpoint(dentry) 
&amp;&amp; __follow_down(&amp;nd-&gt;mnt, &amp;dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1203</x>
      <y>26</y>
      <w>25</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
和查找中间节点的方法类似
但是注意real_lookup和cached_lookup
的flag变为了0
但是d_revalidate在ext2中没有</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1244</x>
      <y>49</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_follow_link
（refrence）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1204</x>
      <y>26</y>
      <w>67</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1253</x>
      <y>40</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
只有在LOOKUP_FOLLOW
的时候采取找符号链接</panel_attributes>
    <additional_attributes>160.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1280</x>
      <y>50</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>dput(nd-&gt;dentry);
			nd-&gt;dentry = dentry;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1258</x>
      <y>49</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>dput(dentry)
inode = nd-&gt;dentry-&gt;d_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1248</x>
      <y>45</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1255</x>
      <y>45</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1268</x>
      <y>40</y>
      <w>22</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1299</x>
      <y>40</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>no_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1297</x>
      <y>43</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
只有在LOOKUP_POSITIVE|LOOKUP_DIRECTORY
的时候在报错</panel_attributes>
    <additional_attributes>90.0;10.0;250.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1314</x>
      <y>52</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_release(nd)
return err
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1204</x>
      <y>26</y>
      <w>105</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1030.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1204</x>
      <y>26</y>
      <w>146</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1440.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1315</x>
      <y>36</y>
      <w>41</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
存在inode
当LOOKUP_DIRECTORY的时候，但是没有	inode-&gt;i_op-&gt;lookup
会报错</panel_attributes>
    <additional_attributes>330.0;10.0;70.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>843</x>
      <y>16</y>
      <w>314</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3120.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>842</x>
      <y>16</y>
      <w>362</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3600.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>685</x>
      <y>66</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op-&gt;permission
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>691</x>
      <y>59</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果文件系统规定了permission</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>714</x>
      <y>68</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_permission
1.首先看超级块的权限，只读/mute等
2.其次看进程的权限
	2.1如果可执行文件的setuid位置上，可以改变进程的uid gid（参考prepare_binprm和compute_creds）
	2.2.CAP_DAC_OVERRIDE/CAP_DAC_READ_SEARCH可以将uid的权限覆盖
3.看uid的权限（即DAC）,和文件主是同一个用户？同组用户？还是其他用户

inode 的mode位：
0~8：其他用户、同组用户、文件主权限
10 11：setuid setgrd
12~15：文件类型
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>719</x>
      <y>59</y>
      <w>19</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否则就用vfs的permission</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>575</x>
      <y>71</y>
      <w>146</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(mask &amp; S_IWOTH) &amp;&amp; IS_RDONLY(inode) &amp;&amp;
(S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))
需要写权限||磁盘是只读安装 ||（是常规文件 || 目录 ||链接）</panel_attributes>
    <additional_attributes>1440.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>570</x>
      <y>90</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>EROFS
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>598</x>
      <y>71</y>
      <w>123</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(mask &amp; S_IWOTH) &amp;&amp; IS_IMMUTABLE(inode)
写 || 不可更改
IS_IMMUTABLE和用户无关</panel_attributes>
    <additional_attributes>1210.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>593</x>
      <y>90</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>EACCES
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>579</x>
      <y>83</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mode = inode-&gt;i_mode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>587</x>
      <y>71</y>
      <w>133</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1310.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>612</x>
      <y>91</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mode &gt;&gt;= 6
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>618</x>
      <y>71</y>
      <w>104</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;fsuid == inode-&gt;i_uid
fsuid大部分和euid相同
但是在NFS中可能会不一样</panel_attributes>
    <additional_attributes>1020.0;10.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>633</x>
      <y>71</y>
      <w>89</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>870.0;10.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>628</x>
      <y>91</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>in_group_p</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>619</x>
      <y>94</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode-&gt;i_gid == current-&gt;fsgid</panel_attributes>
    <additional_attributes>150.0;10.0;50.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>612</x>
      <y>102</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>supplemental_group_member</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>614</x>
      <y>109</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>遍历current-&gt;groups
看是否有组号一样的
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>621</x>
      <y>105</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
一个用户可能在不同的组中</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>641</x>
      <y>94</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mode &gt;&gt;= 3
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>636</x>
      <y>90</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>663</x>
      <y>71</y>
      <w>59</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
此时判断权限
(mode &amp; mask &amp; S_IRWXO) == mask) || capable(CAP_DAC_OVERRIDE)
others已经在最后三位上所以不用移
CAP_DAC_OVERRIDE：授权进程
</panel_attributes>
    <additional_attributes>570.0;10.0;10.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>657</x>
      <y>95</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>689</x>
      <y>94</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>686</x>
      <y>71</y>
      <w>44</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(mask == S_IROTH) ||
 (S_ISDIR(inode-&gt;i_mode)  &amp;&amp; !(mask &amp; ~(S_IROTH | S_IXOTH))))
	if (capable(CAP_DAC_READ_SEARCH)
读||
（目录 || 没要写权限）
</panel_attributes>
    <additional_attributes>340.0;10.0;90.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>649</x>
      <y>162</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_setuid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>638</x>
      <y>165</y>
      <w>17</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CAP_SETUID</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>638</x>
      <y>172</y>
      <w>12</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>643</x>
      <y>180</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;suid = uid
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>630</x>
      <y>172</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uid != old_ruid</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>625</x>
      <y>179</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>592</x>
      <y>189</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_uid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>597</x>
      <y>182</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>562</x>
      <y>192</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从uidhash_table对应的哈希值
处查找，直到为空，或者找到user的uid
和想找的相同，并将user.count++</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>556</x>
      <y>198</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uid_hash_find</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>586</x>
      <y>192</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果哈希表中没找到</panel_attributes>
    <additional_attributes>120.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>559</x>
      <y>205</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>564</x>
      <y>199</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uid_cachep
申请user</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>575</x>
      <y>206</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>new-&gt;uid = uid;
atomic_set(&amp;new-&gt;__count, 1);
atomic_set(&amp;new-&gt;processes, 0);
atomic_set(&amp;new-&gt;files, 0)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>586</x>
      <y>199</y>
      <w>5</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>603</x>
      <y>207</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uid_hash_find</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>586</x>
      <y>199</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为在操作哈希表的时候有spinlock
所以这里再查查哈希表中是否有对应的
user</panel_attributes>
    <additional_attributes>30.0;10.0;210.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>588</x>
      <y>199</y>
      <w>35</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>617</x>
      <y>205</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有将申请到的user释放</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>610</x>
      <y>211</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>630</x>
      <y>211</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //注意pprev指向的是（指向自己的）箭头
uid_hash_insert(new, hashent);
up = new;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>620</x>
      <y>205</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>609</x>
      <y>190</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>old_user = current-&gt;user;
atomic_dec(&amp;old_user-&gt;processes);
atomic_inc(&amp;new_user-&gt;processes);
current-&gt;uid = new_ruid;
current-&gt;user = new_user;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>624</x>
      <y>182</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>646</x>
      <y>192</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_uid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>631</x>
      <y>182</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
old_user</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>630</x>
      <y>195</y>
      <w>40</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
up &amp;&amp; atomic_dec_and_lock(&amp;up-&gt;__count, &amp;uidhash_lock)</panel_attributes>
    <additional_attributes>230.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>642</x>
      <y>200</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //注意pprev的操作
uid_hash_remove
kmem_cache_free
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>661</x>
      <y>179</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>EPERM
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>652</x>
      <y>165</y>
      <w>18</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没有权限
设置的uid又不是
current-&gt;uid
current-&gt;suid</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>673</x>
      <y>179</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;fsuid = current-&gt;euid = uid
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>652</x>
      <y>165</y>
      <w>32</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>702</x>
      <y>179</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes> //越界访问不产生dump文件
current-&gt;dumpable = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>652</x>
      <y>165</y>
      <w>58</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
old_euid != uid</panel_attributes>
    <additional_attributes>10.0;10.0;560.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>664</x>
      <y>109</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>capable</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>664</x>
      <y>118</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cap_raised</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>669</x>
      <y>112</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;cap_effective
相应的位有没有置上</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>675</x>
      <y>118</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果置上</panel_attributes>
    <additional_attributes>10.0;20.0;100.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>685</x>
      <y>118</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>current-&gt;flags |= PF_SUPERPRIV;
return 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>652</x>
      <y>165</y>
      <w>82</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!issecure(SECURE_NO_SETUID_FIXUP)
SECUREBITS_DEFAULT中这一位没置上</panel_attributes>
    <additional_attributes>10.0;10.0;800.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>727</x>
      <y>178</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cap_emulate_setxuid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>711</x>
      <y>181</y>
      <w>26</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 {r,e,s}uid == 0 _to_ all of
 *  {r,e,s}uid != 0
 !current-&gt;keep_capabilities
 //r=uid e=euid s=suid
 </panel_attributes>
    <additional_attributes>240.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>690</x>
      <y>189</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //keep_capabilities可以通过prctl
 	//变成1，这样在setuid的时候，就不会
 	//将permitted清空，当返回的时候
 	//相应的cap_effective也会恢复
cap_clear(current-&gt;cap_permitted);
cap_clear(current-&gt;cap_effective);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>731</x>
      <y>181</y>
      <w>23</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
from_ euid == 0 _to_ euid != 0</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>719</x>
      <y>194</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cap_clear(current-&gt;cap_effective)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>735</x>
      <y>181</y>
      <w>20</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
from_ euid != 0 _to_ euid == 0</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>744</x>
      <y>193</y>
      <w>31</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;cap_effective = current-&gt;cap_permitted
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1200</x>
      <y>282</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_special_inode
i_rdev表示索引节点
代表的设备号
存在i_block[0]</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1208</x>
      <y>278</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1190</x>
      <y>285</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISCHR</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1179</x>
      <y>290</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_fop = &amp;def_chr_fops;
inode-&gt;i_rdev = to_kdev_t(rdev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1208</x>
      <y>285</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISBLK</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1202</x>
      <y>290</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_fop = &amp;def_blk_fops;
inode-&gt;i_rdev = to_kdev_t(rdev);
inode-&gt;i_bdev = bdget(rdev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1208</x>
      <y>285</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISFIFO</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1226</x>
      <y>291</y>
      <w>20</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_fop = &amp;def_fifo_fops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1208</x>
      <y>285</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISSOCK</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1247</x>
      <y>291</y>
      <w>20</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_fop = &amp;bad_sock_fops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1118</x>
      <y>259</y>
      <w>61</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_mode = le16_to_cpu(raw_inode-&gt;i_mode);
inode-&gt;i_uid = (uid_t)le16_to_cpu(raw_inode-&gt;i_uid_low);
inode-&gt;i_gid = (gid_t)le16_to_cpu(raw_inode-&gt;i_gid_low);
if(!(test_opt (inode-&gt;i_sb, NO_UID32))) {
	inode-&gt;i_uid |= le16_to_cpu(raw_inode-&gt;i_uid_high) &lt;&lt; 16;
	inode-&gt;i_gid |= le16_to_cpu(raw_inode-&gt;i_gid_high) &lt;&lt; 16;
}
inode-&gt;i_nlink = le16_to_cpu(raw_inode-&gt;i_links_count);
inode-&gt;i_size = le32_to_cpu(raw_inode-&gt;i_size);
inode-&gt;i_atime = le32_to_cpu(raw_inode-&gt;i_atime);
inode-&gt;i_ctime = le32_to_cpu(raw_inode-&gt;i_ctime);
inode-&gt;i_mtime = le32_to_cpu(raw_inode-&gt;i_mtime);
inode-&gt;u.ext2_i.i_dtime = le32_to_cpu(raw_inode-&gt;i_dtime);
inode-&gt;i_blksize = PAGE_SIZE;	/* This is the optimal IO size (for stat), not the fs block size */
inode-&gt;i_blocks = le32_to_cpu(raw_inode-&gt;i_blocks);
inode-&gt;i_version = ++event;
inode-&gt;u.ext2_i.i_flags = le32_to_cpu(raw_inode-&gt;i_flags);
inode-&gt;u.ext2_i.i_faddr = le32_to_cpu(raw_inode-&gt;i_faddr);
inode-&gt;u.ext2_i.i_frag_no = raw_inode-&gt;i_frag;
inode-&gt;u.ext2_i.i_frag_size = raw_inode-&gt;i_fsize;
inode-&gt;u.ext2_i.i_file_acl = le32_to_cpu(raw_inode-&gt;i_file_acl);
if (S_ISDIR(inode-&gt;i_mode))
	inode-&gt;u.ext2_i.i_dir_acl = le32_to_cpu(raw_inode-&gt;i_dir_acl);
else {
	inode-&gt;u.ext2_i.i_high_size = le32_to_cpu(raw_inode-&gt;i_size_high);
	inode-&gt;i_size |= ((__u64)le32_to_cpu(raw_inode-&gt;i_size_high)) &lt;&lt; 32;
}
inode-&gt;i_generation = le32_to_cpu(raw_inode-&gt;i_generation);
inode-&gt;u.ext2_i.i_block_group = block_group;
inode-&gt;u.ext2_i.i_data[block] = raw_inode-&gt;i_block[block]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1157</x>
      <y>252</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1098</x>
      <y>120</y>
      <w>52</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在proc_read_super中完成了连接
proc_root.proc_root_inode_operations</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1140</x>
      <y>144</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_root_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1094</x>
      <y>158</y>
      <w>27</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_nlink =proc_root.nlink +nr_threads
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1102</x>
      <y>147</y>
      <w>51</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果父节点dir是proc的根节点
更新/proc的nlink</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1137</x>
      <y>158</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1143</x>
      <y>147</y>
      <w>10</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1100</x>
      <y>169</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de = dir-&gt;u.generic_ip
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1106</x>
      <y>161</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取inode对应的proc_dir_entry
proc_dir_entry被抽象成硬盘上的数据</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1121</x>
      <y>168</y>
      <w>41</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果链表遍历完或者子节点的ino为0，退出遍历
2.如果子节点的名称长度和当前寻找的dentry的名字长度
	不相等，就查找下一个
3.如果长度相同，并且查找的dentry的名称和子节点的名称相同
	通过proc_get_inode获取节点的inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1136</x>
      <y>161</y>
      <w>26</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历父目录de的子节点链表subdir</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1164</x>
      <y>169</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>dentry-&gt;d_op = &amp;proc_dentry_operations;
 //将dentry加到inode的i_dentry的链表中
 //并将dentry加到hash中
d_add(dentry, inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1142</x>
      <y>161</y>
      <w>39</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1206</x>
      <y>156</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_pid_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1150</x>
      <y>147</y>
      <w>67</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在dir中没找到</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1204</x>
      <y>159</y>
      <w>18</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要查找self文件</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1195</x>
      <y>168</y>
      <w>31</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>inode = new_inode(dir-&gt;i_sb)
inode-&gt;i_mtime = inode-&gt;i_atime = 
inode-&gt;i_ctime = CURRENT_TIME;
inode-&gt;i_ino = fake_ino(0, PROC_PID_INO);
inode-&gt;u.proc_i.file = NULL;
inode-&gt;u.proc_i.task = NULL;
inode-&gt;i_mode = S_IFLNK|S_IRWXUGO;
inode-&gt;i_uid = inode-&gt;i_gid = 0;
inode-&gt;i_size = 64;
inode-&gt;i_op = &amp;proc_self_inode_operations;
d_add(dentry, inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1231</x>
      <y>169</y>
      <w>31</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.将name转化成pid号
2.通过find_task_by_pid在hash中找到task
3.通过get_task_struct增加task的计数
3.通过proc_pid_make_inode创建inode，并对其
	属性赋值（该task要有父进程）
4.通过free_task_struct释放task
5.赋值inode相应的属性
	inode-&gt;i_mode = S_IFDIR|S_IRUGO|S_IXUGO;
	inode-&gt;i_op = &amp;proc_base_inode_operations;
	inode-&gt;i_fop = &amp;proc_base_operations;
	inode-&gt;i_nlink = 3;
	inode-&gt;i_flags|=S_IMMUTABLE;

	dentry-&gt;d_op = &amp;pid_base_dentry_operations;
	d_add(dentry, inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1212</x>
      <y>159</y>
      <w>29</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
name可能是数字，如果不是，返回-ENOENT</panel_attributes>
    <additional_attributes>40.0;10.0;240.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1235</x>
      <y>198</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_pid_make_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1245</x>
      <y>193</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要查找self文件</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1230</x>
      <y>205</y>
      <w>31</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.通过new_inode申请inode
2.属性赋值（）
	inode-&gt;i_mtime = inode-&gt;i_atime = 
	inode-&gt;i_ctime = CURRENT_TIME;
	inode-&gt;i_ino = fake_ino(task-&gt;pid, ino);
	inode-&gt;u.proc_i.file = NULL;
	//创建的节点增加了task的计数
	inode-&gt;u.proc_i.task = task;
	get_task_struct(task);

	inode-&gt;i_uid = 0;
	inode-&gt;i_gid = 0;
	//dumpable表示进程访问出错会残生dump文件
	if (ino == PROC_PID_INO || task-&gt;dumpable) {
		inode-&gt;i_uid = task-&gt;euid;
		inode-&gt;i_gid = task-&gt;egid;
	}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1243</x>
      <y>201</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1098</x>
      <y>57</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_self_inode_operations
访问/proc/self时
在vfs_follow_link中去path_walk
找/proc/pid，然后再通过proc_pid_lookup配置相关的pid的
inode</panel_attributes>
    <additional_attributes>10.0;10.0;390.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1126</x>
      <y>68</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_self_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1126</x>
      <y>71</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
换算成字符类型</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1119</x>
      <y>76</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tmp=current-&gt;pid
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1137</x>
      <y>76</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1134</x>
      <y>71</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1098</x>
      <y>119</y>
      <w>286</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在proc_pid_lookup中完成了连接
proc_base_inode_operations</panel_attributes>
    <additional_attributes>10.0;20.0;2840.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1373</x>
      <y>122</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_base_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1324</x>
      <y>134</y>
      <w>35</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.遍历base_stuff，找到相同name长度和name的entry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1338</x>
      <y>125</y>
      <w>43</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1364</x>
      <y>134</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_pid_make_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1373</x>
      <y>125</y>
      <w>19</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建访问节点的inode</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1393</x>
      <y>133</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>PROC_PID_CWD：
inode-&gt;i_op = &amp;proc_pid_link_inode_operations;
inode-&gt;u.proc_i.op.proc_get_link = proc_cwd_link;
PROC_PID_MAPS:
inode-&gt;i_fop = &amp;proc_maps_operations;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1383</x>
      <y>125</y>
      <w>16</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据访问节点的类型</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1098</x>
      <y>57</y>
      <w>84</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;820.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1178</x>
      <y>51</y>
      <w>70</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果找到最后，发现inode时link
比如找到了cwd的inode</panel_attributes>
    <additional_attributes>680.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1178</x>
      <y>59</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1179</x>
      <y>66</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_pid_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1157</x>
      <y>76</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.释放寻找过来的dentry和mnt  path_release(nd)
2.进程的fsuid==i_uid，或者CAP_DAC_OVERRIDE至少
	满足一个
3.proc_check_root检查inode指向task.fs的root
	要是current.fs.root的子目录
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1172</x>
      <y>69</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1196</x>
      <y>78</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;u.proc_i.op.proc_get_link
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1223</x>
      <y>78</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nd-&gt;last_type = LAST_BIND
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1187</x>
      <y>69</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1186</x>
      <y>69</y>
      <w>48</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;460.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1199</x>
      <y>87</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_cwd_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1206</x>
      <y>81</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1198</x>
      <y>95</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>fs = inode-&gt;u.proc_i.task-&gt;fs
*mnt = mntget(fs-&gt;pwdmnt);
*dentry = dget(fs-&gt;pwd);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1206</x>
      <y>90</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将nd中的mnt和dentry更新</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1206</x>
      <y>299</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1211</x>
      <y>295</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1192</x>
      <y>305</y>
      <w>35</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.首先通过bdfind在bdev_hashtable中查找
2.如果没找到，通过alloc_bdev在slab中申请数据结构
	并将其属性赋值
	new_bdev-&gt;bd_dev = dev;
	new_bdev-&gt;bd_op = NULL;
3.因为alloc_bdev有可能休眠，所以通过bdfind在找一遍
4.如果没找到，将其加入hash表中
	list_add(&amp;new_bdev-&gt;bd_hash, head);
5.如果找到了，将新申请的inode释放
	destroy_bdev(new_bdev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1210</x>
      <y>302</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>276</x>
      <y>490</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_from_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>245</x>
      <y>499</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__constant_copy_to_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>269</x>
      <y>499</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__generic_copy_to_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>260</x>
      <y>493</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
__builtin_constant_p</panel_attributes>
    <additional_attributes>210.0;10.0;18.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>278</x>
      <y>493</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里因为__copy_user_zeroing是一个宏
所以这里返回的是发生异常的剩余的字节数</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>265</x>
      <y>502</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
access_ok
（检查是否所要复制的是否在用户空间）
</panel_attributes>
    <additional_attributes>150.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>263</x>
      <y>507</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__copy_user_zeroing</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>245</x>
      <y>513</y>
      <w>45</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>"0:	rep; movsl\n"					\//将esi中的内容复制到edi中，直到ecx=0
											//每次复制为4个字节
"	movl %3,%0\n"					\//令ecx=size&amp;3，
"1:	rep; movsb\n"					\//每次复制为1个字节
"2:\n"							\
".section .fixup,\"ax\"\n"				\//将链接到fixup 段
"3:	lea 0(%3,%0,4),%0\n"				\//ecx=size&amp;3+size(剩下的)*4
"4:	pushl %0\n"					\
"	pushl %%eax\n"					\
"	xorl %%eax,%%eax\n"				\
"	rep; stosb\n"					\将eax中的值填充到edi对应的地址
"	popl %%eax\n"					\
"	popl %0\n"					\
"	jmp 2b\n"					\
".previous\n"						\
".section __ex_table,\"a\"\n"				\//因为这一段虚拟内存可能并没有映射
					//所以可能会产生缺页中断，但是这里不能直接给进程分配页面，所以
					//在do_page_fault中，有着search_exception_table去寻找着此时应该
					//返回的ip地址，这一段是在链接的时候链接到__ex_table段，然后通过
					//遍历module_list中的module，再在每个段中通过二分法查找到对应发生
					//异常的位置，查找出要fix_up的ip
"	.align 4\n"					\
"	.long 0b,3b\n"					//在0地址发生异常，则跳到3出执行
"	.long 1b,4b\n"					\//在1处发生异常，则跳到4处
".previous"						\
: "=&amp;c"(size), "=&amp;D" (__d0), "=&amp;S" (__d1)		\
: "r"(size &amp; 3), "0"(size / 4), "1"(to), "2"(from)	\
: "memory");

ecx=size/4   edi=to   esi=from 

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>264</x>
      <y>510</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>401</x>
      <y>457</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>262</x>
      <y>478</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_mount_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>271</x>
      <y>460</y>
      <w>138</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
type</panel_attributes>
    <additional_attributes>1360.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>249</x>
      <y>492</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_free_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>256</x>
      <y>481</y>
      <w>14</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请一页内存</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>262</x>
      <y>481</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1.data不能超过3G
2.copy的最大内存最大为1页
3.如果copy的不到一页，就将其他内存清零
</panel_attributes>
    <additional_attributes>60.0;10.0;210.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>284</x>
      <y>478</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>289</x>
      <y>460</y>
      <w>120</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dir_name</panel_attributes>
    <additional_attributes>1180.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>303</x>
      <y>479</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_mount_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>307</x>
      <y>460</y>
      <w>102</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dev_name
data</panel_attributes>
    <additional_attributes>1000.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>503</x>
      <y>478</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>406</x>
      <y>460</y>
      <w>106</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
之前将数据copy到系统空间，
这里真正做mount</panel_attributes>
    <additional_attributes>10.0;10.0;1040.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>290</x>
      <y>494</y>
      <w>43</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果magic是MS_MGC_VAL，就将magic清掉
2.dir_name存在，不为空字符串，一个页面内存在结束字符0
	memchr
	if (!count)
	return NULL;
__asm__ __volatile__(
	"repne\n\t"
	"scasb\n\t" //edi++,ecx--,比较edi和eax（al）,不同继续，相同退出
	"je 1f\n\t" //如果相同，说明存在结束字符，跳到1将edi--
	"movl $1,%0\n" //如果不同，说明没结束字符，结合下一句将res=0
	"1:\tdecl %0"
	:"=D" (__res), "=&amp;c" (d0)
	:"a" (c), "0" (cs), "1" (count))
3.错误：dev_name存在但是一个页面内不存在结束字符
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>310</x>
      <y>481</y>
      <w>199</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dir_name</panel_attributes>
    <additional_attributes>1970.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>333</x>
      <y>496</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_remount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>341</x>
      <y>481</y>
      <w>170</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flags &amp; MS_REMOUNT
如果需要将设备重新安装
（因为安装方式改变，eg:只读-&gt;可写）</panel_attributes>
    <additional_attributes>1680.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>361</x>
      <y>497</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_loopback</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>367</x>
      <y>481</y>
      <w>145</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flags &amp; MS_BIND
回接
将普通文件通过losetup回接成设备
可以将这个设备加密或者mkfs格式化
然后再将这个设备进行安装
这里只是安装过程</panel_attributes>
    <additional_attributes>1430.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>433</x>
      <y>498</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>filter：
1.type_page不为空并且在一页内结束
2.进程capable(CAP_SYS_ADMIN)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>440</x>
      <y>481</y>
      <w>74</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>720.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>460</x>
      <y>505</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_fs_type</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>464</x>
      <y>481</y>
      <w>50</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>420</x>
      <y>510</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_filesystem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>426</x>
      <y>507</y>
      <w>41</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历file_systems链表
找到名字相同的file_system_type</panel_attributes>
    <additional_attributes>390.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>391</x>
      <y>516</y>
      <w>37</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>strcmp
"1:\tlodsb\n\t"//将esi指向的字节存到al中，并esi++
"scasb\n\t"//edi++，比较edi和al，
"jne 2f\n\t"
"testb %%al,%%al\n\t"//eax&amp;eax
"jne 1b\n\t"//不为0
"xorl %%eax,%%eax\n\t"//eax清零
"jmp 3f\n"
"2:\tsbbl %%eax,%%eax\n\t"//-cf
"orb $1,%%al\n"//eax|=1
"3:"
:"=a" (__res), "=&amp;S" (d0), "=&amp;D" (d1)
	     :"1" (cs),"2" (ct));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>412</x>
      <y>513</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>434</x>
      <y>519</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>try_inc_mod_count</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>440</x>
      <y>508</y>
      <w>28</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果找到了
fs-&gt;owner</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>431</x>
      <y>528</y>
      <w>8</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>res=1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>433</x>
      <y>522</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是通过
register_filesystem
注册</panel_attributes>
    <additional_attributes>90.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>441</x>
      <y>522</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是通过模块安装</panel_attributes>
    <additional_attributes>20.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>439</x>
      <y>526</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mod-&gt;flags &amp; MOD_DELETED</panel_attributes>
    <additional_attributes>130.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>441</x>
      <y>530</y>
      <w>8</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>res=0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>453</x>
      <y>530</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__MOD_INC_USE_COUNT
res=1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>450</x>
      <y>526</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>455</x>
      <y>518</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>461</x>
      <y>508</y>
      <w>12</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没找到</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>475</x>
      <y>518</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_filesystem
try_inc_mod_count
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>462</x>
      <y>508</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
然后再次查找，并且增加模块计数</panel_attributes>
    <additional_attributes>40.0;10.0;180.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>476</x>
      <y>504</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>493</x>
      <y>504</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>480</x>
      <y>481</y>
      <w>34</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
LOOKUP_FOLLOW
|LOOKUP_POSITIVE
|LOOKUP_DIRECTORY</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>499</x>
      <y>481</y>
      <w>15</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>510</x>
      <y>481</y>
      <w>5</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;210.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>499</x>
      <y>500</y>
      <w>30</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fstype-&gt;fs_flags &amp; FS_NOMOUNT
虚拟文件系统（pipe 共享内存）
不能通过mount安装</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>495</x>
      <y>514</y>
      <w>6</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>EINVAL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>500</x>
      <y>526</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_sb_bdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>412</x>
      <y>529</y>
      <w>98</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>960.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>506</x>
      <y>501</y>
      <w>27</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FS_REQUIRES_DEV
普通的文件系统
（不同设备有不同超级块）
通过DECLARE_FSTYPE_DEV申明
其他的通过DECLARE_FSTYPE申明</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;250.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>509</x>
      <y>500</y>
      <w>38</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FS_SINGLE
文件系统只有一个超级块
（即使是不同设备）</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>537</x>
      <y>519</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_sb_single</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>560</x>
      <y>513</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_sb_nodev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>509</x>
      <y>500</y>
      <w>58</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
虚拟文件系统
没有设备
用于实现相应的规程
生成超级块</panel_attributes>
    <additional_attributes>10.0;10.0;560.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>409</x>
      <y>548</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>filter:
dev_name存在
且不为空字符串
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>424</x>
      <y>548</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>437</x>
      <y>548</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>429</x>
      <y>529</y>
      <w>81</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到dev_name的inode</panel_attributes>
    <additional_attributes>790.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>442</x>
      <y>529</y>
      <w>68</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>660.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>429</x>
      <y>555</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode = nd.dentry-&gt;d_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>429</x>
      <y>551</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>437</x>
      <y>551</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>450</x>
      <y>548</y>
      <w>47</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.要是块设备S_ISBLK(inode-&gt;i_mode)
2.inode的super_block要有dev
	IS_NODEV(inode)
3.bdev = inode-&gt;i_bdev;
4.如果dev的主次设备号是通过节点的路径名来表示
	1.devfs_get_handle_from_inode
		1.inode和inode的超级块不为空
		2.超级块的s_magic位DEVFS_SUPER_MAGIC
		3.inode号大于文件系统的第一个inode号
		4. inode-&gt;i_sb-&gt;u.generic_sbp不为空
		5.inode号在fs的最大inode号之内
		6.返回inode-&gt;i_sb-&gt;u.generic_sbp-&gt;table[inode-&gt;i_ino - FIRST_INODE]
	2.通过devfs_get_ops得到块设备的驱动函数
		1.第一步返回不为空
		2.de-&gt;registered为1
		3.是字符设备/块设备/常规文件 返回de-&gt;u.fcb.ops，否则返回NULL
	如果是通过一个平面结构（16位主设备号，16位次设备号）mknod表示，
	返回NULL
5.bdev-&gt;bd_op = bdops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>456</x>
      <y>529</y>
      <w>54</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>529</y>
      <w>6</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>504</x>
      <y>547</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>498</x>
      <y>556</y>
      <w>41</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历super_blocks，如果s-&gt;s_dev不等于查找的设备dev
·就查找链表的下一个
2.如果等于dev，就wait_on_super查看lock，如果有lock，
就sleep，如果没lock，直接返回
3.醒来之后如果发现dev不同了，就重新再遍历一遍super_blocks
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>510</x>
      <y>550</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>529</y>
      <w>53</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;180.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>542</x>
      <y>546</y>
      <w>20</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果内存中存在super_block
</panel_attributes>
    <additional_attributes>160.0;10.0;30.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>540</x>
      <y>556</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.sb的type要和安装时候格式化的fs_type相同
2.安装的flag和sb-&gt;s_flags要在MS_RDONLY位相同
满足上面两条条件，返回sb，否则返回错误
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>557</x>
      <y>546</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不存在sb
</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>577</x>
      <y>552</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FMODE_READ
如果不是只读安装
就把FMODE_WRITE置上
打开设备文件</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>574</x>
      <y>560</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>502</x>
      <y>571</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rdev = to_kdev_t(bdev-&gt;bd_dev)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>512</x>
      <y>563</y>
      <w>70</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>680.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>528</x>
      <y>571</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_blkfops</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>534</x>
      <y>563</y>
      <w>48</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!bdev-&gt;bd_op
如果不是devfs设备
（devfs之前已经设置过bd_op）</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>533</x>
      <y>574</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
主设备号</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>508</x>
      <y>578</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!blkdevs[major].bdops
如果没在这里注册，有可能是可安装设备
</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>502</x>
      <y>581</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>535</x>
      <y>583</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdevs[major].bdops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>533</x>
      <y>578</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果
blkdevs中存在</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>577</x>
      <y>563</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里无论是devfs还是主次设备号
bd_op正常都执行驱动函数</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>556</x>
      <y>572</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_empty_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>561</x>
      <y>568</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>544</x>
      <y>578</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>548</x>
      <y>575</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>558</x>
      <y>579</y>
      <w>34</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>inodes_stat.nr_inodes++;
list_add(&amp;inode-&gt;i_list, &amp;inode_in_use);
inode-&gt;i_sb = NULL;
inode-&gt;i_dev = 0;
 //atten:last_ino是static
inode-&gt;i_ino = ++last_ino;
inode-&gt;i_flags = 0;
atomic_set(&amp;inode-&gt;i_count, 1);
inode-&gt;i_state = 0;
clean_inode(inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>562</x>
      <y>575</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>577</x>
      <y>568</y>
      <w>23</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>593</x>
      <y>579</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //file--dentry---inode
fake_file.f_mode = mode;
fake_file.f_flags = flags;
fake_file.f_dentry = &amp;fake_dentry;
fake_dentry.d_inode = fake_inode;
fake_inode-&gt;i_rdev = rdev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>621</x>
      <y>580</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdev-&gt;bd_op-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>577</x>
      <y>568</y>
      <w>53</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>577</x>
      <y>568</y>
      <w>69</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>634</x>
      <y>577</y>
      <w>12</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
正确返回</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>626</x>
      <y>585</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;bdev-&gt;bd_openers)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>643</x>
      <y>577</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
错误返回
并且bd_openers没有</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>649</x>
      <y>585</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdev-&gt;bd_op = NULL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>667</x>
      <y>585</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iput(fake_inode)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>643</x>
      <y>577</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放申请的inode</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>603</x>
      <y>558</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>check_disk_change</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>581</x>
      <y>552</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查介质是否变动</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>623</x>
      <y>557</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>!(flags &amp; MS_RDONLY) 
&amp;&amp; 
is_read_only(dev)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>581</x>
      <y>552</y>
      <w>53</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不是只读安装
但是设备却设置成只读</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>621</x>
      <y>566</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>blkdev_put(bdev, BDEV_FS)
path_release(&amp;nd)
return ERR_PTR(error) 
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>630</x>
      <y>562</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>665</x>
      <y>555</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>581</x>
      <y>552</y>
      <w>91</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;890.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>643</x>
      <y>562</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_empty_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>648</x>
      <y>558</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>643</x>
      <y>569</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.遍历链表super_blocks
2.如果存在s_dev为0，且
	s_lock没有锁住，则在链表
	中找到了空闲的sb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>649</x>
      <y>565</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>649</x>
      <y>565</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在super_blocks
中没找到空闲的sb</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>666</x>
      <y>576</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>669</x>
      <y>568</y>
      <w>8</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>683</x>
      <y>582</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>nr_super_blocks++;
memset(s, 0, sizeof(struct super_block));
INIT_LIST_HEAD(&amp;s-&gt;s_dirty);
list_add (&amp;s-&gt;s_list, super_blocks.prev);
init_waitqueue_head(&amp;s-&gt;s_wait);
INIT_LIST_HEAD(&amp;s-&gt;s_files);
INIT_LIST_HEAD(&amp;s-&gt;s_mounts);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>674</x>
      <y>568</y>
      <w>17</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请到了内存
就初始化sb</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>686</x>
      <y>563</y>
      <w>28</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>s-&gt;s_dev = dev;//设备号
s-&gt;s_bdev = bdev;//具体的设备
s-&gt;s_flags = flags;
s-&gt;s_dirt = 0;
sema_init(&amp;s-&gt;s_vfs_rename_sem,1);
sema_init(&amp;s-&gt;s_nfsd_free_path_sem,1);
s-&gt;s_type = type;
sema_init(&amp;s-&gt;s_dquot.dqio_sem, 1);
sema_init(&amp;s-&gt;s_dquot.dqoff_sem, 1);
s-&gt;s_dquot.flags = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>670</x>
      <y>558</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>717</x>
      <y>567</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>type-&gt;read_super(s, data, silent)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>670</x>
      <y>558</y>
      <w>66</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
type是从file_systems中
找到的file_system_type</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;30.0;640.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>744</x>
      <y>568</y>
      <w>21</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;bdev-&gt;bd_count)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>670</x>
      <y>556</y>
      <w>87</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是块设备，则增加计数</panel_attributes>
    <additional_attributes>10.0;30.0;510.0;20.0;850.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>735</x>
      <y>555</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>get_filesystem(fs_type);
path_release(&amp;nd);
return sb;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>581</x>
      <y>552</y>
      <w>160</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到了sb</panel_attributes>
    <additional_attributes>10.0;10.0;1580.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>512</x>
      <y>481</y>
      <w>39</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在read_super的过程中发现安装点已经被
其他的设备安装了，那么将会在已经安装的dentry上
继续安装现在的设备（管理上应该避免）</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>543</x>
      <y>494</y>
      <w>49</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.通过d_mountpoint检测nd.dentry是否安装了其他设备
 	（检测d_vfsmnt是否为空）
2.通过follow_down查找d_vfsmnt链表，如果检查安装点
	的mnt_parent，如果与将要安装的相同，则安装点mnt和dentry
	都变成下一层的mnt和dentry，将原来的dentry和mnt释放，并返回1
3.如果mnt_parent不相同，就遍历链表的下一个，重复2步骤，如果最后没有
	返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>551</x>
      <y>455</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfsmount
valign=center
bg=red</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>563</x>
      <y>455</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_mountpoint
安装的节点</panel_attributes>
    <additional_attributes>10.0;30.0;190.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>582</x>
      <y>455</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>535</x>
      <y>458</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_root
要安装设备的根目录</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>523</x>
      <y>453</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>super_block
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>584</x>
      <y>458</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
d_vfsmount
安装在这个目录下的所有vfsmount
（同一个设备可以有不同的安装点，
所以到这个dentry的路径可能不同
所以这里是可以有不同的安装点指向不同的设备
因为mnt_parent不同）</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>556</x>
      <y>458</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过mnt_clash链入</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>523</x>
      <y>461</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>535</x>
      <y>453</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_sb
要安装设备的超级块</panel_attributes>
    <additional_attributes>160.0;30.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>524</x>
      <y>446</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
s_mounts
这个设备所有要安装的安装点</panel_attributes>
    <additional_attributes>60.0;70.0;130.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>535</x>
      <y>446</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过
mnt_instances
链入</panel_attributes>
    <additional_attributes>210.0;90.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>559</x>
      <y>443</y>
      <w>25</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_parent
安装的节点的安装点</panel_attributes>
    <additional_attributes>10.0;120.0;230.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>582</x>
      <y>442</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfsmount
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>587</x>
      <y>445</y>
      <w>8</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_root</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>559</x>
      <y>440</y>
      <w>31</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_mounts
链接所有安装在这个设备上的安装点</panel_attributes>
    <additional_attributes>290.0;20.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>548</x>
      <y>441</y>
      <w>19</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过mnt_child链入</panel_attributes>
    <additional_attributes>100.0;140.0;10.0;10.0;120.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>589</x>
      <y>428</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfsmntlist
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>592</x>
      <y>431</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
系统中所有安装点的链表</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>594</x>
      <y>442</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=&lt;.&gt;
通过mnt_list链入</panel_attributes>
    <additional_attributes>10.0;20.0;160.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>563</x>
      <y>445</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=&lt;.&gt;
通过mnt_list链入</panel_attributes>
    <additional_attributes>10.0;100.0;200.0;70.0;230.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>610</x>
      <y>442</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfsmount
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>592</x>
      <y>435</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=&lt;.&gt;
通过mnt_list链入</panel_attributes>
    <additional_attributes>250.0;70.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>590</x>
      <y>445</y>
      <w>28</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_root</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>511</x>
      <y>481</y>
      <w>105</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1030.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>595</x>
      <y>495</y>
      <w>49</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>filter:
1.nd.mnt &amp;&amp; nd.mnt-&gt;mnt_sb == sb
   &amp;&amp; nd.mnt-&gt;mnt_root == nd.dentry
   同一设备不能安装到同一个安装点
2.nd.dentry-&gt;d_inode
 	安装目录的inode要存在

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>511</x>
      <y>481</y>
      <w>175</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
nd.dentry-&gt;d_inode.i_flags中S_DEAD没置上</panel_attributes>
    <additional_attributes>10.0;10.0;1730.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>676</x>
      <y>493</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_vfsmnt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>630</x>
      <y>496</y>
      <w>53</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请mnt,并将内存清0</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>626</x>
      <y>510</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc
memset
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>644</x>
      <y>510</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mnt-&gt;mnt_flags = MNT_VISIBLE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>654</x>
      <y>496</y>
      <w>29</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
nd || dev_name</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>678</x>
      <y>496</y>
      <w>10</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dev_name</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>670</x>
      <y>510</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>kmalloc
strcpy(name, dev_name);
mnt-&gt;mnt_devname = name;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>693</x>
      <y>510</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>mnt-&gt;mnt_owner = current-&gt;uid;
atomic_set(&amp;mnt-&gt;mnt_count,1);
mnt-&gt;mnt_sb = sb;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>680</x>
      <y>496</y>
      <w>26</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>681</x>
      <y>496</y>
      <w>44</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>719</x>
      <y>509</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>nd &amp;&amp; 
 //dentry不是root
!IS_ROOT(nd-&gt;dentry) 
 //dentry没装入hash
&amp;&amp; d_unhashed(nd-&gt;dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>741</x>
      <y>511</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>mnt-&gt;mnt_root = dget(root);
 //nd为空表示mount_root kern_mount
mnt-&gt;mnt_mountpoint = nd ? dget(nd-&gt;dentry) : dget(root);
mnt-&gt;mnt_parent = nd ? mntget(nd-&gt;mnt) : mnt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>681</x>
      <y>496</y>
      <w>72</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;700.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>780</x>
      <y>509</y>
      <w>33</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>if (nd) {
list_add(&amp;mnt-&gt;mnt_child, &amp;nd-&gt;mnt-&gt;mnt_mounts);
	list_add(&amp;mnt-&gt;mnt_clash, &amp;nd-&gt;dentry-&gt;d_vfsmnt);
} else {
	INIT_LIST_HEAD(&amp;mnt-&gt;mnt_child);
	INIT_LIST_HEAD(&amp;mnt-&gt;mnt_clash);
}
INIT_LIST_HEAD(&amp;mnt-&gt;mnt_mounts);
list_add(&amp;mnt-&gt;mnt_instances, &amp;sb-&gt;s_mounts);
list_add(&amp;mnt-&gt;mnt_list, vfsmntlist.prev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>682</x>
      <y>496</y>
      <w>109</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1070.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>335</x>
      <y>506</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>!old_name || !*old_name
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>342</x>
      <y>500</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设备dev_name不为空</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>354</x>
      <y>506</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init
path_walk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>357</x>
      <y>500</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
寻找设备的dentry</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>366</x>
      <y>506</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init
path_walk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>367</x>
      <y>500</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
寻找安装目录的dentry</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>367</x>
      <y>500</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>378</x>
      <y>503</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.检查进程和安装目录的权限
	mount_is_safe
2.S_ISDIR(new_nd.dentry-&gt;d_inode-&gt;i_mode) !=
	      S_ISDIR(old_nd.dentry-&gt;d_inode-&gt;i_mode)
3.如果安装设备的file_system的fs_flags中FS_SINGLE
  增加file_system的计数
4.new_nd.dentry-&gt;d_inode的i_flags中S_DEAD没置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>414</x>
      <y>503</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_vfsmnt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>369</x>
      <y>500</y>
      <w>53</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里传参，相当于将sb再次安装到其他的安装点
理解：这里只是将格式化好的sb和root传给要安装的目录</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>792</x>
      <y>580</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_read_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>729</x>
      <y>570</y>
      <w>71</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_fs_type
因为只有在有sb的时候
才能有ext2_sops，所以
现在只能通过文件系统的方法
将sb读进来</panel_attributes>
    <additional_attributes>10.0;10.0;690.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>711</x>
      <y>592</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_hardblocksize</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>716</x>
      <y>583</y>
      <w>84</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从hardsect_size中获取
最小为BLOCK_SIZE</panel_attributes>
    <additional_attributes>820.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>726</x>
      <y>593</y>
      <w>22</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>sb-&gt;u.ext2_sb.s_mount_opt = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>736</x>
      <y>583</y>
      <w>64</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>749</x>
      <y>592</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>parse_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>754</x>
      <y>583</y>
      <w>46</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>763</x>
      <y>592</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_blocksize</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>768</x>
      <y>583</y>
      <w>32</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>780</x>
      <y>583</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果blocksize大于BLOCK_SIZE</panel_attributes>
    <additional_attributes>180.0;10.0;30.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>778</x>
      <y>592</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //超级块物理上在sb_block*BLOCK_SIZE的位置
logic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;
offset = (sb_block*BLOCK_SIZE) % blocksize;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>818</x>
      <y>593</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>797</x>
      <y>583</y>
      <w>30</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>797</x>
      <y>583</y>
      <w>44</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>833</x>
      <y>592</y>
      <w>40</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>es=(char *)bh-&gt;b_data + offset
sb-&gt;u.ext2_sb.s_es = es
sb-&gt;s_magic = le16_to_cpu(es-&gt;s_magic)
  //check
1.check magic EXT2_SUPER_MAGIC
2.le32_to_cpu(es-&gt;s_rev_level) == EXT2_GOOD_OLD_REV
 &amp;&amp;(COMPAT  ||  RO_COMPAT  || INCOMPAT)
3.INCOMPAT没有INCOMPAT_SUPP位
4.sb-&gt;s_flags不是MS_RDONLY
	但是RO_COMPAT没置

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>876</x>
      <y>593</y>
      <w>40</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_blocksize_bits =
	le32_to_cpu(EXT2_SB(sb)-&gt;s_es-&gt;s_log_block_size) + 10;
sb-&gt;s_blocksize = 1 &lt;&lt; sb-&gt;s_blocksize_bits
 //在不等于BLOCK_SIZE，但是是1k，2k，4k的时候
1.s_blocksize要大于get_hardblocksize
2.将s_blocksize保存在logic_sb_block
3.通过bread在读一整个大小为s_blocksize的记录块
注：ext2在sb_block*BLOCK_SIZE总是是超级块
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>923</x>
      <y>594</y>
      <w>63</w>
      <h>95</h>
    </coordinates>
    <panel_attributes>sb-&gt;u.ext2_sb.s_inode_size
sb-&gt;u.ext2_sb.s_first_ino
sb-&gt;u.ext2_sb.s_frag_size=EXT2_MIN_FRAG_SIZE &lt;&lt;
				   le32_to_cpu(es-&gt;s_log_frag_size)
sb-&gt;u.ext2_sb.s_frags_per_block
sb-&gt;s_magic
 //这个block的数量包含inode/描述结构/管理结构/超级块的block
sb-&gt;u.ext2_sb.s_blocks_per_group = le32_to_cpu(es-&gt;s_blocks_per_group);
sb-&gt;u.ext2_sb.s_frags_per_group = le32_to_cpu(es-&gt;s_frags_per_group);
sb-&gt;u.ext2_sb.s_inodes_per_group = le32_to_cpu(es-&gt;s_inodes_per_group);
sb-&gt;u.ext2_sb.s_inodes_per_block = sb-&gt;s_blocksize /
				   EXT2_INODE_SIZE(sb);
sb-&gt;u.ext2_sb.s_itb_per_group = sb-&gt;u.ext2_sb.s_inodes_per_group /
			        sb-&gt;u.ext2_sb.s_inodes_per_block;
sb-&gt;u.ext2_sb.s_desc_per_block = sb-&gt;s_blocksize /
				 sizeof (struct ext2_group_desc);
sb-&gt;u.ext2_sb.s_sbh = bh;
sb-&gt;u.ext2_sb.s_resuid
sb-&gt;u.ext2_sb.s_resgid
sb-&gt;u.ext2_sb.s_mount_state = le16_to_cpu(es-&gt;s_state);
 //log2是第一个1所在位的索引 bsfl op1 op2， 计算op1中第一个1，索引放在op2中
sb-&gt;u.ext2_sb.s_addr_per_block_bits =
	log2 (EXT2_ADDR_PER_BLOCK(sb));
sb-&gt;u.ext2_sb.s_desc_per_block_bits =
	log2 (EXT2_DESC_PER_BLOCK(sb));
	//check
1.sb-&gt;s_magic = EXT2_SUPER_MAGIC
2.sb-&gt;s_blocksize = bh-&gt;b_size
3.sb-&gt;s_blocksize = sb-&gt;u.ext2_sb.s_frag_size
4.不能有超过一个记录块记录block的数量
 sb-&gt;u.ext2_sb.s_blocks_per_group &gt; sb-&gt;s_blocksize * 8
5.sb-&gt;u.ext2_sb.s_frags_per_group &gt; sb-&gt;s_blocksize * 8
6.不能超过一个记录块记录inoe
	sb-&gt;u.ext2_sb.s_inodes_per_group &gt; sb-&gt;s_blocksize * 8

 //一个desc描述一个组，前面检查过blocksize和bh的b_size相同
sb-&gt;u.ext2_sb.s_groups_count = (le32_to_cpu(es-&gt;s_blocks_count) -
			        le32_to_cpu(es-&gt;s_first_data_block) +
			       EXT2_BLOCKS_PER_GROUP(sb) - 1) /
			       EXT2_BLOCKS_PER_GROUP(sb);
db_count = (sb-&gt;u.ext2_sb.s_groups_count + EXT2_DESC_PER_BLOCK(sb) - 1) /
	   EXT2_DESC_PER_BLOCK(sb);
sb-&gt;u.ext2_sb.s_group_desc = kmalloc (db_count * sizeof (struct buffer_head *), GFP_KERNEL);
 //填充group信息
sb-&gt;u.ext2_sb.s_group_desc[i] = bread (dev, logic_sb_block + i + 1,
					       sb-&gt;s_blocksize);
 //检查每个group的bg_block_bitmap  bg_block_bitmap   	bg_inode_table是否在合适的块
ext2_check_descriptors
 //先初始化8个bitmap和块号
sb-&gt;u.ext2_sb.s_inode_bitmap_number[i] = 0;
sb-&gt;u.ext2_sb.s_inode_bitmap[i] = NULL;
sb-&gt;u.ext2_sb.s_block_bitmap_number[i] = 0;
sb-&gt;u.ext2_sb.s_block_bitmap[i] = NULL;

sb-&gt;u.ext2_sb.s_loaded_inode_bitmaps = 0;
sb-&gt;u.ext2_sb.s_loaded_block_bitmaps = 0;
 //所有desc占的所有block总数
sb-&gt;u.ext2_sb.s_gdb_count = db_count;
sb-&gt;s_op = &amp;ext2_sops;
sb-&gt;s_root = d_alloc_root(iget(sb, EXT2_ROOT_INO));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>798</x>
      <y>583</y>
      <w>95</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;930.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>799</x>
      <y>583</y>
      <w>137</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1350.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1002</x>
      <y>595</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_alloc_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>798</x>
      <y>583</y>
      <w>213</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sb-&gt;s_root
为根目录inode建立dentry
iget(sb, EXT2_ROOT_INO)</panel_attributes>
    <additional_attributes>10.0;10.0;2110.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>987</x>
      <y>603</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>991</x>
      <y>598</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请并初始化dentry
{ "/", 1, 0 }</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1003</x>
      <y>602</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>res-&gt;d_sb = root_inode-&gt;i_sb;
res-&gt;d_parent = res;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1007</x>
      <y>598</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1029</x>
      <y>602</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_instantiate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1007</x>
      <y>598</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1017</x>
      <y>609</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //dentry连接到inode中
list_add(&amp;entry-&gt;d_alias, &amp;inode-&gt;i_dentry)
entry-&gt;d_inode = inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1031</x>
      <y>605</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1051</x>
      <y>595</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_setup_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1047</x>
      <y>604</y>
      <w>52</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>es-&gt;s_state = cpu_to_le16(le16_to_cpu(es-&gt;s_state) &amp; ~EXT2_VALID_FS);
if (!(__s16) le16_to_cpu(es-&gt;s_max_mnt_count))
	es-&gt;s_max_mnt_count = (__s16) cpu_to_le16(EXT2_DFL_MAX_MNT_COUNT);
es-&gt;s_mnt_count=cpu_to_le16(le16_to_cpu(es-&gt;s_mnt_count) + 1);
es-&gt;s_mtime = cpu_to_le32(CURRENT_TIME);
mark_buffer_dirty(sb-&gt;u.ext2_sb.s_sbh);
sb-&gt;s_dirt = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1056</x>
      <y>598</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置管理信息</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>798</x>
      <y>583</y>
      <w>261</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2590.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>518</x>
      <y>527</y>
      <w>22</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>sb = fs_type-&gt;kern_mnt-&gt;mnt_sb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>528</x>
      <y>522</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取init_proc_fs设置的sb</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>542</x>
      <y>526</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_filesystem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>540</x>
      <y>522</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加file_system计数</panel_attributes>
    <additional_attributes>50.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>560</x>
      <y>526</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_remount_sb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>544</x>
      <y>522</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>530</x>
      <y>534</y>
      <w>43</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果要以MS_RDONLY安装，sb-&gt;s_dev要是read_only
	(procfs是NULL,这个检测不存在)
2.如果以MS_RDONLY安装，但是sb却不是read_only的，此时需要
	检测sb中的所有文件，查看inode是否只读，如果不是，返回-EBUSY

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>550</x>
      <y>529</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>575</x>
      <y>536</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;remount_fs
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>565</x>
      <y>529</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sb-&gt;s_op-&gt;remount_fs存在</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>595</x>
      <y>535</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_flags = 
(sb-&gt;s_flags &amp; ~MS_RMT_MASK) | 
(flags &amp; MS_RMT_MASK)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>566</x>
      <y>529</y>
      <w>40</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果flag中MS_RMT_MASK置上，
就将sb-&gt;s_flags置上
否则将其清掉</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1142</x>
      <y>490</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_umount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1069</x>
      <y>511</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1074</x>
      <y>493</y>
      <w>76</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>740.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1086</x>
      <y>512</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1090</x>
      <y>493</y>
      <w>60</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
LOOKUP_POSITIVE|LOOKUP_FOLLOW</panel_attributes>
    <additional_attributes>580.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1105</x>
      <y>512</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1109</x>
      <y>493</y>
      <w>41</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1122</x>
      <y>512</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>putname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1126</x>
      <y>493</y>
      <w>24</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
已经得到了nd
将name释放</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1136</x>
      <y>510</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>filter
1.要释放的目录必须是设备的根目录
	nd.dentry != nd.mnt-&gt;mnt_root时报错
2.检查进程卸载的权限
 !capable(CAP_SYS_ADMIN)
 &amp;&amp; current-&gt;uid!=nd.mnt-&gt;mnt_owner
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1147</x>
      <y>493</y>
      <w>6</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1166</x>
      <y>511</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput(nd.dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1145</x>
      <y>493</y>
      <w>29</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放文件的根目录
atomic_dec_and_lock只有counter为0的时候
返回true</panel_attributes>
    <additional_attributes>30.0;10.0;250.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1181</x>
      <y>510</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_umount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1147</x>
      <y>493</y>
      <w>42</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放nd.mnt</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;170.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1149</x>
      <y>513</y>
      <w>40</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt == current-&gt;fs-&gt;rootmnt &amp;&amp; 
!umount_root
如果用户进程要删除进程的跟设备，那就把跟设备设置为只读</panel_attributes>
    <additional_attributes>380.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1138</x>
      <y>524</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1134</x>
      <y>529</y>
      <w>11</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mntput(mnt)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1148</x>
      <y>529</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_remount_sb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1149</x>
      <y>524</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果sb-&gt;s_flags &amp; MS_RDONLY没置上
那么将sb进行只读安装</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1186</x>
      <y>513</y>
      <w>37</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果sb上安装在多个vfsmnt
mnt-&gt;mnt_instances.next != mnt-&gt;mnt_instances.prev</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1161</x>
      <y>527</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
atomic_read(&amp;mnt-&gt;mnt_count) &gt; 2
nd中一次，vfsmnt自身一次
这里大于2次，说明有其他地方引用这个vfsmnt</panel_attributes>
    <additional_attributes>280.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1159</x>
      <y>533</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //释放nd中的一次
mntput(mnt)
return -EBUSY
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1182</x>
      <y>527</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sb-&gt;s_type-&gt;fs_flags &amp; FS_SINGLE
文件系统只有一个超级块</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1175</x>
      <y>535</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes> //释放文件系统的引用
put_filesystem(sb-&gt;s_type)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1188</x>
      <y>527</y>
      <w>17</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放其中一个（nd的）</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1197</x>
      <y>535</y>
      <w>11</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mntput(mnt)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1210</x>
      <y>534</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_vfsmnt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1188</x>
      <y>527</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1205</x>
      <y>541</y>
      <w>23</w>
      <h>25</h>
    </coordinates>
    <panel_attributes> //mnt脱离sb链表
list_del(&amp;mnt-&gt;mnt_instances);
 //脱离dentry链表
list_del(&amp;mnt-&gt;mnt_clash);
	//脱离mnt总的链表
list_del(&amp;mnt-&gt;mnt_list);
 //解除和parent的关系
list_del(&amp;mnt-&gt;mnt_child);
if (mnt-&gt;mnt_parent != mnt)
	mntput(mnt-&gt;mnt_parent);
dput(mnt-&gt;mnt_mountpoint);
dput(mnt-&gt;mnt_root);
if (mnt-&gt;mnt_devname)
	kfree(mnt-&gt;mnt_devname);
kfree(mnt);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1214</x>
      <y>537</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1186</x>
      <y>513</y>
      <w>70</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果sb上只安装在一个vfsmnt</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1230</x>
      <y>525</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
磁盘空间分配</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1224</x>
      <y>533</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>DQUOT_OFF(sb);
acct_auto_close(sb-&gt;s_dev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1245</x>
      <y>534</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;umount_begin(sb)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1253</x>
      <y>525</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(flags&amp;MNT_FORCE) &amp;&amp; sb-&gt;s_op-&gt;umount_begin
有些设备要求拆卸之前先执行这个函数</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1273</x>
      <y>534</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shrink_dcache_sb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1253</x>
      <y>525</y>
      <w>29</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1262</x>
      <y>537</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1239</x>
      <y>541</y>
      <w>47</w>
      <h>55</h>
    </coordinates>
    <panel_attributes>1.遍历dentry_unused，如果dentry.d_sb和要卸载的sb相同
	就先通过list_del删除其当前的链接关系，再通过list_add
	将这个dentry头插到dentry_unused（注意这里因为时头插
	所以不会无限循环）
	如果sb不相同，就遍历下一个
2.再次遍历dentry_unused，将d_sb相同，d_count为0的删掉
	dentry_stat.nr_unused--;
	list_del(tmp);
	INIT_LIST_HEAD(tmp);
	prune_one_dentry：真正释放

	
		list_del_init(&amp;dentry-&gt;d_hash);
		list_del(&amp;dentry-&gt;d_child);
		dentry_iput(dentry);//释放inode
		parent = dentry-&gt;d_parent;

		
		d_free(dentry)：
			if (dentry-&gt;d_op &amp;&amp; dentry-&gt;d_op-&gt;d_release)
				dentry-&gt;d_op-&gt;d_release(dentry);
			if (dname_external(dentry)) 
				kfree(dentry-&gt;d_name.name);
			kmem_cache_free(dentry_cache, dentry); 
			dentry_stat.nr_dentry--;

			
		if (parent != dentry)
			dput(parent);
疑问：这里虽然将要删除的dentry都移到了最前面，在second pass
的时候只需要遍历一次(我感觉不repreat也是可以的？)，但是first_pass
和second_pass也是要遍历2次，为什么不在first_pass的时候将dentry删了？
这里又是spinlock，不会被打断。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1318</x>
      <y>534</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fsync_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1186</x>
      <y>513</y>
      <w>141</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1390.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1297</x>
      <y>542</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1302</x>
      <y>537</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dev,0</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1317</x>
      <y>543</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_supers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1321</x>
      <y>537</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1339</x>
      <y>544</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_inodes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1364</x>
      <y>544</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DQUOT_SYNC</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1385</x>
      <y>544</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1322</x>
      <y>537</y>
      <w>69</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dev,1</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1322</x>
      <y>537</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1322</x>
      <y>537</y>
      <w>49</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1299</x>
      <y>551</y>
      <w>41</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.遍历super_blocks
2，筛选出sb-&gt;s_dev不为0，dev存在 &amp;&amp; sb-&gt;s_dev == dev，
	sb-&gt;s_dirt（sb是脏的）的sb
3.筛选出之后lock_super,因为在lock的时候可能睡着，所以再次
  检测上面的条件，如果提供了write_super的函数通过
  sb-&gt;s_op-&gt;write_super(sb)，然后unlock_super.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1315</x>
      <y>546</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1341</x>
      <y>551</y>
      <w>41</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历super_blocks
2，筛选出sb-&gt;s_dev不为0，dev存在 &amp;&amp; sb-&gt;s_dev == dev，
	的sb
3.通过sync_list去同步sb中s_dirty管理的inode
	sync_list通过sync_one去处理s_dirty中的每一个inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1340</x>
      <y>547</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里只是设标志，并没向磁盘写
因为sync_one中syn的传参是0</panel_attributes>
    <additional_attributes>40.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1358</x>
      <y>564</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_one</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1362</x>
      <y>560</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1346</x>
      <y>567</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
i_state &amp; I_LOCK
如果inode正在向磁盘写</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1302</x>
      <y>571</y>
      <w>47</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1297</x>
      <y>577</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__iget
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1316</x>
      <y>577</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__wait_on_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1323</x>
      <y>571</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
等待向磁盘写完</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1287</x>
      <y>585</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DECLARE_WAITQUEUE(wait, current)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1299</x>
      <y>580</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申明wait
将其中的唤醒进程设置为current</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1317</x>
      <y>585</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_wait_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1322</x>
      <y>580</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将wait加在inode-&gt;i_wait</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1291</x>
      <y>593</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait-&gt;flags = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1296</x>
      <y>588</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1312</x>
      <y>593</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__add_wait_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1316</x>
      <y>588</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将task_list链表连接</panel_attributes>
    <additional_attributes>80.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1334</x>
      <y>585</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>repeat：
TASK_UNINTERRUPTIBLE
if (inode-&gt;i_state &amp; I_LOCK) {
	schedule();
	goto repeat;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1323</x>
      <y>580</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查锁</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1358</x>
      <y>586</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_wait_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1323</x>
      <y>580</y>
      <w>44</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1358</x>
      <y>592</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__remove_wait_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1365</x>
      <y>589</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将task_list解开</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1374</x>
      <y>586</y>
      <w>14</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>TASK_RUNNING
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1323</x>
      <y>580</y>
      <w>61</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为repeat的时候将task的状态设置成
TASK_UNINTERRUPTIBLE</panel_attributes>
    <additional_attributes>10.0;10.0;590.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1405</x>
      <y>581</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iput
猜想：
1.如果count有计数，则放在inode_in_use中
2.如果count=0，则放在inode_unused中
3.以上两种情况都是!dirty，如果dirty
	则不管count，直接放在s_dirty中
3.i_nlink表示物理上有多少个链接，在文件
	刚创建的时候，i_nlink为1，其后创建链接
	会增加计数，如果这个链接为0，表示要在物理硬盘上
	将这个inode删除，通过clear_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1346</x>
      <y>571</y>
      <w>66</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;640.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1383</x>
      <y>584</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode-&gt;i_sb-&gt;s_op
如果sb规定了put_inode
先通过sb的函数处理</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1378</x>
      <y>591</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>op-&gt;put_inode(inode)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1400</x>
      <y>591</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>atomic_dec_and_lock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1408</x>
      <y>584</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将wait加在inode-&gt;i_wait</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1410</x>
      <y>584</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1417</x>
      <y>590</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!i_nlink
猜想：没有符号链接的时候</panel_attributes>
    <additional_attributes>120.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1389</x>
      <y>596</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1378</x>
      <y>600</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>list_del(&amp;inode-&gt;i_hash);
INIT_LIST_HEAD(&amp;inode-&gt;i_hash);
list_del(&amp;inode-&gt;i_list);
INIT_LIST_HEAD(&amp;inode-&gt;i_list);
inode-&gt;i_state|=I_FREEING;
inodes_stat.nr_inodes--;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1410</x>
      <y>596</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode-&gt;i_data.nrpages</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1403</x>
      <y>601</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>truncate_inode_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1422</x>
      <y>596</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1415</x>
      <y>601</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果sb提供了
op-&gt;delete_inode</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1407</x>
      <y>606</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>op-&gt;delete_inode(inode)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1427</x>
      <y>601</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;58.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1428</x>
      <y>606</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>clear_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1428</x>
      <y>590</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
i_nlink不为0
有符号链接？</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1437</x>
      <y>595</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果inode连在hash中</panel_attributes>
    <additional_attributes>100.0;10.0;48.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1437</x>
      <y>604</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>list_del(&amp;inode-&gt;i_list);
list_add(&amp;inode-&gt;i_list,
	 &amp;inode_unused);
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1441</x>
      <y>599</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果inode没脏
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1457</x>
      <y>605</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inodes_stat.nr_unused++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1441</x>
      <y>599</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;218.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1446</x>
      <y>595</y>
      <w>42</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没连在hash中
将inode清掉</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1477</x>
      <y>602</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>list_del(&amp;inode-&gt;i_list);
INIT_LIST_HEAD(&amp;inode-&gt;i_list);
inode-&gt;i_state|=I_FREEING;
inodes_stat.nr_inodes--;
clear_inode(inode)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1362</x>
      <y>567</y>
      <w>108</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果inode没有在向磁盘写</panel_attributes>
    <additional_attributes>10.0;10.0;1060.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1449</x>
      <y>570</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1431</x>
      <y>573</y>
      <w>37</w>
      <h>18</h>
    </coordinates>
    <panel_attributes> //从s_dirty中删除，加到其他两个链表中
list_del(&amp;inode-&gt;i_list);
list_add(&amp;inode-&gt;i_list, atomic_read(&amp;inode-&gt;i_count)
					? &amp;inode_in_use
					: &amp;inode_unused);
 //将dirty标志提取
dirty = inode-&gt;i_state &amp; I_DIRTY;
 //将inode上锁，表示要想磁盘写
inode-&gt;i_state |= I_LOCK;
 //将dirty清掉
inode-&gt;i_state &amp;= ~I_DIRTY;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1472</x>
      <y>576</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filemap_fdatasync</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1467</x>
      <y>570</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1491</x>
      <y>576</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>write_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1467</x>
      <y>570</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1508</x>
      <y>576</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filemap_fdatawait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1524</x>
      <y>576</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_state &amp;= ~I_LOCK;
wake_up(&amp;inode-&gt;i_wait)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1467</x>
      <y>570</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1467</x>
      <y>570</y>
      <w>65</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;630.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1503</x>
      <y>584</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_write_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1496</x>
      <y>579</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1516</x>
      <y>594</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_update_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1510</x>
      <y>587</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1500</x>
      <y>604</y>
      <w>46</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.检查i_ino
2.三段；group_desc  desc  offset
	每个inode都分组成为一个desc，而desc作为一个数据结构存在磁盘中
	首先通过group_desc找到存储当前inode 的desc的bh，再通过desc找到
	相应的desc结构，最后通过desc中的基础block bg_inode_table和offset
	找到inode对应的block
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1515</x>
      <y>597</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1555</x>
      <y>605</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1523</x>
      <y>597</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1570</x>
      <y>609</y>
      <w>42</w>
      <h>48</h>
    </coordinates>
    <panel_attributes>raw_inode-&gt;i_mode = cpu_to_le16(inode-&gt;i_mode);
raw_inode-&gt;i_uid_low 
raw_inode-&gt;i_gid_low
raw_inode-&gt;i_uid_high 
raw_inode-&gt;i_gid_high
raw_inode-&gt;i_links_count = cpu_to_le16(inode-&gt;i_nlink);
raw_inode-&gt;i_size = cpu_to_le32(inode-&gt;i_size);
raw_inode-&gt;i_atime = cpu_to_le32(inode-&gt;i_atime);
raw_inode-&gt;i_ctime = cpu_to_le32(inode-&gt;i_ctime);
raw_inode-&gt;i_mtime = cpu_to_le32(inode-&gt;i_mtime);
raw_inode-&gt;i_blocks = cpu_to_le32(inode-&gt;i_blocks);
raw_inode-&gt;i_dtime = cpu_to_le32(inode-&gt;u.ext2_i.i_dtime);
raw_inode-&gt;i_flags = cpu_to_le32(inode-&gt;u.ext2_i.i_flags);
raw_inode-&gt;i_faddr = cpu_to_le32(inode-&gt;u.ext2_i.i_faddr);
raw_inode-&gt;i_frag = inode-&gt;u.ext2_i.i_frag_no;
raw_inode-&gt;i_fsize = inode-&gt;u.ext2_i.i_frag_size;
raw_inode-&gt;i_file_acl = cpu_to_le32(inode-&gt;u.ext2_i.i_file_acl);
if (S_ISDIR(inode-&gt;i_mode))
	raw_inode-&gt;i_dir_acl = cpu_to_le32(inode-&gt;u.ext2_i.i_dir_acl);
else {
	raw_inode-&gt;i_size_high = cpu_to_le32(inode-&gt;i_size &gt;&gt; 32);
...
	}
raw_inode-&gt;i_generation = cpu_to_le32(inode-&gt;i_generation);
if (S_ISCHR(inode-&gt;i_mode) || S_ISBLK(inode-&gt;i_mode))
	raw_inode-&gt;i_block[0] = cpu_to_le32(kdev_t_to_nr(inode-&gt;i_rdev));
else for (block = 0; block &lt; EXT2_N_BLOCKS; block++)
	raw_inode-&gt;i_block[block] = inode-&gt;u.ext2_i.i_data[block];
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1619</x>
      <y>606</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_buffer_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1523</x>
      <y>597</y>
      <w>106</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;860.0;50.0;1040.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1523</x>
      <y>596</y>
      <w>129</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
do_sync</panel_attributes>
    <additional_attributes>10.0;20.0;1110.0;30.0;1270.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1635</x>
      <y>609</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ll_rw_block </panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1655</x>
      <y>610</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait_on_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1640</x>
      <y>604</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
WRITE</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1649</x>
      <y>604</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1523</x>
      <y>597</y>
      <w>75</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;60.0;730.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>439</x>
      <y>852</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>220</x>
      <y>889</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>224</x>
      <y>855</y>
      <w>223</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filename</panel_attributes>
    <additional_attributes>2210.0;10.0;10.0;340.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>291</x>
      <y>891</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_unused_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>295</x>
      <y>855</y>
      <w>152</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1500.0;10.0;10.0;360.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>237</x>
      <y>898</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_next_zero_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>246</x>
      <y>894</y>
      <w>53</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>227</x>
      <y>901</y>
      <w>21</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 next_fd表示空置的fd最小偏移量
 (注意__put_unused_fd)
addr=open_fds
size=max_fdset
offset=next_fd</panel_attributes>
    <additional_attributes>180.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>203</x>
      <y>907</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>199</x>
      <y>912</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //所在的word
p=addr+(offset&gt;&gt;5)
 //在word中的偏移
bit = offset &amp; 31
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>215</x>
      <y>914</y>
      <w>21</w>
      <h>13</h>
    </coordinates>
    <panel_attributes> //看*p中的第一个0的索引位
"bsfl %1,%0\n\t" //低到高直到1
"jne 1f\n\t"
"movl $32, %0\n"
"1:"
: "=r" (set)
: "r" (~(*p &gt;&gt; bit)))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>226</x>
      <y>907</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果偏移不为0</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>227</x>
      <y>910</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
set &lt; (32 - bit)
32位内找到了0</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>221</x>
      <y>910</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>239</x>
      <y>915</y>
      <w>14</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>return set + offset
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>227</x>
      <y>910</y>
      <w>37</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否者推到下一个word</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>254</x>
      <y>914</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set = 32 - bit;
		p++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>267</x>
      <y>913</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_first_zero_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>228</x>
      <y>907</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>245</x>
      <y>920</y>
      <w>54</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>"movl $-1,%%eax\n\t"//0xffffffff
"xorl %%edx,%%edx\n\t"
 //edi和eax比较（ecx计数），相等继续（repe，如果是repne，就是不相等继续）
"repe; scasl\n\t" 
"je 1f\n\t"
 //这里异或，（edi-4）中为0的会置为1
"xorl -4(%%edi),%%eax\n\t"
"subl $4,%%edi\n\t"
 //找出eax中第一个1，即（edi）中第一个0
"bsfl %%eax,%%edx\n"
 //偏移量 edi=edi-ebx 如果ecx减到0，此时的偏移量大于size
"1:\tsubl %%ebx,%%edi\n\t"
 //算出字节的偏移量，左移（shr右移）
"shll $3,%%edi\n\t"
 //算出总的偏移量
"addl %%edi,%%edx"
:"=d" (res), "=&amp;c" (d0), "=&amp;D" (d1), "=&amp;a" (d2)
:"1" ((size + 31) &gt;&gt; 5), "2" (addr), "b" (addr))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>270</x>
      <y>916</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>264</x>
      <y>894</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fd&gt;rlim[RLIMIT_NOFILE]
如果文件打开的数量超出了进程的限制</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>261</x>
      <y>904</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>277</x>
      <y>907</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expand_fdset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>279</x>
      <y>894</y>
      <w>20</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fd &gt;= files-&gt;max_fdset
扩展fd位图</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>290</x>
      <y>908</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expand_fdset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>296</x>
      <y>894</y>
      <w>15</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fd &gt;= files-&gt;max_fds
扩展file数组</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>306</x>
      <y>906</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>FD_SET(fd, files-&gt;open_fds);（btsl将偏移值设置为1，将原来的值存在CF）
FD_CLR(fd, files-&gt;close_on_exec);（btrl将偏移值设置为0，将原来的值存在CF）
files-&gt;next_fd = fd + 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>297</x>
      <y>894</y>
      <w>17</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>333</x>
      <y>907</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>files-&gt;fd[fd] == NULL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>297</x>
      <y>894</y>
      <w>44</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fd对应的file要NULL</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>445</x>
      <y>864</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>444</x>
      <y>855</y>
      <w>9</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1240</x>
      <y>885</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fd_install</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>444</x>
      <y>855</y>
      <w>804</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;8020.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1240</x>
      <y>892</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>files-&gt;fd[fd] = file
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1246</x>
      <y>888</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>444</x>
      <y>855</y>
      <w>821</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;8190.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1258</x>
      <y>885</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1256</x>
      <y>892</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>putname(tmp)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1262</x>
      <y>888</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1270</x>
      <y>885</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out_error
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>444</x>
      <y>855</y>
      <w>832</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;8300.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1270</x>
      <y>891</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_unused_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1274</x>
      <y>888</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1270</x>
      <y>897</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__put_unused_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1275</x>
      <y>894</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1268</x>
      <y>903</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>FD_CLR(fd, files-&gt;open_fds);
 //从这里看出，next_fd存储的
 //最小空闲的fd的偏移量
if (fd &lt; files-&gt;next_fd)
	files-&gt;next_fd = fd;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1275</x>
      <y>900</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>330</x>
      <y>891</y>
      <w>34</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //当flag的低两位是11时，flag没有++，所以还是11
if ((namei_flags+1) &amp; O_ACCMODE)
		namei_flags++;
 //空白打开，增加写权限
if (namei_flags &amp; O_TRUNC)
	namei_flags |= 2;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>340</x>
      <y>867</y>
      <w>112</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
open的权限转化成open_namei权限</panel_attributes>
    <additional_attributes>1100.0;10.0;10.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>390</x>
      <y>899</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>open_namei</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>394</x>
      <y>867</y>
      <w>58</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到文件的dentry</panel_attributes>
    <additional_attributes>560.0;10.0;10.0;320.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>343</x>
      <y>902</y>
      <w>53</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!(flag &amp; O_CREAT)
找不到文件不创建文件</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>335</x>
      <y>941</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>329</x>
      <y>944</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_flags</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>344</x>
      <y>944</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>359</x>
      <y>944</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>343</x>
      <y>941</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>343</x>
      <y>941</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>309</x>
      <y>950</y>
      <w>49</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.默认打开置上LOOKUP_FOLLOW (遇到link，继续向下找到真实文件)
2.O_NOFOLLOW 或者 O_CREAT|O_EXCL置上时，LOOKUP_FOLLOW取消
3.O_DIRECTORY时 LOOKUP_DIRECTORY（如果inode没有op则会报错）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>331</x>
      <y>947</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>394</x>
      <y>902</y>
      <w>21</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flag &amp; O_CREAT</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;370.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>373</x>
      <y>944</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>387</x>
      <y>944</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>378</x>
      <y>938</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
LOOKUP_PARENT表示只找到父节点
但是nd.last是指向最后一个节点的</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>392</x>
      <y>938</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>401</x>
      <y>944</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //不能是.或者..
nd-&gt;last_type != LAST_NORM 
 //字符串最后一个字符是'\0'
 //不能是'\'
|| nd-&gt;last.name[nd-&gt;last.len]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>409</x>
      <y>938</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为O_CREAT
所以最后一个节点不能是目录
目录要通过mkdir创建</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>431</x>
      <y>945</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>408</x>
      <y>938</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在dir中查找nd.last</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>361</x>
      <y>959</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode = base-&gt;d_inode;
err = permission(inode, MAY_EXEC)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>372</x>
      <y>948</y>
      <w>66</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>640.0;10.0;310.0;90.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>390</x>
      <y>961</y>
      <w>15</w>
      <h>3</h>
    </coordinates>
    <panel_attributes> base-&gt;d_op-&gt;d_hash
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>948</y>
      <w>42</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
base-&gt;d_op &amp;&amp; base-&gt;d_op-&gt;d_hash</panel_attributes>
    <additional_attributes>400.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>406</x>
      <y>960</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cached_lookup
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>411</x>
      <y>948</y>
      <w>27</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在dentry_hashtable中查找</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>434</x>
      <y>948</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!dentry
如果在hash中没找到dentry</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>420</x>
      <y>960</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_alloc
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>424</x>
      <y>953</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
先alloc
是因为alloc可能睡</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>434</x>
      <y>961</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op-&gt;lookup
（reference）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>434</x>
      <y>953</y>
      <w>9</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>434</x>
      <y>953</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2中!dentry
表示没返回错误</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>451</x>
      <y>958</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>if (!dentry)
	dentry = new;
else
	dput(new)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>462</x>
      <y>940</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!dentry-&gt;d_inode
如果磁盘上没有这个文件</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>462</x>
      <y>962</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>462</x>
      <y>943</y>
      <w>8</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>474</x>
      <y>950</y>
      <w>15</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //释放父目录
dput(nd-&gt;dentry);
 //更新为文件的dentry
nd-&gt;dentry = dentry;
acc_mode = 0;
flag &amp;= ~O_TRUNC;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>462</x>
      <y>943</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>489</x>
      <y>940</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
存在这个文件</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>943</y>
      <w>7</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>491</x>
      <y>960</y>
      <w>43</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.O_CREAT|O_EXCL 如果这两个标志置上，表示文件必须得不存在
	所以这里检查O_EXCL，如果有，则报错文件存在
2.检查是否要打开的文件是否挂载设备 d_mountpoint
	如果挂载了，但是O_NOFOLLOW置上，则报错，
	如果O_NOFOLLOW没置上，则一直__follow_down到最后的文件
3.如果!dentry-&gt;d_inode，表示文件指向的最终文件不存在，
	返回错误
4.如果当前文件时符号链接（i_op-&gt;follow_link存在），去do_link

 //中间将dentry替换成寻找的文件
dput(nd-&gt;dentry);
nd-&gt;dentry = dentry;

5.dentry-&gt;d_inode &amp;&amp; S_ISDIR open不能打开目录
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>943</y>
      <w>94</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;480.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>597</x>
      <y>991</y>
      <w>3</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>ok
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>943</y>
      <w>275</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2730.0;540.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>777</x>
      <y>997</y>
      <w>7</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>do_link
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>760</x>
      <y>999</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
O_NOFOLLOW</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>757</x>
      <y>1008</y>
      <w>7</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>-ELOOP
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>768</x>
      <y>1007</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>UPDATE_ATIME</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>774</x>
      <y>999</y>
      <w>8</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>785</x>
      <y>1008</y>
      <w>25</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>dentry-&gt;d_inode-&gt;i_op-&gt;follow_link
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>774</x>
      <y>999</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注意这里nd中的flag还是之前path_init的
LOOKUP_PARENT</panel_attributes>
    <additional_attributes>60.0;10.0;200.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>812</x>
      <y>1008</y>
      <w>9</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>dput(dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>780</x>
      <y>999</y>
      <w>36</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>780</x>
      <y>999</y>
      <w>50</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>823</x>
      <y>1008</y>
      <w>35</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1. LAST_BIND（Procfs相关）
	dentry = nd-&gt;dentry;
	goto ok;
2.LAST_NORM ||  nd-&gt;last.name[nd-&gt;last.len]
	-EISDIR
3.counter==32
	dentry = nd-&gt;dentry;
	putname(nd-&gt;last.name);
	goto ok;
  注意：follow_link中虽然有循环的计数，
  			但是那是针对要寻找节点的，但是现在
  			要寻找的节点是 目标节点的父节点
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>485</x>
      <y>937</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_last
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>409</x>
      <y>936</y>
      <w>82</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;30.0;800.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>860</x>
      <y>1008</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //保存父目录
dir = nd-&gt;dentry;
dentry = lookup_hash(&amp;nd-&gt;last, nd-&gt;dentry);
 //找到了目标节点，释放其名称
putname(nd-&gt;last.name);
goto do_last;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>780</x>
      <y>999</y>
      <w>90</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;880.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>529</x>
      <y>1001</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.!inode 不存在inode
	-ENOENT
2.S_ISLNK 如果是符号链接
	-ELOOP
3.S_ISDIR &amp;&amp; FMODE_WRITE
  -EISDIR

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>536</x>
      <y>993</y>
      <w>64</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter
这些条件在某些情况下并没有被检查
（例如!(flag &amp; O_CREAT)）</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>316</x>
      <y>944</y>
      <w>10</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>acc_mode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>320</x>
      <y>902</y>
      <w>76</w>
      <h>44</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
"\000\004\002\006"[(x)&amp;O_ACCMODE]
注：1.ASCII中\ddd表示一个八进制的数
    2.这里字符串是一个指针，[]中时索引
    所以这里是将open_namei的权限转换成
    permission的权限</panel_attributes>
    <additional_attributes>740.0;10.0;190.0;130.0;10.0;420.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>552</x>
      <y>1003</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>permission</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>556</x>
      <y>993</y>
      <w>44</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>420.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>565</x>
      <y>1001</y>
      <w>30</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.S_ISFIFO  S_ISSOCK  S_ISBLK  S_ISCHR
	flag &amp;= ~O_TRUNC
2.IS_RDONLY &amp;&amp; (flag &amp; 2)
	是readonly安装，但是要求写 报-EROFS
3.如果sb只能添加IS_APPEND
	3.1但是 FMODE_WRITE &amp;&amp; ！O_APPEND
		要写，但是不是添加
	3.2.O_TRUNC 空白打开
	报-EPERM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>577</x>
      <y>993</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>596</x>
      <y>1002</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_lease</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>598</x>
      <y>993</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
文件“租借”相关</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>598</x>
      <y>993</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>626</x>
      <y>1001</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flag &amp; O_TRUNC</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>608</x>
      <y>1005</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>579</x>
      <y>1018</y>
      <w>30</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.检查inode-&gt;i_writecount是否小于0
	注：文件有可能通过mmap映射到内存中，
		这个时候进程访问内存和进程直接访问文件就
		需要互斥。所以就有了get_write_access和
		deny_write_access。当访问内存文件时，通过
		deny_write_access，将i_writecount置为负数
		如果此时另一个进程需要访问inode文件，需要通过
		get_write_access检查i_writecount是否小于0，
		如果小于0，则返回-ETXTBSY
2.增加inode-&gt;i_writecount的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>604</x>
      <y>1009</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_write_access</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>593</x>
      <y>1012</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>635</x>
      <y>1008</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_verify_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>626</x>
      <y>1005</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>629</x>
      <y>1011</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查强制锁</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>622</x>
      <y>1015</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>MANDATORY_LOCK</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>610</x>
      <y>1023</y>
      <w>48</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.检查sb中的s_flags是否有MS_MANDLOCK
2.并且inode中i_mode的S_ISGID置上，但是S_IXGRP没置
	注：1.强制锁指的是操作系统在进程访问文件时，主动加锁（fcntl）
			协调锁是进程在调用的过程中自己主动加锁
			（进程通过一次系统调用实现读或写的时候，对于进程本身是“原子”的
			因为进程在内核中不会因为时间而发生进程的切换，但是在对一个文件做
			多次的读写操作时，这个过程就不可能是“原子的”）
		2.一般S_ISGID置上，就是为了以这个group的权限去执行文件，但是如果
			S_IXGRP没设置，这个对于这个实例是没有意义的，所以Unix就用这个标志
			来确定是否要给inode加强制锁
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>630</x>
      <y>1018</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>655</x>
      <y>1017</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_mandatory_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>645</x>
      <y>1011</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>659</x>
      <y>1024</y>
      <w>36</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>遍历inode-&gt;i_flock，如果fl-&gt;fl_flags
的FL_POSIX置上，但是fl_owner却不是
current-&gt;files，说明这个inode被其他进程锁上
所以返回-EAGAIN。遍历完，没有被自己以外的其
他进程锁上，就返回0.
注：1.每当进程对文件的一个区间加锁时，就会在
		链表中增加一个 file_lock结构，该结构中
		fl_start和fl_end确定这个区间
	2.FL_POSIX（ fcntl）支持对区间加锁，可以是强制锁，
		也可以是协调锁因为前面有MANDATORY_LOCK的检测，
	  所以这里是强制锁，
	  FL_FLOCK（ fcntl）是协调锁，只支持对整个文件加锁
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>665</x>
      <y>1020</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>672</x>
      <y>1010</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DQUOT_INIT</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>626</x>
      <y>1005</y>
      <w>53</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>669</x>
      <y>1015</y>
      <w>21</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_sb-&gt;dq_op-&gt;initialize
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>677</x>
      <y>1013</y>
      <w>4</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>709</x>
      <y>1011</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_truncate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>626</x>
      <y>1005</y>
      <w>90</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;880.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>706</x>
      <y>1024</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>attr-&gt;ia_ctime = now
attr-&gt;ia_atime
attr-&gt;ia_mtime
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>719</x>
      <y>1032</y>
      <w>16</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op-&gt;setattr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>737</x>
      <y>1031</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_change_ok</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>766</x>
      <y>1031</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_setattr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>715</x>
      <y>1020</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>725</x>
      <y>1020</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>727</x>
      <y>1022</y>
      <w>16</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode-&gt;i_op-&gt;setattr</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>739</x>
      <y>1022</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2没有setattr</panel_attributes>
    <additional_attributes>20.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>742</x>
      <y>1025</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>746</x>
      <y>1025</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>704</x>
      <y>1038</y>
      <w>37</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.ia_valid中ATTR_FORCE 置上，权限检查ok
2.ATTR_UID置上时
	fsuid要和inode-&gt;i_uid相等，并且如果attr-&gt;ia_uid和
	i_uid不相等，CAP_CHOWN就得置上
3.ATTR_GID置上时，以下三种情况要满足一个：
	1.attr-&gt;ia_gid在fsgid中，
	2.ia_gid等于i_gid
	3.CAP_CHOWN置上
4.ATTR_MODE置上时
	1.fsuid不等于inode-&gt;i_uid时，CAP_FOWNER得置上
	2.ia_gid（ATTR_GID）或者i_gid不在fsgid中时，
		CAP_FSETID得置上。
5.ATTR_MTIME_SET | ATTR_ATIME_SET有一个置上时：
	如果fsuid不等于i_uid，CAP_FOWNER得置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>724</x>
      <y>1034</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>744</x>
      <y>1039</y>
      <w>22</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.ATTR_UID时：
	inode-&gt;i_uid = attr-&gt;ia_uid
2.ATTR_GID时：
	inode-&gt;i_gid = attr-&gt;ia_gid
3.ATTR_SIZE时：
	vmtruncate(inode, attr-&gt;ia_size)
4.ATTR_ATIME时：
	inode-&gt;i_atime = attr-&gt;ia_atime
5.ATTR_MTIME时：
	inode-&gt;i_mtime = attr-&gt;ia_mtime
6.ATTR_CTIME时：
	inode-&gt;i_ctime = attr-&gt;ia_ctime
7.ATTR_MODE时：
	inode-&gt;i_mode = attr-&gt;ia_mode
	如果inode-&gt;i_gid不在fsgid中，但是CAP_FSETID没置上时：
		inode-&gt;i_mode &amp;= ~S_ISGID
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>753</x>
      <y>1034</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>682</x>
      <y>1019</y>
      <w>31</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>newattrs.ia_size = length;
newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>697</x>
      <y>1014</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>720</x>
      <y>1017</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>notify_change</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>713</x>
      <y>1014</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>772</x>
      <y>1034</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>782</x>
      <y>1037</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_inode_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>786</x>
      <y>1040</y>
      <w>48</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
没I_DIRTY
I_DIRTY是指I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES
全置上</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>781</x>
      <y>1046</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__mark_inode_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>768</x>
      <y>1053</y>
      <w>16</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_state |= flags
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>774</x>
      <y>1049</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
此时flag传的是I_DIRTY</panel_attributes>
    <additional_attributes>130.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>780</x>
      <y>1049</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode在hash中时
从inode_in_use或者inode_unused中删除
添加到s_dirty中</panel_attributes>
    <additional_attributes>70.0;10.0;200.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>792</x>
      <y>1054</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_del(&amp;inode-&gt;i_list);
list_add(&amp;inode-&gt;i_list, &amp;sb-&gt;s_dirty);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>787</x>
      <y>1025</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setattr_mask</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>805</x>
      <y>1025</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_dir_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>725</x>
      <y>1020</y>
      <w>69</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>725</x>
      <y>1020</y>
      <w>89</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;870.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>628</x>
      <y>1001</y>
      <w>123</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flag中O_TRUNC没置上
但是FMODE_WRITE置上</panel_attributes>
    <additional_attributes>10.0;10.0;1210.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>743</x>
      <y>1005</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DQUOT_INIT</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>730</x>
      <y>1009</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_write_access</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>626</x>
      <y>1005</y>
      <w>112</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>449</x>
      <y>867</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请file与dentry关联</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>478</x>
      <y>874</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>450</x>
      <y>884</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_empty_filp</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>454</x>
      <y>877</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>430</x>
      <y>892</y>
      <w>41</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.如果files_stat.nr_free_files大于NR_RESERVED_FILES
	1.从free_list中申请一个file
		f = list_entry(free_list.next, struct file, f_list);
		list_del(&amp;f-&gt;f_list);
		files_stat.nr_free_files--;
	2.对file进行初始化
		memset(f, 0, sizeof(*f));
		atomic_set(&amp;f-&gt;f_count,1);
		f-&gt;f_version = ++event;
		f-&gt;f_uid = current-&gt;fsuid;
		f-&gt;f_gid = current-&gt;fsgid;
		//暂时加到anon_list链表中
		list_add(&amp;f-&gt;f_list, &amp;anon_list);
2.剩余file的数量小于要reserve的，并且之歌数量不为0，uid为0
	也做1.1和1.2
3.如果上述两个条件都不满足
	1.如果files_stat.nr_files &lt; files_stat.max_files
		就向filp_cachep申请file（kmem_cache_alloc），并
		增加计数（files_stat.nr_files++），然后通过1.2进行初始化
	2.否则返回NULL（静态变量old_max做到只提示一次）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>446</x>
      <y>887</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>473</x>
      <y>892</y>
      <w>26</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>f-&gt;f_flags = flags;
 //flags转换成file的read/write标志
f-&gt;f_mode = (flags+1) &amp; O_ACCMODE;
inode = dentry-&gt;d_inode;
if (f-&gt;f_mode &amp; FMODE_WRITE)
	get_write_access
f-&gt;f_dentry = dentry;
f-&gt;f_vfsmnt = mnt;
f-&gt;f_pos = 0;
f-&gt;f_reada = 0;
 //如果(fops) &amp;&amp; (fops)-&gt;owner存在
 //增加owner的计数，返回inode-&gt;i_fop
f-&gt;f_op = fops_get(inode-&gt;i_fop);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>483</x>
      <y>877</y>
      <w>4</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>483</x>
      <y>877</y>
      <w>30</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode-&gt;i_sb存在
将f_list添加到
inode-&gt;i_sb-&gt;s_files中</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>504</x>
      <y>892</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file_move</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>501</x>
      <y>899</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>list_del(&amp;file-&gt;f_list);
list_add(&amp;file-&gt;f_list, list);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>509</x>
      <y>895</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>483</x>
      <y>877</y>
      <w>51</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
f-&gt;f_op-&gt;open
附加操作</panel_attributes>
    <additional_attributes>10.0;10.0;490.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>526</x>
      <y>892</y>
      <w>11</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>f-&gt;f_op-&gt;open
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>519</x>
      <y>902</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_open_file</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>524</x>
      <y>894</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>500</x>
      <y>908</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>当f_flags中O_LARGEFILE没置上时
 inode-&gt;i_size不能大于2G
 (如果O_LARGEFILE置上，高32位在
	i_high_size中，其低32位为ext2_inode
	中的i_size，两者合起来为i_size是64位整数)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>513</x>
      <y>905</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>553</x>
      <y>886</y>
      <w>35</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>f-&gt;f_flags &amp;= 
~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>483</x>
      <y>877</y>
      <w>83</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将打开时用的flag给清掉</panel_attributes>
    <additional_attributes>10.0;10.0;810.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>407</x>
      <y>970</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //umask置1的位表示该进程对组没有响应的权限
mode &amp;= S_IALLUGO &amp; ~current-&gt;fs-&gt;umask;
mode |= S_IFREG;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>446</x>
      <y>971</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>may_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>426</x>
      <y>977</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.child-&gt;d_inode不能存在
2.i_flags中S_DEAD不能置上，
	S_DEAD表示inode被删除，但是count不为0
3.检查父节点的MAY_WRITE | MAY_EXEC权限
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>462</x>
      <y>971</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_op-&gt;create
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>389</x>
      <y>987</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>393</x>
      <y>974</y>
      <w>90</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_dir_inode_operations</panel_attributes>
    <additional_attributes>760.0;10.0;670.0;110.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>420</x>
      <y>965</y>
      <w>50</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>450</x>
      <y>965</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>467</x>
      <y>965</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>443</x>
      <y>974</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>288</x>
      <y>993</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_new_inode
1.内存中申请管理结构new_inode
2.在磁盘上寻找inode
	1.找到对应的group
	2.在group的位图中找到对应空闲inode号
	3.对group的硬盘信息更新
3.根据硬件和进程信息初始化内存inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>293</x>
      <y>990</y>
      <w>103</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1010.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>87</x>
      <y>1016</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>filter
1.!dir || !dir-&gt;i_nlink
	父节点不能为空，存在和这个inode相关的目录项
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>105</x>
      <y>996</y>
      <w>189</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1870.0;10.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>120</x>
      <y>1017</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>new_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>125</x>
      <y>996</y>
      <w>170</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sb</panel_attributes>
    <additional_attributes>1680.0;10.0;10.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>104</x>
      <y>1025</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_empty_inode
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>110</x>
      <y>1020</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>119</x>
      <y>1026</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_sb = sb;
inode-&gt;i_dev = sb-&gt;s_dev;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>124</x>
      <y>1020</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>156</x>
      <y>1012</y>
      <w>35</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISDIR</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>138</x>
      <y>1025</y>
      <w>58</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.每个组平均inode的数量
avefreei = le32_to_cpu(es-&gt;s_free_inodes_count) /
			sb-&gt;u.ext2_sb.s_groups_count;
2.inode属于哪个group
i = dir-&gt;u.ext2_i.i_block_group;
3.（被注释）从i开始遍历所有的group，找到bg_used_dirs_count(目录的数量)*256
	低于bg_free_inodes_count（空闲inode数量）的group
注：1.遍历方式，遍历的次数（bg_free_inodes_count）和遍历的起始点（i）分开
	2.ext2_get_group_desc
		sb-&gt;u.ext2_sb.s_group_desc[group_desc].b_data+desc
		bh存储s_group_desc[group_desc]这个管理结构
4.如果没有找到相应的group，再次遍历所有的group，找到空闲inode数量（s_groups_count）
	大于avefreei的inode数量（这个条件使遍历少了一些），找到最大的bg_free_blocks_count
	的group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>188</x>
      <y>1012</y>
      <w>17</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不是目录文件</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>188</x>
      <y>996</y>
      <w>107</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
文件最好和父目录放在同一个group
但是子目录可以不放在同一个group</panel_attributes>
    <additional_attributes>1050.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>197</x>
      <y>1028</y>
      <w>45</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.获取当前dir所在的group
2，如果当前group存在空闲inode（bg_free_inodes_count不为0）
	就选取当前的group
3.如果当前group不存在空闲inode，以j &lt;&lt;= 1的方式，遍历所有的group
	找到有空闲inode的group
4.如果还没找到就通过线性查找所有的group，找到空闲inode的group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>249</x>
      <y>1008</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>load_inode_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>252</x>
      <y>996</y>
      <w>46</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>243</x>
      <y>1016</y>
      <w>52</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.要load的group要小于s_groups_count
2.一般将最近使用的group放在0号位
	所以利用程序执行的局部性，如果0号位就
	检测到了要加载的group，直接返回
3.如果设备对应的group总数（s_groups_count）
	小于加载数组的大小（EXT2_MAX_GROUP_LOADED）
	那么每个group都存在数组对应的group号下面
	如果在block_group号下没找到，就通过read_inode_bitmap
	读取group的位图
4.如果group的总数大于数组的大小，将已经加载到数组中的
	位图（s_loaded_inode_bitmaps）向后移一位，将0号空闲出来
	（注：如果数组包含当前group，就移当前group之前的位，如果不包含
	就将所有的s_loaded_inode_bitmaps向后移一位）。再看是否包含要查找的group，
	如果不包含就通过read_inode_bitmap将位图读入数组（s_loaded_inode_bitmaps
	如果小于EXT2_MAX_GROUP_LOADED，在再次加载的时候，应该++）
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>255</x>
      <y>1011</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>255</x>
      <y>1043</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_inode_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>263</x>
      <y>1040</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>230</x>
      <y>1051</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_get_group_desc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>236</x>
      <y>1046</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>204</x>
      <y>1054</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>194</x>
      <y>1062</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_group&lt;s_groups_count
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>227</x>
      <y>1054</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
计算group对应的bh
和在bh中的偏移</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>217</x>
      <y>1061</y>
      <w>39</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>group_desc = block_group / EXT2_DESC_PER_BLOCK(sb);
desc = block_group % EXT2_DESC_PER_BLOCK(sb);
s_group_desc[group_desc]不为空
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>258</x>
      <y>1061</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.bh存储管理结构s_group_desc[group_desc]
2.返回磁盘中的真实数据的内存偏移
	s_group_desc[group_desc]-&gt;b_data+desc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>237</x>
      <y>1054</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>265</x>
      <y>1052</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>264</x>
      <y>1046</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读取位图的inode
位图的inode号通过管理结构desc存储</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>279</x>
      <y>1052</y>
      <w>43</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>sb-&gt;u.ext2_sb.s_inode_bitmap_number[bitmap_nr] = block_group;
sb-&gt;u.ext2_sb.s_inode_bitmap[bitmap_nr] = bh;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>264</x>
      <y>1046</y>
      <w>40</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>281</x>
      <y>996</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_find_first_zero_bit
（find_first_zero_bit）
&lt;EXT2_INODES_PER_GROUP</panel_attributes>
    <additional_attributes>150.0;10.0;60.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>276</x>
      <y>1003</y>
      <w>13</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>272</x>
      <y>1011</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_set_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>287</x>
      <y>1011</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_buffer_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>286</x>
      <y>1003</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>286</x>
      <y>1003</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MS_SYNCHRONOUS
如果同步就写超级块</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>303</x>
      <y>1010</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>ll_rw_block (WRITE, 1, &amp;bh);
wait_on_buffer (bh);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>295</x>
      <y>996</y>
      <w>46</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
计算inode号</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>328</x>
      <y>1010</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //i是group号
 //j是在group中的偏移索引
 //所以+1
j += i * EXT2_INODES_PER_GROUP(sb) + 1
 EXT2_FIRST_INO&lt;j&lt;s_inodes_count
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>360</x>
      <y>1005</y>
      <w>50</w>
      <h>88</h>
    </coordinates>
    <panel_attributes> //更新group中空闲inode数量
gdp-&gt;bg_free_inodes_count =
	cpu_to_le16(le16_to_cpu(gdp-&gt;bg_free_inodes_count) - 1);
 //如果是目录，更新group中目录的数量
if (S_ISDIR(mode))
	gdp-&gt;bg_used_dirs_count =
		cpu_to_le16(le16_to_cpu(gdp-&gt;bg_used_dirs_count) + 1);
 //标记group的管理结构dirty
mark_buffer_dirty(bh2);
 //更新设备空闲inode数量
es-&gt;s_free_inodes_count =
	cpu_to_le32(le32_to_cpu(es-&gt;s_free_inodes_count) - 1);
mark_buffer_dirty(sb-&gt;u.ext2_sb.s_sbh);
sb-&gt;s_dirt = 1;
inode-&gt;i_mode = mode;
 //注意inode的mode是fsuid，所以如果进程通过执行isuid文件改变相应的uid
 //其创建出来的文件也是改变之后的uid
inode-&gt;i_uid = current-&gt;fsuid;
 //sb在安装时GRPID置上，或者dir的S_ISGID置上
 //该目录下的i_gid都是目录的gid
 //否则就是进程的fsgid
if (test_opt (sb, GRPID))
	inode-&gt;i_gid = dir-&gt;i_gid;
else if (dir-&gt;i_mode &amp; S_ISGID) {
	inode-&gt;i_gid = dir-&gt;i_gid;
	if (S_ISDIR(mode))
		mode |= S_ISGID;
} else
	inode-&gt;i_gid = current-&gt;fsgid;

inode-&gt;i_ino = j;
inode-&gt;i_blksize = PAGE_SIZE;	
inode-&gt;i_blocks = 0;
inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = CURRENT_TIME;
inode-&gt;u.ext2_i.i_new_inode = 1;
inode-&gt;u.ext2_i.i_flags = dir-&gt;u.ext2_i.i_flags;
if (S_ISLNK(mode))
	inode-&gt;u.ext2_i.i_flags &amp;= ~(EXT2_IMMUTABLE_FL | EXT2_APPEND_FL);
inode-&gt;u.ext2_i.i_faddr = 0;
inode-&gt;u.ext2_i.i_frag_no = 0;
inode-&gt;u.ext2_i.i_frag_size = 0;
inode-&gt;u.ext2_i.i_file_acl = 0;
inode-&gt;u.ext2_i.i_dir_acl = 0;
inode-&gt;u.ext2_i.i_dtime = 0;
inode-&gt;u.ext2_i.i_block_group = i;
if (inode-&gt;u.ext2_i.i_flags &amp; EXT2_SYNC_FL)
	inode-&gt;i_flags |= S_SYNC;
 //如果文件没有sb就存放在anon_hash_chain
 //如果有sb就存放在inode_hashtable + hash(inode-&gt;i_sb, inode-&gt;i_ino)中
 //注：list_add是头插
insert_inode_hash(inode);
inode-&gt;i_generation = event++;
mark_inode_dirty(inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>295</x>
      <y>996</y>
      <w>81</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;790.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>332</x>
      <y>992</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op = &amp;ext2_file_inode_operations;
inode-&gt;i_fop = &amp;ext2_file_operations;
inode-&gt;i_mapping-&gt;a_ops = &amp;ext2_aops;
inode-&gt;i_mode = mode;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>346</x>
      <y>990</y>
      <w>49</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>364</x>
      <y>993</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>mark_inode_dirty
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>370</x>
      <y>990</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>393</x>
      <y>993</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>ext2_add_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>390</x>
      <y>990</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在目录中添加目录项</panel_attributes>
    <additional_attributes>30.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>417</x>
      <y>993</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>d_instantiate
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>391</x>
      <y>990</y>
      <w>36</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将inode和dir的管理结构关联</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>185</x>
      <y>812</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file.f_op
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>212</x>
      <y>812</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_fop
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>197</x>
      <y>812</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dentry_open</panel_attributes>
    <additional_attributes>10.0;20.0;150.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>243</x>
      <y>812</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de-&gt;proc_fops
ext2_file_operations
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>223</x>
      <y>812</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_read_inode
proc_get_inode
ext2_create
文件系统中给inode的操作函数赋值</panel_attributes>
    <additional_attributes>20.0;20.0;200.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>255</x>
      <y>812</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_register
proc_register
proc_root</panel_attributes>
    <additional_attributes>10.0;20.0;220.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>277</x>
      <y>812</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_file_operations
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>211</x>
      <y>822</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>242</x>
      <y>823</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de-&gt;proc_iops
ext2_file_inode_operations
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>222</x>
      <y>822</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_read_inode
proc_get_inode
ext2_create
文件系统中给inode的操作函数赋值</panel_attributes>
    <additional_attributes>20.0;20.0;200.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>272</x>
      <y>823</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_dir_inode_operations
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>254</x>
      <y>823</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_register
proc_register
proc_root</panel_attributes>
    <additional_attributes>10.0;20.0;180.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>532</x>
      <y>894</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISCHR
def_chr_fops</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>543</x>
      <y>901</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>chrdev_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>535</x>
      <y>909</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_chrfops</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>540</x>
      <y>904</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filp-&gt;f_op</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>577</x>
      <y>906</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>548</x>
      <y>904</y>
      <w>37</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>531</x>
      <y>915</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fops_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>536</x>
      <y>912</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>500</x>
      <y>923</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.查看chrdevs[major].fops是否存在
2.如果存在，且对应的owner module存在
	增加module的计数，并返回fops，如果不存在
	owner，直接返回fops
3、如果不存在，直接返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>517</x>
      <y>918</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>535</x>
      <y>922</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果能找到major的fops，并且是终端设备
	（major是TTY_MAJOR或者TTYAUX_MAJOR）
2.如果需要need_serial，通过fops_put将找到的
	fops释放，之后利用内核提供的module
	need_serial(get_tty_driver)：
	遍历tty_drivers，看其中是否有一个driver，其
	和device相同的 major，并且minor要在dirver
	的minor_start~ minor_start + p-&gt;num之间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>535</x>
      <y>918</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>570</x>
      <y>923</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //请求char-major-x  module
sprintf(name, "char-major-%d", major);
request_module(name);
 //获取fops
ret = fops_get(chrdevs[major].fops);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>535</x>
      <y>918</y>
      <w>47</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果fops为NULL</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1057</x>
      <y>918</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>532</x>
      <y>894</y>
      <w>531</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_fops</panel_attributes>
    <additional_attributes>10.0;10.0;5290.0;240.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1040</x>
      <y>921</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据inode获得虚拟设备devfs_entrylt</panel_attributes>
    <additional_attributes>210.0;10.0;18.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1030</x>
      <y>926</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_devfs_entry_from_vfs_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1047</x>
      <y>931</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果是S_ISDIR，goto out
2.de-&gt;registered为false， -ENODEV
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1057</x>
      <y>921</y>
      <w>6</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1073</x>
      <y>931</y>
      <w>55</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.file-&gt;private_data = de-&gt;info
2.S_ISBLK：
	file-&gt;f_op = &amp;def_blk_fops
	//如果df-&gt;ops存在
	inode-&gt;i_bdev-&gt;bd_op = df-&gt;ops
	其他：
	file-&gt;f_op=df-&gt;ops
3.如果file-&gt;f_op存在，且桥接的fop要求open（file-&gt;f_op-&gt;open）
	(*file-&gt;f_op-&gt;open) (inode, file)
4.如果file-&gt;f_op不存在
	如果是S_ISCHR，通过chrdev_open从chrdevs获取fops，并且
	执行桥接的filp-&gt;f_op-&gt;open
	如果是其他设备，返回-ENODEV
5.如果df已经打开（df-&gt;open为true），返回
6.如果df没打开，df-&gt;open = TRUE
7，如果要求自动owner（df-&gt;auto_owner）
	de-&gt;inode.mode = (de-&gt;inode.mode &amp; ~S_IALLUGO) |(de-&gt;mode &amp; S_IRWXUGO);
	de-&gt;inode.uid = current-&gt;euid;
	de-&gt;inode.gid = current-&gt;egid;
	inode-&gt;i_mode = de-&gt;inode.mode;
	inode-&gt;i_uid = de-&gt;inode.uid;
	inode-&gt;i_gid = de-&gt;inode.gid;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1060</x>
      <y>921</y>
      <w>34</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1132</x>
      <y>930</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfsd_notify_one</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1060</x>
      <y>921</y>
      <w>80</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
df-&gt;aopen_notify</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;80.0;780.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>533</x>
      <y>894</y>
      <w>627</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISBLK
def_blk_fops</panel_attributes>
    <additional_attributes>10.0;10.0;6250.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1153</x>
      <y>918</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1126</x>
      <y>925</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdev = inode-&gt;i_bdev
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1131</x>
      <y>921</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1155</x>
      <y>921</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bdev-&gt;bd_op不存在</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1149</x>
      <y>926</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_blkfops</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1138</x>
      <y>934</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.major不能为0，并且要小于MAX_BLKDEV
2.如果blkdevs[major].bdops不存在，通过
	request_module安装module
3.返回blkdevs[major].bdops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1150</x>
      <y>929</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1157</x>
      <y>921</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1167</x>
      <y>928</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果没找到了bd_op，返回ENXIO
2.如果找到了，并且bdev-&gt;bd_op-&gt;open存在，
	通过这个函数对file的op进行桥接
3.如果正确返回，atomic_inc(&amp;bdev-&gt;bd_openers)
	如果没有，且没有bd_openers：
	bdev-&gt;bd_op = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1174</x>
      <y>942</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdev-&gt;bd_op-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>938</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1181</x>
      <y>945</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_fops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1176</x>
      <y>949</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1150</x>
      <y>954</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_info_ptr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>952</y>
      <w>29</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1132</x>
      <y>961</y>
      <w>28</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.通过major在ide_hwifs（接口）找到对应的类型
	hwif-&gt;present &amp;&amp; major == hwif-&gt;major
2.通过minor在hwif-&gt;drives中找到特定种类的
	设备（ide_drive_t）
3.如果drive-&gt;present置上，返回设备
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1147</x>
      <y>957</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>952</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;driver == NULL
如果设备中没有相应的操作</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1173</x>
      <y>954</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>80.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1168</x>
      <y>957</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_driver_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1161</x>
      <y>962</y>
      <w>28</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果之前有ide interface检测到
	直接将ide_modules链表中module-&gt;init
	然后在revalidate_drives
2.如果没有ide interface检测到
	通过ide_probe_module检测module
	然后在初始化ide_modules链表中的module
	并执行revalidate_drives
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>960</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1158</x>
      <y>976</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_probe_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1163</x>
      <y>973</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1150</x>
      <y>979</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!ide_probe
请求安装ide-probe-mod</panel_attributes>
    <additional_attributes>120.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1147</x>
      <y>983</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1160</x>
      <y>984</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_probe-&gt;init
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1160</x>
      <y>979</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_probe存在</panel_attributes>
    <additional_attributes>20.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1177</x>
      <y>983</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>revalidate_drives</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1161</x>
      <y>979</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1183</x>
      <y>973</y>
      <w>4</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1161</x>
      <y>986</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历所有ide interface的设备（注意这里都是实体，没有指针）
查看drive-&gt;revalidate是否置上，如果置上并且没被初始化
（!initializing）</panel_attributes>
    <additional_attributes>220.0;10.0;160.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1170</x>
      <y>992</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_revalidate_disk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1191</x>
      <y>958</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>955</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果时具体的设备被拆除
根据drive-&gt;media安装</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1205</x>
      <y>958</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>while (drive-&gt;busy)
	sleep_on(&amp;drive-&gt;wqueue);
drive-&gt;usage++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>952</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1230</x>
      <y>959</y>
      <w>15</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>DRIVER(drive)-&gt;open
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>953</y>
      <w>57</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;driver != NULL</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1237</x>
      <y>961</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
idedisk_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1231</x>
      <y>966</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>idedisk_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1230</x>
      <y>973</y>
      <w>18</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>MOD_INC_USE_COUNT
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1237</x>
      <y>969</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>564</x>
      <y>911</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memory_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>568</x>
      <y>908</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
memory_fops</panel_attributes>
    <additional_attributes>160.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>557</x>
      <y>913</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MINOR=3</panel_attributes>
    <additional_attributes>150.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>551</x>
      <y>916</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op = &amp;null_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>571</x>
      <y>914</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果filp-&gt;f_op-&gt;open
不为空，继续桥接</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>581</x>
      <y>917</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>648</x>
      <y>914</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty_open
1.识别设备号
2.通过设备号，找到tty_driver，并通过driver找到tty
3.tty链路层ldisc.open
4.tty.driver.open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>584</x>
      <y>909</y>
      <w>70</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty_fops</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>599</x>
      <y>920</y>
      <w>47</w>
      <h>44</h>
    </coordinates>
    <panel_attributes>1.存储noctty(表示进程如果没有代开tty，第一次打开tty
	会将打开的tty作为进程的tty，但是如果这个标志置上，
	则不会成为进程的tty)
	noctty = filp-&gt;f_flags &amp; O_NOCTTY
2.如果是/dev/tty，需要检查current-&gt;tty，如果存在
	获取设备号
	device = current-&gt;tty-&gt;device
	 filp-&gt;f_flags |= O_NONBLOCK
3.如果是/dev/tty0，获取前台console（fg_console），因为
	fg_console是从0开始计数，tty*是从1开始计数，所以：
	device = MKDEV(TTY_MAJOR, fg_console + 1);
	noctty = 1;
4.如果是/dev/console，查找console_drivers链表中device
	存在的console，并获取设备号：
	device = c-&gt;device(c);
	filp-&gt;f_flags |= O_NONBLOCK; /* Don't let /dev/console block */
	noctty = 1
5.如果是/dev/ptmx,扫描伪终端主设备数组ptm_driver，根据driver组装
	device = MKDEV(driver-&gt;major, minor)
	然后试图init_dev，如果正确返回，ptmx_found
注：/dev/tty0，(4,0)系统当前虚拟终端，由键盘和显示器组成,
					可以通过CONFIG_VT开关
	/dev/tty,(5,0)当前进程使用的终端，可以是tty0，可以是URAT
					或者其他终端设备
	/dev/comsole，（5,1）系统当前使用的控制台，默认是tty0，也可以是URAT
	/dev/ptmx，是伪终端设备的总入口，在打开时临时分配设备号，参考P1190
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>618</x>
      <y>917</y>
      <w>39</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>654</x>
      <y>917</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>663</x>
      <y>920</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ptmx_found
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>647</x>
      <y>927</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>set_bit(TTY_PTY_LOCK, &amp;tty-&gt;flags)
 //算出伪终端设备在driver终端的偏移量
minor -= driver-&gt;minor_start
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>657</x>
      <y>923</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>675</x>
      <y>928</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devpts_pty_new</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>667</x>
      <y>923</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为slave创建inode</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>649</x>
      <y>937</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //获取devpts的sb
sb = devpts_mnt-&gt;mnt_sb
sbi = SBI(sb)
 //如果inode存在，则直接返回
if ( sbi-&gt;inodes[number] )
		return
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>657</x>
      <y>931</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>670</x>
      <y>936</y>
      <w>37</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>inode = new_inode(sb)
inode-&gt;i_ino = number+2;
inode-&gt;i_blocks = 0;
inode-&gt;i_blksize = 1024;
inode-&gt;i_uid = sbi-&gt;setuid ? sbi-&gt;uid : current-&gt;fsuid;
inode-&gt;i_gid = sbi-&gt;setgid ? sbi-&gt;gid : current-&gt;fsgid;
inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = CURRENT_TIME;
init_special_inode(inode, S_IFCHR|sbi-&gt;mode, kdev_t_to_nr(device))
 //因为new_inode可能睡，所以需要再次检查
if ( sbi-&gt;inodes[number] ) {
		iput(inode);
		return;
}
sbi-&gt;inodes[number] = inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>679</x>
      <y>931</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>705</x>
      <y>929</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty_register_devfs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>667</x>
      <y>923</y>
      <w>44</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为slave注册devfs</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>710</x>
      <y>932</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>708</x>
      <y>934</y>
      <w>22</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>tty.driver = *driver;
tty.device = MKDEV (driver-&gt;major, minor)

mode默认：mode = S_IFCHR | S_IRUSR | S_IWUSR
/dev/tty，/dev/ptmx加上：mode |= S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH

major=2（静态分配的伪终端主设备）flags |= DEVFS_FL_AUTO_OWNER
动态分配的伪终端主设备：flags |= DEVFS_FL_CURRENT_OWNER

devfs_register（name:tty-&gt;driver.name，idx + tty-&gt;driver.name_base嵌入到name中）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>743</x>
      <y>924</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>653</x>
      <y>917</y>
      <w>96</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;940.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>730</x>
      <y>930</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_tty_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>731</x>
      <y>937</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>遍历tty_drivers找到：
tty_driver.major = major
tty_driver.minor_start&lt;minor &lt; tty_driver.minor_start+tty_driver.num
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>735</x>
      <y>927</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>736</x>
      <y>933</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>748</x>
      <y>930</y>
      <w>38</w>
      <h>44</h>
    </coordinates>
    <panel_attributes>1.算出device在driver中偏移量
	idx = MINOR(device) - driver-&gt;minor_start
2.如果driver-&gt;table[idx]中的tty存在，就找到了，fast_track
3.如果没找到：
	1.通过alloc_tty_struct申请tty，然后通过initialize_tty_struct
		初始化，并初始化driver和device
		tty-&gt;device = device;
		tty-&gt;driver = *driver
	2.如果driver-&gt;termios[idx]不存在，通过kmalloc在cache中申请，
		并初始化为driver-&gt;init_termios
	3.如果driver-&gt;termios_locked[idx]不存在，通过kmalloc在cache中申请
		并初始化为0
	4.如果是伪终端设备（TTY_DRIVER_TYPE_PTY），通过alloc_tty_struct
		为另一设备申请tty，并通过initialize_tty_struct初始化，并设置device和driver
		o_tty-&gt;device = (kdev_t) MKDEV(driver-&gt;other-&gt;major,
					driver-&gt;other-&gt;minor_start + idx);
		o_tty-&gt;driver = *driver-&gt;other
		如果另一设备的termios不存在，通过kmalloc申请，并初始化为driver-&gt;other-&gt;init_termios
		如果另一设备的termios_locked不存在，通过kmalloc申请，并初始化为0
		driver-&gt;other-&gt;table[idx] = o_tty
		o_tty-&gt;termios = *o_tp_loc;
		o_tty-&gt;termios_locked = *o_ltp_loc
		(*driver-&gt;other-&gt;refcount)++
		如果是主设备（PTY_TYPE_MASTER），从设备：o_tty-&gt;count++
		建立起主从设备的联系：
		tty-&gt;link   = o_tty;
		o_tty-&gt;link = tty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>749</x>
      <y>927</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>751</x>
      <y>975</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_tty_struct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>737</x>
      <y>981</y>
      <w>40</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果PAGE_SIZE大于8k,则通过kmalloc在cache中申请
2.如果小于等于8k，通过get_zeroed_page从伙伴系统中申请
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>756</x>
      <y>978</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>775</x>
      <y>975</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>initialize_tty_struct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>782</x>
      <y>980</y>
      <w>28</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>memset(tty, 0, sizeof(struct tty_struct));
tty-&gt;magic = TTY_MAGIC;
 //分配链路层ldiscs
tty-&gt;ldisc = ldiscs[N_TTY];
tty-&gt;pgrp = -1; 
 //用于存储传递过来的目标码
tty-&gt;flip.char_buf_ptr = tty-&gt;flip.char_buf;
tty-&gt;flip.flag_buf_ptr = tty-&gt;flip.flag_buf;
tty-&gt;flip.tqueue.routine = flush_to_ldisc;
tty-&gt;flip.tqueue.data = tty;
init_MUTEX(&amp;tty-&gt;flip.pty_sem);
init_waitqueue_head(&amp;tty-&gt;write_wait);
init_waitqueue_head(&amp;tty-&gt;read_wait);
tty-&gt;tq_hangup.routine = do_tty_hangup;
tty-&gt;tq_hangup.data = tty;
sema_init(&amp;tty-&gt;atomic_read, 1);
sema_init(&amp;tty-&gt;atomic_write, 1);
spin_lock_init(&amp;tty-&gt;read_lock);
INIT_LIST_HEAD(&amp;tty-&gt;tty_files);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>784</x>
      <y>978</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>756</x>
      <y>973</y>
      <w>6</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>778</x>
      <y>973</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>788</x>
      <y>931</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>driver-&gt;table[idx] = tty
tty-&gt;termios = *tp_loc;
tty-&gt;termios_locked = *ltp_loc;
(*driver-&gt;refcount)++;
tty-&gt;count++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>749</x>
      <y>927</y>
      <w>51</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
处理新申请的tty，tp_loc，ltp_loc</panel_attributes>
    <additional_attributes>10.0;10.0;490.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>817</x>
      <y>931</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;ldisc.open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>749</x>
      <y>927</y>
      <w>76</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty_ldisc_N_TTY</panel_attributes>
    <additional_attributes>10.0;10.0;740.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>817</x>
      <y>938</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>n_tty_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>821</x>
      <y>934</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>801</x>
      <y>941</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!tty-&gt;read_buf
如果!tty-&gt;read_buf不存在</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>796</x>
      <y>945</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_buf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>790</x>
      <y>952</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1，如果在in_interrupt中，采用GFP_ATOMIC
	申请内存，否则使用GFP_KERNEL申请
	这个允许等待和同步
2.如果N_TTY_BUF_SIZE和PAGE_SIZE
	不相等，则通过kmalloc在cache中
	申请，并清0；否则通过get_zeroed_page
	在buddy中申请
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>800</x>
      <y>948</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>815</x>
      <y>947</y>
      <w>24</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>memset(tty-&gt;read_buf, 0, N_TTY_BUF_SIZE);
reset_buffer_flags(tty);
tty-&gt;column = 0;
n_tty_set_termios(tty, 0);
tty-&gt;minimum_to_wake = 1;
tty-&gt;closing = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>823</x>
      <y>941</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>815</x>
      <y>960</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reset_buffer_flags</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>819</x>
      <y>957</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>793</x>
      <y>967</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>tty-&gt;read_head = tty-&gt;read_tail = tty-&gt;read_cnt = 0
tty-&gt;canon_head = tty-&gt;canon_data = tty-&gt;erasing = 0
memset(&amp;tty-&gt;read_flags, 0, sizeof tty-&gt;read_flags)
 //tty.count不为0，tty-&gt;flags的TTY_THROTTLED置上时
 //执行tty-&gt;driver.unthrottle
check_unthrottle
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>808</x>
      <y>963</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>838</x>
      <y>961</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>n_tty_set_termios</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>828</x>
      <y>957</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置tty.process_char_map</panel_attributes>
    <additional_attributes>20.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>834</x>
      <y>931</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>o_tty-&gt;ldisc.open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>749</x>
      <y>927</y>
      <w>94</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果o_tty和o_tty-&gt;ldisc.open存在</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>855</x>
      <y>931</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fast_track
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>750</x>
      <y>927</y>
      <w>112</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在driver-&gt;table[idx]中有</panel_attributes>
    <additional_attributes>10.0;10.0;1100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>844</x>
      <y>939</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.测试tty-&gt;flags中TTY_CLOSING置上
	报错
2.如果是伪终端的主设备（如果此时tty.count
	存在，报错),将从设备tty-&gt;link-&gt;count++
3.更新tty
	tty-&gt;count++;
	tty-&gt;driver = *driver
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>853</x>
      <y>934</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>653</x>
      <y>917</y>
      <w>241</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2390.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>885</x>
      <y>926</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_dev_done
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>871</x>
      <y>934</y>
      <w>25</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>filp-&gt;private_data = tty
 //将file.list链接到tty-&gt;tty_files链表中
file_move
 //tty的count包括tty_files中的file的数量
 //+1（如果是伪终端从设备的或，加上主设备的）
check_tty_count
 //如果是伪终端主设备
noctty = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>875</x>
      <y>929</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>897</x>
      <y>934</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;driver.open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>889</x>
      <y>929</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>901</x>
      <y>937</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
con_init-&gt;console_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>870</x>
      <y>946</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
currcons是minor的偏移量</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>864</x>
      <y>954</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vc_allocate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>856</x>
      <y>957</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>852</x>
      <y>961</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>偏移量不能大于
虚拟终端的数量
否则返回-ENXIO
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>865</x>
      <y>957</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果vc_cons[currcons].d存在
返回0，如果不存在</panel_attributes>
    <additional_attributes>60.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>853</x>
      <y>962</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>834</x>
      <y>970</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.检查偏移量
2.检查进程的CAP_SYS_RESOURCE
	权限
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>862</x>
      <y>971</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>865</x>
      <y>962</y>
      <w>16</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请vc_data +vt_struct
的内存</panel_attributes>
    <additional_attributes>120.0;10.0;30.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>876</x>
      <y>969</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //指向vc_data
vc_cons[currcons].d
 //指向vt_struct
vt_cons[currcons]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>877</x>
      <y>962</y>
      <w>7</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>891</x>
      <y>969</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>visual_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>877</x>
      <y>962</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化 vc_cons[currcons].d
中的变量</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>880</x>
      <y>954</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>vt_cons[currcons]-&gt;vc_num = currcons;
tty-&gt;driver_data = vt_cons[currcons]
 //如果下面两项同时为0时
tty-&gt;winsize.ws_row = video_num_lines;
tty-&gt;winsize.ws_col = video_num_columns
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>897</x>
      <y>943</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>con_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>890</x>
      <y>946</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>913</x>
      <y>954</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vcs_make_devfs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>898</x>
      <y>946</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty-&gt;count == 1时
创建虚拟终端的buffer及属性的设备文件</panel_attributes>
    <additional_attributes>50.0;10.0;200.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>906</x>
      <y>964</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_unregister</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>925</x>
      <y>964</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_register
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>911</x>
      <y>960</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>918</x>
      <y>960</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>918</x>
      <y>957</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
（7，1~63）buffer
（7，129~191）attribute
devfs_handle是vcs_init中初始化为/dev/vcc</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>935</x>
      <y>935</y>
      <w>43</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.filp-&gt;f_flags = saved_flags
2.如果之前没错，测试现在如果不是特权用户
	访问TTY_EXCLUSIVE的tty，报EBUSY
3.如果之前有错，释放dev（release_dev）
	只有在是ERESTARTSYS错并且没有signal
	待处理时，会调度之后，然后再次通过filp-&gt;f_op = &amp;tty_fops
	重新open
	否则直接return
4.如果noctty没置上，并且时当前session的主进程（current-&gt;leader）
	且这个进程没有tty，tty.session不存在：
	current-&gt;tty = tty
	current-&gt;tty_old_pgrp = 0;
	tty-&gt;session = current-&gt;session;
	tty-&gt;pgrp = current-&gt;pgrp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>890</x>
      <y>929</y>
      <w>69</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>584</x>
      <y>909</y>
      <w>425</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_init-&gt;usb_major_init-&gt;usb_fops
如果在devfs中注册了，直接执行driver中的open</panel_attributes>
    <additional_attributes>10.0;10.0;4230.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1000</x>
      <y>920</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>991</x>
      <y>928</y>
      <w>32</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.获取usb_driver(usb_minors[minor/16]),并通过
	fops_get获取driver中的fops
2.如果fops存在，将其赋值：
	file-&gt;f_op = new_fops
	如果其中的open接口存在，执行
	file-&gt;f_op-&gt;open
3.如果执行出错，将fops还原：
	file-&gt;f_op = fops_get(old_fops)
4.释放旧的fops，注意这里不管出没出错，都应该释放掉
	这是释放之前的old_fops
	fops_put(old_fops)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1006</x>
      <y>923</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>997</x>
      <y>950</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1002</x>
      <y>946</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1002</x>
      <y>953</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_scanner_init-&gt;usb_register(scanner_driver)
-&gt;usb_scanner_fops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>997</x>
      <y>957</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>open_scanner</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>988</x>
      <y>964</y>
      <w>29</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.算出scanner在p_scn_table中的位置：
	scn_minor=MINOR((X)-&gt;i_rdev) - SCN_BASE_MNR
2.获取scn_usb_data(要存在，否则返回ENODEV)
	scn = p_scn_table[scn_minor]
	dev = scn-&gt;scn_dev
3.filter:
	1.dev要存在
	2.scanner要被初始化（scn-&gt;present）
	3.scanner没被打开（!scn-&gt;isopen）
4.init_waitqueue_head(&amp;scn-&gt;rd_wait_q)
	scn-&gt;isopen = 1
	file-&gt;private_data = scn
	MOD_INC_USE_COUNT
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1002</x>
      <y>960</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>533</x>
      <y>894</y>
      <w>714</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISFIFO
def_fifo_fops</panel_attributes>
    <additional_attributes>10.0;10.0;7120.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1239</x>
      <y>918</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fifo_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1202</x>
      <y>926</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过PIPE_SEM保护整个过程
2.如果没有申请inode-&gt;i_pipe，通过
	pipe_new申请fifo页面和pipe_inode_info
3.filp-&gt;f_version = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1211</x>
      <y>921</y>
      <w>36</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1228</x>
      <y>928</y>
      <w>36</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.桥接fops：
	filp-&gt;f_op = &amp;read_fifo_fops;
2.增加读端计数：
	//注：这里在pipe_new中被设置成1
	PIPE_RCOUNTER(*inode)++;
3.PIPE_READERS++，如果之前是0，通过
	wake_up_partner唤醒等待队列PIPE_WAIT
4.如果之前没有PIPE_WRITERS：
	1.如果要求O_NONBLOCK：
	filp-&gt;f_version = PIPE_WCOUNTER(*inode)
	并返回0
	2.如果要求block，通过wait_for_partner等待（pipe_wait）
		PIPE_RCOUNTER变化，如果醒来发现是信号唤醒，唤醒等待
		队列，并返回ERESTARTSYS
	注：如果此时reader和writer都没有，将整个pipe释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1245</x>
      <y>921</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filp-&gt;f_mode</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1238</x>
      <y>924</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1
只读</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1245</x>
      <y>924</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
２
只写</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1266</x>
      <y>928</y>
      <w>39</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果要求O_NONBLOCK，但是没有PIPE_READERS
	直接返回ENXIO
2.桥接fops：
	filp-&gt;f_op = &amp;write_fifo_fops
3.增加写端计数：
	PIPE_WCOUNTER(*inode)++
4.PIPE_WRITERS(*inode)++，如果之前没有writer
	通过唤醒PIPE_WAIT
5.如果没有reader，通过wait_for_partner等待PIPE_RCOUNTER
	计数不同。如果醒来之后，发现是信号唤醒，释放PIPE_WRITERS
	如果减至0，唤醒等待队列。
注：在５的时候肯定是要求ｂｌｏｃｋ的
	如果最后ｒｅａｄｅｒ和ｗｒｉｔｅｒ都没有，释放ｐｉｐｅ
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1245</x>
      <y>924</y>
      <w>68</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
３
可读可写</panel_attributes>
    <additional_attributes>10.0;10.0;660.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1306</x>
      <y>928</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>１.PIPE_READERS(*inode)++;
	PIPE_WRITERS(*inode)++;
	PIPE_RCOUNTER(*inode)++;
	PIPE_WCOUNTER(*inode)++;
２.如果之前没有ｒｅａｄｅｒ或者ｗｒｉｔｅｒ
	尝试通过wake_up_partner唤醒等待队列
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1410</x>
      <y>847</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_close</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1355</x>
      <y>858</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.fd不能大于max_fds
2，files-&gt;fd[fd]不能为空
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1363</x>
      <y>850</y>
      <w>55</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>530.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1380</x>
      <y>858</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>files-&gt;fd[fd] = NULL;
 //当进程通过execv时，close_on_exec
 //指示要关闭的文件
FD_CLR(fd, files-&gt;close_on_exec);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1390</x>
      <y>850</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1410</x>
      <y>859</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__put_unused_fd
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1415</x>
      <y>850</y>
      <w>5</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1432</x>
      <y>860</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp_close</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1415</x>
      <y>850</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1402</x>
      <y>863</y>
      <w>37</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1396</x>
      <y>870</y>
      <w>15</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.file.f_count不为0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1420</x>
      <y>863</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果文件系统想在文件关闭之前
将文件写入到设备中
（filp-&gt;f_op-&gt;flush存在）</panel_attributes>
    <additional_attributes>170.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1418</x>
      <y>870</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;flush
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1436</x>
      <y>870</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fcntl_dirnotify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1453</x>
      <y>870</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_remove_posix</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1437</x>
      <y>863</y>
      <w>9</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TODO:</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1437</x>
      <y>863</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1474</x>
      <y>870</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1437</x>
      <y>863</y>
      <w>44</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1459</x>
      <y>873</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历inode-&gt;i_flock链表
将该进程（owner）对该文件上的
所有POSIX锁都清掉
TODO:</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1454</x>
      <y>881</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_unlock_delete</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1471</x>
      <y>879</y>
      <w>33</w>
      <h>37</h>
    </coordinates>
    <panel_attributes> //递减file的引用计数
if (atomic_dec_and_test(&amp;file-&gt;f_count)) {
	//如果此时file引用减到0
	//移除协调锁 TODO:
	locks_remove_flock(file);
  //对应ext2_release_file ，将预分配的数据块释放
	if (file-&gt;f_op &amp;&amp; file-&gt;f_op-&gt;release)
		file-&gt;f_op-&gt;release(inode, file);
	//递减模块的动态安装计数
	fops_put(file-&gt;f_op);
	file-&gt;f_dentry = NULL;
	file-&gt;f_vfsmnt = NULL;
	//在dentry_open中get_write_access
	if (file-&gt;f_mode &amp; FMODE_WRITE)
		put_write_access(inode);
	dput(dentry);
	if (mnt)
		mntput(mnt)
	//从sb的s_files中移到free_list中
	list_del(&amp;file-&gt;f_list);
	list_add(&amp;file-&gt;f_list, &amp;free_list);
	files_stat.nr_free_files++;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1481</x>
      <y>873</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1496</x>
      <y>919</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;release
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1484</x>
      <y>915</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1475</x>
      <y>926</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_read_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1482</x>
      <y>922</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
read_pipe_fops
</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1496</x>
      <y>926</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_write_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1498</x>
      <y>922</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
write_pipe_fops
</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1487</x>
      <y>933</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1480</x>
      <y>929</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
第二个参数是读权限
第三个参数是写权限</panel_attributes>
    <additional_attributes>20.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1493</x>
      <y>929</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1481</x>
      <y>941</y>
      <w>34</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.通过信号量inode.sem对整个过程进行保护
2.递减PIPE_READERS和PIPE_WRITERS的计数
3.如果readers和writers都为0：
	//释放fifo缓存，释放i_pipe
	inode-&gt;i_pipe = NULL;
	free_page((unsigned long) info-&gt;base);
	kfree(info);
4.如果不是都为0，通过wake_up_interruptible唤醒
	i_pipe的等待队列
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1492</x>
      <y>936</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1507</x>
      <y>922</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
socket_file_ops
</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1535</x>
      <y>926</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_close</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1541</x>
      <y>929</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1529</x>
      <y>933</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.file的inode要存在
2.通过sock_fasync撤销（第三个参数为0）file在sock上的异步等待
3.通过sock_release将sock释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1527</x>
      <y>943</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_fasync</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1533</x>
      <y>939</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1516</x>
      <y>949</y>
      <w>34</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.如果是插入异步监听（on），通过kmalloc申请一个fasync_struct
2.通过socki_lookup找到sock（本file的sock）
3.遍历sock.fasync_list链表
	1.查看其中是否有和当前file相同的fasync_struct
	2.如果是插入异步监听（on）
		1.如果3.1中查到有和当前file相同的fasync_struct：
			fa-&gt;fa_fd=fd;
			kfree(fna)//释放1申请的fasync_struct
		2.如果没有相同的fasync_struct，将其赋值后，头插至sock-&gt;fasync_list
	3.如果是撤销异步监听
		1.如果找到了fasync_struct，将其从链表中删除：
			*prev=fa-&gt;fa_next;
			kfree(fa)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1532</x>
      <y>946</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1563</x>
      <y>944</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1545</x>
      <y>939</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1554</x>
      <y>950</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过sock-&gt;ops-&gt;release将sock释放
2.如果fasync_list不为空，打印报错信息
 （fasync_list在有链接时会在unix_release_sock中sk_wake_async遍历唤醒）
3.sockets_in_use.counter--
4.如果sock没有file，通过iput将sock对应的inode释放
5.sock-&gt;file=NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1569</x>
      <y>947</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1564</x>
      <y>968</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1564</x>
      <y>962</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;release
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1569</x>
      <y>959</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1569</x>
      <y>965</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops/unix_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1559</x>
      <y>975</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果sock没分配sk，直接返回0
2.如果有分配：
	sock-&gt;sk = NULL
3.通过unix_release_sock释放sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1569</x>
      <y>971</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1563</x>
      <y>986</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_release_sock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1569</x>
      <y>982</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1547</x>
      <y>993</y>
      <w>56</w>
      <h>62</h>
    </coordinates>
    <panel_attributes>1.通过unix_remove_socket将sk从hash表中删除
	//通过af_unix.lock保护整个过程
2.通过sock_orphan使sk关系断开：
	sk-&gt;dead = 1;
	sk-&gt;socket = NULL;
	sk-&gt;sleep = NULL;
注；整个过程被callback_lock保护，所以如果单独读dead，可以对callback_lock上读锁
	但是在读dead时，还有读shutdown等变量，所以大多数时用的是af_unix.loc
3.置shutdown，分别将sk的dentry，mnt，state取出来，然后将sk的这三个属性清除
	sk-&gt;shutdown = SHUTDOWN_MASK;
	dentry = sk-&gt;protinfo.af_unix.dentry;
	sk-&gt;protinfo.af_unix.dentry=NULL;
	mnt = sk-&gt;protinfo.af_unix.mnt;
	sk-&gt;protinfo.af_unix.mnt=NULL;
	state = sk-&gt;state;
	sk-&gt;state = TCP_CLOSE;
	//释放af_unix.lock锁
4.通过wake_up_interruptible_all唤醒peer_wait等待队列
注：1.peer_wait只有在无连接发送的时候receive_queue超出限制时，会使用这个队列
	2.sleep在有链接发送时，senbuf满了之后会用；或者在接收时（不管有链接还是无连接）
		receive_queue中没有skb会用
	3.最重要，在有链接connect时，会将sleep队列指向peer_wait
5.通过unix_peer获取与sk连接的skpair，如果skpair存在时：
	1.如果是有链接（SOCK_STREAM），
		skpair-&gt;shutdown=SHUTDOWN_MASK
		skpair-&gt;err = ECONNRESET //receive_queue不为空，或者调用者要求（参数是1）
		skpair-&gt;state_change(skpair)//通知skpair状态改变
		sk_wake_async(skpair,1,POLL_HUP)//唤醒skpair对应sock的异步队列
	2.不管是有链接还是无连接：
		sock_put(skpair)
		unix_peer(sk) = NULL
6.通过skb_dequeue从sk.receive_queue
	1.如果现在释放的sk处于TCP_LISTEN状态（3中存储的）所以skb存储的是client端connect报文，
		递归调用unix_release_sock释放skb中对应的子serve_sock，注意调用参数是1，会强行将sk.err置上
	2.通过kfree_skb释放skb(不仅包含skb空间，包含sendbuf，发送方sk计数，发送方sk.cb中的fp数组，以及数组中的file)
7.释放dentry，mnt以及自己的sk（sock_put(sk)）
8.如果有还没被接收的file（unix_tot_inflight），通过unix_gc查看sk的hash表中是否有没被用户引用，但是被内核引用（inflight）
	的file（比如a将自己的sock_file授权给b，b也将自己的sock_file授权给a，但是a和b都没接收就close，因为在授权时，内核skb会递增
	对file的引用，导致两个进程都释放了file，但是file因为被skb引用没办法释放，而进程却没办法自己主动释放，所以只能由内核释放）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1569</x>
      <y>989</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1548</x>
      <y>1065</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_def_wakeup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1548</x>
      <y>1058</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skpair-&gt;state_change
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1555</x>
      <y>1054</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1553</x>
      <y>1061</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1540</x>
      <y>1072</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果sk-&gt;sleep不为空，通过wake_up_interruptible_all
	唤醒这个等待队列
注；callback_lock保护
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1553</x>
      <y>1068</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1578</x>
      <y>1057</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_gc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1579</x>
      <y>1054</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1567</x>
      <y>1064</y>
      <w>49</w>
      <h>47</h>
    </coordinates>
    <panel_attributes>1.申请静态信号量unix_gc_sem，down_trylock保证只能有
	一个进程处理
 //unix_table_lock保护hash表操作
2.遍历unix_socket_table表中所有bind的sk
	af_unix.gc_tree=GC_ORPHAN //之后用于栈的链表
3.再次遍历unix_socket_table表中所有bind的sk，查找其中sock_file的计数超过sk的inflight计数
	的sk（因为只有大于才是有用户引用而不全是内核引用），通过maybe_unmark_and_push将其压栈（注意
	栈中的sk是不应该被处理的sk）
4.通过empty_stack检查栈gc_current是否为空
	1.通过pop_stack将sk弹出
	//receive_queue.lock保护skb移出队列
	2.通过skb_peek查看队列中第一个skb
	3.如果队列中有skb，遍历链表中的所有skb（注意这里的skb被没有从链表中移除）
		1.如果skb.cb中有fp，遍历其fp数组。通过unix_get_socket查看这个file是否对应sk，如果对应
			那么这个sk也被用户引用（因为这个skb一旦被接收，就会被用户引用，到时候用户自己释放），所以通过
			maybe_unmark_and_push将这个file对应的sk压栈
		2.如果sk的状态是TCP_LISTEN，说明这个skb是client的控制报文，skb.sk指向的子serve_sk（这个也会被父serve_sk接收）
			所以也会通过maybe_unmark_and_push将这个sk压栈
	4.通过sock_put将sk释放（因为maybe_unmark_and_push中增加了对sk的计数，但是pop_stack中却没有减少）
注：1.在这期间系统过maybe_unmark_and_push加入栈中的sk也会随着!empty_stack被遍历到，所以所以不是GC_ORPHAN
	的sk都会经历pop_stack，sock_put，最终栈的状态也会是empty_stack
	2.在栈中的sk不会重复压栈，因为maybe_unmark_and_push在开始就检查了GC_ORPHAN
5.通过skb_queue_head_init初始化链表hitlist
6.遍历unix_socket_table表中所有bind的sk，
	1.如果是GC_ORPHAN，并且其skb.cb.fp存在，将receive_queue中的所有skb放到hitlist
		__skb_unlink(skb, skb-&gt;list);
		__skb_queue_tail(&amp;hitlist,skb);
	2.最后将所有sk的状态都置为GC_ORPHAN
7.通过__skb_dequeue将hitlist中所有的skb移出队列，并通过kfree_skb将其释放
	（不仅包含skb空间，包含sendbuf，发送方sk计数，发送方sk.cb中的fp数组，以及数组中的file)）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1584</x>
      <y>1060</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1567</x>
      <y>1115</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>maybe_unmark_and_push</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1576</x>
      <y>1110</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1558</x>
      <y>1121</y>
      <w>32</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果不是GC_ORPHAN，直接退出（因为已经在栈中了）
2.通过sock_hold递增sk的计数
3.sk压栈
	x-&gt;protinfo.af_unix.gc_tree = gc_current
	gc_current = x
注：这里要注意栈的链表指针和标志GC_ORPHAN的指针是同一个
	所以只要sk在栈中，就不是GC_ORPHAN
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1574</x>
      <y>1118</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1600</x>
      <y>1115</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pop_stack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1598</x>
      <y>1110</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1594</x>
      <y>1122</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>p=gc_current;
gc_current = p-&gt;protinfo.af_unix.gc_tree;
return p;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1605</x>
      <y>1118</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>221</x>
      <y>1330</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>56</x>
      <y>1359</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>63</x>
      <y>1333</y>
      <w>165</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1630.0;10.0;10.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>36</x>
      <y>1366</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fcheck</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>41</x>
      <y>1362</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>40</x>
      <y>1369</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fd &lt; files-&gt;max_fds</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>34</x>
      <y>1374</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file = files-&gt;fd[fd]
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>60</x>
      <y>1362</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>62</x>
      <y>1367</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_file</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>62</x>
      <y>1374</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file.count++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>68</x>
      <y>1370</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>175</x>
      <y>1333</y>
      <w>53</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file不为空
FMODE_WRITE</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>151</x>
      <y>1344</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里只是验证访问的区域是否被锁上
并没有上锁，locks_mandatory_area
中只是临时上锁检验一下</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>145</x>
      <y>1353</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_verify_area</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>139</x>
      <y>1356</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 //上了锁
inode-&gt;i_flock &amp;&amp; 
 //该inode上强制锁
MANDATORY_LOCK(inode)</panel_attributes>
    <additional_attributes>120.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>139</x>
      <y>1363</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_mandatory_area</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>69</x>
      <y>1380</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_alloc_lock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>74</x>
      <y>1366</y>
      <w>75</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
account指示是否检查current-&gt;locks超过限制</panel_attributes>
    <additional_attributes>730.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>54</x>
      <y>1387</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>63</x>
      <y>1383</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>75</x>
      <y>1388</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;locks++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>72</x>
      <y>1383</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>90</x>
      <y>1381</y>
      <w>44</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>new_fl-&gt;fl_owner = current-&gt;files;
new_fl-&gt;fl_pid = current-&gt;pid;
new_fl-&gt;fl_file = filp;
new_fl-&gt;fl_flags = FL_POSIX | FL_ACCESS;
new_fl-&gt;fl_type = 
(read_write == FLOCK_VERIFY_WRITE) ? F_WRLCK : F_RDLCK;
new_fl-&gt;fl_start = offset; //file-&gt;f_pos
new_fl-&gt;fl_end = offset + count - 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>101</x>
      <y>1366</y>
      <w>48</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>146</x>
      <y>1366</y>
      <w>37</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历inode-&gt;i_flock链表
如果FL_POSIX置上
遍历的posix锁的start小于申请锁的end
（如果大于，直接返回正确，说明锁进行了排序）</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>147</x>
      <y>1377</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>140</x>
      <y>1384</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>posix_locks_conflict</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>147</x>
      <y>1387</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>135</x>
      <y>1391</y>
      <w>35</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.申请的锁没打开posix锁的，直接返回正确（0）
2，是同一个进程加的锁，直接返回正确（0）
	//是同一个files
	fl1-&gt;fl_owner == fl2-&gt;fl_owner
	//是同一个pid
	&amp;&amp; fl1-&gt;fl_pid   == fl2-&gt;fl_pid
3.检查申请的lock（sys_fl），和存在的lock（caller_fl）
	是否有重叠
	(fl1-&gt;fl_end &gt;= fl2-&gt;fl_start) &amp;&amp;
	(fl2-&gt;fl_end &gt;= fl1-&gt;fl_start)
4.如果有重叠，如果存在的lock是读锁（F_RDLCK），
	申请的lock是写锁，则错误（1）
	如果申请的是写锁，则错误（1）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>155</x>
      <y>1377</y>
      <w>34</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果存在冲突</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>173</x>
      <y>1388</y>
      <w>64</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果file是O_NONBLOCK（不能阻断的），返回-EAGAIN
2.查看如果加上申请的锁，是否会形成死锁，如果死锁，返回-EDEADLK
	posix_locks_deadlock
		1.查看申请的锁和阻塞锁是否属于同一个进程（AA）,如果是的话，就是死锁
		2.等待锁序列blocked_list中是否有和阻塞锁是同一个进程的，如果有，说明
		阻塞锁所在的进程被pending（注释说等待序列blocked_list中同一个进程，正在等待
		的锁只有一个，是因为进程只要有一个锁在等待序列中，进程就pending）
		3.在等待序列中的锁的fl_next字段，指向的是这个所等待的锁（见locks_block_on）（
		不在这个等待序列中的fl_next字段是连在inode-&gt;i_flock链表中的），
		4.如果找到等待序列中的锁和block的锁属于同一进程，说明该进程被另一个进程的锁block，具体对应
		的锁是fl-&gt;fl_next，如果这个锁和要申请的锁属于同一个进程，那么就发生死锁（AB BA）。
		5.如果不是同一个进程，重复2，3，4，查看是否有没有AB BA的死锁
3.	如果不会死锁，通过locks_block_on对进程加锁
4.如果醒来之后，发现强制锁被清了之后，直接退出，否者重新查看该锁是否存在冲突
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>194</x>
      <y>1415</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_block_on</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>201</x>
      <y>1411</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>153</x>
      <y>1422</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_insert_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>190</x>
      <y>1423</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>interruptible_sleep_on_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>265</x>
      <y>1422</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_delete_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>161</x>
      <y>1418</y>
      <w>41</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>200</x>
      <y>1418</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>200</x>
      <y>1418</y>
      <w>74</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>126</x>
      <y>1430</y>
      <w>34</w>
      <h>13</h>
    </coordinates>
    <panel_attributes> //加在blocker的链表中，链表中的实体被blocker阻塞
list_add_tail(&amp;waiter-&gt;fl_block,
			&amp;blocker-&gt;fl_block);
 //注意这里fl_next指向的是阻塞自己的实体
waiter-&gt;fl_next = blocker;
 //加载在等待序列中
list_add(&amp;waiter-&gt;fl_link, &amp;blocked_list);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>137</x>
      <y>1425</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>162</x>
      <y>1435</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>current-&gt;state = TASK_INTERRUPTIBLE;
 //加到等待锁的唤醒队列中
add_wait_queue(fl_wait, &amp;wait);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>173</x>
      <y>1426</y>
      <w>30</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>201</x>
      <y>1426</y>
      <w>6</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>198</x>
      <y>1432</y>
      <w>9</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
timeout=0</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>201</x>
      <y>1432</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
时间到了之后自己被timer唤醒</panel_attributes>
    <additional_attributes>40.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>192</x>
      <y>1438</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>209</x>
      <y>1437</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>schedule_timeout</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>201</x>
      <y>1426</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
有不是block的信号将其唤醒时
报错ERESTARTSYS</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>227</x>
      <y>1436</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>signal_pending</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>244</x>
      <y>1436</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_wait_queue(fl_wait, &amp;wait);
current-&gt;state = TASK_RUNNING;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>201</x>
      <y>1426</y>
      <w>55</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;530.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>272</x>
      <y>1431</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>list_del(&amp;waiter-&gt;fl_block);
INIT_LIST_HEAD(&amp;waiter-&gt;fl_block);
list_del(&amp;waiter-&gt;fl_link);
INIT_LIST_HEAD(&amp;waiter-&gt;fl_link);
waiter-&gt;fl_next = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>272</x>
      <y>1425</y>
      <w>9</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>346</x>
      <y>1347</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;write
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>175</x>
      <y>1344</y>
      <w>179</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1770.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>359</x>
      <y>1354</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_file_write
1.计算pos，算出在inode的逻辑block
2.根据逻辑block和adress_space看是否存在内存（page）（__grab_cache_page）
3.如果没有内存就要分配page和bh（create_empty_buffers）
4.如果是分配的bh，需要由逻辑block推导出实际block（ext2_get_block）
5.如果实际block不存在，需要create（ext2_find_goal 找到实际block
	ext2_alloc_branch 使索引chain完整
	）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>352</x>
      <y>1350</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_file_operations</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>243</x>
      <y>1357</y>
      <w>125</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file-&gt;f_error
如果之前有错，直接返回</panel_attributes>
    <additional_attributes>1230.0;10.0;10.0;290.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>238</x>
      <y>1386</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_error=0
goto out
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>258</x>
      <y>1357</y>
      <w>110</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
O_APPEND</panel_attributes>
    <additional_attributes>1080.0;10.0;10.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>251</x>
      <y>1387</y>
      <w>15</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>pos = inode-&gt;i_size
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>269</x>
      <y>1357</y>
      <w>100</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;rlim[RLIMIT_FSIZE].rlim_cur
 != RLIM_INFINITY</panel_attributes>
    <additional_attributes>980.0;10.0;10.0;280.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>267</x>
      <y>1385</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果现在文件的位置pos已经超过了limit
	send_sig(SIGXFSZ, current, 0);
	goto out;
2.如果要添加的内容超过了limit
	send_sig(SIGXFSZ, current, 0);
 //pos如果不是append，就是file-&gt;f_pos
	count = limit - pos;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>313</x>
      <y>1357</y>
      <w>56</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
count
如果此次写操作有效</panel_attributes>
    <additional_attributes>540.0;10.0;10.0;270.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>303</x>
      <y>1383</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>298</x>
      <y>1390</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_suid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>258</x>
      <y>1400</y>
      <w>45</w>
      <h>7</h>
    </coordinates>
    <panel_attributes> //如果S_IXGRP置上，就将S_ISGID置上，S_ISUID一直置
mode = (inode-&gt;i_mode &amp; S_IXGRP)*(S_ISGID/S_IXGRP) | S_ISUID;
	//这里是查看inode中的S_ISGID和S_ISUID权限
mode &amp;= inode-&gt;i_mode;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>286</x>
      <y>1393</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>295</x>
      <y>1393</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果inode有S_ISGID和S_ISUID权限，
但是进程却不具备setuid的特权
mode &amp;&amp; !capable(CAP_FSETID)</panel_attributes>
    <additional_attributes>80.0;10.0;170.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>308</x>
      <y>1401</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //清除inode的setuid特权
inode-&gt;i_mode &amp;= ~mode;
mark_inode_dirty(inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>313</x>
      <y>1383</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>311</x>
      <y>1390</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_ctime = inode-&gt;i_mtime = CURRENT_TIME;
mark_inode_dirty_sync(inode)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>366</x>
      <y>1357</y>
      <w>21</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环写入数据字节数count</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>354</x>
      <y>1372</y>
      <w>19</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>349</x>
      <y>1391</y>
      <w>27</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>offset = (pos &amp; (PAGE_CACHE_SIZE -1));
index = pos &gt;&gt; PAGE_CACHE_SHIFT;
 //现在一页内写入数据
bytes = PAGE_CACHE_SIZE - offset;
 //写入的长度最大不能超过count
if (bytes &gt; count) {
	bytes = count;
	deactivate = 0;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>385</x>
      <y>1392</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__grab_cache_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>370</x>
      <y>1372</y>
      <w>23</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>377</x>
      <y>1401</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>381</x>
      <y>1395</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>353</x>
      <y>1409</y>
      <w>32</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_hash_table+_page_hashfn(mapping,index)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>371</x>
      <y>1404</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>398</x>
      <y>1400</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__find_lock_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>393</x>
      <y>1395</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>386</x>
      <y>1408</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__find_page_nolock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>392</x>
      <y>1403</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>365</x>
      <y>1415</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.遍历hash，过滤出mapping相同，index相同的page
2.增加引用page的寿命，如果page短缺，将激活kswapd进程
age_page_up(page);
if (inactive_shortage() &gt; inactive_target / 2 &amp;&amp; free_shortage())
		wakeup_kswapd(0);
注：page-&gt;index被抽象为在硬盘的偏移，普通的page被抽象为在
	交换设备中的偏移inode的buffer被抽象为在inode中的偏移
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>380</x>
      <y>1411</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>400</x>
      <y>1410</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>400</x>
      <y>1403</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在hash中找到page</panel_attributes>
    <additional_attributes>60.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>401</x>
      <y>1405</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加page.count的计数</panel_attributes>
    <additional_attributes>90.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>415</x>
      <y>1410</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lock_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>409</x>
      <y>1405</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>407</x>
      <y>1417</y>
      <w>40</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.TryLockPage，这里调用test_and_set_bit，
	会将page锁上，并通过sbbl检查之前的位，如果是0
	则返回0，否则返回-1
2.如果不为0，__lock_page
	1.增加局部变量wait（current），并将其加入到page-&gt;wait
	2.利用page提供的硬盘的page-&gt;mapping，将page同步到硬盘
	3.将task设置为TASK_UNINTERRUPTIBLE
	4.如果此时page还是锁着的，将tq_disk链表中存储的routine
		执行一遍（run_task_queue），然后调度schedule
	5.醒来之后继续TryLockPage
	6.如果锁上之后：
		tsk-&gt;state = TASK_RUNNING;
		remove_wait_queue(&amp;page-&gt;wait, &amp;wait)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>420</x>
      <y>1413</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>433</x>
      <y>1411</y>
      <w>10</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>return page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>409</x>
      <y>1405</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page-&gt;mapping
如果醒来之后还在hash</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>449</x>
      <y>1411</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>UnlockPage(page);
page_cache_release(page);
goto repeat;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>408</x>
      <y>1405</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不在hash中，则释放这个page，重新查找</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>394</x>
      <y>1393</y>
      <w>87</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在hash中没找到page</panel_attributes>
    <additional_attributes>10.0;10.0;850.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>473</x>
      <y>1410</y>
      <w>39</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.如果caller提供了cached_page,就使用caller提供的（或者
	在下面add_to_page_cache_unique为1时，cache中的页面）
	否者通过page_cache_alloc申请一个页面
2.调用add_to_page_cache_unique
	1.__find_page_nolock查找是否在page
	2.如果在hash中没找到，利用__add_to_page_cache加入
		到hash和inode的链表中
	__add_to_page_cache
		//清掉flag
		flags = page-&gt;flags &amp; ~((1 &lt;&lt; PG_uptodate) | (1 &lt;&lt; PG_error) | (1 &lt;&lt; PG_dirty) | (1 &lt;&lt; PG_referenced) | (1 &lt;&lt; PG_arch_1));
		//置上lock
		page-&gt;flags = flags | (1 &lt;&lt; PG_locked);
		//增加计数和在inode中的偏移
		page_cache_get(page);
		page-&gt;index = offset;
		//将page加在inode的clean page中，并将page的mapping映射到inode上
		add_page_to_inode_queue
			*head = &amp;mapping-&gt;clean_pages;
			mapping-&gt;nrpages++;
			list_add(&amp;page-&gt;list, head);
			page-&gt;mapping = mapping;
		//将page添加到hash中
		add_page_to_hash_queue
		//添加到active_list中
		lru_cache_add（加入到active_list）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>370</x>
      <y>1372</y>
      <w>71</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;690.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>433</x>
      <y>1391</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page要locked
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>484</x>
      <y>1391</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;prepare_write
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>371</x>
      <y>1372</y>
      <w>126</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1240.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>509</x>
      <y>1400</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_prepare_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>495</x>
      <y>1394</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_aops</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>539</x>
      <y>1409</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_prepare_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>516</x>
      <y>1403</y>
      <w>32</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_get_block</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>514</x>
      <y>1418</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode = 
page-&gt;mapping-&gt;host
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>519</x>
      <y>1412</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page对应的inode</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>545</x>
      <y>1418</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__block_prepare_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>546</x>
      <y>1412</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>515</x>
      <y>1426</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blocksize = 
inode-&gt;i_sb-&gt;s_blocksize
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>522</x>
      <y>1421</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>538</x>
      <y>1427</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_empty_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>542</x>
      <y>1421</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果这个页面没有分配bh
!page-&gt;buffers</panel_attributes>
    <additional_attributes>120.0;10.0;40.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>518</x>
      <y>1434</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>522</x>
      <y>1430</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>523</x>
      <y>1437</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从PAGE_SIZE开始，每个
bh管理blocksize的长度
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>1442</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>494</x>
      <y>1449</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_unused_buffer_head</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>468</x>
      <y>1452</y>
      <w>36</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果unused_list有足够的bh
nr_unused_buffer_heads &gt; NR_RESERVED</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>453</x>
      <y>1461</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>bh = unused_list;
unused_list = bh-&gt;b_next_free;
nr_unused_buffer_heads--;
return bh
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>497</x>
      <y>1452</y>
      <w>16</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没有足够的bh</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>478</x>
      <y>1462</y>
      <w>38</w>
      <h>14</h>
    </coordinates>
    <panel_attributes> //注释说SLAB_BUFFER不会因为申请不到内存将
 //page换出，产生更多的bh，但是从2.4.0中我暂时
 //没看到相关的代码，但是在3.4.2中__zone_watermark_ok
 //中的ALLOC_HIGH可能让page更容易从reserve的page中
 //申请到
kmem_cache_alloc(bh_cachep, SLAB_BUFFER)
memset(bh, 0, sizeof(*bh));
init_waitqueue_head(&amp;bh-&gt;b_wait)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>502</x>
      <y>1452</y>
      <w>22</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果想内存没有申请到page
并且async置上，就像reserve的
unused_list中继续申请</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>518</x>
      <y>1464</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>bh = unused_list;
unused_list = bh-&gt;b_next_free;
nr_unused_buffer_heads--;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>523</x>
      <y>1442</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果申请到bh</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>539</x>
      <y>1450</y>
      <w>29</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>bh-&gt;b_dev = B_FREE;
 //将申请的bh加到head链表中
bh-&gt;b_this_page = head;
head = bh;

bh-&gt;b_state = 0;
bh-&gt;b_next_free = NULL;
bh-&gt;b_pprev = NULL;
atomic_set(&amp;bh-&gt;b_count, 0);
bh-&gt;b_size = size;

set_bh_page(bh, page, offset);
	bh-&gt;b_page = page
	if PageHighMem
		bh-&gt;b_data = (char *)(0 + offset);
	else
		bh-&gt;b_data = page_address(page) + offset;

bh-&gt;b_list = BUF_CLEAN;
bh-&gt;b_end_io = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>523</x>
      <y>1437</y>
      <w>59</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果中间没有申请到bh</panel_attributes>
    <additional_attributes>10.0;10.0;570.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>574</x>
      <y>1447</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>no_grow
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>571</x>
      <y>1456</y>
      <w>31</w>
      <h>23</h>
    </coordinates>
    <panel_attributes> //释放申请的bh
bh = head;
head = head-&gt;b_this_page;
__put_unused_buffer_head(bh);
wake_up(&amp;buffer_wait)

if (!async)
	return NULL;

run_task_queue(&amp;tq_disk);
 //这里是通过宏建wait的queue，然后schedule，
 //等待唤醒后，检查condition
wait_event(buffer_wait,
			nr_unused_buffer_heads &gt;= MAX_BUF_PER_PAGE)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>579</x>
      <y>1450</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>545</x>
      <y>1430</y>
      <w>65</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;630.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>604</x>
      <y>1437</y>
      <w>20</w>
      <h>25</h>
    </coordinates>
    <panel_attributes> //遍历返回的head链表，
 //将bh进行填充
do {
	bh-&gt;b_dev = dev;
	bh-&gt;b_blocknr = 0;
	bh-&gt;b_end_io = NULL;
	tail = bh;
	bh = bh-&gt;b_this_page;
} while (bh);

 //page对应的bh形成循环链表
tail-&gt;b_this_page = head;
 //page指向bh的链表
page-&gt;buffers = head;
page_cache_get(page);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>564</x>
      <y>1425</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>bbits = inode-&gt;i_sb-&gt;s_blocksize_bits;
 //要写区域的逻辑block偏移
block = page-&gt;index &lt;&lt; (PAGE_CACHE_SHIFT 
					- bbits)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>553</x>
      <y>1421</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>553</x>
      <y>1421</y>
      <w>88</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历page-&gt;buffers链表</panel_attributes>
    <additional_attributes>10.0;10.0;860.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>625</x>
      <y>1434</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.block_end = block_start+blocksize;
2.filter：from~to要和bh所在的区间有重合
	//bh还没到要操作的区间（继续下一个bh）
	block_end &lt;= from
	//bh已经超过了要操作的区间（退出循环）
	block_start &gt;= to
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>634</x>
      <y>1425</y>
      <w>7</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>637</x>
      <y>1425</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!buffer_mapped
bh.b_state的Mapped没置上
BH_Mapped:表示bh和实际block映射起来了</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>670</x>
      <y>1437</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_block
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>665</x>
      <y>1430</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>676</x>
      <y>1440</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;35.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>690</x>
      <y>1443</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_get_block
注：ext2_get_block包括寻找chain，补全chain，而获取实际的block号给bh
getblk是根据dev和实际block号找到bh（包括创建bh及其内存）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>637</x>
      <y>1425</y>
      <w>154</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果page的PG_uptodate置上
bh的BH_Uptodate肯定会置上
Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;1520.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>783</x>
      <y>1429</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_bit(BH_Uptodate, &amp;bh-&gt;b_state);
continue;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>638</x>
      <y>1424</y>
      <w>184</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 //磁盘上的内容没有更新到内存
!buffer_uptodate(bh) &amp;&amp;
 //bh中有一段内存不在操作的区域
 //注：前面有filter，所以bh必定是有一部分
 //是要操作的区域，所以这里只是一部分没落在
 //要操作的区域
(block_start &lt; from || block_end &gt; to)</panel_attributes>
    <additional_attributes>10.0;20.0;1820.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>810</x>
      <y>1427</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>ll_rw_block(READ, 1, &amp;bh);
 //wait_bh指向wait，wait是
 //包含两个（包含两个的原因是：
 //不全在操作范围的bh最多只有
 //两个，前面一个，后面一个）
 //函数指针的数组，
*wait_bh++=bh;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>553</x>
      <y>1421</y>
      <w>292</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2900.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>840</x>
      <y>1426</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //等待要读的bh全部读完
while(wait_bh &gt; wait) {
	wait_on_buffer(*--wait_bh);
	if (!buffer_uptodate(*wait_bh))
		goto out;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>626</x>
      <y>1455</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_block_to_path</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>633</x>
      <y>1446</y>
      <w>64</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>604</x>
      <y>1464</y>
      <w>59</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果小于EXT2_NDIR_BLOCKS（12），属于直接索引（逻辑block就是索引号）
2.如果上述条件不满足，但是小于EXT2_ADDR_PER_BLOCK（一个block可以存放
	多少个block号），属于间接索引， 	首层索引为EXT2_IND_BLOCK（12），第二层
	索引为i_block -= direct_blocks
3.如果小于double_blocks（ptrs_bits * 2个bit），属于二层索引，首层索引号为
	EXT2_DIND_BLOCK（13），第二层索引号为i_block &gt;&gt; ptrs_bits，第三层索引号
	为i_block &amp; (ptrs - 1)
4.如果小于ptrs_bits * 3（因为ptrs有一个ptrs_bits），首层索引为EXT2_TIND_BLOCK（14）
	第二程索引为i_block &gt;&gt; (ptrs_bits * 2)，第三层索引为(i_block &gt;&gt; ptrs_bits) &amp; (ptrs - 1)
	第四层索引为i_block &amp; (ptrs - 1)
注：在这里if..elseif..中是先执行i_block -= ，然后在进行判断，所以这里已经将前面判断的值给减掉了
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>628</x>
      <y>1458</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>679</x>
      <y>1455</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_get_branch</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>680</x>
      <y>1446</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果正常找到block，返回NULL
有其他异常，则返回当前的chain</panel_attributes>
    <additional_attributes>160.0;10.0;50.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>665</x>
      <y>1464</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_chain</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>664</x>
      <y>1472</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.p指向bh+offset
2.k记录下一个的实际block号
3.bh指向实际block号所在的buffer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>670</x>
      <y>1458</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>671</x>
      <y>1467</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>682</x>
      <y>1458</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历depth（索引层次）次，
寻找逻辑block对应的实际block号</panel_attributes>
    <additional_attributes>40.0;10.0;180.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>686</x>
      <y>1468</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>689</x>
      <y>1464</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>697</x>
      <y>1468</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>verify_chain</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>699</x>
      <y>1464</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>689</x>
      <y>1475</y>
      <w>41</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.遍历暂存的chain数组，验证读进来的block号有没有被修改
	from-&gt;key == *from-&gt;p
注：注意p是指针，指向的是bh中的一个block号，k是之前从这个
	这个地址中拿来放在chain数组中，在bread时，有可能休眠，
	其他进程有可能将这段给删了，导致之前存的key和现在去的*p
	不一致，所以在这里为了功能安全，需要加以验证
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>701</x>
      <y>1471</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>710</x>
      <y>1468</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_chain</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>699</x>
      <y>1464</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将读入的数据存储在chain中</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>696</x>
      <y>1446</y>
      <w>25</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果找到了实际的block
!partial</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>724</x>
      <y>1460</y>
      <w>36</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>bh_result-&gt;b_dev = inode-&gt;i_dev;
 //物理block号
bh_result-&gt;b_blocknr = le32_to_cpu(chain[depth-1].key);
bh_result-&gt;b_state |= (1UL &lt;&lt; BH_Mapped);
 //这里将partial赋值为最后一个chain
partial = chain+depth-1
goto cleanup
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>712</x>
      <y>1453</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>got_it
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>719</x>
      <y>1456</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>761</x>
      <y>1453</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cleanup
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>696</x>
      <y>1446</y>
      <w>73</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将暂存在chain中的bh释放

如果没找到实际block号，但是
没有要求创建，或者要求创建，但是
出现了EIO,即没有将磁盘中的内容通过
bread读到buffer中，会执行clean_up，并返回err</panel_attributes>
    <additional_attributes>10.0;10.0;710.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>762</x>
      <y>1461</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>while (partial &gt; chain) {
	brelse(partial-&gt;bh);
	partial--;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>767</x>
      <y>1456</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>696</x>
      <y>1446</y>
      <w>118</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
没有找到相应的block
err ！= -EAGAIN
err ！= -EIO
partial！=NULL
create!=0</panel_attributes>
    <additional_attributes>10.0;10.0;1160.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>788</x>
      <y>1452</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里是找到一个物理block
用于与这个逻辑block映射
原则：尽量文件的物理block全部放在一起
	并且连续</panel_attributes>
    <additional_attributes>240.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>784</x>
      <y>1460</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_find_goal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>750</x>
      <y>1473</y>
      <w>53</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>1.如果要分配的逻辑block只比预期要分配的逻辑block大1，
	将预期分配的逻辑block和物理block都加1.（这样使预期分配的
	逻辑block和要分配的逻辑block相等，直接使用i_next_alloc_goal
	而不通过ext2_find_near去寻找实际要分配的block）
	inode-&gt;u.ext2_i.i_next_alloc_block++;
	inode-&gt;u.ext2_i.i_next_alloc_goal++;
2.通过verify_chain验证要分配block的路径的有效性（没有其他进程对这条
	映射链有更改）
3.如果要分配的逻辑block和预期分配的逻辑block（i_next_alloc_block）
	相等，要分配的实际block就为预期分配的实际block（i_next_alloc_goal）
4.如果不相等（或者之前这个inode没有进入过ext2_find_goal，此时
	i_next_alloc_goal为0）就通过ext2_find_near寻找实际block供分配
	
	ext2_find_near
		1.寻找到当前key为0所在的block
		2.在这个block中遍历key为0之前的内存，如果发现内存中的实际block不为0，
			那之后就从这个设备block向前找到这个空闲的block
		3.在这个block中遍历key为0之前的内存，发现key都为0，那么这个间接映射可能是
			inode申请的最后一个block，所以以这个间接映射所在的block为起始点开始寻找
			（ind-&gt;bh-&gt;b_blocknr）
		4.如果不是间接映射的block，就以inode所在的第一个group所在的第一个data_blcok
			开始寻找实际的block（s_first_data_block）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>777</x>
      <y>1463</y>
      <w>14</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>798</x>
      <y>1463</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>left = (chain + depth) - partial
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>810</x>
      <y>1452</y>
      <w>21</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
剩下的没有被映射的间接索引</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>841</x>
      <y>1463</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_alloc_branch</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>811</x>
      <y>1452</y>
      <w>38</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到相应的block
填充好chain
</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>828</x>
      <y>1473</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_alloc_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>830</x>
      <y>1466</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更具goal找到实际的设备block
</panel_attributes>
    <additional_attributes>170.0;10.0;30.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1042</x>
      <y>1474</y>
      <w>47</w>
      <h>43</h>
    </coordinates>
    <panel_attributes>1.将找到的block（parent）放在断裂的chain中（branch）
	branch[0].key = cpu_to_le32(parent)
2.如果找到了block，将所有的没有映射的chain进行填充
	1.找到下一个映射的block（ext2_alloc_block）
	2.填充chain
		1.branch[n].key = cpu_to_le32(nr)
		2.获取parent的bh，并memset（没有获取最后一个bh，因为最后一个bh是作为参数传给
			ext2_get_block）
			bh = getblk(inode-&gt;i_dev, parent, blocksize);
			if (!buffer_uptodate(bh))
				wait_on_buffer(bh);
			memset(bh-&gt;b_data, 0, blocksize);
			branch[n].bh = bh
		3.branch[n].p = (u32*) bh-&gt;b_data + offsets[n];
		4.将key写到内存（注branch[0]的p出没写，也就是和chain还没连起来）
			*branch[n].p = branch[n].key;
			mark_buffer_uptodate(bh, 1);
			mark_buffer_dirty_inode(bh, inode);
		5.如果需要同步写入，就请求写
			if (IS_SYNC(inode) || inode-&gt;u.ext2_i.i_osync) {
				ll_rw_block (WRITE, 1, &amp;bh);
				wait_on_buffer (bh);
			}
3.如果ext2_alloc_block每次都能找到设备block，最后都是n==num,返回0
4.如果ext2_alloc_block出错，就释放bh（bforget(branch[i].bh)）和
	block（ext2_free_blocks），并返回error
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>846</x>
      <y>1466</y>
      <w>204</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2020.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>812</x>
      <y>1476</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果inode的i_prealloc_count不为0
并且goal最多比i_prealloc_block大1</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>804</x>
      <y>1486</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>result = inode-&gt;u.ext2_i.i_prealloc_block++;
inode-&gt;u.ext2_i.i_prealloc_count--;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>832</x>
      <y>1476</y>
      <w>16</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不满足左边的条件</panel_attributes>
    <additional_attributes>20.0;10.0;130.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>833</x>
      <y>1487</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_discard_prealloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>839</x>
      <y>1483</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>806</x>
      <y>1495</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode-&gt;u.ext2_i.i_prealloc_count = 0;
inode-&gt;u.ext2_i.i_prealloc_block = 0;
ext2_free_blocks
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>823</x>
      <y>1490</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>871</x>
      <y>1488</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_new_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>844</x>
      <y>1483</y>
      <w>38</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是S_ISREG，需要填充i_prealloc_count
和i_prealloc_block。否则不用填充</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>810</x>
      <y>1502</y>
      <w>36</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果超级块的空闲block数量小于reserve的数量
	即需要sb的s_resuid在fsuid中，或者sb的s_resgid
	所在的组为超级用户，或者在fsgid所在的组，或者进程有
	CAP_SYS_RESOURCE权限
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>825</x>
      <y>1491</y>
      <w>53</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>847</x>
      <y>1504</y>
      <w>29</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>goal = le32_to_cpu(es-&gt;s_first_data_block)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>853</x>
      <y>1491</y>
      <w>29</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果超出了sb规定的block范围
goal &lt; le32_to_cpu(es-&gt;s_first_data_block) ||
goal &gt;= le32_to_cpu(es-&gt;s_blocks_count)</panel_attributes>
    <additional_attributes>230.0;10.0;50.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>878</x>
      <y>1504</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_get_group_desc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>875</x>
      <y>1491</y>
      <w>14</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取desc</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>894</x>
      <y>1504</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>load_block_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>875</x>
      <y>1491</y>
      <w>29</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
i为所在的block_group
j为在group中的序号

返回在s_block_bitmap_number或者
s_block_bitmap的位置</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>864</x>
      <y>1512</y>
      <w>48</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.代码运行的局部性：
	如果加载过block_bitmap（s_loaded_block_bitmaps &gt; 0）
	首先查看0处是否为要查找的block_group
2.如果磁盘的所有group都不超过最大的缓存数
	（s_groups_count &lt;=EXT2_MAX_GROUP_LOADED）
	此时block_group为其数组的索引，所以查看
	sb-&gt;u.ext2_sb.s_block_bitmap_number[block_group] == block_group &amp;&amp;
 	sb-&gt;u.ext2_sb.s_block_bitmap[block_group]
3.通过__load_block_bitmap将新加的block_group加载进来
	1.要加载的block_group不能大于s_groups_count
	2.当磁盘的group总量小于加载的内存数量（s_groups_count
											&lt;= EXT2_MAX_GROUP_LOADED）
		read_block_bitmap
	3.遍历s_loaded_block_bitmaps，看是block_group的位图是否存在于内存中
		如果存在将block_group在s_block_bitmap_number和s_block_bitmap
		中的位置移到第0位；
		如果不在，腾出一个内存单元（s_loaded_block_bitmaps++或者brelse）
		并通过read_block_bitmap读到第0位
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>889</x>
      <y>1507</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>877</x>
      <y>1546</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_block_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>884</x>
      <y>1542</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>859</x>
      <y>1553</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>862</x>
      <y>1549</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>874</x>
      <y>1553</y>
      <w>42</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;u.ext2_sb.s_block_bitmap_number[bitmap_nr] = block_group;
sb-&gt;u.ext2_sb.s_block_bitmap[bitmap_nr] = bh;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>884</x>
      <y>1549</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>908</x>
      <y>1500</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_test_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>875</x>
      <y>1491</y>
      <w>43</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
测试第i组的第j个block
是否被占用</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>910</x>
      <y>1507</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>got_block
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>914</x>
      <y>1503</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果为0表示没有被占用</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>876</x>
      <y>1491</y>
      <w>76</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果ext2_test_bit不为0</panel_attributes>
    <additional_attributes>10.0;10.0;740.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>930</x>
      <y>1501</y>
      <w>53</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.如果j不为0，通过ext2_find_next_zero_bit寻找位图中为0的索引
	end_goal为其搜索的结束地址（64位对齐）
2.如果还没找到，从end_goal继续查找，直到查找到EXT2_BLOCKS_PER_GROUP
	memscan
	__asm__("repnz; scasb //edi++,ecx--，如果edi！=eax或者ecx&gt;0则继续
		jnz 1f
		dec %%edi //将addr恢复到原来相等的地址
	1:		"
		: "=D" (addr), "=c" (size)
		: "0" (addr), "1" (size), "a" (c));
	如果发现连续8位都为0，search_back去向之前查找!ext2_test_bit (j - 1, bh-&gt;b_data)
	将j更新为最小的空闲block，然后got_block
3.如果在本group没有找到，遍历之后的group，只要其中的bg_free_blocks_count&gt;0，
	就加载其block_bitmap
	先连续查看是否有连续8bit的空闲block（memscan(bh-&gt;b_data, 
				0, EXT2_BLOCKS_PER_GROUP(sb) &gt;&gt; 3)）
	如果没有，通过ext2_find_first_zero_bit查找空闲的block
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>875</x>
      <y>1491</y>
      <w>130</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1280.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>999</x>
      <y>1499</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>got_block
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>986</x>
      <y>1507</y>
      <w>48</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.计算获得的实际block号（group号，s_first_data_block都加进去）
2.获得的block号，不能是本group的block位图区（s_first_data_block）
	也不能是inode位图区（bg_inode_bitmap），也不能在inode所在的block
	区（e32_to_cpu(gdp-&gt;bg_inode_table),
		      sb-&gt;u.ext2_sb.s_itb_per_group）
3.将group中相应的block位图置上（ext2_set_bit），mark_buffer_dirty
4.获取的block号不能大于磁盘最大的block号（s_blocks_count）
5.gdp-&gt;bg_free_blocks_count--，并将其标记为dirty（mark_buffer_dirty）
6.s_free_blocks_count--，将超级块标记为dirty
	mark_buffer_dirty(sb-&gt;u.ext2_sb.s_sbh);
	sb-&gt;s_dirt = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1004</x>
      <y>1502</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1061</x>
      <y>1520</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getblk
1.lru_list,如果正在被使用会被加入到iru_list和hash中
	此时b_count不为0，且b_blocknr存在
2.free_list，如果进程释放掉这个bh，b_count为0，不在
	hash表中，但是b_blocknr存在（page能再次利用）
3.unused_list，这个是bh所指向的page被释放，此时b_count为0，
	不在hash表中，且b_blocknr=-1（要申请page才能利用）
注：1.从这里暂时没看出unused_list和free_list的不同，但是在try_to_free_buffer
中有当b_dev不存在时，将bh从free_list移除，然后放到unused_list中释放
2.这里的touch_buffer是增加page寿命，使其不会被老化换出
3.这里block的传参，是设备上的block号，并不是文件的逻辑block号</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1066</x>
      <y>1516</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1013</x>
      <y>1531</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_hash_table</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1020</x>
      <y>1523</y>
      <w>49</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1004</x>
      <y>1537</y>
      <w>28</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.遍历hash_table（dev和block作为杂凑值）
	中的b_next
2.查看下面字段
bh-&gt;b_blocknr == block	&amp;&amp;
bh-&gt;b_size    == size	&amp;&amp;
bh-&gt;b_dev     == dev
3.增加bh-&gt;b_count计数
4.goto out
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1019</x>
      <y>1534</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1064</x>
      <y>1523</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从free_list对应的size中查找
如果有空闲的bh</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1040</x>
      <y>1532</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__remove_from_free_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1048</x>
      <y>1528</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1035</x>
      <y>1539</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果free_list中只有bh一个（b_next_free指向自己）
	 free_list[index].list = NULL;
2.如果不止一个，将bh从free链表中删除，如果free_list
	指向的是bh，就将free_list指向bh-&gt;b_next_free
3.将bh链表置空
	bh-&gt;b_next_free = bh-&gt;b_prev_free = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1047</x>
      <y>1535</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1064</x>
      <y>1528</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1075</x>
      <y>1532</y>
      <w>31</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>atomic_set(&amp;bh-&gt;b_count, 1)
init_buffer
	bh-&gt;b_list = BUF_CLEAN;
	bh-&gt;b_end_io = handler;（这里是NULL）
	bh-&gt;b_private = private;（这里是NULL）
bh-&gt;b_dev = dev;
bh-&gt;b_blocknr = block;
bh-&gt;b_state = 1 &lt;&lt; BH_Mapped;
__insert_into_queues
out:
touch_buffer  (SetPageReferenced(bh-&gt;b_page))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1058</x>
      <y>1553</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__insert_into_queues</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1065</x>
      <y>1550</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1043</x>
      <y>1561</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__hash_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1060</x>
      <y>1560</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__insert_into_lru_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1048</x>
      <y>1556</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将bh头插至hash中
并将hash指向bh
注：b_pprev指向箭头</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1066</x>
      <y>1556</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1049</x>
      <y>1572</y>
      <w>38</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果lru_list为空，首先将其初始化，使后面的接口操作统一
	*bhp = bh;
	bh-&gt;b_prev_free = bh;
2.将bh尾插至lru链表的最后
	bh-&gt;b_next_free = *bhp;
	bh-&gt;b_prev_free = (*bhp)-&gt;b_prev_free;
	(*bhp)-&gt;b_prev_free-&gt;b_next_free = bh;
	(*bhp)-&gt;b_prev_free = bh;
	nr_buffers_type[blist]++;
	size_buffers_type[blist] += bh-&gt;b_size;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1062</x>
      <y>1563</y>
      <w>15</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里是循环链表
没有pprev</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1149</x>
      <y>1532</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>refill_freelist</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1066</x>
      <y>1523</y>
      <w>92</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果从hash或者free_list中都没找到
</panel_attributes>
    <additional_attributes>10.0;10.0;900.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1119</x>
      <y>1538</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>balance_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1124</x>
      <y>1535</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1113</x>
      <y>1546</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>balance_dirty_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1117</x>
      <y>1541</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1075</x>
      <y>1561</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.计算所有空闲页的数量（free_pages inactive_clean_pages
	inactive_dirty_pages）
2.最小为freepages.high + inactive_target（考虑到kswapd会将
	空闲页恢复到这个数量）
3.然后还要算上nr_active_pages &gt;&gt; 4（应该是考虑到页的换出）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1105</x>
      <y>1549</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1097</x>
      <y>1554</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nr_free_buffer_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1079</x>
      <y>1557</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1117</x>
      <y>1561</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果BUF_DIRTY的数量大于hard_dirty_limit的数量，需要同步
	的将页面进行同步到硬盘
2.如果BUF_DIRTY的数量大于soft_dirty_limit的数量，或者nr_inactive_dirty_pages
	的页面过多，会异步将页面写入硬盘
3.否则不进行flush操作
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1119</x>
      <y>1549</y>
      <w>13</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1142</x>
      <y>1546</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wakeup_bdflush</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1125</x>
      <y>1541</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果需要flush</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1131</x>
      <y>1551</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1136</x>
      <y>1548</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>100.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1160</x>
      <y>1552</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_dirty_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1147</x>
      <y>1549</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果需要同步的flush</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1159</x>
      <y>1560</y>
      <w>49</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.遍历lru_list[BUF_DIRTY]，这里用的是nr_buffers_type，是因为
	__refile_buffer可能使这个链表没有遍历完全，或者成为死循环
2.!buffer_dirty，如果dirty没置上，就将其移到相应的lru链表中
3.buffer_locked，bh正在想硬盘写，不用管，继续下一个
4.check_flushtime置上时，check有没有超时（bh-&gt;b_flushtime）
	没置上时，检查写入到硬盘的dirty_page是否超过bdf_prm.b_un.ndirty
	（最大写入硬盘的dirty_page数）
5.如果上述filter成立，ll_rw_block(WRITE, 1, &amp;bh)
6.如果在wake_up_process中need_resched置上，直接让当前进程进行调度
	schedule
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1167</x>
      <y>1555</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1149</x>
      <y>1535</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果页面短缺
free_shortage</panel_attributes>
    <additional_attributes>60.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1147</x>
      <y>1539</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_launder</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1194</x>
      <y>1539</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>grow_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>1535</y>
      <w>49</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1174</x>
      <y>1548</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.以block为单位（512）
2.不能大于PAGE_SIZE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>1542</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1196</x>
      <y>1548</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1199</x>
      <y>1542</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1212</x>
      <y>1548</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1199</x>
      <y>1542</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1230</x>
      <y>1548</y>
      <w>30</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>tmp-&gt;b_this_page = bh;
free_list[isize].list = bh;
page-&gt;buffers = bh;
page-&gt;flags &amp;= ~(1 &lt;&lt; PG_referenced);
 //加到lru链表中，因为是新申请的page
 //age为0，所以可能加入到inactive_dirty_list中
lru_cache_add(page);
atomic_inc(&amp;buffermem_pages)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1200</x>
      <y>1542</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将bh链表依次插入到free_list中
其next_free的顺序是之前bh链表的顺序
</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1123</x>
      <y>1460</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_splice_branch</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>811</x>
      <y>1452</y>
      <w>320</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;3180.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1090</x>
      <y>1469</y>
      <w>31</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.验证之前没有断裂的索引链表（chain~where-1）
2.验证索引链表在where出断裂（*where-&gt;p）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1103</x>
      <y>1463</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1100</x>
      <y>1478</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>change
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1090</x>
      <y>1486</y>
      <w>36</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.bforget(where[i].bh)
2.ext2_free_blocks(inode, le32_to_cpu(where[i].key), 1)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1106</x>
      <y>1473</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果情况出现了变化</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1107</x>
      <y>1481</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1124</x>
      <y>1470</y>
      <w>44</w>
      <h>15</h>
    </coordinates>
    <panel_attributes> //将所有链表断裂处连接起来
*where-&gt;p = where-&gt;key;
 //下一个待分配的逻辑block
inode-&gt;u.ext2_i.i_next_alloc_block = block;
 //下一个待分配的实际block
inode-&gt;u.ext2_i.i_next_alloc_goal = le32_to_cpu(where[num-1].key);
 //更新inode的block的数量
inode-&gt;i_blocks += num * inode-&gt;i_sb-&gt;s_blocksize/512;
inode-&gt;i_ctime = CURRENT_TIME
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1129</x>
      <y>1463</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1128</x>
      <y>1463</y>
      <w>57</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
where-&gt;bh存在
如果需要同步，则向发送写请求，并等待
if (IS_SYNC(inode) || inode-&gt;u.ext2_i.i_osync) {
	ll_rw_block (WRITE, 1, &amp;where-&gt;bh);
	wait_on_buffer(where-&gt;bh);
}</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1174</x>
      <y>1471</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_buffer_dirty_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1169</x>
      <y>1479</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_buffer_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1188</x>
      <y>1479</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>buffer_insert_inode_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1183</x>
      <y>1474</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1198</x>
      <y>1482</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1194</x>
      <y>1488</y>
      <w>52</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果bh.b_inode指向对应的inode，将bh.b_inode_buffers从inode的链表中删除
2.bh-&gt;b_inode = inode
3.list_add(&amp;bh-&gt;b_inode_buffers, &amp;inode-&gt;i_dirty_buffers)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1172</x>
      <y>1474</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1173</x>
      <y>1482</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
atomic_set_buffer_dirty
set bh dirty
如果之前不是dirty</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>1487</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1162</x>
      <y>1491</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__mark_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1133</x>
      <y>1499</y>
      <w>36</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.bh-&gt;b_flushtime = jiffies + bdf_prm.b_un.age_buffer
2.refile_buffer （__refile_buffer）
	1.查看bh.b_state处于一个什么状态，从而判断其应该处于一个lru链表中
	2，比较其应该在的链表和其现在所在的链表（bh-&gt;b_list），如果不相同，
		将其从现在的lru链表中删除，加在应该处的lru链表中
		__remove_from_lru_list(bh, bh-&gt;b_list);
		bh-&gt;b_list = dispose;
		__insert_into_lru_list(bh, dispose)
	3.如果应该处于BUF_CLEAN中，就将其从inode中删除
		bh-&gt;b_inode = NULL;
		list_del(&amp;bh-&gt;b_inode_buffers)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1152</x>
      <y>1494</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1177</x>
      <y>1491</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>balance_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1172</x>
      <y>1487</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
看是否将dirty_buffer向
硬盘中写</panel_attributes>
    <additional_attributes>30.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1128</x>
      <y>1463</y>
      <w>118</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1160.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1225</x>
      <y>1469</y>
      <w>28</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果需要同步
IS_SYNC(inode) || inode-&gt;u.ext2_i.i_osync</panel_attributes>
    <additional_attributes>190.0;10.0;80.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1225</x>
      <y>1476</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_sync_inode
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1250</x>
      <y>1476</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_inode_dirty
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1243</x>
      <y>1469</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不需要同步</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1180</x>
      <y>1458</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bh_result-&gt;b_state |= (1UL &lt;&lt; BH_New)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>811</x>
      <y>1452</y>
      <w>384</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;3820.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>665</x>
      <y>1430</y>
      <w>36</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
buffer_new
BH_New:表示这个实际block是被创建的</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>694</x>
      <y>1432</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查hash表中有没有和其指向同一个dev和block
的bh，如果有，将这个bh写入磁盘并释放</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>684</x>
      <y>1437</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unmap_underlying_metadata</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>704</x>
      <y>1439</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>set_bit(BH_Uptodate, &amp;bh-&gt;b_state);
continue;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>698</x>
      <y>1432</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>732</x>
      <y>1437</y>
      <w>25</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>if (block_end &gt; to)
	memset(kaddr+to, 0, block_end-to);
if (block_start &lt; from)
	memset(kaddr+block_start, 0, from-block_start);
continue
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>697</x>
      <y>1432</y>
      <w>47</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为是新创建的，把不写的区域清0</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>517</x>
      <y>1390</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>kaddr = page_address(page);
status = copy_from_user(kaddr+offset, buf, bytes);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>370</x>
      <y>1372</y>
      <w>167</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制内容到缓存</panel_attributes>
    <additional_attributes>10.0;10.0;1650.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>569</x>
      <y>1376</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;commit_write
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>370</x>
      <y>1372</y>
      <w>209</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2070.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>578</x>
      <y>1379</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_aops</panel_attributes>
    <additional_attributes>20.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>576</x>
      <y>1382</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_commit_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>558</x>
      <y>1389</y>
      <w>34</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //address_space是inode和page的关联
inode = 
page-&gt;mapping-&gt;host
 //写完最后的位置
pos = ((loff_t)page-&gt;index &lt;&lt; PAGE_CACHE_SHIFT) 
		+ to
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>564</x>
      <y>1385</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>599</x>
      <y>1387</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__block_commit_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>585</x>
      <y>1385</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>607</x>
      <y>1390</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历page-&gt;buffers链表</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>566</x>
      <y>1394</y>
      <w>45</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果这个bh不在要写的范围
block_end &lt;= from || block_start &gt;= to
并且不和硬盘一致
!buffer_uptodate</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>561</x>
      <y>1406</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>partial = 1;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>598</x>
      <y>1394</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果bh在这次写的范围内
（即使部分也是的，因为__block_prepare_write
已经将那部分读了上来）</panel_attributes>
    <additional_attributes>110.0;10.0;190.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>613</x>
      <y>1402</y>
      <w>25</w>
      <h>19</h>
    </coordinates>
    <panel_attributes> //设置bh和硬盘一致
set_bit(BH_Uptodate, &amp;bh-&gt;b_state);
 //bh置dirty
if (!atomic_set_buffer_dirty(bh)) {
 //如果之前没置dirty
 //更新bh的lru链表
	__mark_dirty(bh);
	//将bh加入到inode链表中
	buffer_insert_inode_queue(bh, inode);
	need_balance_dirty = 1;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>607</x>
      <y>1390</y>
      <w>42</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
need_balance_dirty置上
根据空闲page的数量，决定是否唤醒bdflush</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>642</x>
      <y>1400</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>balance_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>608</x>
      <y>1390</y>
      <w>63</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
partial没置上
这个page中所有缓存都和硬盘一致</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>663</x>
      <y>1399</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>SetPageUptodate(page)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>669</x>
      <y>1379</y>
      <w>17</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>written ? written : status
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>638</x>
      <y>1377</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>651</x>
      <y>1378</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_osync_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>603</x>
      <y>1377</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>written += status;
count -= status;
pos += status;
buf += status;
if (deactivate)
	deactivate_page(page);
page_cache_release(page);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>369</x>
      <y>1372</y>
      <w>242</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1510.0;10.0;2400.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>368</x>
      <y>1357</y>
      <w>278</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在__grab_cache_page中
有cached_page，将其释放</panel_attributes>
    <additional_attributes>10.0;10.0;2070.0;130.0;2760.0;200.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>368</x>
      <y>1357</y>
      <w>291</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
没有错误，并要求同步，将其同步到硬盘
(status &gt;= 0) &amp;&amp; (file-&gt;f_flags &amp; O_SYNC)</panel_attributes>
    <additional_attributes>10.0;10.0;1290.0;60.0;2890.0;210.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>369</x>
      <y>1357</y>
      <w>310</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果写过，就返回写的字节数
如果没写过，就返回错误码</panel_attributes>
    <additional_attributes>10.0;10.0;2180.0;50.0;3080.0;220.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>624</x>
      <y>1378</y>
      <w>9</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>*ppos = pos;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>367</x>
      <y>1357</y>
      <w>263</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里更改了file-&gt;f_pos</panel_attributes>
    <additional_attributes>10.0;10.0;1670.0;140.0;2610.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>407</x>
      <y>1344</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_dir_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>224</x>
      <y>1333</y>
      <w>192</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有写buffer</panel_attributes>
    <additional_attributes>10.0;10.0;1900.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1133</x>
      <y>1349</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>225</x>
      <y>1333</y>
      <w>915</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放file</panel_attributes>
    <additional_attributes>10.0;10.0;9130.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1124</x>
      <y>1355</y>
      <w>33</w>
      <h>38</h>
    </coordinates>
    <panel_attributes> //递减file的count
if (atomic_dec_and_test(&amp;file-&gt;f_count)) {
 //如果f_count减到0
 //遍历inode-&gt;i_flock，删除这个file对应的FL_FLOCK|FL_LEASE锁
	locks_remove_flock(file);
	if (file-&gt;f_op &amp;&amp; file-&gt;f_op-&gt;release)
		file-&gt;f_op-&gt;release(inode, file);
	//释放module
	fops_put(file-&gt;f_op);
	file-&gt;f_dentry = NULL;
	file-&gt;f_vfsmnt = NULL;
	//释放write_access
	if (file-&gt;f_mode &amp; FMODE_WRITE)
		put_write_access(inode);
	//释放dentry mnt
	dput(dentry);
	if (mnt)
		mntput(mnt);
	//将file从anon_list加到free_list
	list_del(&amp;file-&gt;f_list);
	list_add(&amp;file-&gt;f_list, &amp;free_list);
	files_stat.nr_free_files++;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1138</x>
      <y>1352</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>15.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>376</x>
      <y>1270</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;write
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>377</x>
      <y>1278</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>381</x>
      <y>1273</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
def_blk_fops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>348</x>
      <y>1291</y>
      <w>37</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.dev不能是只读，is_read_only通过检查ro_bits相应的位
2.设置blocksize，blocksize_bits，block，offset，size
（参考block_read）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>361</x>
      <y>1281</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>397</x>
      <y>1287</y>
      <w>53</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.当起始block大于size时，返回ENOSPC
2.确定此次要写的大小chars（初始化为blocksize - offset，但是不能大于count）
3.通过getblk获取设备的bh，如果bh没更新（!buffer_uptodate）：
	1.如果是整块写（chars == blocksize），不需要将bh读进内存，只要wait_on_buffer
	2.如果不是整块写，需要将block读进来。如果f_reada 和read_ahead都为0，就不考虑预读
	否则预读规定块大小的一半，并根据size和bhlist的大小，重新更新blocks。
	将要读的bh通过getblk填充到bhlist中，然后通过ll_rw_block读取
	之后将预读的block释放（ brelse(bhlist[i])，此时因为lock，不会真正的释放），然后等待
	bh更新（ wait_on_buffer(bh)）
4.更新起始block（block++），更新ppos，更新写进的字节数written，更新要写的字节数count
	然后通过copy_from_user将用户空间的数据写入到bh中，更新用户空间的指针buf
5.mark_buffer_uptodate(bh, 1);
	mark_buffer_dirty(bh);
6.如果要求将数据同步写入磁盘（O_SYNC），将bh放到bufferlist中；当bufferlist满了，或者整个
	写操作完成之后，通过ll_rw_block将数据写入到磁盘
7.每写一个block的数据，通过balance_dirty在必要时将bh做同步
8.写操作完成之后，将filp-&gt;f_reada = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>382</x>
      <y>1281</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环在dev中读取count</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>354</x>
      <y>1350</y>
      <w>372</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
write_pipe_fops</panel_attributes>
    <additional_attributes>10.0;10.0;3700.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>718</x>
      <y>1364</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>687</x>
      <y>1372</y>
      <w>27</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.不能lseek，所以ppos = &amp;filp-&gt;f_pos
	否则返回ESPIPE
2.如果进程要写的数据字节count=0，
	直接返回0
3.通过down_interruptible申请信号量inode.i_sem
	对整个过程进行保护
4.要有PIPE_READERS，否则跳到sigpipe
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>701</x>
      <y>1367</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>821</x>
      <y>1371</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sigpipe
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>812</x>
      <y>1377</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果有写数据到fifo（written），释放信号量，
	然后返回写的字节数
2.如果没写数据（!written），向当前的进程发送
	信号SIGPIPE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>826</x>
      <y>1374</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>724</x>
      <y>1367</y>
      <w>104</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1020.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>716</x>
      <y>1372</y>
      <w>33</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.如果要写的count小于PIPE_BUF：
	1.如果是异步（O_NONBLOCK），在没有
		足够空间放下count字节数据，直接返回EAGAIN
	2.如果是同步，在没有足够空间放下couont数据
		时，睡眠直到有足够的空间能存放下count字节
		//睡着前先递增waiting_writers计数
		PIPE_WAITING_WRITERS(*inode)++;
		pipe_wait(inode);
		PIPE_WAITING_WRITERS(*inode)--;
		//如果有信号唤醒，或者没有reader，返回ERESTARTSYS
		ret = -ERESTARTSYS;
		if (signal_pending(current))
			goto out;

		if (!PIPE_READERS(*inode))
			goto sigpipe;
	3.如果有足够空间放下count字节数据，直接循环写
2.如果要写的count大于PIPE_BUF：
	1.只要有一个字节的空闲fifo，就可以写数据
	2.如果没有任何空闲空间能写，异步时返回EAGAIN，
		同步时等待睡眠，直到有空闲fifo
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>724</x>
      <y>1367</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>750</x>
      <y>1372</y>
      <w>29</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.如果有空闲的fifo（space = PIPE_FREE(*inode)!=0）
	1.本段要写的数据是 进程要写的数据count,fifo中空闲
		空间space，以及写指针到fifo尾端的空间chars的最小值
	2.通过copy_from_user将用户空间要写的数据复制到fifo中
	3.更新变量：
	 //已经写的字节数
		written += chars;
		PIPE_LEN(*inode) += chars;
		count -= chars;
		buf += chars;
		//这个宏是计算fifo空闲空间
		//因为pipe_len被计算，所以这个宏会被重新计算
		space = PIPE_FREE(*inode);
	4.通过continue，继续复制count数据
2.如果没有空闲的空间：
	1.如果是异步（O_NONBLOCK），break退出当前循环
	2.如果是同步，同样睡眠等待，醒来检查signal，pipe_readers
	注意这里do...while条件是!PIPE_FREE，和前面的PIPE_FREE(*inode) &lt; free
	不同，所以没采用pipe_read的结构

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>723</x>
      <y>1367</y>
      <w>44</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环写count字节数据</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>780</x>
      <y>1372</y>
      <w>30</w>
      <h>20</h>
    </coordinates>
    <panel_attributes> //唤醒等待队列
wake_up_interruptible(PIPE_WAIT(*inode))新
 //更新inode
inode-&gt;i_ctime = inode-&gt;i_mtime = CURRENT_TIME;
mark_inode_dirty(inode);
 //进程没写完，没有前面的步骤
 //释放信号量
up(PIPE_SEM(*inode));
 //返回写的字节数
if (written)
	ret = written;
return ret;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>724</x>
      <y>1367</y>
      <w>71</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果进程要写的数据被写完</panel_attributes>
    <additional_attributes>10.0;10.0;690.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>283</x>
      <y>1683</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>244</x>
      <y>1696</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>249</x>
      <y>1686</y>
      <w>43</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>264</x>
      <y>1696</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_verify_area
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>289</x>
      <y>1686</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file存在
f_mode &amp; FMODE_READ</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>269</x>
      <y>1691</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FLOCK_VERIFY_READ
验证这块区域是否加锁使其不可读</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>288</x>
      <y>1698</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;read
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>290</x>
      <y>1691</y>
      <w>6</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>312</x>
      <y>1698</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_dir_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>337</x>
      <y>1698</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fput
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>290</x>
      <y>1691</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>291</x>
      <y>1691</y>
      <w>53</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>179</x>
      <y>1701</y>
      <w>118</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_file_operations</panel_attributes>
    <additional_attributes>1160.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>174</x>
      <y>1713</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_file_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>151</x>
      <y>1720</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>access_ok</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>156</x>
      <y>1716</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
VERIFY_WRITE</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>139</x>
      <y>1727</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__range_ok</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>145</x>
      <y>1723</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>117</x>
      <y>1734</y>
      <w>35</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>"addl %3,%1 ;
 //flag=flag-cf，cf为1表示最高位产生了进位或者借位
sbbl %0,%0; 
 //current-&gt;addr_limit.seg-addr，然后检查cf
cmpl %1,%4; sbbl $0,%0" \
:"=&amp;r" (flag), "=r" (sum) \
:"1" (addr),"g" ((int)(size)),"g" (current-&gt;addr_limit.seg)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>132</x>
      <y>1730</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>160</x>
      <y>1727</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>desc.written = 0;
desc.count = count;
desc.buf = buf;
desc.error = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>166</x>
      <y>1716</y>
      <w>16</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>181</x>
      <y>1730</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_generic_file_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>179</x>
      <y>1716</y>
      <w>12</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>179</x>
      <y>1716</y>
      <w>38</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
desc.written
检查是否想用户空间写了
读上来的数据，否则返回错误</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>208</x>
      <y>1728</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>desc.error
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>154</x>
      <y>1743</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_max_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>162</x>
      <y>1733</y>
      <w>29</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>123</x>
      <y>1750</y>
      <w>40</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果没有设备号，或者此类设备没有规定预读的长度
	（(!inode-&gt;i_dev || !max_readahead[MAJOR(inode-&gt;i_dev)）
	则为MAX_READAHEAD
2.否则，就取规定的
max_readahead[MAJOR(inode-&gt;i_dev)][MINOR(inode-&gt;i_dev)]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>143</x>
      <y>1746</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>177</x>
      <y>1733</y>
      <w>14</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>159</x>
      <y>1744</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果超出了预读窗口
 //f_raend为预读的最后一页，f_rawin为窗口的长度
 //窗口为f_raend-f_rawin ~ f_raend
index &gt; filp-&gt;f_raend || 
index + filp-&gt;f_rawin &lt; filp-&gt;f_raend</panel_attributes>
    <additional_attributes>190.0;10.0;130.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>164</x>
      <y>1751</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>reada_ok = 0;
filp-&gt;f_raend = 0;
filp-&gt;f_ralen = 0;
filp-&gt;f_ramax = 0;
filp-&gt;f_rawin = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>177</x>
      <y>1744</y>
      <w>19</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果现在读取的内容在
之前预读的范围内</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>177</x>
      <y>1754</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>reada_ok = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>188</x>
      <y>1733</y>
      <w>15</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>188</x>
      <y>1744</y>
      <w>41</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果读取file最前半页的内容
不进行预读
 //第0页
!index &amp;&amp; 
 //第0页的前半页
offset + desc-&gt;count &lt;= (PAGE_CACHE_SIZE &gt;&gt; 1)</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>184</x>
      <y>1758</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_ramax = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>200</x>
      <y>1744</y>
      <w>8</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>201</x>
      <y>1756</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.随机读（reada_ok=0），f_ramax为正在读取的长度+1
	((offset + desc-&gt;count) &gt;&gt; PAGE_CACHE_SHIFT) + 1
2.如果是顺序读（reada_ok=1），f_ramax最小为max（need，MIN_READAHEAD）
3.不管何种情况，f_ramax最大为get_max_readahead
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>188</x>
      <y>1733</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环读取内容</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>211</x>
      <y>1741</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>206</x>
      <y>1745</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果读取的长度超出了i_size，退出循环
2.如果是inode的最后一个页面，但是超出了
	i_size &amp; ~PAGE_CACHE_MASK，也超过了inode
	的长度，退出循环
3.更新读取的长度 nr = nr - offset，
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>216</x>
      <y>1741</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从hash表中通过index找page</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>239</x>
      <y>1747</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>page_hash(mapping, index)
__find_page_nolock
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>216</x>
      <y>1741</y>
      <w>56</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;540.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>261</x>
      <y>1745</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在hash表中
找到来了page</panel_attributes>
    <additional_attributes>90.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>259</x>
      <y>1750</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>found_page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>336</x>
      <y>1751</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>no_cached_page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>269</x>
      <y>1745</y>
      <w>73</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在hash表中
没有找到page</panel_attributes>
    <additional_attributes>10.0;10.0;710.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>248</x>
      <y>1753</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加page计数</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>242</x>
      <y>1758</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_get
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>251</x>
      <y>1757</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果page和硬盘一致
</panel_attributes>
    <additional_attributes>90.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>149</x>
      <y>1771</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_file_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>259</x>
      <y>1753</y>
      <w>32</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
Page_Uptodate
注：在do_generic_file_read只检查了
	page的uptodate，所以说如果不在读的范围内
	只要在相同的page中，也要将buffer读上来</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>259</x>
      <y>1757</y>
      <w>56</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不一致</panel_attributes>
    <additional_attributes>10.0;10.0;540.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>308</x>
      <y>1760</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_not_up_to_date
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>260</x>
      <y>1766</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_ok
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>156</x>
      <y>1761</y>
      <w>102</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1000.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>255</x>
      <y>1761</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>252</x>
      <y>1769</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>245</x>
      <y>1772</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file_read_actor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>227</x>
      <y>1779</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__copy_to_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>234</x>
      <y>1775</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将读到的数据复制到用户空间</panel_attributes>
    <additional_attributes>160.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>248</x>
      <y>1779</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>desc-&gt;count = count - size;
desc-&gt;written += size;
desc-&gt;buf += size;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>250</x>
      <y>1775</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新参数
size：nr</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>267</x>
      <y>1773</y>
      <w>27</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>offset += nr;
 //递增页index
index += offset &gt;&gt; PAGE_CACHE_SHIFT;
 //算出页内偏移，开始是offset，后期是0
offset &amp;= ~PAGE_CACHE_MASK;
 //释放页
page_cache_release(page);
 //count，如果还要读，继续循环
if (nr &amp;&amp; desc-&gt;count)
	continue;
 //否则退出
break;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>263</x>
      <y>1769</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>292</x>
      <y>1768</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_file_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>299</x>
      <y>1763</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>316</x>
      <y>1763</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>301</x>
      <y>1766</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
有可能是写一个新的
页，导致其没置上，
如果进过之前一些时间导致
page和磁盘一致</panel_attributes>
    <additional_attributes>160.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>299</x>
      <y>1773</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_ok
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>316</x>
      <y>1766</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果还不一致</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>307</x>
      <y>1776</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lock_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>311</x>
      <y>1771</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>315</x>
      <y>1771</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!page-&gt;mapping
如果醒来发现从hash表中
取消</panel_attributes>
    <additional_attributes>110.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>319</x>
      <y>1777</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>UnlockPage(page);
page_cache_release(page);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>325</x>
      <y>1771</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为lock_page可能导致进程睡眠
（generic_file_write将页locked）
所以醒来要检查是否和磁盘一致
Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>351</x>
      <y>1777</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>UnlockPage(page);
goto page_ok;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>324</x>
      <y>1771</y>
      <w>55</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果还不一致，只能锁住page从硬盘中读取</panel_attributes>
    <additional_attributes>10.0;10.0;530.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>371</x>
      <y>1775</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>readpage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>335</x>
      <y>1785</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;readpage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>343</x>
      <y>1778</y>
      <w>34</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>374</x>
      <y>1778</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>356</x>
      <y>1786</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_ok
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>359</x>
      <y>1782</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果和磁盘一致了</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>370</x>
      <y>1782</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不一致
（因为异步读取，还没传上来）</panel_attributes>
    <additional_attributes>60.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>370</x>
      <y>1785</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>362</x>
      <y>1790</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_file_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>381</x>
      <y>1790</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait_on_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>382</x>
      <y>1785</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
等待</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>395</x>
      <y>1790</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_ok
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>382</x>
      <y>1785</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>397</x>
      <y>1787</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
一致</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>406</x>
      <y>1790</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>error = -EIO
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>401</x>
      <y>1787</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>341</x>
      <y>1754</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
和__find_lock_page找不到时类似
如果找到page了</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>337</x>
      <y>1759</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>readpage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>188</x>
      <y>1733</y>
      <w>136</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1340.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>307</x>
      <y>1736</y>
      <w>32</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //更新f_pos
*ppos =  index &lt;&lt; PAGE_CACHE_SHIFT) + offset;
filp-&gt;f_reada = 1;
 //释放掉cached_page
if (cached_page)
	page_cache_free(cached_page);
UPDATE_ATIME(inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>336</x>
      <y>1793</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_readpage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>344</x>
      <y>1788</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_aops</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>335</x>
      <y>1801</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_read_full_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>342</x>
      <y>1796</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_get_block</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>277</x>
      <y>1811</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page要lock
（PageLocked）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>280</x>
      <y>1804</y>
      <w>65</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>630.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>298</x>
      <y>1804</y>
      <w>47</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!page-&gt;buffers</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>291</x>
      <y>1811</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_empty_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>320</x>
      <y>1804</y>
      <w>25</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历page-&gt;buffers链表</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>316</x>
      <y>1811</y>
      <w>40</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果buffer_uptodate，不用考虑
2.如果没有映射设备的block，并且没有超出inode.i_size，
	通过get_block（ext2_get_block）去获取设备block
	注意这里的create为0
3.如果超出了inode.i_size,
	将bh对应的内存设置为0
4.因为get_block可能使buffer_uptodate，所以再次检查
	注：ext2可能没有在get_block读，可能其他文件系统有读
5.如果get_block正确返回，或者！buffer_uptodate，记录没有
	uptodate的bh到arr,数目为nr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>343</x>
      <y>1804</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!nr
page中所有的bh都uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>361</x>
      <y>1812</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>SetPageUptodate(page);
UnlockPage(page);
return 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>343</x>
      <y>1804</y>
      <w>57</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果nr存在
遍历arr</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>388</x>
      <y>1811</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lock_buffer(bh);
bh-&gt;b_end_io = end_buffer_io_async;
atomic_inc(&amp;bh-&gt;b_count);
submit_bh(READ, arr[i])
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>0</x>
      <y>1786</y>
      <w>82</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.页面locked（PageLocked），此时页面正在和磁盘交互，不管是读还是写，当这个locked清除的时候，页面必然uptodate
	如果之前有预读（f_ralen存在），且当前页面在预读窗口内（raend-f_rawin ~ raend），此时因为磁盘繁忙，并且有预读窗口
	所以暂时不用预读
	如果之前没有预读（!f_ralen）,或者当前页面超出了预读窗口，将本次要读的长度预读到内存中
2.页面没锁
	如果首页在窗口中（reada_ok不为0），不是随机读的条件1（f_ramax不为0），并且在ahead窗口中，此时需要预读；预读的长度
	为f_ramax + 1，并且将之前的ahead窗口改变为现在的current窗口（filp-&gt;f_rawin = filp-&gt;f_ralen），ahead窗口
	将会在之后被设置

注：
1.预读窗口分为current（raend-f_rawin ~ raend-f_ralen）窗口和ahead（raend-f_ralen ~ raend）窗口，其中f_ralen
	指上次预读的长度，f_rawin指的是上次和上上次一起读的长度
2.随机读的条件：
	条件1.读的是最前半页
	条件2：此次读的首页不在整个预读窗口中
	条件1不成立的时候，绝对不会预读；但是条件2不成立的时候，会预读本次要读的数据到内存中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>57</x>
      <y>1774</y>
      <w>100</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>980.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>129</x>
      <y>1774</y>
      <w>38</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
执行需要预读的页面，
超过预读的量，或者超过inode.i_size,或者预读出错，就退出</panel_attributes>
    <additional_attributes>260.0;10.0;110.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>132</x>
      <y>1785</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>154</x>
      <y>1774</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有预读页面（ahead不为0）</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>163</x>
      <y>1780</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果进行了窗口的切换
reada_ok==2</panel_attributes>
    <additional_attributes>130.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>157</x>
      <y>1786</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>run_task_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>175</x>
      <y>1780</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>173</x>
      <y>1785</y>
      <w>25</w>
      <h>18</h>
    </coordinates>
    <panel_attributes> //更新ahead窗口
filp-&gt;f_ralen += ahead;
	//更新整个预读窗口
filp-&gt;f_rawin += filp-&gt;f_ralen;
filp-&gt;f_raend = raend + ahead + 1;
 //预读页面*2
filp-&gt;f_ramax += filp-&gt;f_ramax;

if (filp-&gt;f_ramax &gt; max_readahead)
	filp-&gt;f_ramax = max_readahead;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>199</x>
      <y>1782</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drop_behind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>154</x>
      <y>1774</y>
      <w>54</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放窗口之前的page</panel_attributes>
    <additional_attributes>10.0;10.0;520.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>216</x>
      <y>1782</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>profile_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>154</x>
      <y>1774</y>
      <w>69</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>201</x>
      <y>1789</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果首页到index的长度大于窗口的长度（f_rawin），
	只释放f_rawin的页面，否则一直释放到首页
2.在hash表中找到page，并释放deactivate_page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>206</x>
      <y>1785</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>88</x>
      <y>1798</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>page_hash
__find_page_nolock
return 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>93</x>
      <y>1788</y>
      <w>49</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从hash中查找page</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>140</x>
      <y>1788</y>
      <w>16</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在hash中没找到</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>105</x>
      <y>1802</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>110</x>
      <y>1797</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>123</x>
      <y>1803</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>163</x>
      <y>1804</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>139</x>
      <y>1804</y>
      <w>20</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;readpage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>129</x>
      <y>1797</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>140</x>
      <y>1797</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>140</x>
      <y>1797</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>294</x>
      <y>1701</y>
      <w>94</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_file_operations</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>381</x>
      <y>1714</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_file_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>328</x>
      <y>1729</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dp=inode-&gt;u.generic_ip
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>334</x>
      <y>1717</y>
      <w>54</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取inode对应的硬盘文件（被抽象）</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>362</x>
      <y>1729</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_free_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>367</x>
      <y>1717</y>
      <w>22</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
分配内存</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>386</x>
      <y>1717</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>376</x>
      <y>1726</y>
      <w>37</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读取大小</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>360</x>
      <y>1735</y>
      <w>29</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>count = MIN(PROC_BLOCK_SIZE, nbytes)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>390</x>
      <y>1737</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes> dp-&gt;get_info
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>409</x>
      <y>1726</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
eof指示是否结束</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>395</x>
      <y>1731</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
之前的版本</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>409</x>
      <y>1738</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dp-&gt;read_proc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>409</x>
      <y>1731</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
新版本
返回此次读的长度</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>393</x>
      <y>1748</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>loadavg_read_proc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>414</x>
      <y>1741</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在proc_misc_init中初始化create_proc_read_entry</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>359</x>
      <y>1759</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sprintf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>366</x>
      <y>1751</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
avenrun记录这cup的负荷
nr_running, nr_threads, last_pid
分别是处于运行态的进程数量
线程的数量
最大的pid号</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>393</x>
      <y>1758</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_calc_metrics</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>399</x>
      <y>1751</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
len表示文件现在存在的数据长度</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>386</x>
      <y>1767</y>
      <w>23</w>
      <h>16</h>
    </coordinates>
    <panel_attributes> //这个条件到了文件末尾
if (len &lt;= off+count) *eof = 1;
 //offset的地址
*start = page + off;
 //此次应该读的长度，如果大于了
 //count或者小于0就更新
len -= off;
if (len&gt;count) len = count;
if (len&lt;0) len = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>395</x>
      <y>1761</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>444</x>
      <y>1735</y>
      <w>25</w>
      <h>14</h>
    </coordinates>
    <panel_attributes> //文件偏移量更新
*ppos += start &lt; page ? (long)start : n
 //剩下需要读的字节数
nbytes -= n;
 //用户空间的指针更新
buf += n;
 //完成的字节数更新
retval += n;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>429</x>
      <y>1738</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_to_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>410</x>
      <y>1726</y>
      <w>26</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>410</x>
      <y>1726</y>
      <w>44</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>441</x>
      <y>1750</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>meminfo_read_proc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>400</x>
      <y>1745</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>414</x>
      <y>1745</y>
      <w>35</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>424</x>
      <y>1758</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>si_meminfo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>442</x>
      <y>1759</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>si_swapinfo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>429</x>
      <y>1753</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>445</x>
      <y>1753</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>412</x>
      <y>1767</y>
      <w>33</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>val-&gt;totalram = totalram_pages;
val-&gt;sharedram = 0;
val-&gt;freeram = nr_free_pages();
val-&gt;bufferram = atomic_read(&amp;buffermem_pages);
val-&gt;totalhigh = totalhigh_pages;
val-&gt;freehigh = nr_free_highpages();
val-&gt;mem_unit = PAGE_SIZE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>427</x>
      <y>1761</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>446</x>
      <y>1767</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>val-&gt;freeswap = freeswap;
val-&gt;totalswap = totalswap;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>437</x>
      <y>1762</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
记录交换设备上空闲的page（swap_map如果为0）
注意switch没有break</panel_attributes>
    <additional_attributes>110.0;10.0;200.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>458</x>
      <y>1760</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sprintf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>445</x>
      <y>1753</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>478</x>
      <y>1761</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_calc_metrics</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>445</x>
      <y>1753</y>
      <w>42</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>499</x>
      <y>1724</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pid_maps_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>294</x>
      <y>1701</y>
      <w>218</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果读/proc/self/maps
proc_maps_operations</panel_attributes>
    <additional_attributes>10.0;10.0;2160.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>478</x>
      <y>1735</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>inode = file-&gt;f_dentry-&gt;d_inode
task = inode-&gt;u.proc_i.task
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>488</x>
      <y>1727</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>494</x>
      <y>1744</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.一个vma，用MAPS_LINE_SHIFT个字符表示
2.lineno表示偏移的vma
	column表示在vma中的偏移
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>506</x>
      <y>1739</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
解释</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>528</x>
      <y>1744</y>
      <w>45</w>
      <h>43</h>
    </coordinates>
    <panel_attributes>1.首先遍历mm-&gt;mmap，lineno个vma，找到偏移的vma
2.map-&gt;vm_start, map-&gt;vm_end之后的5个字符
	查看第4条（cp初始地址和str相同）
	*cp++ = flags &amp; VM_READ ? 'r' : '-';
	*cp++ = flags &amp; VM_WRITE ? 'w' : '-';
	*cp++ = flags &amp; VM_EXEC ? 'x' : '-';
	*cp++ = flags &amp; VM_MAYSHARE ? 's' : 'p';
	*cp++ = 0;
3.如果该vma映射了file，那么通过d_path将file的绝对地址存在
	buffer中（这个file向前索引最大到当前进程的root，如果删除
	路径后面会接上/(deleted)）
4.通过sprintf复制 map-&gt;vm_start, map-&gt;vm_end, str, map-&gt;vm_pgoff
	等信息到buffer中（maxlen没用完的，用空格填充）
5.如果vma中的偏移column已经大过了此次vma中的总长度len
6.copy_to_user复制len-column到用户空间
7.更新读的指针，
	destptr += i;
	count   -= i;
	column  += i;
	//更新到下一个vma
	if (column &gt;= len) {
		column = 0; /* next time: next line at column 0 */
		lineno++;
	}
8.循环结束后，更新偏移量
	*ppos = (lineno &lt;&lt; MAPS_LINE_SHIFT) + column
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>500</x>
      <y>1736</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_pid_read_maps</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>1727</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
返回复制的长度</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>472</x>
      <y>1747</y>
      <w>18</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>buffer = __get_free_page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>480</x>
      <y>1739</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>1739</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>293</x>
      <y>1701</y>
      <w>333</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
def_blk_fops</panel_attributes>
    <additional_attributes>10.0;10.0;3310.0;280.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>618</x>
      <y>1729</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>576</x>
      <y>1739</y>
      <w>52</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>blocksize：设备上的块大小（默认是BLOCK_SIZE，查询blksize_size）
blocksize_bits：blocksize所占的位
size：设备的大小（默认INT_MAX 查询blk_size，为单位）
offset：文件内的偏移
left：要读的字节数（1.offset不能大于size;2.不能超过INT_MAX；3.不能超过进程要读的字节数count）
block:起始块的索引（offset &gt;&gt; blocksize_bits）
 //属性发生变化
offset:在块内的偏移
size：设备结束块的索引
blocks：要读的block数，
（初始值：(left + offset + blocksize - 1) &gt;&gt; blocksize_bits
预读调整：read_ahead[MAJOR(dev)] / (blocksize &gt;&gt; 9)，如果小于这个值，blocks就调整为这个值
			由此可知read_ahead存储预读的块的数量（块的大小是512字节）
size调整：不能大于size - block这个剩余的大小
）
bhb：指向这个循环最后一个从设备读到内核的bh
bhe：指向这个循环最后一个从内核写到用户的bh
buflist：相当于一个FIFO,bhb是写指针（将设备的数据写到内核）bhe是读指针（将内核的数据读到用户）
	这两个指针初始化为buflist
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>596</x>
      <y>1732</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>629</x>
      <y>1739</y>
      <w>58</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.首先将要读取的block添加到队列buflist中，这里file的逻辑block和设备的block相同
	*bhb = getblk(dev, block++, blocksize)
	如果!buffer_uptodate，将bh添加到数组bhreq中
	在以下三种情况退出wile循环：
	1.第一个读进来的bh已经uptodate（uptodate！=0）
	2.队列buflist已经被装满（bhb == bhe）
	3.要读的blocks读完了（blocks==0）
2.如果数组中装有未更新的bh（bhrequest!=0）,通过ll_rw_block读取数组bhreq
	中bhrequest个bh
3.进入第二层do..while
	1.通过wait_on_buffer等待bh更新，当醒来时bh应该已经更新，如果没更新，将left赋值为0
		退出整个read过程
	2.更新读进来的字节数chars，如果left没讲block占满，则为chars = left；否者就是
		chars = blocksize - offset
		并进一步更新偏移量ppos，剩余读取量left，读取两read
	3.利用copy_to_user将数据从内核copy到用户空间，并更新buf += chars
	4.offset = 0；++bhe（到最后就回到最开始）
	5.当剩余读取量left&lt;=0，或者队列buflist读完（bhe == bhb），或者要操作的bh还没更新（buffer_locked(*bhe)）
		退出第二层do...while。
		注：当第一个条件满足时退出读操作；当第二个条件满足，并且blocks读完了，退出读操作，但是blocks没读完时，继续
		通过第一层do..while填充队列buflist；当第三个条件满足时，在第一层do..while中填充队列buflist
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>623</x>
      <y>1732</y>
      <w>26</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
第一层do..while</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>293</x>
      <y>1701</y>
      <w>467</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty_fops</panel_attributes>
    <additional_attributes>10.0;10.0;4650.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>753</x>
      <y>1714</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>704</x>
      <y>1717</y>
      <w>58</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>560.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>680</x>
      <y>1727</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.只能顺序读，所以ppos = &amp;file-&gt;f_pos
2.通过file-&gt;private_data获取tty
3.通过tty_paranoia_check检查tty是否为NULL
·magic是否为TTY_MAGIC
4.检查tty是否为空，或者tty-&gt;flags是否有TTY_IO_ERROR
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>733</x>
      <y>1730</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;ldisc.read
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>737</x>
      <y>1717</y>
      <w>26</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty-&gt;ldisc.read存在</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>776</x>
      <y>1730</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_atime = CURRENT_TIME
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>759</x>
      <y>1717</y>
      <w>28</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>738</x>
      <y>1733</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty_ldisc_N_TTY</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>732</x>
      <y>1738</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_chan</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>695</x>
      <y>1741</y>
      <w>45</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>691</x>
      <y>1746</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.tty-&gt;read_buf要存在
2.如果不是当前虚拟终端或者控制台，只是进程的tty
（TODO:暂时不是很清楚）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>736</x>
      <y>1741</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
！tty-&gt;icanon
原始模式
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>726</x>
      <y>1746</y>
      <w>38</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>从termios-&gt;c_cc中获取控制信息
time = (HZ / 10) * TIME_CHAR(tty);
minimum = MIN_CHAR(tty)
1.如果time和minimum都存在，minimum_to_wake=1，因为每次收到需要重置时间
2.如果minum存在，但是time没有，minimum_to_wake取较小的那个（等待队列为空
	就是minimum、如果等待队列不为空，就取小的那个）
3.如果没有mininum，则tty-&gt;minimum_to_wake = minimum = 1
	如果有time，将timeout的时间设置成time，否则默认为0
注：minimum_to_wake：当键入多少字符时应该唤醒tty-&gt;read_wait
	minimum：如果buffer中有minimum的字符在，即使没到nr也不会阻塞	
	timeout：进程如果没有字符，进入休眠。如果此时，进程收到了minimum_to_wake
		会醒来；或者timeout时间到了之后，醒来，如果字符有字符会继续读到buffer
		然后继续睡
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>765</x>
      <y>1747</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果是不阻塞file-&gt;f_flags &amp; O_NONBLOCK
	使用down_trylock，如果没锁住就退出
2.如果不是，就采用down_interruptible
	如果没锁住就睡眠
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>737</x>
      <y>1741</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty-&gt;atomic_read
</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>787</x>
      <y>1747</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.首先通过add_wait_queue将
	其加入等待队列tty-&gt;read_wait
2.set_bit(TTY_DONT_FLIP, &amp;tty-&gt;flags)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>738</x>
      <y>1741</y>
      <w>58</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;560.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>737</x>
      <y>1741</y>
      <w>88</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读数据
</panel_attributes>
    <additional_attributes>10.0;10.0;860.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>808</x>
      <y>1745</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty-&gt;packet（信包模式）
&amp;&amp;tty-&gt;link-&gt;ctrl_status（有数据）</panel_attributes>
    <additional_attributes>150.0;10.0;60.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>807</x>
      <y>1750</y>
      <w>17</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果之前读有其他数据（b != buf），退出整个读
2.否则将ctrl_status的数据放入到buffer，并退出
	cs = tty-&gt;link-&gt;ctrl_status;
	tty-&gt;link-&gt;ctrl_status = 0;
	put_user(cs, b++);
	nr--;
	break;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>819</x>
      <y>1745</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TASK_INTERRUPTIBLE</panel_attributes>
    <additional_attributes>40.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>826</x>
      <y>1749</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_current_state
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>843</x>
      <y>1749</y>
      <w>17</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果之前读有其他数据（b != buf），退出整个读
2.否则将ctrl_status的数据放入到buffer，并退出
	cs = tty-&gt;link-&gt;ctrl_status;
	tty-&gt;link-&gt;ctrl_status = 0;
	put_user(cs, b++);
	nr--;
	break;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>822</x>
      <y>1745</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>862</x>
      <y>1749</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;minimum_to_wake
	= (minimum - (b - buf))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>822</x>
      <y>1745</y>
      <w>48</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据已经写到buffer的数据
更新minimum_to_wake</panel_attributes>
    <additional_attributes>10.0;10.0;460.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>822</x>
      <y>1745</y>
      <w>63</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>880</x>
      <y>1748</y>
      <w>29</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.通过input_available_p检查buffer是否有
	数据（有数据返回1，没有返回0）
2.如果没有数据：
	1.tty-&gt;flags的TTY_OTHER_CLOSED，退出
	报错EIO
	2.tty_hung_up_p检查file的fops是否为hung_up_tty_fops
		（可以等等），直接退出
	3.如果timeout时间为0，直接退出
	4.如果file-&gt;f_flags &amp; O_NONBLOCK，报
		EAGAIN，退出
	5.如果当前进程signal_pending，报ERESTARTSYS
		退出
	6.否则清除TTY_DONT_FLIP，然后以timeout时间
	为限schedule_timeout，醒来之后将TTY_DONT_FLIP
	置上，然后重新循环
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>886</x>
      <y>1777</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>input_available_p</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>890</x>
      <y>1773</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>880</x>
      <y>1784</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果是加工模式（tty-&gt;icanon），并且
	缓冲行有数据（canon_data），返回1
2.如果处于原始模式，read_cnt超过规定
	数量，返回1
3.否者返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>891</x>
      <y>1780</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>910</x>
      <y>1748</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>put_user(TIOCPKT_DATA, b++);
nr--;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>822</x>
      <y>1745</y>
      <w>95</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果packet mode
并且之前没读过(b == buf)</panel_attributes>
    <additional_attributes>10.0;10.0;930.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>933</x>
      <y>1748</y>
      <w>41</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.如果是加工模式（tty-&gt;icanon），就循环读取，直到
	读完nr或者将整个缓冲行读完（tty-&gt;read_cnt）
	1.1.read_flags中记载着该位置上的字符是不是缓冲行终结字符（\n）
	1.2.将buffer队列中的数据取出tty-&gt;read_buf[tty-&gt;read_tail]
	1.3.更新读端tty-&gt;read_tail，更新tty-&gt;read_cnt--
	1.4.如果是缓冲行最后一个字符是'\0'，就不用复制到用户空间
		否者：
		put_user(c, b++);
		nr--;
	1.5.如果缓冲行结束（eol），就退出此次复制
2.通过copy_from_read_buf将缓冲队列中的数据复制到用户空间
	（这里buffer是一个回环队列，而copy_from_read_buf
	中copy_to_user地址只能朝一个方向生长，所以这里复制了两次）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>821</x>
      <y>1745</y>
      <w>124</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1220.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>948</x>
      <y>1774</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_from_read_buf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>954</x>
      <y>1770</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>937</x>
      <y>1781</y>
      <w>34</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.从要读的数据nr，buffer中存在的数据量tty-&gt;read_cnt
	以及tail到buffer尾端的长度（N_TTY_BUF_SIZE - tty-&gt;read_tail，
	这里是让tail之前的数据，在另一个copy_from_read_buf
	中执行）选取一个最小值
2.通过copy_to_user将缓冲队列中的数据（tty-&gt;read_buf）
	复制到用户空间
3.更新缓冲队列，用户空间buffer和nr
	tty-&gt;read_tail = (tty-&gt;read_tail + n) &amp; (N_TTY_BUF_SIZE-1);
	tty-&gt;read_cnt -= n
	*b += n;
	*nr -= n;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>954</x>
      <y>1777</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>978</x>
      <y>1748</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过n_tty_chars_in_buffer检查缓冲队列中的数据
	是否低于TTY_THRESHOLD_UNTHROTTLE。如果低于
	通过check_unthrottle将阀门打开
注;当键盘输入过快时，应用程序来不及将数据读入缓冲区
	驱动（中断)会将阀门关闭，现在低于门限，需要将其
	打开
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>979</x>
      <y>1762</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>n_tty_chars_in_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>984</x>
      <y>1758</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>975</x>
      <y>1769</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果处于原始模式(!tty-&gt;icanon)，
	缓冲队列中的字符数是tty-&gt;read_cnt
2.如果处于加工模式，并且缓冲行
	有数据（tty-&gt;canon_data），字符
	数是tail~head的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>985</x>
      <y>1765</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1000</x>
      <y>1762</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>check_unthrottle</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>999</x>
      <y>1758</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1001</x>
      <y>1769</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>检查TTY_THROTTLED是否置上，
如果置上，使用tty-&gt;driver.unthrottle
将阀门打开
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1006</x>
      <y>1765</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>821</x>
      <y>1745</y>
      <w>171</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1690.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1010</x>
      <y>1748</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果读入字符数量超过了minimum，则退出
2.如果继续读的话，更新timeout为time
注;nr决定了此次读的上限，minimum是下限，
	加工模式具体读多少取决于缓冲行
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>822</x>
      <y>1745</y>
      <w>197</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1950.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1044</x>
      <y>1745</y>
      <w>25</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>clear_bit(TTY_DONT_FLIP
remove_wait_queue(&amp;tty-&gt;read_wait
 //如果等待队列tty-&gt;read_wait中没有
 //等待的进程，更新minimum_to_wake
tty-&gt;minimum_to_wake = minimum

current-&gt;state = TASK_RUNNING
 //如果读到数据（b - buf），返回b - buf
 //如果nr存在（表示进程已经来读过）
 clear_bit(TTY_PUSH
 //如果没读到数据，且TTY_PUSH，就
 //返回重新读
注：TTY_PUSH是底层驱动读到EOF将
	其置成1，表示进程需尽快读走
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>738</x>
      <y>1741</y>
      <w>313</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>296</x>
      <y>1701</y>
      <w>804</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_scanner_fops</panel_attributes>
    <additional_attributes>10.0;10.0;8020.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1093</x>
      <y>1724</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_scanner</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1095</x>
      <y>1727</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1079</x>
      <y>1731</y>
      <w>39</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.更新时间：
	file-&gt;f_dentry-&gt;d_inode-&gt;i_atime = CURRENT_TIME
2.循环从usb设备中读取count个数据
	1.检查进程如果有signal_pending，返回EINTR
	2.依次读的量不能大于IBUF_SIZE，并通过usb_bulk_msg去usb设备中读
	3.如果结果是timeout，并且没有任何数据读进来。这样的情形最多有RD_EXPIRE
	次，每次通过interruptible_sleep_on_timeout让进程睡眠RD_NAK_TIMEOUT
	时间；
	如果是其他错误（除了USB_ST_DATAUNDERRUN），返回EIO
	4.如果读到了数据（partial），最多将其前24字节打印出来
	5.如果读到了数据（partial），通过copy_to_user将数据copy到用户空间,并更新：
	//预期读this_read,实际读partial
	count -= this_read; /* Compensate for short reads */
	bytes_read += partial; /* Keep tally of what actually was read */
	buffer += partial;
	如果没读到数据，直接返回bytes_read
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1095</x>
      <y>1763</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_bulk_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1097</x>
      <y>1757</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_rcvbulkpipe
endpoint是bulk_in_ep</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1074</x>
      <y>1770</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_alloc_urb
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1078</x>
      <y>1766</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1089</x>
      <y>1770</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>urb-&gt;dev=usb_dev;\
urb-&gt;pipe=pipe;\
urb-&gt;transfer_buffer=data;\
urb-&gt;transfer_buffer_length=len;\
urb-&gt;complete=usb_api_blocking_completion;\
urb-&gt;context=0;\
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1099</x>
      <y>1766</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FILL_BULK_URB</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1115</x>
      <y>1770</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_start_wait_urb
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1101</x>
      <y>1766</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1144</x>
      <y>1718</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>298</x>
      <y>1701</y>
      <w>853</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
read_fifo_fops</panel_attributes>
    <additional_attributes>10.0;10.0;8510.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1121</x>
      <y>1725</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.因为pipe不能lseek，所以ppos
	指针必须是&amp;filp-&gt;f_pos
	如果不是，返回ESPIPE
2.如果要读的数据是count，返回0
3.通过inode.sem对整个过程保护
	（down_interruptible）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1129</x>
      <y>1721</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1148</x>
      <y>1721</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果fifo中没有数据
PIPE_EMPTY（inode.i_size=0）</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1142</x>
      <y>1725</y>
      <w>28</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果没有PIPE_WRITERS，直接返回0
2.如果f_flags &amp; O_NONBLOCK，返回EAGAIN
3.循环：
	增加WAITING_READERS的计数，然后通过pipe_wait
	睡眠。
	如果醒来之后，减少WAITING_READERS的计数
	1.如果是因为信号被唤醒（signal_pending），返回ERESTARTSYS
	2.如果是因为有数据被唤醒（!PIPE_EMPTY），退出循环
	3.如果是因为没PIPE_WRITERS被唤醒，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1149</x>
      <y>1744</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_wait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>1740</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>1747</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1151</x>
      <y>1721</y>
      <w>42</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
到这是因为有数据可读</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1177</x>
      <y>1725</y>
      <w>27</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.循环读取数据，直到进程要求读取的数据读取完（count&lt;=0）
	或者fifo中的数据读取完（PIPE_LEN=0）
2.一次读取的数据是count，PIPE_LEN以及PIPE_MAX_RCHUNK（
	start到fifo尾端的长度）的最小值
3.通过copy_to_user将fifo中的数据复制到用户空间
4.更新数据：
	//read是已读的所有数据长度
	read += chars;
	//start是读端的起始位置
	PIPE_START(*inode) += chars;
	PIPE_START(*inode) &amp;= (PIPE_SIZE - 1);
	PIPE_LEN(*inode) -= chars;
	count -= chars;
	buf += chars;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1152</x>
      <y>1721</y>
      <w>63</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_LEN=0
fifo中的数据全部读完
减少下次分两段读的可能性</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1207</x>
      <y>1724</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>PIPE_START(*inode) = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1152</x>
      <y>1721</y>
      <w>85</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;830.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1230</x>
      <y>1724</y>
      <w>30</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果进程要读的数据并没有被读完（count！=0）
	并且pipe中有等待的写端（WAITING_WRITERS）
	并且file被设置成block（!(f_flags &amp; O_NONBLOCK)）
	将等待队列中的唤醒，并跳到do_more_read去等待：
	wake_up_interruptible_sync(PIPE_WAIT(*inode));
	goto do_more_read;
2.如果上述条件并不满足，直接通过wake_up_interruptible唤醒
	等待队列，并返回已读的数据字节数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1139</x>
      <y>1750</y>
      <w>31</w>
      <h>19</h>
    </coordinates>
    <panel_attributes> //申明wait，并将其挂入等待队列
DECLARE_WAITQUEUE(wait, current);
current-&gt;state = TASK_INTERRUPTIBLE;
add_wait_queue(PIPE_WAIT(*inode), &amp;wait);
 //释放信号量，并调度
up(PIPE_SEM(*inode));
schedule();
 //移除wait，并申请信号量
remove_wait_queue(PIPE_WAIT(*inode), &amp;wait);
current-&gt;state = TASK_RUNNING;
down(PIPE_SEM(*inode));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>629</x>
      <y>1796</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.check bh.size和正确的block size是否一致
2.如果要求写，通过is_read_only查看dev是否
	只读

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>661</x>
      <y>1793</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>658</x>
      <y>1798</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过test_and_set_bit
	检查并设置BH_Lock
2.bh-&gt;b_end_io = 
			end_buffer_io_sync
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>667</x>
      <y>1793</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
rw</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>676</x>
      <y>1797</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
WRITE</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>674</x>
      <y>1801</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过atomic_set_buffer_clean
	检查并清除BH_Dirty
	如果没有置上，通过b_end_io
	结束这个bh请求
2.如果dirty置上了，通过__mark_buffer_clean
	改变bh在lru数组中的位置
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>679</x>
      <y>1797</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
READA
READ</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>695</x>
      <y>1802</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.检查bh是否uptodate，如果
	更新了，通过b_end_io结束
	bh请求
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>667</x>
      <y>1793</y>
      <w>70</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果bh请求没被end_io</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>728</x>
      <y>1802</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>submit_bh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>677</x>
      <y>1812</y>
      <w>32</w>
      <h>13</h>
    </coordinates>
    <panel_attributes> //lock要置上
test_bit(BH_Lock

set_bit(BH_Req
bh-&gt;b_rdev = bh-&gt;b_dev;
 //扇区的大小是512字节
bh-&gt;b_rsector = bh-&gt;b_blocknr * (bh-&gt;b_size&gt;&gt;9);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>687</x>
      <y>1805</y>
      <w>49</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>735</x>
      <y>1810</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_make_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>734</x>
      <y>1805</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>735</x>
      <y>1805</y>
      <w>42</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>770</x>
      <y>1810</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>WRITE:
kstat.pgpgout++
default:
kstat.pgpgin++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>713</x>
      <y>1813</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>710</x>
      <y>1816</y>
      <w>29</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.b_end_io要存在
2.通过blk_size计算出dev的扇区数maxsector
	通过bh-&gt;b_size计算出一个bh包含多少个扇区
	如果要写的扇区数count&gt;maxsector
	或者从sector写count个扇区后超过maxsector
	bh-&gt;b_state &amp;= (1 &lt;&lt; BH_Lock) | (1 &lt;&lt; BH_Mapped)
	bh-&gt;b_end_io(bh, 0)
halign=left
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>723</x>
      <y>1813</y>
      <w>51</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过do..while循环向终极设备发送请求
例如对RAID设备，因为RAID设备是对底层硬盘的抽象
所以通过make_request_fn向RAID设备发送请求时，
RAID设备会向第一块硬盘写，然后返回1，通过do..while
再次发送请求，RAID会向第二块硬盘发送写请求，并返回0，终止make_request
注：RAID参考南京大学蒋炎岩老师的视频</panel_attributes>
    <additional_attributes>220.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>746</x>
      <y>1816</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>740</x>
      <y>1819</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blk_get_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>740</x>
      <y>1825</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__blk_get_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>745</x>
      <y>1822</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>736</x>
      <y>1828</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>720</x>
      <y>1832</y>
      <w>37</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果blk_dev[MAJOR(dev)].queue存在，返回queue
2.否者返回blk_dev[MAJOR(dev)].request_queue
注：首次通过queue找到dev的队列，之后就可以直接通过
	request_queue找到
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>750</x>
      <y>1816</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>727</x>
      <y>1843</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_get_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>759</x>
      <y>1820</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;make_request_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>733</x>
      <y>1838</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hwif_init：
blk_dev[hwif-&gt;major].data = hwif;
blk_dev[hwif-&gt;major].queue = ide_get_queue;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>718</x>
      <y>1849</y>
      <w>28</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>hwif-&gt;drives[DEVICE_NR(dev) &amp; 1].queue
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>732</x>
      <y>1846</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>757</x>
      <y>1822</y>
      <w>44</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hwif_init-&gt;init_irq-&gt;ide_init_queue-&gt;blk_init_queue-&gt;__make_request</panel_attributes>
    <additional_attributes>100.0;20.0;330.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>783</x>
      <y>1825</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__make_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>758</x>
      <y>1833</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果是预读（READA）：
	rw_ahead = 1;
	rw = READ
2.通过buffer_mapped检测bh是否
	映射到磁盘

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>760</x>
      <y>1828</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>782</x>
      <y>1835</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_bounce</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>787</x>
      <y>1828</y>
      <w>5</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>788</x>
      <y>1838</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
DMA寻址范围是32位，不能寻址超过4G
需要将低内存区域对其做一个镜像
注：__GFP_HIGH和__GFP_HIGHMEM不一样</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>766</x>
      <y>1841</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>755</x>
      <y>1845</y>
      <w>21</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>!PageHighMem，不做任何处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>780</x>
      <y>1841</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bh_cachep中申请bh</panel_attributes>
    <additional_attributes>90.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>778</x>
      <y>1845</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>793</x>
      <y>1845</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>787</x>
      <y>1841</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在低于4G申请内存</panel_attributes>
    <additional_attributes>20.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>803</x>
      <y>1849</y>
      <w>30</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>set_bh_page(bh, page, 0);

bh-&gt;b_next = NULL;
bh-&gt;b_blocknr = bh_orig-&gt;b_blocknr;
bh-&gt;b_size = bh_orig-&gt;b_size;
bh-&gt;b_list = -1;
bh-&gt;b_dev = bh_orig-&gt;b_dev;
bh-&gt;b_count = bh_orig-&gt;b_count;
bh-&gt;b_rdev = bh_orig-&gt;b_rdev;
bh-&gt;b_state = bh_orig-&gt;b_state;
bh-&gt;b_flushtime = jiffies;
bh-&gt;b_next_free = NULL;
bh-&gt;b_prev_free = NULL;
bh-&gt;b_reqnext = NULL;
bh-&gt;b_pprev = NULL;

w:
bh-&gt;b_end_io = bounce_end_io_write;
copy_from_high_bh(bh, bh_orig);
r:
bh-&gt;b_end_io = bounce_end_io_read

bh-&gt;b_private = (void *)bh_orig;
bh-&gt;b_rsector = bh_orig-&gt;b_rsector;
memset(&amp;bh-&gt;b_wait, -1, sizeof(bh-&gt;b_wait));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>788</x>
      <y>1841</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>820</x>
      <y>1831</y>
      <w>39</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.从max_sectors中获取dev的扇区数（默认是MAX_SECTORS）
2.获取latency(r:read_latency;w:write_latency)，用于后期电梯
	算法的优化
3.如果req已经开始执行，但是没从队列里删除，会在执行完
	之后删除（q-&gt;head_active）
	并且不在bottom_half的任务队列tq_disk中（!q-&gt;plugged）
	head指向q-&gt;queue_head-&gt;next
4.如果队列为空：list_empty(head)，执行q-&gt;plug_device_fn
	因为队列为空，所以不用电梯算法优化，直接get_rq（申请req，
	加入到电梯队列中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>789</x>
      <y>1828</y>
      <w>44</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>840</x>
      <y>1850</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;plug_device_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>847</x>
      <y>1847</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>845</x>
      <y>1853</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
blk_init_queue</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>840</x>
      <y>1856</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_plug_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>834</x>
      <y>1863</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果请求队列为空或者
	队列中有req在tq_disk中
	这个req的IO由进程自己启动
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>841</x>
      <y>1859</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>847</x>
      <y>1859</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不由进程启动IO</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>860</x>
      <y>1862</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>855</x>
      <y>1866</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;plugged = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>863</x>
      <y>1862</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将队列挂在tq_disk中</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>871</x>
      <y>1866</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>queue_task</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>861</x>
      <y>1872</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>test_and_set_bit
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>877</x>
      <y>1872</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_add_tail
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>862</x>
      <y>1869</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
队列的plug_tq.sync检查是否为0
并置1</panel_attributes>
    <additional_attributes>130.0;10.0;70.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>875</x>
      <y>1869</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>866</x>
      <y>1831</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>elevator-&gt;elevator_merge_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>788</x>
      <y>1828</y>
      <w>86</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
blk_init_queue
ELEVATOR_LINUS</panel_attributes>
    <additional_attributes>10.0;10.0;840.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>867</x>
      <y>1838</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>elevator_linus_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>874</x>
      <y>1834</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>860</x>
      <y>1845</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果q-&gt;queue_head只是因为没执行完
	而没在队列中删除（head_active），
	而不是其他原因（q-&gt;plugged），就将
	head指向队列中的下一个
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>869</x>
      <y>1841</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>889</x>
      <y>1845</y>
      <w>37</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.向前遍历request_queue链表，滤除以下req：
	1.队列中req信号量sem存在
	2.队列中req的cmd的读写操作和rw不同
	3.队列中的req写的nr_sectors和现在req要写扇区数
	（count）超过了最大扇区数max_sectors
	4.队列中的req的设备号rq_dev和要写的req
		的b_rdev不同
2.如果要写的req在队列中req的后面
	if (__rq-&gt;sector + __rq-&gt;nr_sectors == bh-&gt;b_rsector) {
			ret = ELEVATOR_BACK_MERGE;
3.如果要写的req在队列中req的前面
	if (__rq-&gt;sector - count == bh-&gt;b_rsector) {
		//elevator_sequence来自latency，在这个检测之前，会看其是否为0
		//这个在电梯算法中为了防止order值过大的req饥饿，所以只要在req的前面
		//有插一个新req，req和之后的req的elevator_sequence都会--
			__rq-&gt;elevator_sequence--;
			ret = ELEVATOR_FRONT_MERGE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>876</x>
      <y>1841</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>927</x>
      <y>1845</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>如果新的req需要merge，并且被merge
的req之后链表还有req
因为之后的req前面有添加req，
所以需要把他们的tmp-&gt;elevator_sequence--
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>876</x>
      <y>1841</y>
      <w>62</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;600.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>789</x>
      <y>1828</y>
      <w>193</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1910.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>967</x>
      <y>1832</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ELEVATOR_BACK_MERGE</panel_attributes>
    <additional_attributes>130.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>964</x>
      <y>1836</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>960</x>
      <y>1848</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ll_back_merge_fn</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>960</x>
      <y>1841</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;back_merge_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>966</x>
      <y>1844</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
blk_init_queue</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>937</x>
      <y>1855</y>
      <w>42</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果req中最后一个bh能和插入的bh在物理内存
	上合并成在一起：
	req-&gt;bhtail-&gt;b_data + req-&gt;bhtail-&gt;b_size == bh-&gt;b_data
	直接返回，不对nr_segments操作
2.如果不能，通过ll_new_segment对nr_segments进行操作
	req-&gt;nr_segments++;
	q-&gt;elevator.nr_segments++
	如果req-&gt;nr_segments超过了限制，返回0，从而不对req进行合并
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>960</x>
      <y>1851</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>972</x>
      <y>1836</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果可以进行合并</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>976</x>
      <y>1841</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //bhtail指向req-&gt;bh链表中最后一个bh
req-&gt;bhtail-&gt;b_reqnext = bh;
req-&gt;bhtail = bh;
req-&gt;nr_sectors = req-&gt;hard_nr_sectors += count;
req-&gt;e = elevator;
 //硬盘信息统计
drive_stat_acct
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>971</x>
      <y>1836</y>
      <w>47</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1010</x>
      <y>1841</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>attempt_back_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1010</x>
      <y>1848</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果当前req是队列中的最后一个，没
	办法merge，直接return
2.不是最后一个，通过attempt_merge
	看能否将req和req.next merge
注：因为新插入的req可能将前后两个req
	连接起来
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1015</x>
      <y>1860</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>attempt_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1019</x>
      <y>1844</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1022</x>
      <y>1857</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1009</x>
      <y>1867</y>
      <w>34</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.查看两个相邻的req在扇区上是否能合并
	req-&gt;sector + req-&gt;nr_sectors = next-&gt;sector
2.查看两个req的属性是否相同，参考elevator_linus_merge
	req-&gt;cmd = next-&gt;cmd
	&amp;&amp; req-&gt;rq_dev = next-&gt;rq_dev
	&amp;&amp; req-&gt;nr_sectors + next-&gt;nr_sectors &lt; max_sectors
	&amp;&amp; !next-&gt;sem
3.通过q-&gt;merge_requests_fn查看bh指向的物理内存
	是否可以合并（nr_segments不能超过限制）
4.如果可以合并：
	//将next的bh链表加入到req的bh链表中，bhtail指向next的bh最后一个
	req-&gt;bhtail-&gt;b_reqnext = next-&gt;bh;
	req-&gt;bhtail = next-&gt;bhtail;
	req-&gt;nr_sectors = req-&gt;hard_nr_sectors += next-&gt;hard_nr_sectors;
	//将next从队列中删除
	list_del(&amp;next-&gt;queue);
	blkdev_release_request
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1022</x>
      <y>1863</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1017</x>
      <y>1899</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_release_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1025</x>
      <y>1895</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1011</x>
      <y>1902</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>996</x>
      <y>1906</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>req-&gt;rq_status = RQ_INACTIVE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1014</x>
      <y>1902</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
req-&gt;free_list不为空
free_list记录req是来自read_req还是write_req链表</panel_attributes>
    <additional_attributes>130.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1023</x>
      <y>1905</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
req释放给free_list</panel_attributes>
    <additional_attributes>90.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1020</x>
      <y>1910</y>
      <w>9</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>list_add
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1031</x>
      <y>1909</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>req-&gt;free_list = NULL;
 //唤醒队列的req等待序列
wake_up(&amp;req-&gt;q-&gt;wait_for_request)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1032</x>
      <y>1905</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>979</x>
      <y>1832</y>
      <w>82</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ELEVATOR_FRONT_MERGE</panel_attributes>
    <additional_attributes>10.0;10.0;800.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1045</x>
      <y>1836</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1039</x>
      <y>1841</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;front_merge_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1039</x>
      <y>1848</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ll_front_merge_fn</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1044</x>
      <y>1844</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1044</x>
      <y>1858</y>
      <w>42</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果bh能和req的最前面的bh在物理内存上合并成在一起：
	bh-&gt;b_data + bh-&gt;b_size == req-&gt;bh-&gt;b_data
	直接返回，不对nr_segments操作
2.如果不能，通过ll_new_segment对nr_segments进行操作
	req-&gt;nr_segments++;
	q-&gt;elevator.nr_segments++
	如果req-&gt;nr_segments超过了限制，返回0，从而不对req进行合并
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1044</x>
      <y>1851</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1058</x>
      <y>1836</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果可以进行合并</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1065</x>
      <y>1839</y>
      <w>33</w>
      <h>18</h>
    </coordinates>
    <panel_attributes> //将bh插入到req的头部
bh-&gt;b_reqnext = req-&gt;bh;
req-&gt;bh = bh;
 //buffer指向第一个bh的数据内存地址
req-&gt;buffer = bh-&gt;b_data;
 //第一个bh有多少个扇区
req-&gt;current_nr_sectors = count;
req-&gt;sector = req-&gt;hard_sector = sector;
req-&gt;nr_sectors = req-&gt;hard_nr_sectors += count;
req-&gt;e = elevator;
drive_stat_acct
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1101</x>
      <y>1839</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>attempt_front_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1057</x>
      <y>1836</y>
      <w>53</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1100</x>
      <y>1846</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果当前req是队列中的第一个，没
	办法merge，直接return
2.不是第一个，通过attempt_merge
	看能否将req.prev和req merge
注：因为新插入的req可能将前后两个req
	连接起来
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1109</x>
      <y>1842</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>980</x>
      <y>1832</y>
      <w>173</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ELEVATOR_NO_MERGE</panel_attributes>
    <additional_attributes>10.0;10.0;1710.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1146</x>
      <y>1837</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_rq
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>971</x>
      <y>1836</y>
      <w>64</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1029</x>
      <y>1840</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1121</x>
      <y>1839</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1057</x>
      <y>1836</y>
      <w>70</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1126</x>
      <y>1846</y>
      <w>34</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果之前申请过freereq
	req = freereq;
	freereq = NULL
2.如果没申请过req，通过get_request申请，
	因为req在blk_init_free_list规定是有限的
	所以有可能申请不到
3.当申请不到时，如果时预读（rw_ahead），直接结束
	本次读取；如果不是通过__get_request_wait等待
	获取，因为醒来时电梯中的req可能发生改变，所以再次
	遍历dev的request_queue
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1138</x>
      <y>1840</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1127</x>
      <y>1866</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1131</x>
      <y>1862</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1114</x>
      <y>1872</y>
      <w>31</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.首先获取空闲req的read/write链表
	q-&gt;request_freelist[rw]
2.如果空闲req链表不为空，通过blkdev_free_rq
	从空闲链表中获取req
3.如果空闲req为空，尝试从write req空闲链表中
	通过blkdev_free_rq获取req
4.如果获取到req，将req脱链，并进行初始化
	list_del(&amp;rq-&gt;table);
	//释放时，释放给对应的free_list
	rq-&gt;free_list = list;
	rq-&gt;rq_status = RQ_ACTIVE;
	rq-&gt;special = NULL;
	//指向req队列
	rq-&gt;q = q;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1127</x>
      <y>1869</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1147</x>
      <y>1867</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_request_wait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1146</x>
      <y>1862</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1149</x>
      <y>1875</y>
      <w>35</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.申明一个wait，加入到队列的wait_for_request链表中
2.将进程的状态设置为TASK_UNINTERRUPTIBLE，并
	试图通过get_request获取req，如果得到了，则退出
	将进程的状态还原，并将wait从wait_for_request从
	链表中移除
3.如果还是无法获取req，通过generic_unplug_device
	执行req队列从而释放req，并schedule
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>1870</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1160</x>
      <y>1891</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_unplug_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>1887</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1161</x>
      <y>1898</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__generic_unplug_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>1894</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>1901</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
q-&gt;plugged
如果有req在tq_disk中</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1163</x>
      <y>1904</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1156</x>
      <y>1907</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;plugged = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1167</x>
      <y>1904</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
q-&gt;queue_head</panel_attributes>
    <additional_attributes>20.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1171</x>
      <y>1907</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;request_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1177</x>
      <y>1910</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_init_queue-&gt;blk_init_queue</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1172</x>
      <y>1914</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_ide_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1150</x>
      <y>1840</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果获取到了req</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1166</x>
      <y>1843</y>
      <w>37</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>req-&gt;cmd = rw;
req-&gt;errors = 0;
req-&gt;hard_sector = req-&gt;sector = sector;
req-&gt;hard_nr_sectors = req-&gt;nr_sectors = count;
 //第一个bh包含的扇区数
req-&gt;current_nr_sectors = count;
 //最初的bh只有一个内存区间
req-&gt;nr_segments = 1; 
req-&gt;nr_hw_segments = 1;
 //buffer是之后硬盘要返回数据的指针，指向缓冲区
req-&gt;buffer = bh-&gt;b_data;
req-&gt;sem = NULL;
 //bh指向链表，bhtail指向最后一个链表
req-&gt;bh = bh;
req-&gt;bhtail = bh;
req-&gt;rq_dev = bh-&gt;b_rdev;
req-&gt;e = elevator;
 //将req加入到电梯队列中
add_request(q, req, head, latency)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1194</x>
      <y>1877</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1192</x>
      <y>1873</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1189</x>
      <y>1880</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
硬盘信息统计</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1185</x>
      <y>1883</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drive_stat_acct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1199</x>
      <y>1883</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;elevator.elevator_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1196</x>
      <y>1880</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
blk_init_queue
ELEVATOR_LINUS</panel_attributes>
    <additional_attributes>40.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1203</x>
      <y>1890</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>elevator_linus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1207</x>
      <y>1886</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1185</x>
      <y>1897</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>req-&gt;elevator_sequence 
				= orig_latency
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1191</x>
      <y>1893</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1207</x>
      <y>1893</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1204</x>
      <y>1897</y>
      <w>32</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.从后向前扫描req链表
2.通过blkdev_entry_to_request获取temp
3.通过IN_ORDER来看要插入的req是否在权重
	上大于temp，如果大于，req就要插到temp的
	后面
	list_add(&amp;req-&gt;queue, entry)
4.如果小于temp，需要插到temp前面，通过
	检查elevator_sequence查看temp前面是否能
	插入req；如果不能，只能插到temp后面；如果可以
	elevator_sequence--
注：1. linux2.4.0为了防止电梯队列中队列最后的
		req饥饿，通过以下方法：
		1.从前向后遍历req链表
		2.elevator_sequence设置req能允许多少个req
			插入其前面
	2.相比于linux0.11，order的权重少了rw的比较
		另外，linux0.11依靠!IN_ORDER(tmp,tmp-&gt;next)
		来防止后面的req饥饿
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1214</x>
      <y>1838</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>790</x>
      <y>1828</y>
      <w>429</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;4270.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>789</x>
      <y>1828</y>
      <w>451</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;4490.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1207</x>
      <y>1841</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!q-&gt;plugged
如果不在tq_disk中</panel_attributes>
    <additional_attributes>110.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1204</x>
      <y>1846</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;request_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1217</x>
      <y>1846</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_release_request
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1216</x>
      <y>1841</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果freereq没用
将其释放</panel_attributes>
    <additional_attributes>20.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1235</x>
      <y>1838</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>end_io
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1234</x>
      <y>1846</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bh-&gt;b_end_io
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1238</x>
      <y>1841</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1199</x>
      <y>1880</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1220</x>
      <y>1883</y>
      <w>26</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>当major满足：
COMPAQ_SMART2_MAJOR~COMPAQ_SMART2_MAJOR+7
COMPAQ_CISS_MAJOR~COMPAQ_CISS_MAJOR+7
DAC960_MAJOR~ DAC960_MAJOR+7
时：
q-&gt;request_fn
注：这里执行request_fn，是即使req加入到
	tq_disk，也要进程自己将其IO启动
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1172</x>
      <y>1921</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_do_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1176</x>
      <y>1917</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1089</x>
      <y>1924</y>
      <w>89</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
关闭中断</panel_attributes>
    <additional_attributes>870.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1087</x>
      <y>1928</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__cli
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1176</x>
      <y>1924</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!hwgroup-&gt;busy</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1096</x>
      <y>1931</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hwgroup-&gt;busy = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1102</x>
      <y>1927</y>
      <w>77</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>750.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1112</x>
      <y>1932</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>choose_drive</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1115</x>
      <y>1927</y>
      <w>64</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1066</x>
      <y>1939</y>
      <w>61</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.遍历hwgroup-&gt;drive（以next连接），如果dev所在
	的req队列不为空，并且设备没有睡眠（!drive-&gt;sleep）
	或者设备已经从睡眠中苏醒（0 &lt;= (signed long)(jiffies - drive-&gt;sleep)）
	时，在下列三种情况下，dev可以参选best：
	1.best还没有
	2.dev有睡过（drive-&gt;sleep，因为前面有条件，所以这里一定是睡着之后醒过来的）
		并且best没睡或者best.sleep比dev大（说明best的req请求是在dev之后，不然best在
		之前就执行完了，不会等到现在才执行）
	3.如果best和dev都不需要睡，就比较执行完操作醒来的时间WAKEUP(best) - WAKEUP(drive)
	（这里有两个假设，1，上次执行的时间service_time和此次执行的时间相同；2，上次执行完的时间点
		和现在执行这个函数的时间点一样，都是drive-&gt;service_start+drive-&gt;service_time
		所以(drive)-&gt;service_start + 2 * (drive)-&gt;service_time是预估dev执行完这个req
		所需的时间）
	如果上述3个条件满足其中一个，并且不在tq_disk中（!drive-&gt;queue.plugged ）
	best = drive
2.如果best存在，且其nice1存在，不曾睡眠（!best-&gt;sleep），best没有和group中的其他dev比较完
	（best != hwgroup-&gt;drive），上一次best的操作时间service_time &gt; WAIT_MIN_SLEEP
	如果上述条件满足，并且此次预估的操作时间WAKEUP(best) - jiffies&gt;WAIT_MIN_SLEEP
	然后再次从best遍历链表，如果在链表中发现有一个dev的sleep为0（只要激活立刻能请求），并且
	dev预估醒来的时间WAKEUP(drive)要大于best上次请求的时间（jiffies - best-&gt;service_time）（这里应该是为了确定dev没有长时间的在tq_disk中，如果长时间在tq_disk中，best留时间给dev也没用）
	并且dev预估醒来的时间比best要块时：
	通过ide_stall_queue让best sleep
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1090</x>
      <y>1978</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_stall_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1084</x>
      <y>1985</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drive-&gt;sleep = timeout + jiffies
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1099</x>
      <y>1935</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1094</x>
      <y>1974</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1092</x>
      <y>1981</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1131</x>
      <y>1927</y>
      <w>48</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive == NULL
如果没找到要执行req的设备</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1128</x>
      <y>1934</y>
      <w>37</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.遍历group的设备链表，找到其中能最早醒来的设备
2.如果sleep=0,表示没有设备睡着，是没有正在请求的req
3.如果sleep存在，设置相应的标志位
	hwgroup-&gt;sleeping = 1
	并且设置定时器hwgroup-&gt;timer，当时间到达之后通知执
	行req的超时（timer的function在init_irq中被设置为ide_timer_expiry）
4.之后直接return
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1140</x>
      <y>1949</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mod_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1144</x>
      <y>1945</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1128</x>
      <y>1957</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>timer-&gt;expires = expires;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1132</x>
      <y>1952</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1146</x>
      <y>1957</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>detach_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1144</x>
      <y>1952</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1158</x>
      <y>1957</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>internal_add_timer
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1144</x>
      <y>1952</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1137</x>
      <y>1964</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.通过timer_pending查看timer是否在链表中
2.如果在，通过list_del将time从链表中删除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1151</x>
      <y>1960</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1167</x>
      <y>1927</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取设备所在的接口</panel_attributes>
    <additional_attributes>100.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1165</x>
      <y>1934</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hwif = HWIF(drive)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1179</x>
      <y>1934</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>SELECT_INTERRUPT
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1176</x>
      <y>1927</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要操作的接口
不是原来的接口</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1168</x>
      <y>1939</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>OUT_BYTE((drive)-&gt;ctl|2, 
hwif-&gt;io_ports[IDE_CONTROL_OFFSET])
注：ctl bit1置1表示中断屏蔽
	第二个参数是是寄存器的IO地址
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>1937</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1197</x>
      <y>1934</y>
      <w>31</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>hwgroup-&gt;hwif = hwif;
hwgroup-&gt;drive = drive;
drive-&gt;sleep = 0;
drive-&gt;service_start = jiffies
 //指向当前的req，make_request中某种情况head指向next是因为next不被遍历
 //这里是处理完了之后才脱链
hwgroup-&gt;rq = blkdev_entry_next_request(&amp;drive-&gt;queue.queue_head)
 //因为要打开中断，防止其他irq被阻塞
 //所以这里将接口的irq屏蔽，打开其他中断
 //但是因为有hwgroup-&gt;busy挡住其他接口的请求
 //所以mask_irq设置位0
disable_irq_nosync
ide__sti
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1176</x>
      <y>1927</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1254</x>
      <y>1932</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1176</x>
      <y>1927</y>
      <w>86</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;840.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1235</x>
      <y>1935</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1229</x>
      <y>1939</y>
      <w>34</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.unit不能大于MAX_DRIVES
2.在ide_disk和ide_floppy进行读写时，
	要写的block号不能大于drive-&gt;part[minor&amp;PARTN_MASK].nr_sects
3.因为block号可能时设备分区的block号，所以通过start_sect+sect0转化
	为设备实际的block号
	block += drive-&gt;part[minor&amp;PARTN_MASK].start_sect + drive-&gt;sect0
4.如果设备的remap_0_to_1置上，那么如果block为0时将其映射到1号block（引导扇区的重新映射）
5.如果设备两次操作之间需要时间间隔，所以需要通过while等待间隔时间
	while ((read_timer() - hwif-&gt;last_time) &lt; DISK_RECOVERY_TIME);
注：unit是实际设备号
minor后面PARTN_BITS指的是设备的逻辑分区
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1273</x>
      <y>1939</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>SELECT_DRIVE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1260</x>
      <y>1935</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1264</x>
      <y>1945</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hwif-&gt;selectproc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1267</x>
      <y>1942</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1278</x>
      <y>1945</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>OUT_BYTE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1271</x>
      <y>1942</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
写寄存器IDE_SELECT_OFFSET
选择磁盘操作的模式，参考P1144</panel_attributes>
    <additional_attributes>90.0;10.0;120.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1292</x>
      <y>1939</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_special</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1260</x>
      <y>1935</y>
      <w>38</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;special.all
如果有什么特殊处理，例如每次操作之后需要回到0号柱面</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1260</x>
      <y>1935</y>
      <w>55</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没什么特殊操作</panel_attributes>
    <additional_attributes>10.0;10.0;530.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1303</x>
      <y>1937</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
IDE_DRIVE_CMD ||
IDE_DRIVE_TASK</panel_attributes>
    <additional_attributes>100.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1302</x>
      <y>1940</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>execute_drive_cmd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1319</x>
      <y>1940</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>driver-&gt;do_request
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1312</x>
      <y>1937</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1324</x>
      <y>1943</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
idedisk_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1320</x>
      <y>1948</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_rw_disk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1276</x>
      <y>1951</y>
      <w>51</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1263</x>
      <y>1954</y>
      <w>35</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.向IDE_CONTROL_REG写drive-&gt;ctl，将中断屏蔽打开
2.向IDE_NSECTOR_REG写要读写的扇区数rq-&gt;nr_sectors
3.如果是lba或者是PDC4030，将block号写入28位寄存器
	低8位写入IDE_SECTOR_REG
	中间16位写入CYL_REG
	最高4位写入IDE_SELECT_REG低4位
4.如果是chs，将block写入到指定寄存器
	扇区模（sect  = block % drive-&gt;sect + 1）写进IDE_SECTOR_REG
	磁头号（track % drive-&gt;head）写进IDE_SELECT_REG低4位
	柱面号（track / drive-&gt;head）写进CYL_REG
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1310</x>
      <y>1951</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
READ</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1302</x>
      <y>1954</y>
      <w>13</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;using_dma
ide_dma_read</panel_attributes>
    <additional_attributes>90.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1299</x>
      <y>1962</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>HWIF(drive)-&gt;dmaproc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1310</x>
      <y>1954</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不用DMA</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1320</x>
      <y>1956</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
read_intr</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1314</x>
      <y>1961</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_set_handler</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1308</x>
      <y>1967</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>hwgroup-&gt;handler	= handler;
 //超时之后的函数指针
hwgroup-&gt;expiry		= expiry;
hwgroup-&gt;timer.expires	= jiffies + timeout;
add_timer(&amp;hwgroup-&gt;timer);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1319</x>
      <y>1964</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1326</x>
      <y>1961</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>OUT_BYTE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1313</x>
      <y>1956</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
向IDE_COMMAND_REG寄存器
发送MULTREAD或者READ命令
MULTREAD取决于要读的扇区号和磁盘缓冲区大小</panel_attributes>
    <additional_attributes>120.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1325</x>
      <y>1951</y>
      <w>46</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
WRITE</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1324</x>
      <y>1956</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1343</x>
      <y>1961</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return ide_started
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1357</x>
      <y>1953</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;using_dma
ide_dma_write</panel_attributes>
    <additional_attributes>120.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1348</x>
      <y>1956</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>HWIF(drive)-&gt;dmaproc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1368</x>
      <y>1954</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不用DMA</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1382</x>
      <y>1956</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1377</x>
      <y>1959</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_wait_stat</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1360</x>
      <y>1966</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果硬盘状态为BUSY_STAT，设置timeout
	时间，然后通过while等待，如果在timeout时间
	之内busy标志清除，执行2，否者返回1
2.如果busy标志清除，检查硬盘状态是good而不是
	bad（循环查询10次），正确返回0，否则返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1374</x>
      <y>1962</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1380</x>
      <y>1956</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要求屏蔽其他中断
!drive-&gt;unmask
暂时没看见在什么时候打开</panel_attributes>
    <additional_attributes>30.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1392</x>
      <y>1962</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cli
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1359</x>
      <y>1956</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查看mult_count，
然后写相应的命令至IDE_COMMAND_REG</panel_attributes>
    <additional_attributes>230.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1361</x>
      <y>1961</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>OUT_BYTE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1382</x>
      <y>1956</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1411</x>
      <y>1959</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mult_count</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1411</x>
      <y>1959</y>
      <w>44</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1447</x>
      <y>1962</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
write_intr</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1444</x>
      <y>1965</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_set_handler</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1457</x>
      <y>1965</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>idedisk_output_data</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1453</x>
      <y>1962</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1458</x>
      <y>1973</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_output_data</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1464</x>
      <y>1968</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bswap表示将数据的高8位和低8位换位置</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1444</x>
      <y>1976</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;io_32bit
如果是32位</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1465</x>
      <y>1976</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是16位</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1459</x>
      <y>1980</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;slow
out在io.h中定义
这里_p是有延时
向IDE_DATA_REG写2个short</panel_attributes>
    <additional_attributes>160.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1459</x>
      <y>1985</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>outw_p
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1473</x>
      <y>1980</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
OUTS
靠rep循环写入16字节
所以wcount左移1位</panel_attributes>
    <additional_attributes>20.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1481</x>
      <y>1986</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>outsw
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1442</x>
      <y>1980</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
rep循环写入32字节</panel_attributes>
    <additional_attributes>30.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1446</x>
      <y>1985</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>outsl
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1472</x>
      <y>1962</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return ide_started
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1368</x>
      <y>1954</y>
      <w>111</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1090.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1438</x>
      <y>1980</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1431</x>
      <y>1983</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过do_vlb_sync读
	3次寄存器IDE_NSECTOR_REG
2.在通过outl写数据
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1411</x>
      <y>1963</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
multwrite_intr</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1407</x>
      <y>1967</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_set_handler</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1393</x>
      <y>1967</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hwgroup-&gt;wrq = *rq
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1399</x>
      <y>1963</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
赋值request</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1421</x>
      <y>1967</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_multwrite</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1412</x>
      <y>1963</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1418</x>
      <y>1970</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1392</x>
      <y>1973</y>
      <w>38</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.确定此次写入的扇区大小，以current_nr_sectors
	为基础，如果超过了mcount，就只写mcount
2.更新mcount
3.通过idedisk_output_data向磁盘写buffer
	将扇区数左移7位换算成32位
4.检查nr_sectors是否读完，如果读完，break
	返回0，之后在上层函数中返回ide_started
5.如果没读完，查看当前bh的扇区是否读完，如果没有读完
	只有可能是mcount比bh扇区数小，所以将buffer指针更新
	返回0，之后在上层函数中返回ide_started
6.如果bh的扇区读完，就读下一个bh，并更新req
	rq-&gt;current_nr_sectors = rq-&gt;bh-&gt;b_size&gt;&gt;9;
	rq-&gt;buffer             = rq-&gt;bh-&gt;b_data;
	执行下一个do...while
7.如果整个req的写完了，通过ide_end_request结束request
	注意uptodate为0，表示数据还没更新
注:磁盘的缓冲区大小是mcount
	如果mcount写完，只能等到中断到来之后，再次通过中断向
	硬盘进行写入
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1300</x>
      <y>1965</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_setup_dma</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1294</x>
      <y>1973</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_dmaproc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1206</x>
      <y>1976</y>
      <w>95</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_dma_read</panel_attributes>
    <additional_attributes>930.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1200</x>
      <y>1986</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reading = 1 &lt;&lt; 3
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1244</x>
      <y>1976</y>
      <w>57</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_dma_read/ide_dma_write</panel_attributes>
    <additional_attributes>550.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1219</x>
      <y>1985</y>
      <w>29</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
&lt;&lt;includes&gt;&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1214</x>
      <y>1988</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>SELECT_READ_WRITE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1234</x>
      <y>1989</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_build_dmatable</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1232</x>
      <y>1985</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果出错返回0，ide_dmaproc返回1
do_rw_disk放弃dma继续执行io指令</panel_attributes>
    <additional_attributes>140.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1185</x>
      <y>1996</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_build_sglist</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1190</x>
      <y>1992</y>
      <w>52</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sg_table</panel_attributes>
    <additional_attributes>500.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1154</x>
      <y>2004</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>Read:
hwif-&gt;sg_dma_direction = PCI_DMA_FROMDEVICE
other:
hwif-&gt;sg_dma_direction = PCI_DMA_TODEVICE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1169</x>
      <y>1999</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1192</x>
      <y>2004</y>
      <w>39</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.遍历req的bh，看两个连着的bh是否在缓冲区上能合并
	virt_addr + size=bh-&gt;b_data
2.如果可以合并，将size增加，并遍历下一个bh
3.如果不能合并，直接退出当前遍历，然后申请一个scatterlist
	sg[nents].address = virt_addr;
	sg[nents].length = size;
	nents++;
4.然后在继续遍历向下遍历那个不能合并的bh
5.bh遍历完成之后，通过pci_map_sg检查，并返回nents
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1191</x>
      <y>1999</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1232</x>
      <y>1998</y>
      <w>44</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.遍历sg_table中的所有scatterlist
2.合并缓冲区的长度在每个DMA处理中都不能超过64K(0x10000)
	的边界，dmatable_cpu中第一项填起始地址，第二项填长度
	（最长不能超过64K,第一个entry可能没超过64K,即使其长度超过
	了64K,因为其内存单位是64K对齐）（两者合起来叫一个entry），
	如果一个DMA entry放不下这个scatterlist，就在下一个DMA entry
	中填写（这个entry不能超过PRD_ENTRIES（256），总共2k，有两个
	ide接口，总共4k）
注：dmatable_cpu指向的虚拟地址，dmatable_dma指向的是物理地址
	因为此时是cpu在操作，所以用的是dmatable_cpu
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1239</x>
      <y>1992</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1245</x>
      <y>1985</y>
      <w>44</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1278</x>
      <y>1993</y>
      <w>45</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.写寄存器
	向dma_base + 4写DMA表的32位指针dmatable_dma（实际物理地址）
	向dma_base（前8位ide0，后8位ide1）8位寄存器写读写命令（reading）
	向dma_base+2中的8位寄存器的第2，3位写1，清intr，error
2.	
	drive-&gt;waiting_for_dma = 1
	ide_set_handler（ide_dma_intr）
3.开启dma
	向IDE_COMMAND_REG写WIN_READDMA/WIN_WRITEDMA
	向dma_base8位寄存器的第1字节写1，开启DMA
注：之后DMA会根据dmatable_dma中的DMA表，向缓冲区读写数据，直到
	表写完之后向cpu发出中断
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1298</x>
      <y>1976</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_dma_end</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1326</x>
      <y>1984</y>
      <w>30</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>drive-&gt;waiting_for_dma = 0
 //向dma_base最低位写0，关闭dma
outb(inb(dma_base)&amp;~1, dma_base)
 //读出状态
dma_stat = inb(dma_base+2)
 //清intr error
outb(dma_stat|6, dma_base+2)
 //没有清除dma表，之后写的时候直接覆盖
ide_destroy_dmatable
最后检查dma_stat第3位（应该是error），正确的话是置上的
（此时返回0，正是ide_dma_intr需要的）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>656</x>
      <y>1785</y>
      <w>14</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历bh数组</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>637</x>
      <y>1785</y>
      <w>22</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>652</x>
      <y>1782</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ll_rw_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>657</x>
      <y>1774</y>
      <w>3</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>86</x>
      <y>2088</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_lseek</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>71</x>
      <y>2097</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>77</x>
      <y>2091</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>98</x>
      <y>2098</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>llseek</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>91</x>
      <y>2091</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
origin &lt;= 2</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>93</x>
      <y>2101</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file-&gt;f_op-&gt;llseek存在</panel_attributes>
    <additional_attributes>100.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>102</x>
      <y>2101</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>107</x>
      <y>2107</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>default_llseek</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>91</x>
      <y>2108</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;llseek
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>92</x>
      <y>2116</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_file_lseek</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>96</x>
      <y>2111</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_file_operations</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>69</x>
      <y>2119</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>56</x>
      <y>2124</y>
      <w>35</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.origin为2时，偏移从文件最后开始算（i_size+offset）
2.origin为1时，偏移从当前位置开始算(f_pos+offset)
3.origin为0时，偏移从文件首开始算(offset)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>97</x>
      <y>2119</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
offset &gt;&gt; 32 != 0
如果超过了32位</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>95</x>
      <y>2126</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>offset不能超过ext2_max_sizes
ext2_max_sizes规定的是逻辑block数组
最大是15经历了3层映射，所以最大长度是有限制的
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>97</x>
      <y>2119</y>
      <w>37</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
offset != file-&gt;f_pos</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>122</x>
      <y>2125</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>file-&gt;f_pos = offset;
file-&gt;f_reada = 0;
file-&gt;f_version = ++event;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>127</x>
      <y>2098</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>res是64位，retval是32位
当res != (loff_t)retval时，
说明sys_lseek超过了32位，报错-EOVERFLOW
如果超过32位，使用sys_llseek
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>91</x>
      <y>2091</y>
      <w>43</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;


</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>204</x>
      <y>2105</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_dup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>179</x>
      <y>2115</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>226</x>
      <y>2115</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dupfd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>184</x>
      <y>2108</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>210</x>
      <y>2108</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果file存在</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>215</x>
      <y>2125</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locate_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>221</x>
      <y>2118</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>191</x>
      <y>2128</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
start &lt; files-&gt;next_fd
start不能小于next_fd</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>182</x>
      <y>2135</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start = files-&gt;next_fd
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>201</x>
      <y>2136</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>newfd = start
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>205</x>
      <y>2128</y>
      <w>17</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
newfd在expand_files统一</panel_attributes>
    <additional_attributes>140.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>219</x>
      <y>2128</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
start &lt; files-&gt;max_fdset
</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>218</x>
      <y>2136</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_next_zero_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>236</x>
      <y>2137</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>申请到的fd要小于
RLIMIT_NOFILE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>219</x>
      <y>2128</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>255</x>
      <y>2137</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expand_files</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>219</x>
      <y>2128</y>
      <w>43</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>246</x>
      <y>2140</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果需要扩充</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>238</x>
      <y>2146</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>nr&gt;max_fdset  expand_fdset
nr&gt;max_fds   expand_fd_array
error=1(需要repeat，重新查找)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>259</x>
      <y>2140</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不需要扩充</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>266</x>
      <y>2147</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>error=0
沿用申请到的newfd
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>219</x>
      <y>2128</y>
      <w>65</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
start &lt;= files-&gt;next_fd
如果申请到next_fd
</panel_attributes>
    <additional_attributes>10.0;10.0;630.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>275</x>
      <y>2138</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>files-&gt;next_fd = newfd + 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>298</x>
      <y>2126</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>allocate_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>232</x>
      <y>2118</y>
      <w>75</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;730.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>294</x>
      <y>2133</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>FD_SET(fd, files-&gt;open_fds);
FD_CLR(fd, files-&gt;close_on_exec);
fd_install(fd, file)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>303</x>
      <y>2129</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>204</x>
      <y>2118</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>194</x>
      <y>2122</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>files = current-&gt;files
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>391</x>
      <y>2107</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_ioctl
可扩充
cmd参考657页
Documentation/ioctl_number.txt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>332</x>
      <y>2122</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>336</x>
      <y>2110</y>
      <w>63</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>610.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>2110</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file不为空</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>353</x>
      <y>2113</y>
      <w>46</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIOCLEX</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>348</x>
      <y>2122</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_close_on_exec(1)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>367</x>
      <y>2122</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_close_on_exec(0)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>374</x>
      <y>2113</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIOCLEX</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>366</x>
      <y>2130</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>2113</y>
      <w>8</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIONBIO</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>371</x>
      <y>2120</y>
      <w>28</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从用户空间拿参数</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>387</x>
      <y>2128</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>if (on)
	filp-&gt;f_flags |= O_NONBLOCK;
else
	filp-&gt;f_flags &amp;= ~O_NONBLOCK;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>2120</y>
      <w>4</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>2113</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIOASYNC</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>412</x>
      <y>2130</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>414</x>
      <y>2121</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从用户空间拿参数</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>423</x>
      <y>2121</y>
      <w>21</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

(flag ^ filp-&gt;f_flags) &amp; FASYNC
FASYNC发生了变化</panel_attributes>
    <additional_attributes>20.0;10.0;170.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>436</x>
      <y>2131</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;fasync
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>424</x>
      <y>2121</y>
      <w>38</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>452</x>
      <y>2129</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>if (on)
	filp-&gt;f_flags |= FASYNC;
else
	filp-&gt;f_flags &amp;= ~FASYNC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>419</x>
      <y>2134</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flag = on ? FASYNC : 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>424</x>
      <y>2121</y>
      <w>5</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>2113</y>
      <w>98</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
default</panel_attributes>
    <additional_attributes>10.0;10.0;960.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>478</x>
      <y>2132</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file_ioctl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>481</x>
      <y>2122</y>
      <w>13</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISREG</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>522</x>
      <y>2132</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;ioctl
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>491</x>
      <y>2122</y>
      <w>42</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否则
如果filp-&gt;f_op-&gt;ioctl存在</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>503</x>
      <y>2119</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>2110</y>
      <w>113</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1110.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>480</x>
      <y>2135</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
cmd</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>448</x>
      <y>2140</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIBMAP
返回逻辑块号对应的物理块号</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>409</x>
      <y>2154</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.mapping-&gt;a_ops-&gt;bmap存在
2.进程具有CAP_SYS_RAWIO
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>418</x>
      <y>2147</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>435</x>
      <y>2154</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.得到逻辑块号get_user
2.根据逻辑块号获取物理块号
mapping-&gt;a_ops-&gt;bmap
3.返回物理块号put_user
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>446</x>
      <y>2147</y>
      <w>5</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>463</x>
      <y>2140</y>
      <w>20</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIGETBSZ
返回文件设备的总块数</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>458</x>
      <y>2155</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_user(inode-&gt;i_sb-&gt;s_blocksize
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>480</x>
      <y>2140</y>
      <w>22</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIONREAD
返回当前位置到文件末尾的距离</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>484</x>
      <y>2155</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_user(inode-&gt;i_size - filp-&gt;f_pos
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>481</x>
      <y>2135</y>
      <w>36</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filp-&gt;f_op-&gt;ioctl存在</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>507</x>
      <y>2149</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;ioctl
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>620</x>
      <y>2106</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>540</x>
      <y>2109</y>
      <w>89</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制用户空间中源文件名和新文件名</panel_attributes>
    <additional_attributes>870.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>537</x>
      <y>2122</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>from = getname(oldname)
to = getname(newname)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>567</x>
      <y>2122</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>path_init
path_walk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>571</x>
      <y>2109</y>
      <w>58</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
from, 
LOOKUP_POSITIVE和LOOKUP_DIRECTORY置上时，如果找不到
inode会报错</panel_attributes>
    <additional_attributes>560.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>589</x>
      <y>2122</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>path_init
path_walk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>592</x>
      <y>2109</y>
      <w>37</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
to,
LOOKUP_PARENT表示只找到上一层目录</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>612</x>
      <y>2109</y>
      <w>16</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
old_nd.mnt != nd.mnt
安装节点不一致时报错</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>610</x>
      <y>2123</y>
      <w>8</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>-EXDEV
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>624</x>
      <y>2122</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>626</x>
      <y>2109</y>
      <w>7</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>607</x>
      <y>2131</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_hash
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>611</x>
      <y>2125</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在hash和磁盘中找inode</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>630</x>
      <y>2125</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>626</x>
      <y>2129</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果is_dir=0，并且是目录last.name[nd-&gt;last.len]
（如果是目录，这个字符应该是‘\’）
	但是在没找到inode，返回-ENOENT
2.否则返回dentry（没找到d_inode为NULL）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>626</x>
      <y>2109</y>
      <w>49</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!IS_ERR(new_dentry)</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>671</x>
      <y>2127</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>672</x>
      <y>2120</y>
      <w>8</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>691</x>
      <y>2126</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>672</x>
      <y>2120</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>642</x>
      <y>2140</y>
      <w>35</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.源文件inode要存在（old_dentry-&gt;d_inode）
2.新文件may_create
	1.新文件的inode不能存在 new_dentry.d_inode
	2.新文件的目录不是IS_DEADDIR
	3.新文件目录要有MAY_WRITE | MAY_EXEC
3.新文件要和源文件在同一个设备
	dir-&gt;i_dev == inode-&gt;i_dev
4.源文件不能有IS_APPEND  IS_IMMUTABLE标记
5.新文件的dir-&gt;i_op-&gt;link要存在
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>654</x>
      <y>2130</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>686</x>
      <y>2141</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>683</x>
      <y>2134</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_op-&gt;link
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>680</x>
      <y>2130</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>689</x>
      <y>2136</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>717</x>
      <y>2135</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_dir_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>680</x>
      <y>2130</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
DN_CREATE
如果链接建立完成，需要通知父目录
i_dnotify中的通知对象</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>653</x>
      <y>2159</y>
      <w>30</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.建立硬链接的不能是目录
2.inode-&gt;i_nlink不能大于EXT2_LINK_MAX
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>665</x>
      <y>2144</y>
      <w>31</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>688</x>
      <y>2159</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_add_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>693</x>
      <y>2144</y>
      <w>3</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>713</x>
      <y>2156</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //增加inode的硬链接计数
inode-&gt;i_nlink++;
inode-&gt;i_ctime = CURRENT_TIME;
mark_inode_dirty(inode);
atomic_inc(&amp;inode-&gt;i_count);
 //将dentry链接到inode的链表中
d_instantiate(dentry, inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>693</x>
      <y>2144</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>624</x>
      <y>2172</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>629</x>
      <y>2162</y>
      <w>67</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读dir的数据到内存</panel_attributes>
    <additional_attributes>650.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>640</x>
      <y>2173</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rec_len = EXT2_DIR_REC_LEN(namelen)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>655</x>
      <y>2162</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
要添加entry需要的长度</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>693</x>
      <y>2162</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历dir，找到足够的长度容纳
要添加的entry</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>678</x>
      <y>2170</y>
      <w>71</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>1.ext2_check_dir_entry 检查de中的各类属性
2.ext2_match 检查de中是否有和此次添加entry
	相同的name
3.检查当前的de是否可以容纳当前的entry
	能容纳的两个条件：
		1.de-&gt;inode为0，且这个entry的长度rec_len大于此次要添加entry的长度
		2.如果de-&gt;inode不为0，但是这个entry的长度能容纳自己的entryEXT2_DIR_REC_LEN(de-&gt;name_len)
		和要添加的entry的长度
		如果是第2中情况，将之前entyr的长度更新为EXT2_DIR_REC_LEN(de-&gt;name_len)，剩下的位置给要添加的entry
		de1 =de+EXT2_DIR_REC_LEN(de-&gt;name_len)
		de1-&gt;rec_len =(le16_to_cpu(de-&gt;rec_len) - EXT2_DIR_REC_LEN(de-&gt;name_len)
	为要添加的entry，赋值其他的属性
	de-&gt;file_type = EXT2_FT_UNKNOWN;
	if (inode) {
		de-&gt;inode = cpu_to_le32(inode-&gt;i_ino);
		ext2_set_de_type(dir-&gt;i_sb, de, inode-&gt;i_mode);
	} else
		de-&gt;inode = 0;
	de-&gt;name_len = namelen;
	memcpy (de-&gt;name, name, namelen);
	dir-&gt;i_mtime = dir-&gt;i_ctime = CURRENT_TIME;
	dir-&gt;u.ext2_i.i_flags &amp;= ~EXT2_BTREE_FL;
	mark_inode_dirty(dir);
	dir-&gt;i_version = ++event;
	mark_buffer_dirty_inode(bh, dir);
	如果需要同步的话，会通过ll_rw_block写dir，并wait_on_buffer
4.如果没找到，更新位置和下一个entry
	offset += le16_to_cpu(de-&gt;rec_len);
	de = (struct ext2_dir_entry_2 *) ((char *) de + le16_to_cpu(de-&gt;rec_len))
5.如果超过了当前读取的bh，通过ext2_bread读下一个block的dir数据,然后重复上述过程继续查找
	1.如果offset超过了dir的size，更新dir的size和将下一个block都设置为一个entry
		de = (struct ext2_dir_entry_2 *) bh-&gt;b_data;
		de-&gt;inode = 0;
		de-&gt;rec_len = le16_to_cpu(sb-&gt;s_blocksize);
		dir-&gt;i_size = offset + sb-&gt;s_blocksize;
		dir-&gt;u.ext2_i.i_flags &amp;= ~EXT2_BTREE_FL;
		mark_inode_dirty(dir);
	2.如果没超过dir的size，继续查找dir下一个block数据
		de = (struct ext2_dir_entry_2 *) bh-&gt;b_data
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>966</x>
      <y>2118</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_proc_fs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>943</x>
      <y>2126</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>950</x>
      <y>2121</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>918</x>
      <y>2136</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.要注册fs要存在  -EINVAL
2.fs的next指针不能在链表中  -EBUSY
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>926</x>
      <y>2129</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>948</x>
      <y>2129</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>944</x>
      <y>2135</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过find_filesystem在链表file_systems中查询
2.如果查到当前filesystem在链表中存在，返回-EBUSY
3.如果不存在，将当前的filesystem链入到链表中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>995</x>
      <y>2128</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kern_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>974</x>
      <y>2121</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果成功注册</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>981</x>
      <y>2136</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_unnamed_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1001</x>
      <y>2136</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_super
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1045</x>
      <y>2139</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_vfsmnt
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>985</x>
      <y>2131</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>962</x>
      <y>2145</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.在位图unnamed_dev_in_use中从1开始查找
2.如果找到，返回MKDEV(UNNAMED_MAJOR, i)
	否则，返回0.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>976</x>
      <y>2139</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1001</x>
      <y>2131</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>997</x>
      <y>2144</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过get_empty_super，得到super_block结构体
2.对super_block属性做相关的设置
3.通过file_system的read_super将超级块读进来
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1007</x>
      <y>2139</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1009</x>
      <y>2156</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_read_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1014</x>
      <y>2150</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_fs_type
proc_root</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>983</x>
      <y>2164</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>s-&gt;s_blocksize = 1024;
s-&gt;s_blocksize_bits = 10;
s-&gt;s_magic = PROC_SUPER_MAGIC;
s-&gt;s_op = &amp;proc_sops;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>994</x>
      <y>2159</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置超级块的块大小和
操作函数等属性</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1013</x>
      <y>2166</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_get_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1015</x>
      <y>2159</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取根节点</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>999</x>
      <y>2174</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1003</x>
      <y>2169</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加proc_root计数</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1015</x>
      <y>2175</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iget
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1018</x>
      <y>2169</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1020</x>
      <y>2178</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
首先会在hash表中查找，
如果没找到会申请inode结构体
然后利用sb的proc_sops的read_inode读取</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1014</x>
      <y>2185</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_read_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1013</x>
      <y>2193</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_mtime = 
inode-&gt;i_atime = 
inode-&gt;i_ctime = CURRENT_TIME;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1020</x>
      <y>2188</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里只是设置了inode时间
其他属性需要在iget中查看</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1030</x>
      <y>2167</y>
      <w>18</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>root_inode-&gt;i_nlink++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1016</x>
      <y>2159</y>
      <w>23</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
除了idle_task，其他task都
增加inode的硬链接计数</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1053</x>
      <y>2167</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_alloc_root
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1017</x>
      <y>2159</y>
      <w>42</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
给s-&gt;s_root分配root管理</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1104</x>
      <y>2168</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>parse_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1016</x>
      <y>2159</y>
      <w>94</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1040</x>
      <y>2176</y>
      <w>27</w>
      <h>23</h>
    </coordinates>
    <panel_attributes> //generic_ip中存储的inode对应的proc_dir_entry
inode-&gt;u.generic_ip=de (proc_root)
inode-&gt;i_mode = de-&gt;mode;
inode-&gt;i_uid = de-&gt;uid;
inode-&gt;i_gid = de-&gt;gid;
inode-&gt;i_size = de-&gt;size
inode-&gt;i_nlink = de-&gt;nlink
__MOD_INC_USE_COUNT(de-&gt;owner)
如果是块设备/字符设备/FIFO设备
	init_special_inode（reference）
否则：
	inode-&gt;i_op = de-&gt;proc_iops
	inode-&gt;i_fop = de-&gt;proc_fops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1018</x>
      <y>2169</y>
      <w>34</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1069</x>
      <y>2178</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>root_inode-&gt;i_uid=current-&gt;uid
root_inode-&gt;i_gid= current-&gt;gid
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1078</x>
      <y>2171</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1093</x>
      <y>2179</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1097</x>
      <y>2171</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没有要解析的数据
!options</panel_attributes>
    <additional_attributes>120.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1084</x>
      <y>2203</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>strtok</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1061</x>
      <y>2212</y>
      <w>43</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果要解析的数据为空，就解析之前剩下的数据___strtok，
	否则解析传过来的数据
2.通过strspn计算和分个符相同的长度，然后将s更新为和分个符
	不同的sbegin
3.如果sbegin为'\0'，___strtok=NULL
4.否则，通过strpbrk找到剩下字符串中的第一个分隔符，并且
*send++ = '\0';
___strtok = send;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1080</x>
      <y>2206</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1107</x>
      <y>2181</y>
      <w>39</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.通过strtok将字符串通过‘，’拆分开
2.循环检查，利用strchr将this_char用‘=’分隔开
	this_char指向等号前面，value指向等号后面
3.如果this_char是"uid"，利用simple_strtoul将字符串
	转化成整数，然后使root_inode-&gt;i_uid=current-&gt;uid=value
	如果value中有不能解析的（*value最后还有值），返回0
4.同理，如果this_char是"gid"：
	root_inode-&gt;i_gid=value
5.如果都不是，直接返回1
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1090</x>
      <y>2196</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1138</x>
      <y>2204</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>simple_strtoul</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1133</x>
      <y>2196</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1138</x>
      <y>2213</y>
      <w>37</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.首先确认base（是10进制。8进制、还是16进制）
	其中isxdigit表示字符是否是16进制数，可以将
	_ctype对比ASCII表
2.将各个字符换算成整数，乘上base再相加，其中
	isdigit表示字符是否是10进制数
3.更改value的地址，（返回后可以看value是否指向'\0'
	来检查是否满足整数的要求）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1144</x>
      <y>2207</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1115</x>
      <y>2203</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>strchr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1120</x>
      <y>2196</y>
      <w>8</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1106</x>
      <y>2211</y>
      <w>30</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>"movb %%al,%%ah\n"
 //将s字符加载到al中，s++
"1:\tlodsb\n\t"
"cmpb %%ah,%%al\n\t"
"je 2f\n\t"
	// al &amp;al,如果结果为0
	//zf会置1，表示相等
"testb %%al,%%al\n\t"
"jne 1b\n\t"
 //这里置1，后面--，就会变成NULL
"movl $1,%1\n"
 //将s--，并返回
"2:\tmovl %1,%0\n\t"
"decl %0"
:"=a" (__res), "=&amp;S" (d0) : "1" (s),"0" (c));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1119</x>
      <y>2206</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
用于在字符串中找到
相应的字符</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1108</x>
      <y>2171</y>
      <w>20</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
解析options</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1001</x>
      <y>2131</y>
      <w>52</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注意这里的安装目录是NULL
mnt_mountpoint指向自己的root
mnt_parent指向自己
mnt_child mnt_clash都不用指向自己

之后用户层会通过调用
mount nvt proc /dev/null /proc
讲procfs装载到/proc目录下
</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1076</x>
      <y>2136</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>type-&gt;kern_mnt = mnt
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1002</x>
      <y>2131</y>
      <w>84</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将安装节点放在文件系统中
之后用户在mount的时候
会通过	get_sb_single调用</panel_attributes>
    <additional_attributes>10.0;10.0;820.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>829</x>
      <y>2124</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_mknod</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>778</x>
      <y>2137</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>783</x>
      <y>2127</y>
      <w>54</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从用户空款copy name到系统空间</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>803</x>
      <y>2127</y>
      <w>34</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取父目录和子文件的name到nd
注意flag是LOOKUP_PARENT</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>800</x>
      <y>2137</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>path_init
path_walk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>816</x>
      <y>2137</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_create
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>821</x>
      <y>2127</y>
      <w>16</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为子节点创建dentry
注意传递的is_dir是0
表示子节点不能是目录</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>835</x>
      <y>2127</y>
      <w>22</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查看传递进来的参数mode
看要创建的文件的类型
注：不能创建目录</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>830</x>
      <y>2137</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
0
S_IFREG</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>826</x>
      <y>2143</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>841</x>
      <y>2137</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_IFCHR
S_IFBLK
S_IFSOCK</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>849</x>
      <y>2143</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_mknod</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>870</x>
      <y>2136</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //释放父目录和mnt
path_release(&amp;nd)
 //释放临时的name内存
putname(tmp)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>835</x>
      <y>2127</y>
      <w>45</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>823</x>
      <y>2146</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>801</x>
      <y>2150</y>
      <w>36</w>
      <h>13</h>
    </coordinates>
    <panel_attributes> //umask规定进程创建的文件不允许有的权限
1.mode &amp;= ~current-&gt;fs-&gt;umask
2.如果是S_ISCHR或者S_ISBLK时，进程要有
	CAP_MKNOD权限
3.may_create（reference）检查父目录的权限
	，并且子节点不能存在
4.父目录要有dir-&gt;i_op-&gt;mknod
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>841</x>
      <y>2153</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DQUOT_INIT</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>845</x>
      <y>2146</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
磁盘容量相关</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>859</x>
      <y>2153</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_op-&gt;mknod
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>855</x>
      <y>2146</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>860</x>
      <y>2160</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_mknod</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>865</x>
      <y>2156</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_dir_inode_operations</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>882</x>
      <y>2152</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_dir_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>855</x>
      <y>2146</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
DN_CREATE</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>820</x>
      <y>2169</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_new_inode
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>824</x>
      <y>2163</y>
      <w>44</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>420.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>836</x>
      <y>2170</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_uid = current-&gt;fsuid
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>844</x>
      <y>2163</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>858</x>
      <y>2170</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_special_inode
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>864</x>
      <y>2163</y>
      <w>4</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>876</x>
      <y>2170</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_add_entry
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>865</x>
      <y>2163</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将inode号和name加到dir中</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>893</x>
      <y>2170</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>mark_inode_dirty(inode);
d_instantiate(dentry, inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>866</x>
      <y>2163</y>
      <w>35</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将inode标dirty
并将其和dentry关联</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>838</x>
      <y>2177</y>
      <w>46</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>注：
1.现在并不会赋值u.ext2_i.i_data，在ext2_update_inode向硬盘写的时候，
	会检查i_mode，然后写入raw_inode-&gt;i_block
2.在ext2_read_inode时，会根据i_mode值将i_block[0]作为dev去
	init_special_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>862</x>
      <y>2173</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>527</x>
      <y>2143</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ioctl_scanner</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>529</x>
      <y>2135</y>
      <w>16</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_scanner_fops</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>524</x>
      <y>2151</y>
      <w>38</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.根据minor找到dev
	scn_minor = USB_SCN_MINOR(inode);
	dev = p_scn_table[scn_minor]-&gt;scn_dev
2.如果是PV8630_IOCTL_INREQUEST（获取状态信息）
	利用copy_from_user将args数据从用户空间复制过来
	然后利用usb_control_msg发送args.request请求
	最后利用copy_to_user将arg返回到用户空间
注：这里使用usb_rcvctrlpipe，
	USB_TYPE_VENDOR表示寄存器时设备制造商定义，不是标准的（USB_TYPE_STANDARD）
	USB_RECIP_DEVICE表示传输的对象是设备，不是接口或者端点
3.如果是PV8630_IOCTL_OUTREQUEST（向扫描器发出控制命令）
	和获取状态信息相似，只是这里只是单纯的发数据（usb_sndctrlpipe）
	，所以size=0，并且不用返回数据到用户空间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>533</x>
      <y>2146</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>414</x>
      <y>2134</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
鼠标
psaux_fops</panel_attributes>
    <additional_attributes>300.0;10.0;220.0;60.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>410</x>
      <y>2142</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fasync_aux</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>392</x>
      <y>2150</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fasync_helper</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>398</x>
      <y>2145</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>380</x>
      <y>2158</y>
      <w>36</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>1.如果要求将file设置成异步
	通过kmem_cache_alloc向fasync_cache
	申请fasync_struct
2.遍历传入的链表，如果链表中存在和要申请的
	file相同的fasync_struct结构：
	1.如果现在要设置异步，那么将新申请的cache释放：
		fa-&gt;fa_fd = fd;
		kmem_cache_free(fasync_cache, new);
	2.如果现在要设置成同步，那么将链表中的结构删除并释放
		*fp = fa-&gt;fa_next;
		kmem_cache_free(fasync_cache, fa);
		result = 1;
	最后直接返回
3.如果要设置成异步，那么将新申请的结构头插至链表中
	之后返回：
	new-&gt;magic = FASYNC_MAGIC;
	new-&gt;fa_file = filp;
	new-&gt;fa_fd = fd;
	new-&gt;fa_next = *fapp;
	*fapp = new;
	result = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>390</x>
      <y>2153</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
queue-&gt;fasync</panel_attributes>
    <additional_attributes>70.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>280</x>
      <y>2081</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_dup2</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>269</x>
      <y>2089</y>
      <w>35</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.通过file_lock将整个过程锁住
2.通过fcheck检查要复制的oldfd是否超过了max_fds，如果没
	超过，返回file
3.如果复制到的newfd和要复制的oldfd相同，直接解锁返回
4.如果newfd超过了进程的限制RLIMIT_NOFILE，返回EBADF
5.通过get_file增加oldfd的file计数，表示newfd要用
6.通过expand_files在必要时扩展得到newfd
7.如果newfd在open_fds位图中置上，但是files-&gt;fd[newfd]
	却不存在，说明这个fd正在被open占用，直接返回
8.如果经过了7表示可以对newfd进行复制：
	files-&gt;fd[newfd] = file;
	FD_SET(newfd, files-&gt;open_fds);
	FD_CLR(newfd, files-&gt;close_on_exec);
9.如果newfd之前存在file，通过filp_close将其关闭
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>284</x>
      <y>2084</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2082</x>
      <y>55</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_query_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2078</x>
      <y>58</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
name_user</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2055</x>
      <y>62</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
NULL</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2049</x>
      <y>70</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mod = &amp;kernel_module
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2078</x>
      <y>62</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
请求module name存在</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2072</x>
      <y>72</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_mod_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2077</x>
      <y>67</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2071</x>
      <y>78</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>__get_free_page
strncpy_from_user
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2076</x>
      <y>75</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2090</x>
      <y>67</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2094</x>
      <y>71</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是空字符串
</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2098</x>
      <y>71</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2106</x>
      <y>77</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2087</x>
      <y>77</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mod = &amp;kernel_module
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2118</x>
      <y>71</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_mod_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2090</x>
      <y>67</y>
      <w>37</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放name的内存</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2097</x>
      <y>84</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.遍历module_list链表
2.如果flags &amp; MOD_DELETED，就不遍历
3.比较mod-&gt;name，如果成功就找到module
	直接退出
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2110</x>
      <y>80</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2089</x>
      <y>58</y>
      <w>74</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2136</x>
      <y>71</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qm_modules</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2141</x>
      <y>64</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
QM_MODULES</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2128</x>
      <y>78</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.遍历module_list链表
2.计算每个module name的长度，如果buf的空间足够
	则用copy_to_user将name复制到用户空间
3.如果buf的空间不足，则将容纳所有module name所需
	的内存通过put_user返回给用户，sys_call返回-ENOSPC
4.如果一直复制到kernel_module，buf的空间足够，则将
	复制多少个module返回给用户
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2142</x>
      <y>74</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2138</x>
      <y>92</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2143</x>
      <y>89</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2138</x>
      <y>100</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__put_user_size</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2143</x>
      <y>95</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
access_ok(VERIFY_WRITE</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2138</x>
      <y>107</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__put_user_asm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2143</x>
      <y>103</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将x放到地址ptr处
如果出错，返回-EFAULT</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2181</x>
      <y>71</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qm_deps</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2160</x>
      <y>64</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
QM_DEPS</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2229</x>
      <y>21</y>
      <w>17</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>module_ref
描述一组依赖关系
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2231</x>
      <y>25</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dep（A依赖B）(父)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2231</x>
      <y>31</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ref（B被A索引）(子)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2231</x>
      <y>39</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>next_ref
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2203</x>
      <y>21</y>
      <w>19</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>module A
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2206</x>
      <y>26</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>deps
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2218</x>
      <y>26</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
数组</panel_attributes>
    <additional_attributes>10.0;20.0;110.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2221</x>
      <y>31</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>100.0;20.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2275</x>
      <y>21</y>
      <w>19</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>module B
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2278</x>
      <y>34</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>refs
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2268</x>
      <y>34</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
链表
next_ref</panel_attributes>
    <additional_attributes>100.0;20.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2266</x>
      <y>26</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;20.0;90.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2252</x>
      <y>22</y>
      <w>17</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>module_ref
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2254</x>
      <y>26</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dep
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2254</x>
      <y>32</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ref
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2254</x>
      <y>39</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>next_ref
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2245</x>
      <y>39</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ref链表指针</panel_attributes>
    <additional_attributes>90.0;20.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2243</x>
      <y>16</y>
      <w>34</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;110.0;80.0;20.0;290.0;30.0;320.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2278</x>
      <y>40</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>next
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2207</x>
      <y>40</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>next
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2212</x>
      <y>44</y>
      <w>72</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>700.0;10.0;630.0;70.0;100.0;80.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2167</x>
      <y>78</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.不能是kernel_module
2.如果请求的module的MOD_RUNNING 和
	MOD_INITIALIZING都没置，或者置上MOD_DELETED
	就不执行，ret=0
3.遍历module的deps数组（ndeps个），将module依赖的模块
	名称复制到用户空间；如果复制完成，则ret返回依赖模块的数目
	如果没有足够的内存，就ret返回所需要的空间，sys_call返回-ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2185</x>
      <y>74</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2219</x>
      <y>71</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qm_refs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2159</x>
      <y>64</y>
      <w>70</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
QM_REFS</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2213</x>
      <y>78</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.不能是kernel_module
2.如果请求的module的MOD_RUNNING 和
	MOD_INITIALIZING都没置，或者置上MOD_DELETED
	就不执行，ret=0
3.遍历module的refs链表，将已用module的模块
	名称复制到用户空间；如果复制完成，则ret返回引用模块的数目
	如果没有足够的内存，就ret返回所需要的空间，sys_call返回-ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2226</x>
      <y>74</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2285</x>
      <y>69</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qm_symbols</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2160</x>
      <y>64</y>
      <w>132</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
QM_SYMBOLS</panel_attributes>
    <additional_attributes>10.0;10.0;1300.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2255</x>
      <y>78</y>
      <w>39</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果请求的module的MOD_RUNNING 或者
	MOD_INITIALIZING没置，或者置上MOD_DELETED
	就不执行，ret=0
2.检查 buf~buf+mod-&gt;nsyms * 2*sizeof(void *)空间的
	写访问权限access_ok(VERIFY_WRITE
注：这个区间是（address，&amp;name）的组合
	然后在这个区间之后放字符串name，因为字符串name区域
	依靠copy_to_user去确保访问权限，所以在这里不做检查
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2269</x>
      <y>72</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2296</x>
      <y>81</y>
      <w>38</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历mod-&gt;syms数组（长度为mod-&gt;nsyms），
2.如果buf有足够的内存，将（address，&amp;name）放在前两，
	name实体放在所有指针的后面。ret返回sybol的数目
3.如果buf在遍历的过程中没有足够的空间，ret返回所需要的空间
	sys_call返回-ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2291</x>
      <y>72</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2368</x>
      <y>68</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qm_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2160</x>
      <y>64</y>
      <w>215</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
QM_INFO</panel_attributes>
    <additional_attributes>10.0;10.0;2130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2337</x>
      <y>81</y>
      <w>29</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.不能是kernel_module
2.如果buf内存不够，sys_call返回-ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2349</x>
      <y>71</y>
      <w>26</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2368</x>
      <y>79</y>
      <w>45</w>
      <h>16</h>
    </coordinates>
    <panel_attributes> //module的地址
info.addr = (unsigned long)mod;
info.size = mod-&gt;size;
info.flags = mod-&gt;flags;
 //如果module的结构体包含can_unload指针，返回-1
 //否则返回usecount
info.usecount = (mod_member_present(mod, can_unload)
		 &amp;&amp; mod-&gt;can_unload ? -1 : atomic_read(&amp;mod-&gt;uc.usecount));
注：mod_member_present是检测member在不在结构体内
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2373</x>
      <y>71</y>
      <w>8</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2374</x>
      <y>71</y>
      <w>50</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2417</x>
      <y>80</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>ret最后都返回
sizeof(struct module_info)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2560</x>
      <y>59</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_create_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2510</x>
      <y>71</y>
      <w>25</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.进程需要CAP_SYS_MODULE权限
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2520</x>
      <y>62</y>
      <w>48</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2536</x>
      <y>71</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_mod_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2542</x>
      <y>62</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从用户空间获取
创建module的name</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2555</x>
      <y>71</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>2.name+module所占的内存空间，
	不能大于用户要求申请的内存大小
	size &lt; sizeof(struct module)+namelen
3.find_module从module_list中如果找到了
	name一样的 module，返回-EEXIST
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2563</x>
      <y>62</y>
      <w>7</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2584</x>
      <y>71</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>module_map</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2566</x>
      <y>62</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请size大小的虚拟内存</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2584</x>
      <y>78</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2589</x>
      <y>74</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2601</x>
      <y>70</y>
      <w>30</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>memset(mod, 0, sizeof(*mod));
mod-&gt;size_of_struct = sizeof(*mod);
 //链入module_list
mod-&gt;next = module_list;
mod-&gt;name = (char *)(mod + 1);
 //module所占内存大小，module+name
mod-&gt;size = size;
 //复制name到module后面
memcpy((char*)(mod+1), name, namelen+1);

put_mod_name(name);
 //更新module_list链表
module_list = mod;
 //正确的话，返回的是module的地址
return error
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2566</x>
      <y>62</y>
      <w>45</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2822</x>
      <y>56</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_init_module
(init_module时用户传进来的参数
create_module时用户之前在sys_create_module创建的)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2717</x>
      <y>82</y>
      <w>42</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.进程要有CAP_SYS_MODULE
2.通过get_mod_name将create_module的name
	复制到系统空间，再通过find_module查找
	如果找不到，返回-ENOENT
3.通过get_user获取init_module的size_of_struct
	（这个size是module结构体的大小），init_module的persist_start
	至少包含到；另外这个size不能大于module size16个指针

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2736</x>
      <y>59</y>
      <w>94</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>920.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2761</x>
      <y>84</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>mod_tmp = *mod
name_tmp = kmalloc(strlen(mod-&gt;name) + 1
strcpy(name_tmp, mod-&gt;name)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2773</x>
      <y>59</y>
      <w>56</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将create_module的module和name复制到temp
</panel_attributes>
    <additional_attributes>540.0;10.0;10.0;250.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2797</x>
      <y>85</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_from_user
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2802</x>
      <y>59</y>
      <w>30</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将init_module赋值到mod</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2814</x>
      <y>83</y>
      <w>49</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>1.init_module的size不能大于create_module的size
2.mod-&gt;name，mod-&gt;syms，mod-&gt;deps，指向的位置要
	在size_of_struct外。并且所占的内存要在size内
	注：因为sys_create_module返回的是内核module的起始地址，用户应该将
	name的指针指向内核地址，而不是用户空间name的实际地址，所以这里
	mod_bound才会通过。
3.mod-&gt;init，mod-&gt;cleanup要在size_of_struct外。
	并且要在size内
4.异常处理表：
	ex_table_start不能大于ex_table_end
	ex_table_start小于mod的尾端的时候，ex_table_end不能小于
	缓冲区（size）的尾端
	ex_table的大小要被exception_table_entry的大小整除
5.mod-&gt;flags中至少要有一个除了MOD_AUTOCLEAN的flage置上
6.can_unload如果要在module 结构内且不为空时，can_unload函数
	要在缓冲区内
7.kallsyms_end在module内，且不为空，kallsyms_start和kallsyms_end
	指向的地址要在缓冲区内
	kallsyms_start不能大于kallsyms_end
8.archdata和kallsyms相似
9.kernel_data在moduler内，mod-&gt;kernel_data不能为空
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2826</x>
      <y>59</y>
      <w>21</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
对init_module进行filter</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2869</x>
      <y>83</y>
      <w>51</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.通过get_mod_name从用户层将name实体复制到系统空间
	如果name的长度，或者name不一致，返回错误
2.通过copy_from_user将init_module的缓冲区，复制到用户空间
（如果在cache中，需要通过flush_icache_range刷入到内存）
3.将init_module链入到链表
	mod-&gt;next = mod_tmp.next;
	mod-&gt;refs = NULL;
4.遍历mod-&gt;deps，这个数组中不能有自己，并且数组中的元素要在
	module_list链表中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2829</x>
      <y>59</y>
      <w>56</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
对init_module的缓冲区进行filter</panel_attributes>
    <additional_attributes>10.0;10.0;540.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2927</x>
      <y>84</y>
      <w>21</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //ref指向自己
dep-&gt;ref = mod
 //链入到父的链表中（d是父）
dep-&gt;next_ref = d-&gt;refs;
d-&gt;refs = dep;
d-&gt;flags |= MOD_USED_ONCE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2829</x>
      <y>59</y>
      <w>108</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
对module的dep的实体，进行初始化</panel_attributes>
    <additional_attributes>10.0;10.0;1060.0;250.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2954</x>
      <y>85</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes> //n_name 最终的name，name是传进来的参数
 //name_tmp是之前sys_create_module识别的name
put_mod_name(n_name);
put_mod_name(name);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2830</x>
      <y>59</y>
      <w>132</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放临时内存</panel_attributes>
    <additional_attributes>10.0;10.0;1300.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2994</x>
      <y>85</y>
      <w>44</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>mod-&gt;flags |= MOD_INITIALIZING;
atomic_set(&amp;mod-&gt;uc.usecount,1);
 //如果init函数存在，执行init
mod-&gt;init &amp;&amp; (error = mod-&gt;init())

atomic_dec(&amp;mod-&gt;uc.usecount);
mod-&gt;flags = (mod-&gt;flags | MOD_RUNNING) &amp; ~MOD_INITIALIZING;
error = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2830</x>
      <y>59</y>
      <w>175</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1730.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3170</x>
      <y>55</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_delete_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3101</x>
      <y>72</y>
      <w>23</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>进程要有CAP_SYS_MODULE权限
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3109</x>
      <y>58</y>
      <w>70</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>680.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3175</x>
      <y>58</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果name_user不为NULL</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3139</x>
      <y>66</y>
      <w>45</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3132</x>
      <y>72</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_mod_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3152</x>
      <y>73</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3160</x>
      <y>66</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3173</x>
      <y>73</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_mod_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3180</x>
      <y>66</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到后，释放name</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3180</x>
      <y>66</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mod-&gt;refs
如果被依赖，则不能释放</panel_attributes>
    <additional_attributes>20.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3192</x>
      <y>72</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>-EBUSY
goto out;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3181</x>
      <y>66</y>
      <w>50</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
没被使用
!__MOD_IN_USE
如果can_unload在module中，通过can_unload判断
否则通过mod.uc.usecount判断</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3215</x>
      <y>69</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3204</x>
      <y>75</y>
      <w>23</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mod-&gt;flags |= MOD_DELETED
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3235</x>
      <y>75</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3227</x>
      <y>69</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tag_freed为0</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3227</x>
      <y>78</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3216</x>
      <y>84</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>mod-&gt;cleanup
mod-&gt;flags &amp;= ~MOD_RUNNING
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3243</x>
      <y>78</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3240</x>
      <y>83</y>
      <w>35</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.通过mod-&gt;deps数组找到mod依赖的所有module
2.遍历module的refs链表，将mod从其链表中删除
	*pp = dep-&gt;next_ref;
	如果tag_freed为1，且module的refs链表为空
	module.flags |= MOD_JUST_FREED
	注：module_ref脱链之后不用单独释放，因为deps数组
		是和module结构体一起申请的，所以之后一起释放
3.将mod从module_list链表中删除
	注;这里用二重指针更为方便，不用if..else
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3280</x>
      <y>84</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>module_unmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3243</x>
      <y>78</y>
      <w>45</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3280</x>
      <y>90</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3285</x>
      <y>87</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3176</x>
      <y>58</y>
      <w>125</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
name_user为NULL时，
表示内核自动删除module_list中满足条件的module</panel_attributes>
    <additional_attributes>10.0;10.0;1230.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3294</x>
      <y>65</y>
      <w>45</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>条件：
1.mod-&gt;refs指向NULL,表示没有其他module依赖mod
2.MOD_AUTOCLEAN，表示mod允许自动删除
3.MOD_RUNNING，已经成功安装，但是没有free_module-&gt;cleanup
4.！MOD_DELETED，没有free_module
5.MOD_USED_ONCE,模块安装之后受到引用
6.!__MOD_IN_USE，不被使用

上述条件满足且（MOD_VISITED没置或者MOD_JUST_FREED置上）
mod-&gt;flags |= MOD_DELETED;
 //这里可能将其他模块的MOD_JUST_FREED置上
free_module(mod, 1);
 //需要重新遍历module_list链表，因为free_module的tag_freed为1
something_changed = 1;

但是如果MOD_VISITED置上并且MOD_JUST_FREED没置
mod-&gt;flags &amp;= ~MOD_VISITED
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3448</x>
      <y>57</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3360</x>
      <y>69</y>
      <w>44</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.current-&gt;fs-&gt;root要存在，因为进程需要通过
	/sbin/insmod去安装module
2.max_threads规定最大的线程数，因为request_module
	会通过创建thread，所以这里规定request_module创建的
	线程数最大是max_threads/2，
	所以嵌套或者共存的request_module最大是
	max(max_threads/2，MAX_KMOD_CONCURRENT)
3.如果嵌套的request_module数目（kmod_concurrent）超过了最大值
	返回-ENOMEM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3378</x>
      <y>60</y>
      <w>79</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>770.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3411</x>
      <y>70</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kernel_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3416</x>
      <y>60</y>
      <w>41</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3428</x>
      <y>70</y>
      <w>47</w>
      <h>14</h>
    </coordinates>
    <panel_attributes> //存储block的signal，便于之后恢复
tmpsig = current-&gt;blocked;
 //将除SIGKILL和SIGSTOP的signal清掉，以免在安装的途中受到干扰
 //清掉表示在blocked中置1
siginitsetinv(&amp;current-&gt;blocked, sigmask(SIGKILL) | sigmask(SIGSTOP));
 //重新计算pending.signal中是否有被置上的signal（blocked中为0）
 //如果有t-&gt;sigpending置1
recalc_sigpending(current);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3444</x>
      <y>60</y>
      <w>13</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3454</x>
      <y>60</y>
      <w>35</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3482</x>
      <y>72</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //wait子线程
waitpid(pid, NULL, __WCLONE)
 //已经安装完，递减request_module计数
atomic_dec(&amp;kmod_concurrent)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3511</x>
      <y>72</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //恢复mask，并重新检测是否
 //收到相关信号
current-&gt;blocked = tmpsig;
recalc_sigpending(current);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3454</x>
      <y>60</y>
      <w>68</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;660.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3411</x>
      <y>78</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>exec_modprobe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3415</x>
      <y>73</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3371</x>
      <y>86</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.设置环境变量
2.设置argv
	这里相当于/sbin/modprobe -s -k module_name
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3386</x>
      <y>81</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3415</x>
      <y>87</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>exec_usermodehelper</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3416</x>
      <y>81</y>
      <w>9</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3388</x>
      <y>95</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //指向当前线程
curtask = current
 //指向init_task
curtask-&gt;session = 1;
curtask-&gt;pgrp = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3394</x>
      <y>90</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3405</x>
      <y>98</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>use_init_fs_context</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3408</x>
      <y>90</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为线程的根目录可能不是
系统的根目录，所以需要切换成
init_task的根目录</panel_attributes>
    <additional_attributes>160.0;10.0;50.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3389</x>
      <y>108</y>
      <w>29</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>rootmnt = mntget(init_fs-&gt;rootmnt);
root = dget(init_fs-&gt;root);
pwdmnt = mntget(init_fs-&gt;pwdmnt);
pwd = dget(init_fs-&gt;pwd);

our_fs = current-&gt;fs;
our_fs-&gt;umask = init_fs-&gt;umask;
 //设置root pwd，如果之前的root pwd存在
 //将其dput，mntput
set_fs_root(our_fs, rootmnt, root);
set_fs_pwd(our_fs, pwdmnt, pwd);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3395</x>
      <y>101</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取init_task的root、pwd、umask
</panel_attributes>
    <additional_attributes>190.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3413</x>
      <y>101</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
our_fs-&gt;altroot存在</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3420</x>
      <y>110</y>
      <w>18</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //更新altroot
our_fs-&gt;altrootmnt = NULL;
our_fs-&gt;altroot = NULL;
 //将其原来的释放
dput(dentry);
mntput(mnt);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3442</x>
      <y>111</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>dput(root);
mntput(rootmnt);
dput(pwd);
mntput(pwdmnt);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3413</x>
      <y>101</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将原来的root和pwd释放</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3439</x>
      <y>99</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>	sigemptyset(&amp;curtask-&gt;blocked);
	flush_signals(curtask);
	flush_signal_handlers(curtask);
	recalc_sigpending(curtask);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3422</x>
      <y>90</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将父进程处理的信号和相应的action丢弃</panel_attributes>
    <additional_attributes>20.0;10.0;240.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3463</x>
      <y>102</y>
      <w>20</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>if (curtask-&gt;files-&gt;fd[i]) close(i)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3423</x>
      <y>90</y>
      <w>52</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
关闭所有的文件</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3486</x>
      <y>99</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>curtask-&gt;user = INIT_USER;
atomic_inc(&amp;INIT_USER-&gt;__count);
atomic_inc(&amp;INIT_USER-&gt;processes);
atomic_dec(&amp;user-&gt;processes);
free_uid(user);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3423</x>
      <y>90</y>
      <w>71</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复用init_task的user
将之前的user释放</panel_attributes>
    <additional_attributes>10.0;10.0;690.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3516</x>
      <y>99</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>curtask-&gt;euid = curtask-&gt;fsuid = 0;
curtask-&gt;egid = curtask-&gt;fsgid = 0;
 //所有的进程权限都给予这个内核线程
cap_set_full(curtask-&gt;cap_effective);
set_fs(KERNEL_DS)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3424</x>
      <y>90</y>
      <w>107</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
给与线程权限</panel_attributes>
    <additional_attributes>10.0;10.0;1050.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3546</x>
      <y>99</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>execve</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3423</x>
      <y>90</y>
      <w>130</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1280.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3002</x>
      <y>104</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sparcaudio_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3007</x>
      <y>98</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2981</x>
      <y>111</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_register_chrdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2986</x>
      <y>107</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2981</x>
      <y>118</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_chrdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2988</x>
      <y>114</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2958</x>
      <y>121</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果major为0</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2946</x>
      <y>126</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.从 MAX_CHRDEV-1向前遍历，找到
	chrdevs[major].fops为NULL的位置
	赋值：
	chrdevs[major].name = name;
	chrdevs[major].fops = fops;
	return major;
2.如果没找到，返回-EBUSY
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2972</x>
      <y>128</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果major &gt;= MAX_CHRDEV，返回-EINVAL
2.如果chrdevs[major].fops且和当前注册的fops
	不同，返回return -EBUSY
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2986</x>
      <y>121</y>
      <w>7</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3005</x>
      <y>128</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>chrdevs[major].name = name;
chrdevs[major].fops = fops;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2988</x>
      <y>121</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3040</x>
      <y>111</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_mk_dir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3005</x>
      <y>107</y>
      <w>44</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3010</x>
      <y>121</y>
      <w>22</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.name == NULL时，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3020</x>
      <y>114</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3035</x>
      <y>120</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>search_for_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3043</x>
      <y>114</y>
      <w>6</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3029</x>
      <y>129</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_root_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3030</x>
      <y>123</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果dir为NULL
如果通过下面接口无法找到
就返回NULL</panel_attributes>
    <additional_attributes>120.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3014</x>
      <y>136</y>
      <w>14</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>return root_entry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3021</x>
      <y>132</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
root_entry != NULL</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3035</x>
      <y>132</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
root_entry为NULL</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3028</x>
      <y>135</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请root_entry</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3020</x>
      <y>141</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2901</x>
      <y>144</y>
      <w>130</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果table的size不够
fs_info.num_inodes &gt;= fs_info.table_size</panel_attributes>
    <additional_attributes>1280.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2857</x>
      <y>165</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2863</x>
      <y>159</y>
      <w>41</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注：sizeof *table相当于sizeof(*table)</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2875</x>
      <y>166</y>
      <w>42</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memcpy (table, fs_info.table, sizeof *table *fs_info.num_inodes);
kfree (fs_info.table);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2887</x>
      <y>159</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fs_info.table存在
就copy原来的table到新申请的内存</panel_attributes>
    <additional_attributes>150.0;10.0;70.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2921</x>
      <y>166</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fs_info.table = table
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2901</x>
      <y>159</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新table</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2942</x>
      <y>167</y>
      <w>18</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>namelen = strlen (name)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2948</x>
      <y>144</y>
      <w>83</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 name &amp;&amp; (namelen &lt; 1) 时
重新计算name的长度</panel_attributes>
    <additional_attributes>810.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2966</x>
      <y>144</y>
      <w>65</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请devfs_entry+name长度的内存
并reset</panel_attributes>
    <additional_attributes>630.0;10.0;10.0;220.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2963</x>
      <y>166</y>
      <w>29</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>kmalloc
 memset (new, 0, sizeof *new + namelen);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2999</x>
      <y>144</y>
      <w>33</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置新申请的devfs_entry</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2995</x>
      <y>165</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>new-&gt;parent = parent;
 //注：name是new中的一个字节
if (name) memcpy (new-&gt;name, name, namelen);
new-&gt;namelen = namelen;
 //更新inode号
new-&gt;inode.ino = fs_info.num_inodes + FIRST_INODE;
new-&gt;inode.nlink = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3029</x>
      <y>144</y>
      <w>31</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
新申请的devfs_entry关联到fs_info</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;220.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3033</x>
      <y>166</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>fs_info.table[fs_info.num_inodes] = new;
 //更新num_inodes，记录fs_info中inode的个数
++fs_info.num_inodes;
 //如果新申请的devfs_entry是dev的根目录
if (parent == NULL) return new;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3030</x>
      <y>144</y>
      <w>47</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果新申请的不是dev的根目录
建立new和parent的关系</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3068</x>
      <y>164</y>
      <w>37</w>
      <h>16</h>
    </coordinates>
    <panel_attributes> //u.dir.last表示parent中的最后一个devfs_entry
 //u.dir.first表示parent中第一个devfs_entry
 //这里将new链接到链表最后
new-&gt;prev = parent-&gt;u.dir.last
 //如果first不存在，更新first，不然链接到链表的最后
if (parent-&gt;u.dir.first == NULL) parent-&gt;u.dir.first = new;
else parent-&gt;u.dir.last-&gt;next = new;
 //更新last
parent-&gt;u.dir.last = new;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3046</x>
      <y>140</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>root_entry-&gt;registered = TRUE;
root_entry-&gt;mode = S_IFDIR;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3042</x>
      <y>136</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3079</x>
      <y>139</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>update_devfs_inode_from_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3042</x>
      <y>136</y>
      <w>47</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3107</x>
      <y>151</y>
      <w>61</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>S_ISDIR：
de-&gt;inode.mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;
de-&gt;inode.uid = 0;
de-&gt;inode.gid = 0;

S_ISLNK：
de-&gt;inode.mode = S_IFLNK | S_IRUGO | S_IXUGO;
de-&gt;inode.uid = 0;
de-&gt;inode.gid = 0;

S_ISFIFO：
de-&gt;inode.mode = de-&gt;mode;
de-&gt;inode.uid = de-&gt;u.fifo.uid;
de-&gt;inode.gid = de-&gt;u.fifo.gid;

其他：
 //fcb存在owner
if(u.fcb.auto_owner) de-&gt;inode.mode = (de-&gt;mode &amp; ~S_IALLUGO) | S_IRUGO | S_IWUGO;
else de-&gt;inode.mode = de-&gt;mode;
de-&gt;inode.uid = de-&gt;u.fcb.default_uid;
de-&gt;inode.gid = de-&gt;u.fcb.default_gid;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3091</x>
      <y>142</y>
      <w>36</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置新申请的devfs_entry的inode</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3035</x>
      <y>134</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新root_entry</panel_attributes>
    <additional_attributes>10.0;20.0;80.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3123</x>
      <y>139</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3035</x>
      <y>132</y>
      <w>95</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在root_entry下创建名为.devfsd的devfs_entry</panel_attributes>
    <additional_attributes>10.0;10.0;930.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3036</x>
      <y>132</y>
      <w>142</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新.devfsd的devfs_entry</panel_attributes>
    <additional_attributes>10.0;10.0;1400.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3170</x>
      <y>140</y>
      <w>37</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>new-&gt;registered = TRUE;
new-&gt;u.fcb.u.device.major = next_devnum_char &gt;&gt; 8;
new-&gt;u.fcb.u.device.minor = next_devnum_char &amp; 0xff;
++next_devnum_char;
new-&gt;mode = S_IFCHR | S_IRUSR | S_IWUSR;
new-&gt;u.fcb.default_uid = 0;
new-&gt;u.fcb.default_gid = 0;
new-&gt;u.fcb.ops = &amp;devfsd_fops;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3041</x>
      <y>123</y>
      <w>187</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环解析name</panel_attributes>
    <additional_attributes>10.0;10.0;1850.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3213</x>
      <y>137</y>
      <w>55</w>
      <h>45</h>
    </coordinates>
    <panel_attributes>1.找到以‘/’隔离的subname
2.如果是最后一个节点，获取最后一个节点的namelen(stop - subname)
	通过search_for_entry_in_dir在父目录dir中查找，如果找到了entry，
	将其返回；如果没有找到，但是!mkfile，返回NULL;如果要求mkfile，通过create_entry
	在dir中创建subname节点。且：
	if (entry &amp;&amp; is_new) *is_new = TRUE
3.如果subname是../，将dir切换成dir = dir-&gt;parent，并且
	 //不能返回到devfs的父目录
	 if (dir == NULL) return NULL;
	 subname += 3;
    continue;
3.获取dir中查找的name长度(len = ptr - subname)
	并通过search_for_entry_in_dir在父目录中查找
4.如果在父目录dir中没找到entry，并且不要求创建新目录（!mkdir）
	返回NULL
5.如果没找到entry，但是要求mkdir，需要通过create_entry在父目录
	下创建一个名为subname的entry，,并且：
	entry-&gt;mode = S_IFDIR | S_IRUGO | S_IXUGO | S_IWUSR
	//标志新创建
	if (is_new) *is_new = TRUE;
6.如果找到或者创建的的entry不是S_ISDIR，返回NULL
7.改变entry的属性：
	entry-&gt;registered = TRUE;
	entry-&gt;hide = FALSE;
8.遍历下一个：
	subname = ptr + 1;
	dir = entry;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3059</x>
      <y>119</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果没找到entry，返回NULL
2.如果entry不是S_ISDIR，但是
	registered置上，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3048</x>
      <y>114</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3084</x>
      <y>119</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>de-&gt;u.dir.first = NULL;
de-&gt;u.dir.last = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3049</x>
      <y>114</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不是S_ISDIR，并且没有创建（!is_new）</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3101</x>
      <y>117</y>
      <w>45</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>de-&gt;mode = S_IFDIR | S_IRUGO | S_IXUGO;
de-&gt;info = info;
if (!de-&gt;registered) de-&gt;u.dir.num_removable = 0;
de-&gt;registered = TRUE;
de-&gt;show_unreg = (boot_options &amp; OPTION_SHOW) ? TRUE : FALSE;
de-&gt;hide = FALSE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3049</x>
      <y>114</y>
      <w>63</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3221</x>
      <y>189</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3210</x>
      <y>193</y>
      <w>17</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.父目录要是S_ISDIR
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3230</x>
      <y>193</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.遍历parent的子节点链表parent-&gt;u.dir.first
2.根据namelen和name滤出对应的devfs_entry
3.如果在链表中没有找到devfs_entry，返回NULL
4.如果找到了，但是不是S_ISLNK，或者是link，
	但是不要求traverse_symlink，直接返回找到的
	devfs_entry
5.如果需要根据link找到实体（traverse_symlink），
	使用search_for_entry在parent中找curr-&gt;u.symlink.linkname
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3234</x>
      <y>189</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3227</x>
      <y>186</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>search_for_entry_in_dir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3236</x>
      <y>181</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2078</x>
      <y>420</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>uhci_hcd_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2087</x>
      <y>430</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>pci_module_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2064</x>
      <y>430</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>kmem_cache_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2071</x>
      <y>424</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uhci_td
uhci_qh
uhci_urb_priv</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2083</x>
      <y>424</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2075</x>
      <y>441</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>pci_register_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2099</x>
      <y>442</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>pci_unregister_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2080</x>
      <y>434</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uhci_pci_driver</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2089</x>
      <y>434</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果register成功，返回0
否则unregister，然后返回-ENODEV</panel_attributes>
    <additional_attributes>50.0;10.0;180.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2041</x>
      <y>453</y>
      <w>13</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>list_add_tail
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2044</x>
      <y>445</y>
      <w>39</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将pci_driver链接到pci_drivers链表后面</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2080</x>
      <y>445</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2074</x>
      <y>451</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历pci_devices中所有的pci_dev
2.如果dev没有相应的driver（!pci_dev_driver），
	通过pci_announce_device查找和driver match
	的dev去初始化
3.返回所有初始化的dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2073</x>
      <y>466</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_dev_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2077</x>
      <y>460</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2065</x>
      <y>474</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果dev.driver存在，直接返回
2.如果不存在，遍历dev所有的rom resource
	如果其中有一个resource的IORESOURCE_BUSY
	（地址区间已启用）置上，返回pci_compat_driver
3.否则返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2076</x>
      <y>469</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2095</x>
      <y>466</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_announce_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2089</x>
      <y>460</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2095</x>
      <y>474</y>
      <w>35</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.如果drv-&gt;id_table存在，通过pci_match_device遍历
	表中是否有和dev匹配的pci_device_id，如果没有，则
	直接返回0。如果找到通过drv-&gt;probe初始化
2.如果drv-&gt;id_table不存在，则默认是直接初始化drv-&gt;probe
3.如果初始化成功：
	dev-&gt;driver = drv;
	ret = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2102</x>
      <y>469</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2095</x>
      <y>489</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_match_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2099</x>
      <y>486</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2085</x>
      <y>497</y>
      <w>26</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果pci_device_id的vendor、subvendor、class_mask都为空
	则到了table的末尾，直接返回NULL
2.否则，只有在pci_device_id和dev的vendor，device、
	subvendor、subdevice以及class（
	class_mask为~0，表示其要完全相同）
	都相同的情况下，才是和dev匹配的pci_device_id
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2097</x>
      <y>492</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2115</x>
      <y>494</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drv-&gt;probe
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2120</x>
      <y>486</y>
      <w>4</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2115</x>
      <y>502</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_pci_probe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2119</x>
      <y>497</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uhci_pci_driver</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2104</x>
      <y>505</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
向dev的USBLEGSUP寄存器写0</panel_attributes>
    <additional_attributes>180.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2095</x>
      <y>511</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_write_config_word
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2117</x>
      <y>511</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_enable_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2121</x>
      <y>505</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2101</x>
      <y>519</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_enable_device
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2110</x>
      <y>514</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2126</x>
      <y>519</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_set_power_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2122</x>
      <y>514</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2147</x>
      <y>508</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.遍历pci设备的[0,6)号resource
2.resource的flag中IORESOURCE_IO要置上
3.通过check_region检查resource是否被用
	如果被用直接退出
4.通过pci_set_master将USB竞争总线的能力打开
	（能使用DMA功能）
5.通过setup_uhci初始化USB总线（传入usb设备的其实地址和长度）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2121</x>
      <y>505</y>
      <w>38</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2138</x>
      <y>523</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>check_region</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2145</x>
      <y>519</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2133</x>
      <y>530</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__check_region</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2139</x>
      <y>526</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2129</x>
      <y>537</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过__request_region（reference）
	申请对应的resource
2.如果没申请到，说明有conflict，返回EBUSY
3.如果申请到了，通过release_resource将
	之前申请的resource释放（将其从parent.child
	的sibling链表中删除），并通过kfree将其内存释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2138</x>
      <y>533</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2155</x>
      <y>523</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_set_master</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2160</x>
      <y>519</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2149</x>
      <y>531</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_write_config_word
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2148</x>
      <y>526</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
向PCI_COMMAND写
PCI_COMMAND_MASTER</panel_attributes>
    <additional_attributes>120.0;10.0;60.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2167</x>
      <y>531</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_set_master</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2163</x>
      <y>526</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2159</x>
      <y>538</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.更改PCI_LATENCY_TIMER寄存器
	的值，如果原本的值小于16，则取
	pcibios_max_latency（但是最大是64）；
	如果原来的值大于pcibios_max_latency，
	则取pcibios_max_latency
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2166</x>
      <y>534</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2227</x>
      <y>526</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_uhci</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2174</x>
      <y>519</y>
      <w>59</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;570.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2189</x>
      <y>534</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_uhci</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2194</x>
      <y>529</y>
      <w>41</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2185</x>
      <y>578</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_alloc_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2193</x>
      <y>537</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2192</x>
      <y>573</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2182</x>
      <y>585</y>
      <w>30</w>
      <h>23</h>
    </coordinates>
    <panel_attributes> //申请usb_bus
bus = kmalloc
memset(&amp;bus-&gt;devmap, 0
bus-&gt;op = op;
bus-&gt;root_hub = NULL;
bus-&gt;hcpriv = NULL;
bus-&gt;busnum = -1;
bus-&gt;bandwidth_allocated = 0;
bus-&gt;bandwidth_int_reqs  = 0;
bus-&gt;bandwidth_isoc_reqs = 0;

INIT_LIST_HEAD(&amp;bus-&gt;bus_list);
INIT_LIST_HEAD(&amp;bus-&gt;inodes)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2191</x>
      <y>581</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2183</x>
      <y>541</y>
      <w>30</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>kmalloc(sizeof(*uhci)
memset(uhci, 0, sizeof(*uhci));
uhci-&gt;irq = -1;
uhci-&gt;io_addr = io_addr;
uhci-&gt;io_size = io_size;
spin_lock_init(&amp;uhci-&gt;qh_remove_lock);
INIT_LIST_HEAD(&amp;uhci-&gt;qh_remove_list);
spin_lock_init(&amp;uhci-&gt;urb_remove_lock);
INIT_LIST_HEAD(&amp;uhci-&gt;urb_remove_list);
nested_init(&amp;uhci-&gt;urblist_lock);
INIT_LIST_HEAD(&amp;uhci-&gt;urb_list);
spin_lock_init(&amp;uhci-&gt;framelist_lock)

 //框架表
uhci-&gt;fl = (void *)__get_free_page

 //申请bus，并建立关系
bus = usb_alloc_bus(&amp;uhci_device_operations)
uhci-&gt;bus = bus;
bus-&gt;hcpriv = uhci

 //读取port的状态，其状态寄存器是1，表示这个port存在
 //从而确定port的数量。注：前16字节是总线控制器本身
 //后面是port寄存器，每2个字节一个port
 //如果port的数量小于2或者大于8，将其赋值成2
 portstatus = inw(io_addr + 0x10 + (port * 2));
	if (!(portstatus &amp; 0x0080))
		break;
 uhci-&gt;rh.numports = port
 //初始化中断交互队列skeltd
 //1.首先索引[1,9)
 //填充status，buffer（都为0，表示空操作），info（是操作码 	(UHCI_NULL_DATA_SIZE &lt;&lt; 21) | (0x7f &lt;&lt; 8) | USB_PID_IN）
 uhci_fill_td
 //指向上一个skeltd的物理地址
	td-&gt;link	=virt_to_bus(&amp;uhci-&gt;skeltd[i - 1])
 //2.其次索引0，填充和[1，9）相同，
 uhci_fill_td
 //link指向skelqh[0]，uhci_td和uhci_qh是16字节对齐，所以低4位为0，可以填标志
 //UHCI_PTR_QH,表示其指向队列描述块
 uhci-&gt;skel_int1_td.link = virt_to_bus(&amp;uhci-&gt;skel_ls_control_qh) | UHCI_PTR_QH;
 //3.其次是索引9，填充和之前相同
 uhci_fill_td
 //UHCI_PTR_TERM,表示结束位
 uhci-&gt;skel_term_td.link = UHCI_PTR_TERM;

 //初始化队列描述块skelqh
 //索引0，link指向下一个队列描述块，element是队列头指针（都初始化为结束，只有最后一个指向skeltd[9]）
 uhci-&gt;skel_ls_control_qh.link = virt_to_bus(&amp;uhci-&gt;skel_hs_control_qh) | UHCI_PTR_QH;
 uhci-&gt;skel_ls_control_qh.element = UHCI_PTR_TERM;
 //索引1
 uhci-&gt;skel_hs_control_qh.link = virt_to_bus(&amp;uhci-&gt;skel_bulk_qh) | UHCI_PTR_QH;
 uhci-&gt;skel_hs_control_qh.element = UHCI_PTR_TERM;
 //索引2
 uhci-&gt;skel_bulk_qh.link = virt_to_bus(&amp;uhci-&gt;skel_term_qh) | UHCI_PTR_QH;
 uhci-&gt;skel_bulk_qh.element = UHCI_PTR_TERM
 //索引3，最后一个，link指向结束
 uhci-&gt;skel_term_qh.link = UHCI_PTR_TERM;
 uhci-&gt;skel_term_qh.element = virt_to_bus(&amp;uhci-&gt;skel_term_td)

注：链表skeltd[8] -link-&gt; ..-link-&gt; skeltd[0] -link-&gt; ls_qh -link-&gt; hs_qh -link-&gt; bulk_qh -link-&gt; term_qh -link-&gt;NULL
																															      |
																															      element
																															      |
																															      skeltd[9]
 //将skeltd（irq）[0,7]数组分配到fl的第（2^n-1）个框架结构中
 //所以第n个skeltd是（2^n）ms执行一次（注：虽然只链接了第n个skeltd到fl中，但是skeltd通过link链接在一起）
 uhci-&gt;fl-&gt;frame[i] =  virt_to_bus(irq)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2205</x>
      <y>535</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;driver_data = uhci
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2211</x>
      <y>529</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2229</x>
      <y>529</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
请求resource
uhci-&gt;io_addr(len=io_size)</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2224</x>
      <y>534</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_region
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2237</x>
      <y>534</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reset_hc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2232</x>
      <y>529</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2229</x>
      <y>540</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //向USB控制器发送”全局总清“命令，将其初始化
outw(USBCMD_GRESET, io_addr + USBCMD)
wait_ms(50);
outw(0, io_addr + USBCMD);
wait_ms(10);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2239</x>
      <y>537</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2262</x>
      <y>534</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_register_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2232</x>
      <y>529</y>
      <w>38</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2253</x>
      <y>541</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_next_zero_bit
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2247</x>
      <y>537</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从1开始查找busmap.busmap中是否有空闲的位</panel_attributes>
    <additional_attributes>200.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2266</x>
      <y>537</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
busnum &lt; USB_MAXBUS
如果有空闲位</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2267</x>
      <y>542</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>set_bit(busnum, busmap.busmap);
bus-&gt;busnum = busnum
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2295</x>
      <y>542</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_add
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2266</x>
      <y>537</y>
      <w>36</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将bus的bus_list链接到usb_bus_list链表中</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2308</x>
      <y>542</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usbdevfs_add_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2266</x>
      <y>537</y>
      <w>50</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2297</x>
      <y>549</y>
      <w>44</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.遍历usb的超级块链表superlist，然后通过new_bus_inode
	在sb中添加inode
2.通过update_special_inodes检查special数组中如果
	存在inode，将其时间更新
	inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME
3.执行usbdevfs_conn_disc_event：
	wake_up(&amp;deviceconndiscwq);
	conndiscevcnt++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2315</x>
      <y>545</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2309</x>
      <y>566</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>new_bus_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2314</x>
      <y>562</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2285</x>
      <y>576</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2288</x>
      <y>569</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
busnum 不能大于255
在超级块中获取IBUS | (busnum &lt;&lt; 8)号inode</panel_attributes>
    <additional_attributes>270.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2313</x>
      <y>572</y>
      <w>36</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;
inode-&gt;i_uid = sb-&gt;u.usbdevfs_sb.busuid;
inode-&gt;i_gid = sb-&gt;u.usbdevfs_sb.busgid;
inode-&gt;i_mode = sb-&gt;u.usbdevfs_sb.busmode | S_IFDIR;
inode-&gt;i_op = &amp;usbdevfs_bus_inode_operations;
inode-&gt;i_fop = &amp;usbdevfs_bus_file_operations;
 //从inode能找到bus
inode-&gt;u.usbdev_i.p.bus = bus;
 //将inode挂入到sb的链表中
list_add_tail(&amp;inode-&gt;u.usbdev_i.slist, &amp;sb-&gt;u.usbdevfs_sb.ilist);
 //将inode挂入到bus的链表中
list_add_tail(&amp;inode-&gt;u.usbdev_i.dlist, &amp;bus-&gt;inodes);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2315</x>
      <y>569</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2285</x>
      <y>586</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_new_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2289</x>
      <y>579</y>
      <w>3</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.()</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2289</x>
      <y>589</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.()</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2281</x>
      <y>594</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;read_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2289</x>
      <y>597</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usbdevfs_read_super-&gt;usbdevfs_sops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2281</x>
      <y>603</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usbdevfs_read_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2257</x>
      <y>612</y>
      <w>32</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_ctime = inode-&gt;i_mtime = inode-&gt;i_atime = CURRENT_TIME;
inode-&gt;i_mode = S_IFREG;
inode-&gt;i_gid = inode-&gt;i_uid = 0;
INIT_LIST_HEAD(&amp;inode-&gt;u.usbdev_i.dlist);
INIT_LIST_HEAD(&amp;inode-&gt;u.usbdev_i.slist);
inode-&gt;u.usbdev_i.p.dev = NULL;
inode-&gt;u.usbdev_i.p.bus = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2273</x>
      <y>606</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2293</x>
      <y>612</y>
      <w>37</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果是ISPECIAL:
	1.如果是root_inode
	inode-&gt;i_op = &amp;usbdevfs_root_inode_operations;
	inode-&gt;i_fop = &amp;usbdevfs_root_file_operations;
	inode-&gt;i_mode = S_IFDIR | S_IRUGO | S_IXUGO;
	return;
	2.如果超过了ISPECIAL类型中inode号的限制，直接return
	3.如果是其他special类型的inode
	spec = &amp;special[inode-&gt;i_ino-(IROOT+1)];
	inode-&gt;i_fop = spec-&gt;fops;
	return;
2.如果是其他类型，直接return
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2286</x>
      <y>606</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查看inode的类型
ITYPE(inode-&gt;i_ino)</panel_attributes>
    <additional_attributes>20.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2359</x>
      <y>536</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_hc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2232</x>
      <y>529</y>
      <w>132</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1300.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2344</x>
      <y>542</y>
      <w>43</w>
      <h>19</h>
    </coordinates>
    <panel_attributes> //reset host controller,并在timeout时间内检测其是否置上
outw (USBCMD_HCRESET, io_addr + USBCMD)
 //打开USB的四种中断: 超时，唤醒，规定的交互完成，short_packet
outw (USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP, io_addr + USBINTR)
 //将框架寄存器设置为0，并将其地址赋给相应的寄存器，表示从s-&gt;framelist[0]开始扫描
outw (0, io_addr + USBFRNUM);
outl (virt_to_bus (s-&gt;framelist), io_addr + USBFLBASEADD);
 //USBCMD_RS启动USB控制器
outw (USBCMD_RS | USBCMD_CF | USBCMD_MAXP, io_addr + USBCMD);
s-&gt;apm_state = 1;
s-&gt;running = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2362</x>
      <y>539</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2390</x>
      <y>535</y>
      <w>32</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.通过request_irq请求irq，其中：
	action-&gt;handler = uhci_interrupt;
	action-&gt;flags = SA_SHIRQ;
	action-&gt;name =  "usb-uhci";
	action-&gt;dev_id = uhci;（uhci对象）
2.如果请求成功：
	uhci-&gt;irq = irq;
	//设置USBLEGSUP
	pci_write_config_word(dev, USBLEGSUP, USBLEGSUP_DEFAULT)
	//启用根集中器
	uhci_start_root_hub（）
3.如果irq没请求成功，或者根集中器启动失败
	reset_hc(uhci);
	release_region(uhci-&gt;io_addr, uhci-&gt;io_size);
	release_uhci(uhci);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2396</x>
      <y>563</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_start_root_hub</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2232</x>
      <y>529</y>
      <w>172</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1700.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2404</x>
      <y>560</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2362</x>
      <y>570</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_alloc_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2370</x>
      <y>566</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2355</x>
      <y>576</y>
      <w>27</w>
      <h>20</h>
    </coordinates>
    <panel_attributes> //申请usb_device
dev = kmalloc(sizeof(*dev)

memset(dev, 0, sizeof(*dev))
 //这里bus=uhci-&gt;bus，parent=NULL(因为申请的是根集中器)
dev-&gt;bus = bus;
dev-&gt;parent = parent;
atomic_set(&amp;dev-&gt;refcnt, 1);
INIT_LIST_HEAD(&amp;dev-&gt;inodes);
INIT_LIST_HEAD(&amp;dev-&gt;filelist);

dev-&gt;bus-&gt;op-&gt;allocate(dev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2368</x>
      <y>573</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2360</x>
      <y>599</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;bus-&gt;op-&gt;allocate
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2367</x>
      <y>595</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2367</x>
      <y>602</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uhci_device_operations
这里直接返回0</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2362</x>
      <y>606</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_alloc_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2381</x>
      <y>570</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci-&gt;bus-&gt;root_hub = dev
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2389</x>
      <y>566</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根集中器的usb_dev赋值</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2405</x>
      <y>570</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2401</x>
      <y>566</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2394</x>
      <y>577</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>dev-&gt;descriptor.bMaxPacketSize0 = 8
 //从dev-&gt;bus-&gt;devmap.devicemap中找到空闲的devnum
 //如果定义了DEVNUM_ROUND_ROBIN，则从devnum_next开始查找
 //并更新devnum_next= devnum + 1
devnum = find_next_zero_bit
 //如果找到的devnum有效：devnum &lt; 128
 set_bit(devnum, dev-&gt;bus-&gt;devmap.devicemap);
	dev-&gt;devnum = devnum
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2411</x>
      <y>573</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2468</x>
      <y>567</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_new_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2401</x>
      <y>566</y>
      <w>74</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2427</x>
      <y>587</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_set_address</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2427</x>
      <y>605</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_control_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2431</x>
      <y>570</y>
      <w>45</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2431</x>
      <y>590</y>
      <w>46</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_snddefctrl：定义了pipe，__default_pipe中devnum和endpoint为0
(30~31,传输方式，成块传输、等时传输，中断传输，控制传输
26，指示是否为低速设备（dev-&gt;slow）
8~14位，设备号devnum，没被设置地址前是0
15~18位，endpoint号
7位，0指示输出，1指示输入)
USB_REQ_SET_ADDRESS：命令码，设置地址
dev-&gt;devnum：要设置的设备地址</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2427</x>
      <y>576</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //设置输入，输出预取信包的大小
dev-&gt;epmaxpacketin [0] = 8;
dev-&gt;epmaxpacketout[0] = 8
usb_set_address(dev)
wait_ms(10)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2432</x>
      <y>584</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2451</x>
      <y>578</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_get_descriptor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2456</x>
      <y>570</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
先读8个字节，将
支持的信包容量读出</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2449</x>
      <y>585</y>
      <w>34</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.将buf(dev-&gt;descriptor)清0
	memset(buf,0,size)
2.请求描述块，如果请求大小为0，则retry（总共5次）
	//这里type=USB_DT_DEVICE，表示设备描述块
	//usb_rcvctrlpipe中定义了devnum+endpoint和方向USB_DIR_IN
	usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
		USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
		(type &lt;&lt; 8) + index, 0, buf, size, HZ * GET_TIMEOUT)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2458</x>
      <y>581</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2468</x>
      <y>578</y>
      <w>30</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;epmaxpacketin [0] = dev-&gt;descriptor.bMaxPacketSize0;
dev-&gt;epmaxpacketout[0] = dev-&gt;descriptor.bMaxPacketSize0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2473</x>
      <y>570</y>
      <w>23</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据读进来的设备描述块
设置控制交互信包的最大容量</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2500</x>
      <y>577</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_get_device_descriptor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2473</x>
      <y>570</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2488</x>
      <y>585</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.再次通过usb_get_descriptor读取设备描述块
	此次读取的size是sizeof(dev-&gt;descriptor)
2.将bcdUSB，idVendor，idProduct，bcdDevice
	从小端模式转化成cpu使用的模式
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2503</x>
      <y>580</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2524</x>
      <y>577</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_get_configuration</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2472</x>
      <y>570</y>
      <w>64</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2519</x>
      <y>585</y>
      <w>40</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.filter:配置描述快的数量需要在：
	1&lt;dev-&gt;descriptor.bNumConfigurations&lt;USB_MAXCONFIG
2.申请配置描述快数组，并清0
	dev-&gt;config =kmalloc
	memset(dev-&gt;config, 0,
3.申请原始的配置描述快指针数组
	dev-&gt;rawdescriptors=kmalloc
4.循环bNumConfigurations次读取配置描述块：
	1.通过usb_get_descriptor读取配置描述块（USB_DT_CONFIG）
		的前8字节。从而获取到配置描述快的大小（wTotalLength）
	2.通过kmalloc为读进来的原始配置描述块申请内存
	3.然后再次通过usb_get_descriptor读取配置描述快（USB_DT_CONFIG）
		这次的长度是wTotalLength，并将存储配置描述块的指针赋值：
		dev-&gt;rawdescriptors[cfgno] = bigbuffer
	4.通过usb_parse_configuration根据配置描述块解析出各种层次的描述块
		并建立相应的数据结构
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2532</x>
      <y>580</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2529</x>
      <y>615</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_parse_configuration</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2536</x>
      <y>611</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2519</x>
      <y>621</y>
      <w>44</w>
      <h>47</h>
    </coordinates>
    <panel_attributes>1.通过memcpy将buffer中的原始数据拷贝前9字节（USB硬件管理信息）
	到对应的dev-&gt;config[cfgno]中
2.获取配置描述快的大小：
	size = config-&gt;wTotalLength
3.为usb_interface申请数组（大小为config-&gt;bNumInterfaces，并且其大小
	不能大于32），并将内存空间清0
4.将配置头去掉：
	buffer += config-&gt;bLength;
	size -= config-&gt;bLength
5.遍历所有的interface（bNumInterfaces）
	1.通过usb_descriptor_header解析读进来的数据，
	其中:2&lt;bLength&lt;size,否则返回-1
	2.如果遇到了USB_DT_ENDPOINT，USB_DT_INTERFACE，USB_DT_CONFIG，USB_DT_DEVICE
		则退出未知header的解析
	3.如果不是上述四个，则是未知的header，并继续1~3
	4.如果退出了未知header的解析，
		1.如果不存在未知header（buffer-begin==0），
			config-&gt;extra = NULL;
			config-&gt;extralen = 0
		2.如果存在未知header（buffer-begin!=0),需要为其申请内存，并复制
			config-&gt;extra = kmalloc(len
			memcpy(config-&gt;extra, begin, len);
			config-&gt;extralen = len;
	注：这里如果有多个bNumInterfaces，并且其中的一个interface有未知的header，只要这个interface不在最后
	一个，会造成内存的泄露
	5.通过usb_parse_interface解析上述的四个interface
	6.更新buffer和size，并重新遍历interface
		buffer += retval;
		size -= retval;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2537</x>
      <y>618</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2532</x>
      <y>671</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_parse_interface</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2538</x>
      <y>667</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2519</x>
      <y>677</y>
      <w>44</w>
      <h>61</h>
    </coordinates>
    <panel_attributes>1.首先初始化
	interface-&gt;act_altsetting = 0;
	interface-&gt;num_altsetting = 0;
	//接口描述块数组暂定为4个
	interface-&gt;max_altsetting = USB_ALTSETTINGALLOC
2.为接口描述块数组申请内存，大小为max_altsetting
	interface-&gt;altsetting = kmalloc
3.遍历buffer
	1.如果这个interface存在的接口描述块（num_altsetting）超过了数组的
		界限，更新数组的界限interface-&gt;max_altsetting += USB_ALTSETTINGALLOC
		并为之分配内存interface-&gt;altsetting = kmalloc，并将之前的数据复制到新申请的内存中
		然后将旧数组释放
	2.获取存放接口描述快的内存，并更新num_altsetting：
		ifp = interface-&gt;altsetting + interface-&gt;num_altsetting;
		interface-&gt;num_altsetting++;
	3.将接口描述块存储到数组中并更新buffer，parse，size
		memcpy(ifp, buffer, USB_DT_INTERFACE_SIZE)
		buffer += ifp-&gt;bLength;
		parsed += ifp-&gt;bLength;
		size -= ifp-&gt;bLength;
	4.继续向下遍历buffer，识别出不能识别的header（和usb_parse_configuration相似）
		将其放入到：
		ifp-&gt;extra
		ifp-&gt;extralen
	5.如果遇到了USB_DT_CONFIG或者USB_DT_DEVICE说明遇到了下一个配置或者设备描述块
		直接返回上层，让usb_parse_configuration处理
	6.为ifp-&gt;endpoint申请数组，大小为bNumEndpoints（不能大于USB_MAXENDPOINTS），
		并清0
	7.遍历所有的endpoint(bNumEndpoints),通过usb_parse_endpoint对其进行解析
		并更新：
		buffer += retval;
		parsed += retval;
		size -= retval;	
	8.更新完endpoint之后，如果size小于USB_DT_INTERFACE_SIZE，说明读进来的描述块已经读完
		如果不为USB_DT_INTERFACE，说明读到了下一个设备或者配置描述块
		如果bAlternateSetting为0，说明读到了下一个interface
		都将退出，由上层usb_parse_endpoin继续处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2538</x>
      <y>674</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2531</x>
      <y>741</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_parse_endpoint</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2538</x>
      <y>737</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2518</x>
      <y>748</y>
      <w>43</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.filter：header-&gt;bLength不能大于读进来的数据的size
			bDescriptorType必须是USB_DT_ENDPOINT
2.将读进来的数据复制到endpoint中（对于视频是9，其他的长度是7）
3.根据cpu的大小端改变endpoint-&gt;wMaxPacketSize的格式
4.将其他未识别的数据存放在endpoint-&gt;extra中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2537</x>
      <y>744</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2565</x>
      <y>577</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_set_configuration</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2472</x>
      <y>570</y>
      <w>105</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1030.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2562</x>
      <y>585</y>
      <w>27</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.在dev.config的数组中找到和configuration
	一样的usb_config_descriptor
2.如果没找到，返回EINVAL
	如果找到了，通过usb_control_msg给usb_sndctrlpipe
	设置（USB_REQ_SET_CONFIGURATION）configuration
3.更新正在使用的configuration
	dev-&gt;actconfig = cp;
	dev-&gt;toggle[0] = 0;
	dev-&gt;toggle[1] = 0;
4.通过usb_set_maxpacket更新endpoint
	最大传输信包的数量
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2573</x>
      <y>580</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2567</x>
      <y>606</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_set_maxpacket</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2574</x>
      <y>603</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2565</x>
      <y>613</y>
      <w>43</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.遍历dev激活的configuration（dev-&gt;actconfig）
	下的所有interface（bNumInterfaces）中的
	所有endpoint（bNumEndpoints）：
	1.如果bmAttributes是USB_ENDPOINT_XFER_CONTROL
	（控制交互是双向的）：
	dev-&gt;epmaxpacketout[b] = ep[e].wMaxPacketSize;
	dev-&gt;epmaxpacketin [b] = ep[e].wMaxPacketSize
	2.如果是输出型endpoint，并且大于既有的epmaxpacketout
		将其更新
		dev-&gt;epmaxpacketout[b] = ep[e].wMaxPacketSize
	3.如果是输入型的endpoint，并且大于存储endpoint的epmaxpacketin
	dev-&gt;epmaxpacketin [b] = ep[e].wMaxPacketSize
注：bEndpointAddress的低四位存储的是endpoint的序号
	第4位存储的是endpoint的方向，0表示输出
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2576</x>
      <y>609</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2593</x>
      <y>577</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usbdevfs_add_device
（和usbdevfs_add_bus类似）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2473</x>
      <y>570</y>
      <w>131</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2618</x>
      <y>577</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_find_drivers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2474</x>
      <y>570</y>
      <w>155</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1530.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2608</x>
      <y>583</y>
      <w>38</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.遍历dev激活configuration所有的interface（bNumInterfaces）
	通过usb_interface_claimed检查改interface是否被认领
	如果没被认领，通过usb_find_interface_driver扫描驱动队列
	为其寻找driver
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2626</x>
      <y>580</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2600</x>
      <y>593</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_interface_claimed</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2607</x>
      <y>589</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2592</x>
      <y>599</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.检查interface是否有driver
	（iface-&gt;driver != NULL）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2601</x>
      <y>596</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2630</x>
      <y>593</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_find_interface_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2630</x>
      <y>589</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2614</x>
      <y>600</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.dev要存在
2.ifnum不能大于bNumInterfaces
3.根据interface号（ifnum）找到interface
	interface = dev-&gt;actconfig-&gt;interface + ifnum
4.通过usb_interface_claimed检测interface.driver
	不能存在
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2627</x>
      <y>596</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2647</x>
      <y>600</y>
      <w>39</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.遍历usb_driver_list
	1.如果driver-&gt;id_table存在，遍历dev所有的interface
		通过usb_match_id检查这个id是否和dev还有其中的interface
		匹配，如果匹配，通过driver-&gt;probe将其初始化
	2.如果id不存在，直接通过driver-&gt;probe将其初始化
	注：如果已经初始化，则返回NULL
2.如果初始化完成，通过usb_driver_claim_interface完成认领：
	iface-&gt;driver = driver;
	iface-&gt;private_data = priv
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2639</x>
      <y>596</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2663</x>
      <y>576</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>call_policy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2474</x>
      <y>570</y>
      <w>197</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
热插拔相关
注意创建内核线程时使用了VCLONE_VFORK</panel_attributes>
    <additional_attributes>10.0;10.0;1950.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2405</x>
      <y>374</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2364</x>
      <y>381</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_major_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2369</x>
      <y>377</y>
      <w>44</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>420.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2349</x>
      <y>390</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_register_chrdev
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2356</x>
      <y>384</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
USB_MAJOR,usb_fops</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2371</x>
      <y>390</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_mk_dir
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2368</x>
      <y>384</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs下的目录
usb_devfs_handle</panel_attributes>
    <additional_attributes>20.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2399</x>
      <y>381</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usbdevfs_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2405</x>
      <y>377</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2387</x>
      <y>389</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>INIT_LIST_HEAD
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2388</x>
      <y>384</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化special数组的inodes链表</panel_attributes>
    <additional_attributes>160.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2403</x>
      <y>389</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2402</x>
      <y>384</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usbdevfs_driver</panel_attributes>
    <additional_attributes>20.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2419</x>
      <y>389</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2403</x>
      <y>384</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2439</x>
      <y>389</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_mkdir
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2403</x>
      <y>384</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usbdir</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2397</x>
      <y>396</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.new_driver-&gt;fops存在时，usb_minors对应的设备
	要为空，如果为空，将其赋值：
	usb_minors[new_driver-&gt;minor/16] = new_driver
2.将new_driver的driver_list链接到usb_driver_list中
3.调用usb_scan_devices
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2409</x>
      <y>392</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2403</x>
      <y>409</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_scan_devices</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2409</x>
      <y>405</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2409</x>
      <y>412</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历usb_bus_list链表
中bus的根集中器</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2403</x>
      <y>416</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_check_support</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2393</x>
      <y>422</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.dev要存在
2.遍历dev-&gt;children，递归usb_check_support
	为其子设备认领driver
3.如果该设备激活的configuration不存在，该设备不在认领driver
4.如果configuration存在，且其devnum有效，遍历其interface
	通过usb_find_interface_driver为interface认领driver
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2409</x>
      <y>419</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2463</x>
      <y>382</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2410</x>
      <y>377</y>
      <w>61</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;590.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2453</x>
      <y>389</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_register
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2459</x>
      <y>385</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hub_driver</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2468</x>
      <y>385</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2489</x>
      <y>396</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2488</x>
      <y>389</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kernel_thread
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2494</x>
      <y>392</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2457</x>
      <y>392</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.()
usb_find_interface_driver</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2452</x>
      <y>400</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hub_probe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2442</x>
      <y>407</y>
      <w>36</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.集中器的子设备号(bInterfaceSubClass)要是0或者1
2.除了默认的控制端点（代码中没有），还要有一个（bNumEndpoints）
	中断(USB_ENDPOINT_XFER_INT)交互的输入(USB_DIR_IN)端点
3.申请usb_hub数据结构，并初始化
	hub = kmalloc(sizeof(*hub)
	memset(hub, 0
	INIT_LIST_HEAD(&amp;hub-&gt;event_list);
	//hub和dev关联
	hub-&gt;dev = dev
	INIT_LIST_HEAD(&amp;hub-&gt;hub_list);
	//将hub加到hub_list链表中
	list_add(&amp;hub-&gt;hub_list, &amp;hub_list);
4.通过usb_hub_configure对hub进一步初始化，其中有对中断传输
	查询状态进行初始化
5.如果成功，return hub
	如果不成功，将hub从链表中删除，并释放hub内存
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2457</x>
      <y>403</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2450</x>
      <y>436</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_configure</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2455</x>
      <y>432</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2402</x>
      <y>445</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2407</x>
      <y>439</y>
      <w>50</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hub-&gt;descriptor
HUB_DESCRIPTOR_MAX_SIZE</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2421</x>
      <y>446</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_get_hub_descriptor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2428</x>
      <y>439</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取hub描述符
放在 hub-&gt;descriptor中</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2420</x>
      <y>453</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_control_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2428</x>
      <y>449</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
USB_REQ_GET_DESCRIPTOR
USB_DIR_IN | USB_RT_HUB</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2443</x>
      <y>445</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>hub-&gt;nports = 
dev-&gt;maxchild = 
			hub-&gt;descriptor-&gt;bNbrPorts
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2450</x>
      <y>439</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2464</x>
      <y>445</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_get_hub_status</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2454</x>
      <y>439</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2462</x>
      <y>454</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_control_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2470</x>
      <y>448</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
USB_REQ_GET_STATUS
USB_DIR_IN | USB_RT_HUB</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2454</x>
      <y>439</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请中断传输</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2490</x>
      <y>444</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.获取中断传输的pipe和最大信包maxp（不能大于hub-&gt;buffer）
2.通过usb_alloc_urb为hub-&gt;urb申请urb_t
3.通过宏FILL_INT_URB填充urb结构体
4.将urb提交，申请uhci_td链入到skeltd中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2485</x>
      <y>454</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_alloc_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2490</x>
      <y>451</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2459</x>
      <y>461</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.申请urb和iso_packets个iso_packet_descriptor_t
2.初始化urb：
	memset(urb, 0, sizeof(*urb))
	spin_lock_init(&amp;urb-&gt;lock)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2473</x>
      <y>457</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2502</x>
      <y>455</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>FILL_INT_URB
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2509</x>
      <y>451</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2496</x>
      <y>461</y>
      <w>25</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>hub-&gt;urb-&gt;dev=dev;\
hub-&gt;urb-&gt;pipe=pipe;\
hub-&gt;urb-&gt;transfer_buffer=hub-&gt;buffer;\
hub-&gt;urb-&gt;transfer_buffer_length=maxp;\
hub-&gt;urb-&gt;complete=hub_irq;\
hub-&gt;urb-&gt;context=hub;\
hub-&gt;urb-&gt;interval=endpoint-&gt;bInterval;\
hub-&gt;urb-&gt;start_frame=-1;\
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2506</x>
      <y>458</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2526</x>
      <y>455</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_submit_urb
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2513</x>
      <y>451</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2523</x>
      <y>462</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>urb-&gt;dev-&gt;bus-&gt;op-&gt;submit_urb
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2532</x>
      <y>458</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果urb和urb.dev存在</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2528</x>
      <y>444</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up(&amp;khubd_wait);
usb_hub_power_on(hub);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2454</x>
      <y>439</y>
      <w>81</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;790.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2504</x>
      <y>478</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hub_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2508</x>
      <y>475</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2497</x>
      <y>481</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查集中器hub的状态</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2471</x>
      <y>485</y>
      <w>32</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果urb-&gt;status为0，表示中断交互正常完成
2.如果status显示没有文件（-ENOENT），直接退出
3.如果是其他错误，错误十次之后，记录
	hub-&gt;error = urb-&gt;status
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2511</x>
      <y>485</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果等待队列khubd_wait不为空，将hub的event_list
	加入到hub_event_list中，并唤醒khubd_wait
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2509</x>
      <y>481</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2480</x>
      <y>403</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>daemonize</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2485</x>
      <y>399</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2479</x>
      <y>410</y>
      <w>19</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>exit_mm
current-&gt;session = 1;
current-&gt;pgrp = 1;
exit_fs(current);	/* current-&gt;fs-&gt;count--; */
fs = init_task.fs;
current-&gt;fs = fs;
atomic_inc(&amp;fs-&gt;count);
exit_files(current);
current-&gt;files = init_task.files;
atomic_inc(&amp;current-&gt;files-&gt;count);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2485</x>
      <y>406</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
退出所有的用户资源</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2495</x>
      <y>404</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>strcpy(current-&gt;comm, "khubd")
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2494</x>
      <y>399</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
指定thread的名称</panel_attributes>
    <additional_attributes>20.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2518</x>
      <y>404</y>
      <w>26</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.通过usb_hub_events处理集中器
	的状态变化
2.通过interruptible_sleep_on等待
	唤醒
3.唤醒之后检测是否有信号pending
	（一般是存在的），然后再去处理
	集中器事件
注：这里先处理usb_hub_events是为了
	处理根集中器的状态
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2495</x>
      <y>399</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
do..while</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2530</x>
      <y>420</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_events</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2532</x>
      <y>418</y>
      <w>6</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2501</x>
      <y>429</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过usb_hub_reset重置集中器
2.如果出错，通过usb_hub_disconnect
	断开链接，并继续遍历下一个hub
3.重置error
	hub-&gt;nerrors = 0;
	hub-&gt;error = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2535</x>
      <y>422</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
while读取链表hub_event_list
获取链表中的usb_hub和hub对应的dev = hub-&gt;dev
并将其temp实体从链表中移除，并初始化</panel_attributes>
    <additional_attributes>10.0;20.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2517</x>
      <y>425</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hub-&gt;error
如果出错超过10次</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2535</x>
      <y>425</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历hub的所有端口
hub-&gt;nports</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2548</x>
      <y>431</y>
      <w>35</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.通过usb_get_port_status获取port的状态
2.如果port的链接状态发生了变化（USB_PORT_STAT_C_CONNECTION）
	通过usb_hub_port_connect_change进行处理
3.如果enable状态发生了变化（USB_PORT_STAT_C_ENABLE），
	通过usb_clear_port_feature将USB_RT_PORT的ENABLE改变的状态信息
	清除。
	如果此时port状态是没有enable，但是connect，并且该端口上
	有设备（dev-&gt;children[i])），需要通过usb_hub_port_connect_change
	进行处理
4.如果SUSPEND状态位发生了变化，通过usb_clear_port_feature
	将SUSPEND改变的状态清除
5.如果过流（OVERCURRENT）状态发生了变化，通过usb_clear_port_feature
	清除其改变的状态，并通过usb_hub_power_on将hub中每个port的POWER置上
6.如果RESET状态发生了变化，通过usb_clear_port_feature清除RESET改变的状态
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2535</x>
      <y>425</y>
      <w>59</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;570.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2586</x>
      <y>431</y>
      <w>27</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.通过usb_get_hub_status获取hub的状态
2.如果获取hub状态出错，直接报错
	如果成功：
		1.如果POWER状态发生了改变，通过usb_clear_hub_feature
		将其POWER状态清掉
		2.如果其OVERCURRENT状态发生了改变，通过usb_clear_hub_feature
		将其OVERCURRENT状态，并通过usb_hub_power_on将hub中每个port的POWER置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2556</x>
      <y>458</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_port_connect_change</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2566</x>
      <y>454</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2552</x>
      <y>465</y>
      <w>34</w>
      <h>54</h>
    </coordinates>
    <panel_attributes>1.通过usb_clear_port_feature将CONNECTION改变的状态
	清除
2.如果该hub当前端口有子设备（hub-&gt;children[port]）
	通过usb_disconnect将子设备断开
注：1.如果连接状态从无到有，children不可能存在，如果存在
		只有可能是之前没被清除，所以现在将其断开，之后再申请
	2.如果连接状态从有到无，需要将usb设备断开
3.如果设备现在断开了（连接状态是从有到无）
	1.如果此时端口是ENABLE的，通过usb_hub_port_disable
		将hub的该端口禁止
	2.直接return
4.（现在连接状态一定是从无到有）申请tempstr（存储之前的port路径）
	和portstr（存储总的port路径）
5.可以尝试两次去初始化port
	1.通过usb_alloc_dev申请usb_dev,parent是hub
		hub-&gt;children[port] = dev
	2.通过usb_hub_port_reset将该port reset
	3.通过usb_connect申请dev-&gt;devnum
	4.找到当前port从根集中器到当前port的port路径，存储到portstr
		并打印
	5.通过usb_new_device
		1.将dev的地址设置为dev-&gt;devnum
		2.获取设备的设备描述块和配置描述块（包括接口和endpoint）存放在内存中
		3.将configuration默认设置为0号描述符
		4.如果相应的usb驱动已经安装，会通过usb_find_drivers去初始化设备
			否则会在后续安装usb驱动的时候初始化
	6.如果usb_new_device出错了，先通过usb_free_dev将usb_dev释放，
		然后再去尝试初始化port
		如果usb_new_device成功了，将之前申请的tempstr和
		portstr释放，并返回
	7.如果两次尝试初始化都失败了：
		hub-&gt;children[port] = NULL;
		usb_hub_port_disable(hub, port)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2566</x>
      <y>461</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2570</x>
      <y>522</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_port_disable</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2570</x>
      <y>518</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2571</x>
      <y>528</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_clear_port_feature
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2579</x>
      <y>525</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
清除port的enable状态</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2546</x>
      <y>518</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2541</x>
      <y>523</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_disconnect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2608</x>
      <y>522</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_port_reset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2578</x>
      <y>518</y>
      <w>39</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2514</x>
      <y>526</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
清除actconfig中的所有interface</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2495</x>
      <y>534</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>driver-&gt;disconnect
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2501</x>
      <y>530</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2510</x>
      <y>534</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_driver_release_interface</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2514</x>
      <y>530</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2494</x>
      <y>541</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hub_disconnect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2508</x>
      <y>541</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>iface-&gt;driver = NULL;
iface-&gt;private_data = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2517</x>
      <y>537</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2499</x>
      <y>537</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hub_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2481</x>
      <y>548</y>
      <w>31</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.将hub从链表中删除，并初始化
	//从khubd的等待链表hub_event_list中删除
	list_del(&amp;hub-&gt;event_list);
	INIT_LIST_HEAD(&amp;hub-&gt;event_list);
	//从所有hub的管理链表hub_list中删除
	list_del(&amp;hub-&gt;hub_list);
	INIT_LIST_HEAD(&amp;hub-&gt;hub_list);
2.如果hub-&gt;urb存在：
	usb_unlink_urb(hub-&gt;urb);-&gt; urb-&gt;dev-&gt;bus-&gt;op-&gt;unlink_urb
	usb_free_urb(hub-&gt;urb);
	hub-&gt;urb = NULL;
3.如果设备描述块hub-&gt;descriptor存在，将其释放：
	kfree(hub-&gt;descriptor);
	hub-&gt;descriptor = NULL
4.释放hub:
	kfree(hub)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2498</x>
      <y>544</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2524</x>
      <y>526</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
递归释放掉usb_dev的所有子设备
dev-&gt;children（最多只有USB_MAXCHILDREN个）</panel_attributes>
    <additional_attributes>220.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2529</x>
      <y>532</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_disconnect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2542</x>
      <y>532</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>call_policy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2545</x>
      <y>526</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
热插拔相关</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2555</x>
      <y>532</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //将devnum在devicemap中清除
clear_bit(dev-&gt;devnum, &amp;dev-&gt;bus-&gt;devmap.devicemap);
usbdevfs_remove_device(dev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2543</x>
      <y>526</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果设备号dev-&gt;devnum存在</panel_attributes>
    <additional_attributes>30.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2567</x>
      <y>533</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_free_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2545</x>
      <y>526</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2557</x>
      <y>540</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果dev-&gt;refcnt递减至0，需要彻底释放dev：
	1.dev-&gt;bus-&gt;op-&gt;deallocate(dev)
	2.通过usb_destroy_configuration
		1.释放掉原始数据的rawdescriptors（指针数组，指针
		指向原始数据）
		2.释放掉从原始数据中提取的管理结构，config--interface--endpoint
	3.释放掉dev：
		kfree(dev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2573</x>
      <y>536</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2601</x>
      <y>529</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.设置port的reset状态
2.通过usb_hub_port_wait_reset检测port是否在delay时间
	内reset
3.如果在delay时间reset，清掉reset改变的状态信息，并return 0
	如果在delay时间内没检测到reset，将delay时间换成HUB_LONG_RESET_TIME
	之后，再去将尝试将port reset
4.如果两次都没reset，return -1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2615</x>
      <y>525</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2616</x>
      <y>540</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2606</x>
      <y>544</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_port_wait_reset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2597</x>
      <y>551</y>
      <w>42</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.等待delay的时间
2.通过usb_get_port_status获取port的状态
3.如果port的CONNECTION从有到无，返回-1
4.如果完成了reset（RESET状态没有），并且
	ENABLE置上时：
	1.dev-&gt;slow在LOW_SPEED置上时，是1，否则为0
	2.return 0
5.如果检测时间超过了2*HUB_SHORT_RESET_TIME，就换算
	成HUB_LONG_RESET_TIME继续检测是否reset
6.等到HUB_RESET_TIMEOUT时间就return -1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2615</x>
      <y>547</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2686</x>
      <y>396</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_scanner_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2691</x>
      <y>399</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
scanner_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2687</x>
      <y>403</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_register
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2692</x>
      <y>406</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.()</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2687</x>
      <y>411</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>probe_scanner</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2649</x>
      <y>420</y>
      <w>30</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.下面两种情况的其中之一满足，就是有效的dev（valid_device）：
	1.遍历scanner_device_ids数组，查看其中是否有和
	设备描述块的idVendor和idProduct一致的项
	2.用户定义的vendor和product和设备描述块中的相同
2.配置描述块的数量（bNumConfigurations）和接口的数量
	（bNumInterfaces）都要是1
3.接口中endpoint的数量（bNumEndpoints）不是2就是3个
	如果是2个，就分别是成块传输的输入和输出
	如果是3个，就分别是成块传输的输入，输出和中断传输

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2661</x>
      <y>414</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2684</x>
      <y>420</y>
      <w>36</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.找到p_scn_table中空闲的scn_usb_data指针位
注：minor的高4位指示的是usb_driver的位置
	后4位指示的是特定的usb设备的位置(就是这里在p_scn_table中的位置)
2.申请scn_usb_data，并初始化为0
	scn = kmalloc
	memset (scn, 0,
3.如果有中断传输的endpoint（have_intr），设置urb
	scn-&gt;scn_irq-&gt;dev=dev;\
	scn-&gt;scn_irq-&gt;pipe=usb_rcvintpipe(dev, have_intr);\
	scn-&gt;scn_irq-&gt;transfer_buffer=&amp;scn-&gt;button;\
	scn-&gt;scn_irq-&gt;transfer_buffer_length=1;\
	scn-&gt;scn_irq-&gt;complete=irq_scanner;\
	scn-&gt;scn_irq-&gt;context=scn;\
	scn-&gt;scn_irq-&gt;interval=250;\
	scn-&gt;scn_irq-&gt;start_frame=-1;\
4.为scanner的ouput buffer和input buffer申请内存
	scn-&gt;obuf =kmalloc(OBUF_SIZE
	scn-&gt;ibuf = kmalloc(IBUF_SIZE
5.初始化scanner：
	//分别指示成块传输的输入，成块传输的输出，中断传输的endpoint号
	scn-&gt;bulk_in_ep = have_bulk_in;
	scn-&gt;bulk_out_ep = have_bulk_out;
	scn-&gt;intr_ep = have_intr;
	scn-&gt;present = 1;
	scn-&gt;scn_dev = dev;
	//在p_scn_table中的位置
	scn-&gt;scn_minor = scn_minor;
	scn-&gt;isopen = 0;
	init_MUTEX(&amp;(scn-&gt;gen_lock))
	p_scn_table[scn_minor] = scn
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2692</x>
      <y>414</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2371</x>
      <y>612</y>
      <w>23</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>dr = kmalloc(sizeof(devrequest)
 //8位，最高位-方向，5~6--寄存器类型，是否是标准的，0~4--操作的对象
dr-&gt;requesttype = requesttype;
 //操作的类型
dr-&gt;request = request;
 //参数
dr-&gt;value = cpu_to_le16p(&amp;value);
 //设备/接口/endpoint具体的单元（“设备”的缓冲区地址寄存器）
dr-&gt;index = cpu_to_le16p(&amp;index);
	//读写缓冲区大小
dr-&gt;length = cpu_to_le16p(&amp;size)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2381</x>
      <y>608</y>
      <w>54</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请devrequest，并初始化</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2425</x>
      <y>613</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_internal_control_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2450</x>
      <y>612</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kfree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2432</x>
      <y>608</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放devrequest</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2432</x>
      <y>608</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2396</x>
      <y>620</y>
      <w>23</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>urb = usb_alloc_urb(0)
spin_lock_init(&amp;urb-&gt;lock);\
urb-&gt;dev=usb_dev;\
urb-&gt;pipe=pipe;\
urb-&gt;setup_packet=devrequest;\
urb-&gt;transfer_buffer=data;\
urb-&gt;transfer_buffer_length=len;\
urb-&gt;complete=usb_api_blocking_completion;\
urb-&gt;context=0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2405</x>
      <y>616</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请urb（reference），并初始化CONTROL_URB</panel_attributes>
    <additional_attributes>290.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2427</x>
      <y>624</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_start_wait_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2433</x>
      <y>616</y>
      <w>5</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2466</x>
      <y>618</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果出错，返回错误信息
	否则返回buffer实际长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2433</x>
      <y>616</y>
      <w>40</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2086</x>
      <y>642</y>
      <w>27</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.声明局部变量wait，wqh（等待队列）
2.
	//将等待队列放在awd中，
	awd.wakeup = &amp;wqh;
	init_waitqueue_head(&amp;wqh); 	
	current-&gt;state = TASK_INTERRUPTIBLE;
	//将wait放到等待队列中
	add_wait_queue(&amp;wqh, &amp;wait);
	//之后在中断时可通过urb找到其等待队列
	urb-&gt;context = &amp;awd
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2095</x>
      <y>627</y>
      <w>342</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>3400.0;10.0;3220.0;90.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2128</x>
      <y>643</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_submit_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2135</x>
      <y>627</y>
      <w>303</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>3010.0;10.0;2840.0;100.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2122</x>
      <y>649</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>urb-&gt;dev-&gt;bus-&gt;op-&gt;submit_urb
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2133</x>
      <y>646</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2134</x>
      <y>652</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
alloc_uhci-&gt;uhci_device_operations</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2129</x>
      <y>655</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_submit_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2079</x>
      <y>661</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.urb要存在
2.urb-&gt;dev，urb-&gt;dev-&gt;bus，
	urb-&gt;dev-&gt;bus-&gt;hcpriv（存储的是uhci）
	都要存在
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2088</x>
      <y>658</y>
      <w>49</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2105</x>
      <y>658</y>
      <w>33</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是根集中器
(usb_pipedevice(urb-&gt;pipe) == uhci-&gt;rh.devnum)
就不需要usb总线参与，
直接操作root_hub的
寄存器</panel_attributes>
    <additional_attributes>300.0;10.0;20.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2100</x>
      <y>668</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rh_submit_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2134</x>
      <y>658</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不是根集中器</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2128</x>
      <y>662</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果能找到dev和pipe相同的urb
并且不是需要串行化成块传输（USB_QUEUE_BULK）
返回ENXIO</panel_attributes>
    <additional_attributes>180.0;10.0;160.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2138</x>
      <y>665</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_find_urb_ep</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2125</x>
      <y>671</y>
      <w>38</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.取pipe的最高2位，查看是不是等时传输（usb_pipeisoc）
	如果是，返回NULL
	注：等时传输等时传输中有时间戳信息，不能造成交互夹杂（猜测）。
		等时传输有1个交互，每个交互中有2个信包（传令，数据，没有握手）。
2.通过nested_lock给urblist_lock上锁。这个上锁机制是：如果是同进程给其
	上锁，只是增加锁的count；如果是不同进程则是通过spin_lock自旋
3.遍历uhci-&gt;urb_list链表，如果传进来的urb和链表中的urb的dev和pipe
	相同，则在nested_unlock解锁之后，返回链表中的urb
4.否则在nested_unlock解锁之后，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2143</x>
      <y>668</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2153</x>
      <y>665</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_inc_dev_use
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2144</x>
      <y>662</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加urb-&gt;dev-&gt;refcnt计数</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2170</x>
      <y>665</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_alloc_urb_priv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2145</x>
      <y>662</y>
      <w>34</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2166</x>
      <y>671</y>
      <w>24</w>
      <h>17</h>
    </coordinates>
    <panel_attributes> //申请urb_priv，并初始化
urbp = kmem_cache_alloc(uhci_up_cachep
memset((void *)urbp, 0
urbp-&gt;inserttime = jiffies;
urbp-&gt;urb = urb;

INIT_LIST_HEAD(&amp;urbp-&gt;list);
INIT_LIST_HEAD(&amp;urbp-&gt;urb_queue_list);

urb-&gt;hcpriv = urbp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2177</x>
      <y>668</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2144</x>
      <y>661</y>
      <w>75</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_pipetype(urb-&gt;pipe)
查看传输的类型</panel_attributes>
    <additional_attributes>10.0;10.0;730.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2009</x>
      <y>703</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_submit_control</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2015</x>
      <y>664</y>
      <w>204</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_CONTROL</panel_attributes>
    <additional_attributes>2020.0;10.0;1770.0;270.0;10.0;390.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1994</x>
      <y>711</y>
      <w>35</w>
      <h>21</h>
    </coordinates>
    <panel_attributes> //0~7位定义交互类型（setup）,8~18定义为dev endpoint
 //后面21~31定义信包的长度
destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | USB_PID_SETUP
 //26位表示是否为低速设备，23位 1表示等待执行（TD_CTRL_ACTIVE），0表示已经执行
 //27位表示允许出错的次数（3）
status = (urb-&gt;pipe &amp; TD_CTRL_LS) | TD_CTRL_ACTIVE | (3 &lt;&lt; 27)

td = uhci_alloc_td(urb-&gt;dev)
uhci_add_td_to_urb(urb, td);
 //(7 &lt;&lt; 21)表示信包的长度是（7+1）=8字节
uhci_fill_td(td, status, destination | (7 &lt;&lt; 21),
	virt_to_bus(urb-&gt;setup_packet));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2003</x>
      <y>706</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备setup交互</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1969</x>
      <y>734</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_alloc_td</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1974</x>
      <y>731</y>
      <w>26</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1961</x>
      <y>740</y>
      <w>28</w>
      <h>24</h>
    </coordinates>
    <panel_attributes> //申请uhci_td
td = kmem_cache_alloc(uhci_td_cachep
 //bit0是1表示链接终结，bit1是1表示队列头
 //bit2是1表示纵向执行，0表示横向执行
td-&gt;link = UHCI_PTR_TERM;
td-&gt;buffer = 0;

td-&gt;frameptr = NULL;
td-&gt;nexttd = td-&gt;prevtd = NULL;
td-&gt;dev = dev;
INIT_LIST_HEAD(&amp;td-&gt;list);

 //增加dev-&gt;refcnt计数
usb_inc_dev_use(dev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1974</x>
      <y>737</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1993</x>
      <y>736</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_add_td_to_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2002</x>
      <y>730</y>
      <w>25</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这是将td挂入到链表urb_priv中，
这里是虚拟地址，以便cpu遍历
为了usb DMA设备遍历，还有一个
物理地址链表头uhci_qh
</panel_attributes>
    <additional_attributes>40.0;20.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1991</x>
      <y>744</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>td-&gt;urb = urb;
 //将td挂入到urb-&gt;hcpriv指向的urb_priv链表中
list_add_tail(&amp;td-&gt;list, &amp;urbp-&gt;list);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2000</x>
      <y>739</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2020</x>
      <y>736</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_fill_td</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2015</x>
      <y>731</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2020</x>
      <y>743</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>td-&gt;status = status;
 //destination
td-&gt;info = info;
 //setup_packet
td-&gt;buffer = buffer;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2026</x>
      <y>739</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2014</x>
      <y>706</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备数据交互</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2033</x>
      <y>711</y>
      <w>30</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.针对数据交互，更新destination和status
 //将setup清除，看其pipe的输入输出特性，看是USB_PID_IN还是USB_PID_OUT
destination ^= (USB_PID_SETUP ^ usb_packetid(urb-&gt;pipe));
 //如果urb-&gt;transfer_flags中USB_DISABLE_SPD（short packet dected）没被置上
status |= TD_CTRL_SPD
2.遍历传输数据的长度urb-&gt;transfer_buffer_length，单次交互最长信包长度是epmaxpacketout或者epmaxpacketin
	1.申请td=uhci_alloc_td(urb-&gt;dev)
	2.data0和data1信包指示连续信包：
	destination ^= 1 &lt;&lt; TD_TOKEN_TOGGLE;
	3.将td加入到urb_priv链表中，并初始化
		uhci_add_td_to_urb(urb, td);
		//长度是pktsze，buffer是urb-&gt;transfer_buffer
		uhci_fill_td(td, status, destination | ((pktsze - 1) &lt;&lt; 21),
			virt_to_bus(data));
	4.更新长度和buffer，直到传输数据完成
		data += pktsze;
		len -= pktsze;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2014</x>
      <y>706</y>
      <w>66</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备状态交互</panel_attributes>
    <additional_attributes>10.0;10.0;640.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2065</x>
      <y>711</y>
      <w>29</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.申请td = uhci_alloc_td(urb-&gt;dev);
2.清除交互的属性（destination &amp;= ~TD_PID;）
	如果数据交互是输出，或者不要求传输数据
	destination |= USB_PID_IN
	否则为：
	destination |= 1 &lt;&lt; TD_TOKEN_TOGGLE;
3.清除status中的short packet dected
	status &amp;= ~TD_CTRL_SPD
4.加入到urb_priv链表中，并初始化
	uhci_add_td_to_urb(urb, td);
	//TD_CTRL_IOC表示交互完成之后向cpu发送中断
	uhci_fill_td(td, status | TD_CTRL_IOC,
		destination | (UHCI_NULL_DATA_SIZE &lt;&lt; 21), 0)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2015</x>
      <y>706</y>
      <w>128</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将td挂入到usb总线的调度队列</panel_attributes>
    <additional_attributes>10.0;10.0;1260.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2125</x>
      <y>710</y>
      <w>38</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.通过uhci_alloc_qh申请队列头uhci_qh
2.通过uhci_insert_tds_in_qh将urbp中的td挂入到qh的链表中
	如果是低速设备(TD_CTRL_LS)，深度优先，纵向连接,通过uhci_insert_qh将其插入到skel_ls_control_qh中
	如果是高速设备，宽度优先，横向连接，通过uhci_insert_qh将其插入到skel_hs_control_qh中，并通过uhci_inc_fsbr
		使term_qh的link指向hs_qh，使总线的空闲的时候能继续执行hs_qh后面的qh
3.将qh和urbp关联，并将urb挂入到uhci链表中
	urbp-&gt;qh = qh;
	//将urb挂入到uhci-&gt;urb_list
	uhci_add_urb_list(uhci, urb);
	//表示正在处理这个urb，需要在中断中将其complete
	return -EINPROGRESS
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2094</x>
      <y>732</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_alloc_qh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2082</x>
      <y>738</y>
      <w>25</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>qh = kmem_cache_alloc(uhci_qh_cachep
qh-&gt;element = UHCI_PTR_TERM;
qh-&gt;link = UHCI_PTR_TERM;

qh-&gt;dev = dev;
qh-&gt;prevqh = qh-&gt;nextqh = NULL;

INIT_LIST_HEAD(&amp;qh-&gt;remove_list);

usb_inc_dev_use(dev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2090</x>
      <y>735</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请uhci_qh，并初始化</panel_attributes>
    <additional_attributes>100.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2113</x>
      <y>732</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_insert_tds_in_qh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2109</x>
      <y>738</y>
      <w>36</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.遍历urb-&gt;hcpriv（urbp）链表
2.如果链表是空（head == tmp）直接返回
3.将qh-&gt;element指向链表中的第一个td
	如果是低速设备将纵向连接（UHCI_PTR_DEPTH）置上
4.然后遍历链表中剩下的td用td.link指针连接到第一个td的
	链表中（qh-&gt;element）
5.最后一个td指向UHCI_PTR_TERM（表示连接的终结）
注：1.qh.element和td.link指向的都是物理地址，后4位
		是对齐的，用于指示
	2.qh-&gt;element指向一个urb的td队列，纵向连接
	 qh-&gt;link用于队列之间的连接，横向连接
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2121</x>
      <y>735</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2150</x>
      <y>732</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_insert_qh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2147</x>
      <y>738</y>
      <w>31</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.将申请的qh连接到规定的qh链表中（头插）（虚拟地址连接）
	qh-&gt;nextqh = skelqh-&gt;nextqh;
	qh-&gt;prevqh = skelqh;
	if (skelqh-&gt;nextqh)
		skelqh-&gt;nextqh-&gt;prevqh = qh;
	skelqh-&gt;nextqh = qh;
2.将申请的qh插入到规定qh的link链表中（物理地址连接）
	qh-&gt;link = skelqh-&gt;link;
	skelqh-&gt;link = virt_to_bus(qh) | UHCI_PTR_QH;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2156</x>
      <y>735</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2182</x>
      <y>732</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_inc_fsbr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2180</x>
      <y>738</y>
      <w>34</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果urb-&gt;transfer_flags的USB_NO_FSBR
	没置上，且urbp-&gt;fsbr为0时：
	urbp-&gt;fsbr=1
	如果uhci-&gt;fsbr为0（注意这里是uhci）
	uhci-&gt;fsbr++
	//term是终结的qh，现在将其指向hs_qh，在总线空闲的时候，
	//会返回到hs_qh继续执行
	uhci-&gt;skel_term_qh.link = virt_to_bus(&amp;uhci-&gt;skel_hs_control_qh) | UHCI_PTR_QH
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2186</x>
      <y>735</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2099</x>
      <y>728</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2121</x>
      <y>728</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2131</x>
      <y>728</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2132</x>
      <y>728</y>
      <w>56</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;540.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2134</x>
      <y>658</y>
      <w>359</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;3570.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2473</x>
      <y>663</y>
      <w>38</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.记录提交urb之后的返回状态
	urb-&gt;status = ret
2.如果是返回状态是-EINPROGRESS，说明urb正在被处理，
	需要中断之后提醒uhci结束，所以ret=0
	如果是其他状态，说明urb已经被处理完，或者产生一些错误
	需要将提交的urb摧毁(uhci_unlink_generic)，并
	递减对dev.rfecnt的引用 
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2463</x>
      <y>679</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_unlink_generic</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2504</x>
      <y>680</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_dec_dev_use</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2470</x>
      <y>674</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2485</x>
      <y>674</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2506</x>
      <y>687</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_free_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2511</x>
      <y>683</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
reference</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2434</x>
      <y>685</y>
      <w>13</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.urb_priv要存在
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2439</x>
      <y>682</y>
      <w>34</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2449</x>
      <y>685</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_dec_fsbr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2455</x>
      <y>682</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2435</x>
      <y>690</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果urb-&gt;transfer_flags的USB_NO_FSBR
	没置上，且urbp-&gt;fsbr为1时：
	urbp-&gt;fsbr=0
	先递减uhci-&gt;fsbr，如果uhci-&gt;fsbr为0（注意这里是uhci）
	//term是终结的qh，
	uhci-&gt;skel_term_qh.link =UHCI_PTR_TERM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2449</x>
      <y>688</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2463</x>
      <y>686</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_remove_urb_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2468</x>
      <y>682</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过nested_lock锁住
uhci-&gt;urblist_lock</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2462</x>
      <y>691</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.将urb.urb_list在uhci-&gt;urb_list
	链表中，通过list_del将urb从链表中
	删除，并初始化uhci-&gt;urb_list
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2466</x>
      <y>689</y>
      <w>6</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2486</x>
      <y>686</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_remove_qh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2470</x>
      <y>682</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果urbp-&gt;qh存在</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2477</x>
      <y>693</y>
      <w>20</w>
      <h>17</h>
    </coordinates>
    <panel_attributes> //将qh从虚拟地址链表和物理地址链表中断开
if (qh-&gt;prevqh) {
	qh-&gt;prevqh-&gt;nextqh = qh-&gt;nextqh;
	qh-&gt;prevqh-&gt;link = qh-&gt;link;
}
if (qh-&gt;nextqh)
	qh-&gt;nextqh-&gt;prevqh = qh-&gt;prevqh;
 //初始化qh链表指针
qh-&gt;prevqh = qh-&gt;nextqh = NULL;
qh-&gt;element = qh-&gt;link = UHCI_PTR_TERM;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2483</x>
      <y>689</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2498</x>
      <y>693</y>
      <w>21</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果qh在skelqh队列中(delay)	
	1.如果uhci-&gt;qh_remove_list为空
		通过uhci_set_next_interrupt将
		skel最后一个td(uhci-&gt;skel_term_td.status)
		的TD_CTRL_IOC置上，使其结束之后
		向cpu发送中断，让cpu将qh_remove_list
		链表中的qh回收
	2.通过list_add将qh.remove_list加入到
		qh_remove_list链表中（有可能usb控制器暂时
		还没出这个qh，需要放在remove_list中冷却）
2.如果不在skelqh队列中，通过uhci_free_qh
	将qh释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2492</x>
      <y>689</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2502</x>
      <y>714</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_free_qh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2508</x>
      <y>711</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2498</x>
      <y>720</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.如果qh-&gt;dev存在，通过usb_dec_dev_use递减其rfecnt
2.将qh释放给uhci_qh_cachep
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2507</x>
      <y>717</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2408</x>
      <y>638</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //释放urb
usb_free_urb(urb);
current-&gt;state = TASK_RUNNING;
 //将wait从等待队列wqh中删除
remove_wait_queue(&amp;wqh, &amp;wait);
 //返回出错信息
return status;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2416</x>
      <y>627</y>
      <w>26</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果出错（status不为0）
-EINPROGRESS已经将status转化成0
并将其存在urb-&gt;status中</panel_attributes>
    <additional_attributes>200.0;10.0;50.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2437</x>
      <y>631</y>
      <w>50</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.如果原始信息urb-&gt;status显示是EINPROGRESS，（表示urb正在被处理，需要等待）
	如果定义了timeout，通过schedule_timeout使进程休眠，到timeout时间唤醒（或者中间有其他进程唤醒）
	status和timeout记录剩余的时间
	如果原来正常返回，表示urb已经处理完，status=1
2.将进程的状态设置为running，并将wait从等待队列中删除
3.如果status为0，表示timeout时间到了，进程才被唤醒：
	//如果正常处理完成，usb将link element等物理地址清除
	//但是timeout需要通过unlink将其物理地址链表清除
	usb_unlink_urb(urb);  // remove urb safely
	status = -ETIMEDOUT;
	如果因为被处理完而被唤醒，将其原始状态返回
	status = urb-&gt;status
4.如果要求返回actual_length
	*actual_length = urb-&gt;actual_length
5.通过usb_free_urb释放urb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2435</x>
      <y>627</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2494</x>
      <y>637</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_unlink_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2486</x>
      <y>636</y>
      <w>13</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2489</x>
      <y>643</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>urb-&gt;dev-&gt;bus-&gt;op-&gt;unlink_urb
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2500</x>
      <y>640</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2500</x>
      <y>646</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uhci_device_operations</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2494</x>
      <y>649</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_unlink_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2215</x>
      <y>664</y>
      <w>11</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_BULK</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2210</x>
      <y>690</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_submit_bulk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2126</x>
      <y>698</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.要读的长度len &lt; 0，返回EINVAL
2.如果是低速设备（TD_CTRL_LS），返回EINVAL
	（因为成块传输的数据量大，可能没办法通过深度优先
	在1ms内将数据传输完成）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2152</x>
      <y>693</y>
      <w>66</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>640.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2163</x>
      <y>698</y>
      <w>39</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.destination：设备号+方向
	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe)
2.status：td传输标记+出错次数+SPD(short packer dectected)
	status = TD_CTRL_ACTIVE | (3 &lt;&lt; TD_CTRL_C_ERR_SHIFT)
	如果urb的USB_DISABLE_SPD没置上，
	status |= TD_CTRL_SPD
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2169</x>
      <y>693</y>
      <w>50</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备数据</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2205</x>
      <y>699</y>
      <w>27</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.循环准备len长度的数据交互，每个交互的最大长度
	是maxsze
	1.利用uhci_alloc_td申请交互td
	2.通过uhci_add_td_to_urb将td加入到链表urbp-&gt;list中
	3.利用uhci_fill_td填充td：
	info=destination | ((pktsze - 1) &lt;&lt; 21) |TD_TOKEN_TOGGLE(事先有翻转)
	buffer=virt_to_bus(data)
	4.更新buffer和长度
	data += pktsze;
	len -= maxsze;
	5.如果是最后一个td（len &lt;= 0）
	td-&gt;status |= TD_CTRL_IOC
	6.通过usb_dotoggle将urb-&gt;dev-&gt;toggle[out]对应的endpoint中翻转
	（之后用于TD_TOKEN_TOGGLE位）
注：利用do..while，所以即使len=0，还是有一个数据td
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2209</x>
      <y>693</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备数据交互</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2236</x>
      <y>699</y>
      <w>42</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.利用uhci_alloc_qh申请qh，并赋值给urbp
	urbp-&gt;qh = qh
2.通过uhci_insert_tds_in_qh将urbp.list中的
	td通过物理指针element link链接在qh中
3.如果该传输urb被标记为USB_QUEUE_BULK，
	并且在uhci中有和其dev和endpoint相同的
	eurb，将新添加进去的urbp标记成不是队列头
	（urbp-&gt;queued = 1），并通过uhci_append_queued_urb
	将其加入到队列中
	如果上述情况不满足，通过uhci_insert_qh将其加入到skel_bulk_qh
	后
4.通过uhci_add_urb_list将urb加入到uhci-&gt;urb_list链表中
5.通过uhci_inc_fsbr查看该urb是否需要usb总线空闲时间，如果需要
	递增uhci-&gt;fsbr，并将term_qh链接到hs_qh
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2215</x>
      <y>693</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备qh</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2249</x>
      <y>726</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_append_queued_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2257</x>
      <y>722</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2240</x>
      <y>733</y>
      <w>37</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.找到队列的队列头furbp：
	1.如果eurbp-&gt;queued=0，那么eurbp就是队列头
	2.如果queued=1，那么就顺着eurbp-&gt;urb_queue_list链表
	查找，直到找到turbp-&gt;queued为0的urbp退出（或者整个链表查找完，没找到也退出）
	注：这里tmp = tmp-&gt;next位置应该是个bug
2.通过furbp-&gt;urb_queue_list.prev找到最后一个urbp（lurbp）
3.找到lurbp的最后一个td：
	ltd= list_entry(lurbp-&gt;list.prev, struct uhci_td, list)
4.找到要插入队列urbp的第一个td：
	td = list_entry(urbp-&gt;list.next, struct uhci_td, list)
5.将ltd链接到td
	ltd-&gt;link = virt_to_bus(td)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2257</x>
      <y>729</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2216</x>
      <y>664</y>
      <w>93</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_INTERRUPT</panel_attributes>
    <additional_attributes>10.0;10.0;910.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2290</x>
      <y>685</y>
      <w>38</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果urb没被分配带宽urb-&gt;bandwidth == 0
	1.通过usb_check_bandwidth计算该交互需要的带宽
	2.如果返回错误（小于0），返回错误信息
		如果bustime正确返回，通过uhci_submit_interrupt将
		urb提交，并通过usb_claim_bandwidth将bustime申请带宽
2.如果urb已经被分配带宽，直接通过uhci_submit_interrupt将urb提交
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2283</x>
      <y>700</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_check_bandwidth</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2289</x>
      <y>695</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2280</x>
      <y>707</y>
      <w>33</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.通过usb_calc_bus_time计算该传输需要的bustime
	主要和usb_maxpacket相关。但是在计算时会考虑
	是否是低速设备，传输的方向、是否是等时传输
2.如果是等时传输，因为会将等时传输的包放在不同的框架中
	所以bustime/=number_of_packets（每个信包构成一个交互）
	如果是中断传输，就是之前计算的bustime
3.计算如果加入该urb之后的带宽：
	new_alloc=dev-&gt;bus-&gt;bandwidth_allocated+ (int)bustime
4.如果没有带宽检查，直接返回bustime；如果有，在总体带宽大于框架
	时间的90%时，会报USB_ST_BANDWIDTH_ERROR，其他情况，返回bustime
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2289</x>
      <y>703</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2340</x>
      <y>701</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_claim_bandwidth</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2317</x>
      <y>695</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2354</x>
      <y>708</y>
      <w>28</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>dev-&gt;bus-&gt;bandwidth_allocated += bustime
 //如果是等时传输
dev-&gt;bus-&gt;bandwidth_isoc_reqs++
 //如果是中断传输
dev-&gt;bus-&gt;bandwidth_int_reqs++

urb-&gt;bandwidth = bustime
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2348</x>
      <y>704</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2317</x>
      <y>703</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_submit_interrupt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2311</x>
      <y>695</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2315</x>
      <y>710</y>
      <w>33</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.要发送的长度transfer_buffer_length，
	不能大于usb_maxpacket，因为中断传输
	只有一个交互
2.准备数据
	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe);
	status = (urb-&gt;pipe &amp; TD_CTRL_LS) | TD_CTRL_ACTIVE | TD_CTRL_IOC;
3.准备td：
	td = uhci_alloc_td
	//准备TD_TOKEN_TOGGLE位，和长度
	destination |= usb_gettoggle&lt;&lt; TD_TOKEN_TOGGLE | ((urb-&gt;transfer_buffer_length - 1) &lt;&lt; 21)
	//翻转(dev)-&gt;toggle[out]
	usb_dotoggle
4.建立td的关系
	//将td加入到urbp.list
	uhci_add_td_to_urb(urb, td);
	uhci_fill_td(td, status, destination,
		virt_to_bus(urb-&gt;transfer_buffer));
	//将td的物理链表挂入到框架对应的td下
	uhci_insert_td(uhci, &amp;uhci-&gt;skeltd[__interval_to_skel(urb-&gt;interval)], td);
	//将urb挂入到uhci-&gt;urb_list链表中
	uhci_add_urb_list(uhci, urb)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2325</x>
      <y>706</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2324</x>
      <y>747</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__interval_to_skel</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2331</x>
      <y>743</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2323</x>
      <y>753</y>
      <w>16</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>interval		实际间隔		index
0~1			int1			0
2~3			int2			1
4~7			int4			2
8~15			int8			3
16~31			int16			4
32~63			int32			5
64~127		int64			6
128~255		int128		7
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2330</x>
      <y>750</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2216</x>
      <y>664</y>
      <w>183</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_ISOCHRONOUS</panel_attributes>
    <additional_attributes>10.0;10.0;1810.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2385</x>
      <y>685</y>
      <w>37</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果传输urb之前没被分配带宽（urb-&gt;bandwidth == 0）
	1.如果需要发的信包的数量（number_of_packets）小于0，返回EINVAL
	2.通过usb_check_bandwidth为等时交互分配bustime，如果出现错误，直接返回
	3.通过uhci_submit_isochronous将urb提交
	4.如果urb在框架内执行，通过usb_claim_bandwidth将urb的带宽加在总线上
2.如果之前被分配过带宽，直接使用uhci_submit_isochronous将urb提交
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2395</x>
      <y>698</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_submit_isochronous</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2403</x>
      <y>695</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2387</x>
      <y>704</y>
      <w>39</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.准备数据：
	//激活td，等时传输
	status = TD_CTRL_ACTIVE | TD_CTRL_IOS;
	//pipe 方向
	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe)
2.通过isochronous_find_start寻找等时传输的首个框架
3.要从urb-&gt;start_frame，分配number_of_packets依次到每个框架内：
	1.如果urb-&gt;iso_frame_desc[i].length为0，该框架内不分配
	2.如果该框架内需要分配交互，通过uhci_alloc_td申请td结构
	3.通过uhci_add_td_to_urb将td加入到urbp.list链表中
	4.通过uhci_fill_td填充td
		长度为urb-&gt;iso_frame_desc[i].length
		buffer为：urb-&gt;transfer_buffer + urb-&gt;iso_frame_desc[i].offset
	5.如果是最后一个td（i + 1 &gt;= urb-&gt;number_of_packets）：
		td-&gt;status |= TD_CTRL_IOC;
	6.通过uhci_insert_td_frame_list将td挂入到框架中
4.通过uhci_add_urb_list将urb挂入到uhci-&gt;urb_list中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2404</x>
      <y>701</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2376</x>
      <y>737</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>isochronous_find_start</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2383</x>
      <y>732</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2359</x>
      <y>744</y>
      <w>36</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.number_of_packets不能大于900
2.通过isochronous_find_limits查看是否有在框架内的urb
	的pipe和dev和此次交互相同，如果有，得到其结束的框架号
	并返回0；没有返回-1
3.如果要求尽快传输（transfer_flags &amp; USB_ISO_ASAP），
	如果2步返回-1，通过uhci_get_current_frame_number得到正在运行的框架号：
	urb-&gt;start_frame = (curframe + 10) % UHCI_NUMFRAMES;
	如果2步返回0：
	urb-&gt;start_frame = end
4.如果不要求尽快传输
	urb-&gt;start_frame %= UHCI_NUMFRAMES
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2376</x>
      <y>740</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2368</x>
      <y>766</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>isochronous_find_limits</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2357</x>
      <y>773</y>
      <w>35</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.遍历uhci-&gt;urb_list链表，看其中有没有和现在要操作的传输
	相同的dev，pipe，并处于EINPROGRESS（不是当前操作的传输）
	start记录第一个u-&gt;start_frame
	last_urb记录最后一个传输
2.如果有相同的urb
	*end = (last_urb-&gt;start_frame + last_urb-&gt;number_of_packets) &amp; 1023;
	ret = 0;
	否则
	ret = -1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2375</x>
      <y>762</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2374</x>
      <y>769</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2409</x>
      <y>737</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_insert_td_frame_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2401</x>
      <y>732</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2407</x>
      <y>740</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
加入到物理链表中</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2398</x>
      <y>744</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //td为链表头，所以frameptr有值
td-&gt;frameptr = &amp;uhci-&gt;fl-&gt;frame[framenum];
td-&gt;link = uhci-&gt;fl-&gt;frame[framenum];
uhci-&gt;fl-&gt;frame[framenum] = virt_to_bus(td)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2413</x>
      <y>740</y>
      <w>26</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果当前td不是该链表中的最后一个td
（不是term，或者没链接到qh）</panel_attributes>
    <additional_attributes>50.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2427</x>
      <y>743</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //获取下一个td的虚拟地址
nexttd = (struct uhci_td *)uhci_ptr_to_virt(td-&gt;link);
 //虚拟链表连接
td-&gt;nexttd = nexttd;
nexttd-&gt;prevtd = td;
 //链表头已经发生转变，所以赋值为NULL
nexttd-&gt;frameptr = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2061</x>
      <y>673</y>
      <w>47</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.如果是中断传输（PIPE_INTERRUPT）
	uhci-&gt;rh.urb = urb;
	uhci-&gt;rh.send = 1;
	uhci-&gt;rh.interval = urb-&gt;interval;
	rh_init_int_timer(urb)
	return 0
2.因为根集中器是和controller在一起，不需要通过总线usb总线访问，
	可以直接通过io地址读写相应的状态和数据.
	通过解析cmd（urb-&gt;setup_packet），数据存放在urb-&gt;transfer_buffer中，
	数据的预期长度是urb-&gt;transfer_buffer_length
3.处理完urb之后，更新actual_length,并执行urb-&gt;complete
	urb-&gt;actual_length = len;
	urb-&gt;status = stat;
	if (urb-&gt;complete)
		urb-&gt;complete(urb);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2092</x>
      <y>671</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2050</x>
      <y>679</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2044</x>
      <y>681</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rh_init_int_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2023</x>
      <y>687</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.赋值usb polling的间隔
	uhci-&gt;rh.interval = urb-&gt;interval
2.赋值timer，并添加：
	init_timer(&amp;uhci-&gt;rh.rh_int_timer);
	uhci-&gt;rh.rh_int_timer.function = rh_int_timer_do;
	uhci-&gt;rh.rh_int_timer.data = (unsigned long)urb;
	uhci-&gt;rh.rh_int_timer.expires = jiffies + (HZ * (urb-&gt;interval &lt; 30 ? 30 : urb-&gt;interval)) / 1000;
	add_timer(&amp;uhci-&gt;rh.rh_int_timer)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2043</x>
      <y>684</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1977</x>
      <y>696</y>
      <w>52</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>500.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1972</x>
      <y>700</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rh_int_timer_do</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1948</x>
      <y>707</y>
      <w>41</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.通过rh_send_irq获取port中USBPORTSC1寄存器的状态
	存储到urb-&gt;transfer_buffer中，并：
	urb-&gt;actual_length = len;
	urb-&gt;status = USB_ST_NOERROR;
	返回0
2.遍历uhci-&gt;urb_list中的urb
	1.如果urb要求做空闲时间回收（fsbr），但是却长期没得到执行
	（jiffies&lt;urbp-&gt;inserttime + IDLE_TIMEOUT）,通过
	uhci_fsbr_timeout断开其回收机制
	2.如果urb设置了timeout时间（u-&gt;timeout），并且已经timeout（jiffies&lt;u-&gt;timeout）
	将urb.transfer_flags的USB_ASYNC_UNLINK | USB_TIMEOUT_KILLED置上
	并且通过uhci_unlink_urb将urb的交互队列从框架中移除
3.	通过rh_init_int_timer重新将timer添加
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1974</x>
      <y>703</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1946</x>
      <y>732</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_fsbr_timeout</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1952</x>
      <y>729</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1939</x>
      <y>739</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过uhci_dec_fsbr将总线回收断开
2.urbp-&gt;fsbr_timeout = 1
3.遍历urbp-&gt;list中的td，将第一个TD_CTRL_ACTIVE
	的td中的TD_CTRL_IOC置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1948</x>
      <y>735</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2919</x>
      <y>387</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>amd7930_init/
init_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2919</x>
      <y>396</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>amd7930_attach</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2924</x>
      <y>390</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2915</x>
      <y>405</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_sparcaudio_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2924</x>
      <y>399</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
amd7930向上层模块sparcaudio注册
sparcaudio在sparcaudio_init中向内核注册
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2918</x>
      <y>413</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2923</x>
      <y>408</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2864</x>
      <y>423</y>
      <w>59</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.节点名name不能为NULL
2.如果传递的ops为NULL,
	1.如果是S_ISBLK，返回blkdevs[major].bdops（并打印消息）
	2.如果是其他设备，返回NULL，打印错误
3.如果是S_ISDIR，返回NULL
4.S_ISLNK，返回NULL
5.如果是S_ISCHR，并且要求自动分配设备号，next_devnum_char不能大于MAX_DEVNUM
	如果不大于：
	major = next_devnum_char &gt;&gt; 8;
	minor = next_devnum_char &amp; 0xff;
	++next_devnum_char;
6.如果是S_ISBLK，并且要求自动分配设备号，next_devnum_block不能大于MAX_DEVNUM
	如果不大于：
	major = next_devnum_block &gt;&gt; 8;
	minor = next_devnum_block &amp; 0xff;
	++next_devnum_block;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2891</x>
      <y>416</y>
      <w>34</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2927</x>
      <y>424</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>search_for_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2916</x>
      <y>416</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在devfs中找name，如果没找到就创建</panel_attributes>
    <additional_attributes>80.0;10.0;170.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2923</x>
      <y>416</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不是新创建的
!is_new</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2944</x>
      <y>424</y>
      <w>34</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.一定要是S_ISCHR  S_ISBLK  S_ISREG其中一个
2.de-&gt;registered不能为true
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2979</x>
      <y>423</y>
      <w>54</w>
      <h>52</h>
    </coordinates>
    <panel_attributes>1.de-&gt;registered = TRUE;
2.如果是S_ISCHR或者S_ISBLK
	de-&gt;u.fcb.u.device.major = major;
	de-&gt;u.fcb.u.device.minor = minor;
	如果是S_ISREG
	de-&gt;u.fcb.u.file.size = 0
3.如果是其他设备，返回NULL
4.de-&gt;info = info;
  de-&gt;mode = mode;
5.如果是指定current为owner（DEVFS_FL_CURRENT_OWNER）
	de-&gt;u.fcb.default_uid = current-&gt;uid;
	de-&gt;u.fcb.default_gid = current-&gt;gid;
	否则：
	de-&gt;u.fcb.default_uid = 0;
	de-&gt;u.fcb.default_gid = 0;
6. 
 //之前不是设置registered了吗？
	 de-&gt;registered = TRUE;
	 //设置ops
	 de-&gt;u.fcb.ops = ops;
 	de-&gt;u.fcb.auto_owner = (flags &amp; DEVFS_FL_AUTO_OWNER) ? TRUE : FALSE;
 	de-&gt;u.fcb.aopen_notify = (flags &amp; DEVFS_FL_AOPEN_NOTIFY) ? TRUE : FALSE;
7.DEVFS_FL_REMOVABLE：
	de-&gt;u.fcb.removable = TRUE;
	++de-&gt;parent-&gt;u.dir.num_removable;
8.
	de-&gt;u.fcb.open = FALSE;
    de-&gt;show_unreg = ( (boot_options &amp; OPTION_SHOW)
			|| (flags &amp; DEVFS_FL_SHOW_UNREG) ) ? TRUE : FALSE;
    de-&gt;hide = (flags &amp; DEVFS_FL_HIDE) ? TRUE : FALSE;
    de-&gt;no_persistence = (flags &amp; DEVFS_FL_NO_PERSISTENCE) ? TRUE : FALSE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2924</x>
      <y>416</y>
      <w>83</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;810.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3038</x>
      <y>423</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfsd_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2924</x>
      <y>416</y>
      <w>123</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1210.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2850</x>
      <y>530</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_select</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2839</x>
      <y>533</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取用户层的tvp</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2825</x>
      <y>541</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过verify_area验证tvp的VERIFY_READ权限
	然后通过__get_user获取用户层的tv_sec和tv_usec
2.filter:tv_sec和tv_usec不能小于0
3.将tvp的时间转化成hz（timeout）
注：ROUND_UP是如果超出了bound，就按bound算
	1s=1hz=(1000000/hz)us
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2858</x>
      <y>539</y>
      <w>39</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.n不能小于0（n表示位图的个数）
2.当n超过进程的max_fdset时：
	n = current-&gt;files-&gt;max_fdset
3.通过FDS_BYTES计算n需要size的空间（几个long型大小）
4.通过select_bits_alloc申请6个size长度的
	这6个空间分别用于
	//要求监测的输入，输出，异常
	fds.in      = (unsigned long *)  bits;
	fds.out     = (unsigned long *) (bits +   size);
	fds.ex      = (unsigned long *) (bits + 2*size);
	//因为唤醒的输入，输出，异常
	fds.res_in  = (unsigned long *) (bits + 3*size);
	fds.res_out = (unsigned long *) (bits + 4*size);
	fds.res_ex  = (unsigned long *) (bits + 5*size);
5.通过get_fd_set将要求监测的输入（inp），输出（outp）
	，异常（exp）复制到内核空间，并通过zero_fd_set将其清0
6.通过do_select对要求的文件进行监测，并等待监测结果
7.如果tvp存在，并且进程的personality STICKY_TIMEOUTS标记
	置上，timeout剩余事件转化为us，s，并将其通过put_user
	放在用户空间中
8.检查是否有错（ret&lt;0）,是否有signal_pending，直接返回
9.将fds.res_in，res_out，res_ex中的数据通过set_fd_set
	放到用户空间
10.通过select_bits_free将申请的6个size长度的bits释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2857</x>
      <y>533</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2846</x>
      <y>573</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_fd_set</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2850</x>
      <y>567</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2837</x>
      <y>579</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过FDS_BYTES获取位图的实际字节数
2.通过verify_area验证写权限
注：虽然这里是读，但是之后需要对齐进行写，
	所以这里直接验证写权限
3.通过__copy_from_user从用户层将数据复制到内核空间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2851</x>
      <y>576</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2885</x>
      <y>573</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_select
主要是申请多个wait结构（poll_table）
其他一个wait一样，都是挂在相应inode的等待队列中</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2873</x>
      <y>567</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2873</x>
      <y>580</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>max_select_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2878</x>
      <y>576</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
files-&gt;file_lock</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2865</x>
      <y>586</y>
      <w>26</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.首先获取不足long长度的mask
	set =~(~0UL &lt;&lt; (n &amp; (__NFDBITS-1)))
2.如果mask存在，获取其关心的mask
	set &amp;= BITS(fds, n);
注：BITS表示in，out，ex中关心的fd
3.如果set存在，且其关心的fd都没有关闭（!(set &amp; ~*open_fds)）
	直接去计算max
4.如果关心的fd有关的，返回EBADF
5.然后按照long去遍历低字节
	1.在这个long中存在关心的fd（set不为0）
	2.所有关心的fd都没有关闭（set &amp; ~*open_fds），否则返回EBADF
	3.如果max得到了，continue（这里去5.2检查传入数据的有效性）
6.返回max
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2877</x>
      <y>583</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从高bit向低遍历</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2893</x>
      <y>580</y>
      <w>16</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //初始化table
poll_initwait(&amp;table);
 //如果timeout存在
wait = &amp;table;
 //如果timeout为0
wait = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2890</x>
      <y>576</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2890</x>
      <y>576</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2910</x>
      <y>580</y>
      <w>42</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.将task的状态设置为TASK_INTERRUPTIBLE
2.遍历要关注的最大fd，
	1.通过bit &amp; BITS(fds, off)，检查这个fd是否关心
	2.如果改fd是其关心的，通过fget得到file：
		mask = file-&gt;f_op-&gt;poll(file, wait)
		fput(file)
	3.检查mask中POLLIN_SET，POLLOUT_SET,POLLEX_SET是否
		置上，如果置上通过ISSET检查是否关心，如果关心
		//x是__RES_IN，__RES_OUT，__RES_EX
		SET(bit, x(fds,off));
		retval++;
		wait = NULL;
3.将所有关注的fd遍历完之后，如果有关注的fd事件发生（retval）
	不需要休眠（!__timeout）或者有signal_pending，跳出死循环
4.检查table.error，如果有错，跳出死循环
5.__timeout = schedule_timeout(__timeout)
	当其因为事件发生，或者因为timeout而醒来时，因为是死循环，所以
	从1再次开始检测
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2916</x>
      <y>621</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_poll</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2916</x>
      <y>614</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;poll
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2921</x>
      <y>609</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2921</x>
      <y>617</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
read_pipe_fops</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2901</x>
      <y>614</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_poll</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2906</x>
      <y>609</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2899</x>
      <y>620</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>pt-&gt;error = 0;
pt-&gt;table = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2905</x>
      <y>617</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2904</x>
      <y>628</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>poll_wait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2908</x>
      <y>624</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
&amp;inode.i_pipe-&gt;wait</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2908</x>
      <y>631</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果poll_table和wait_queue_head_t
都存在</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2903</x>
      <y>635</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__pollwait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2875</x>
      <y>638</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果poll_table中table不存在
或者table中entry满了
（(table-&gt;entry+1) &gt; PAGE_SIZE + table）
注：table-&gt;entry指向空闲的entry，table-&gt;entry+1
	指的是空闲entry填满之后的地址</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2864</x>
      <y>644</y>
      <w>27</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.通过__get_free_page获取poll_table_page
	（new_table），并初始化
	//空闲的entry，指向第一个
	new_table-&gt;entry = new_table-&gt;entries;
	//table头插至链表中
	new_table-&gt;next = table;
	p-&gt;table = new_table;
	table = new_table;
	注：这里这个管理结构在page中，之后就全是数组entries了
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2902</x>
      <y>643</y>
      <w>32</w>
      <h>19</h>
    </coordinates>
    <panel_attributes> //获取空闲的entry
entry = table-&gt;entry;
table-&gt;entry = entry+1;
 //初始化entry
get_file(filp);
entry-&gt;filp = filp;
entry-&gt;wait_address = wait_address;
init_waitqueue_entry(&amp;entry-&gt;wait, current);//初始化wait
 //将wait插入到等待队列中
add_wait_queue(wait_address,&amp;entry-&gt;wait);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2900</x>
      <y>638</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取空闲的entry放到inode的等待队列中</panel_attributes>
    <additional_attributes>80.0;10.0;180.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2921</x>
      <y>624</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
先遍历一遍
查看是否有使进程醒着的原因</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2939</x>
      <y>630</y>
      <w>25</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.mask = POLLIN | POLLRDNORM;
1.PIPE_EMPTY（inode.i_size==0）：
	mask = POLLOUT | POLLWRNORM;
2.!(inode).i_pipe-&gt;writers
	&amp;&amp; filp-&gt;f_version !=(inode).i_pipe-&gt;w_counter
	mask |= POLLHUP;
3.! (!PIPE_READERS(*inode))
		mask |= POLLERR;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2956</x>
      <y>581</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;state = TASK_RUNNING
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2891</x>
      <y>576</y>
      <w>74</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
跳出之前，因为在死循环第一步将其状态设置为TASK_INTERRUPTIBLE</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2985</x>
      <y>581</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>poll_freewait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2892</x>
      <y>576</y>
      <w>99</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;970.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2972</x>
      <y>587</y>
      <w>36</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.遍历p-&gt;table链表
2.得到空闲的entry（p-&gt;entry）
3.然后通过do..while释放p-&gt;entries
	中的所有entry：
	entry--;
	remove_wait_queue(entry-&gt;wait_address,&amp;entry-&gt;wait);
	fput(entry-&gt;filp);
4.然后在遍历下一个table：
	old = p;
	p = p-&gt;next;
	free_page((unsigned long) old);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2989</x>
      <y>584</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3065</x>
      <y>544</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.打开文件
2.设置号SIGIO的信号响应
2.将文件与本进程（要通知的进程）关联（fcntl）
3.iocntl为file添加通知本进程的fasync
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3058</x>
      <y>559</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_fcntl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3041</x>
      <y>566</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3061</x>
      <y>567</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_fcntl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3083</x>
      <y>567</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3047</x>
      <y>562</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过fd获取file</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3065</x>
      <y>562</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放file</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3064</x>
      <y>562</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3060</x>
      <y>570</y>
      <w>10</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
F_SETOWN
设置f_owner</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3043</x>
      <y>577</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_owner.pid = arg;
filp-&gt;f_owner.uid = current-&gt;uid;
filp-&gt;f_owner.euid = current-&gt;euid;
注：inode是对磁盘的抽象
	dentry是对路径的抽象（路径+inode）
	file是对进程的抽象（进程+dentry）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3073</x>
      <y>578</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_fcntl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3067</x>
      <y>570</y>
      <w>14</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sock_fcntl</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3124</x>
      <y>559</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_mouse_event</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3132</x>
      <y>562</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
head != queue-&gt;tail
如果buffer没满</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3131</x>
      <y>566</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3126</x>
      <y>571</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kill_fasync</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3124</x>
      <y>577</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__kill_fasync</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3130</x>
      <y>574</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
&amp;queue-&gt;fasync, SIGIO, POLL_IN
fasync_lock</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3119</x>
      <y>584</y>
      <w>30</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.遍历链表，如果magic != FASYNC_MAGIC
	直接返回
2.获取file.f_owner
3.如果f_owner.pid不为0，并且不是在fown-&gt;signum == 0
	的时候发SIGURG
	通过send_sigio将信号发送
4.遍历链表的下一个
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3130</x>
      <y>580</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3129</x>
      <y>600</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>send_sigio</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3133</x>
      <y>596</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3119</x>
      <y>607</y>
      <w>30</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果pid&gt;0,通过find_task_by_pid在hash表中
	查找task，并通过send_sigio_to_task将信号发出去
2.如果pid=0（或者pid暂时没存储到hash中），遍历task链表，
	通过send_sigio_to_task发送信号
3.如果pid&lt;0，遍历task链表，查找进程组号和-pid相同的
	进程，并通过send_sigio_to_task对这些进程发送信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3133</x>
      <y>603</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tasklist_lock</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3127</x>
      <y>621</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>send_sigio_to_task</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3134</x>
      <y>617</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3069</x>
      <y>585</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.socki_lookup通过inode找到sock
2.如果sock存在，且其ops存在，调用sock_no_fcntl
3.否则返回EINVAL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3078</x>
      <y>581</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3075</x>
      <y>594</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_no_fcntl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3081</x>
      <y>591</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3067</x>
      <y>600</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.根据sock获取sk
2.如果是F_SETOWN：
	1.要满足当前进程组是-arg，或者当前进程是arg，或者当前进程有CAP_KILL权限这三个条件之一
	2.sk-&gt;proc = arg
 如果是F_GETOWN，返回sk-&gt;proc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3080</x>
      <y>597</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1680</x>
      <y>37</y>
      <w>66</w>
      <h>67</h>
    </coordinates>
    <panel_attributes>dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1532</x>
      <y>37</y>
      <w>58</w>
      <h>66</h>
    </coordinates>
    <panel_attributes>VFS
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1608</x>
      <y>37</y>
      <w>48</w>
      <h>67</h>
    </coordinates>
    <panel_attributes>file_system
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1611</x>
      <y>41</y>
      <w>40</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>do_initcalls
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1613</x>
      <y>44</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>module_init(init_ext2_fs)
(FS_REQUIRES_DEV)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1625</x>
      <y>47</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1614</x>
      <y>57</y>
      <w>35</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>module_init(init_proc_fs)
(FS_SINGLE)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1624</x>
      <y>59</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1624</x>
      <y>64</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kern_mount
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1611</x>
      <y>81</y>
      <w>40</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>filesystem_setup
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1613</x>
      <y>84</y>
      <w>35</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>init_devfs_fs
(FS_SINGLE)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1625</x>
      <y>86</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1625</x>
      <y>91</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kern_mount
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1564</x>
      <y>57</y>
      <w>49</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sys_mount</panel_attributes>
    <additional_attributes>10.0;20.0;470.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1564</x>
      <y>89</y>
      <w>49</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
do_mount
在/dev上安装devfs</panel_attributes>
    <additional_attributes>10.0;20.0;470.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1499</x>
      <y>54</y>
      <w>14</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>用户
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1500</x>
      <y>84</y>
      <w>14</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>内核
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1696</x>
      <y>45</y>
      <w>38</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>(FS_REQUIRES_DEV)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1689</x>
      <y>67</y>
      <w>50</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>(FS_SINGLE)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1707</x>
      <y>51</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>实际存在的块设备
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1636</x>
      <y>65</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_fs_type</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1637</x>
      <y>72</y>
      <w>30</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_fs_type</panel_attributes>
    <additional_attributes>10.0;210.0;280.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1664</x>
      <y>71</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建设备</panel_attributes>
    <additional_attributes>10.0;20.0;250.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1553</x>
      <y>89</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mount_devfs_fs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1513</x>
      <y>89</y>
      <w>42</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1552</x>
      <y>57</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_call
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1512</x>
      <y>58</y>
      <w>42</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1692</x>
      <y>74</y>
      <w>44</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>dev: MKDEV(UNNAMED_MAJOR, i)
sb:	get_empty_super和属性初始化
root:	type-&gt;read_super 
		proc通过proc_root新建inode和dentry，并赋值
		devfs通过root_entry新建inode和dentry，并赋值
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1616</x>
      <y>5</y>
      <w>30</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1631</x>
      <y>31</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
type-&gt;read_super </panel_attributes>
    <additional_attributes>10.0;60.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1625</x>
      <y>12</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>super
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1625</x>
      <y>20</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>root:inode
		dentry
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1564</x>
      <y>19</y>
      <w>54</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;180.0;520.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1645</x>
      <y>17</y>
      <w>68</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
procfs的read/write能转接到虚拟设备对应的read/write，所以设备驱动可以在proc中不需要有主次设备号
</panel_attributes>
    <additional_attributes>10.0;10.0;660.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1794</x>
      <y>16</y>
      <w>73</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>ext2.i_fop
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1803</x>
      <y>23</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>S_ISCHR：def_chr_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1803</x>
      <y>31</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>S_ISBLK：def_blk_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1803</x>
      <y>39</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>S_ISFIFO：def_fifo_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1803</x>
      <y>47</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>S_ISSOCK：bad_sock_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1839</x>
      <y>23</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>chrdevs[major].fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1827</x>
      <y>23</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filp-&gt;f_op替换为</panel_attributes>
    <additional_attributes>10.0;20.0;120.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1793</x>
      <y>63</y>
      <w>74</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>procfs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1802</x>
      <y>70</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>S_ISREG：proc_file_operations
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1826</x>
      <y>69</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_file_read</panel_attributes>
    <additional_attributes>10.0;30.0;130.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1826</x>
      <y>71</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_file_write</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1839</x>
      <y>68</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_proc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1839</x>
      <y>73</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>write_proc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1815</x>
      <y>73</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
可以自定义</panel_attributes>
    <additional_attributes>10.0;80.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1810</x>
      <y>81</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1792</x>
      <y>105</y>
      <w>77</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>System
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1803</x>
      <y>118</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1830</x>
      <y>128</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>def_blk_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1820</x>
      <y>121</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISBLK</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1820</x>
      <y>113</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISCHR</panel_attributes>
    <additional_attributes>10.0;50.0;160.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1848</x>
      <y>107</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de-&gt;u.fcb.ops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1835</x>
      <y>109</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
de-&gt;u.fcb.ops存在</panel_attributes>
    <additional_attributes>10.0;50.0;130.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1848</x>
      <y>115</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>chrdevs[major].fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1834</x>
      <y>113</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不存在</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1574</x>
      <y>964</y>
      <w>51</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops/inet_dgram_ops
2.6.20</panel_attributes>
    <additional_attributes>10.0;20.0;490.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1617</x>
      <y>967</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1608</x>
      <y>973</y>
      <w>30</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过ip_mc_drop_socket将多播列表删除
2.如果sk的SOCK_LINGER设置，并且进程的
	PF_EXITING没置上，设置timeout时间为
	sk_lingertime
3.sock-&gt;sk = NULL
4.sk-&gt;sk_prot-&gt;close关闭sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1621</x>
      <y>970</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1618</x>
      <y>988</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;close
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1625</x>
      <y>983</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1625</x>
      <y>991</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1619</x>
      <y>995</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_close</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1617</x>
      <y>1002</y>
      <w>33</w>
      <h>65</h>
    </coordinates>
    <panel_attributes>1.sk-&gt;shutdown = SHUTDOWN_MASK
2.如果sk的状态是TCP_LISTEN
	1.通过tcp_set_state将sk的状态设置为TCP_CLOSE
	2.通过tcp_listen_stop终止监听
	3.跳到adjudge_to_death
3.释放队列receive_queue中的所有skb，并统计没被
	读取的数据data_was_unread，最后通过sk_stream_mem_reclaim
	进行内存的回收
4.根据状态决定close的动作
	1.如果有数据没被读取data_was_unread
		tcp_set_state(sk, TCP_CLOSE);
		tcp_send_active_reset(sk, GFP_KERNEL);
	2.如果有SOCK_LINGER，但是sk_lingertime为0
		sk-&gt;sk_prot-&gt;disconnect
	3.如果tcp_close_state检查到要发fin，通过
		tcp_send_fin发送fin
5.通过sk_stream_wait_close等待fin的ack
6.adjudge_to_death：
	1.sock_orphan(sk);
		atomic_inc(sk-&gt;sk_prot-&gt;orphan_count);
	2.如果sk的状态在lock时从其他状态变为TCP_CLOSE
		跳到out，通过sock_put释放sk
	3.如果sk的状态是TCP_FIN_WAIT2
		1.如果linger2小于0，直接给peer发送rst
			tcp_set_state(sk, TCP_CLOSE);
			tcp_send_active_reset(sk, GFP_ATOMIC);
		2.如果设置了linger2
			1.通过tcp_fin_time获取close的最长等待时间
			注：最小为4rto-1/2rto
			2.如果超过了1min，通过inet_csk_reset_keepalive_timer
				修改sk_timer为timeout-1min
			3.否则通过tcp_time_wait等待timeout时间到close，最后
				跳到out，释放sk
	4.如果sk状态没到close
		1.通过sk_stream_mem_reclaim释放sk内存
		2.如果orphan_count超过限制，或者内存超过限制
			tcp_set_state(sk, TCP_CLOSE);
			tcp_send_active_reset(sk, GFP_ATOMIC);
	5.如果sk是close，通过inet_csk_destroy_sock释放sk的所有关系
	6.sock_put释放sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1625</x>
      <y>998</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1623</x>
      <y>1071</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_listen_stop</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1618</x>
      <y>1078</y>
      <w>30</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.通过tcp_delete_keepalive_timer停止timer
2.取出监听队列tp-&gt;listen_opt，并释放
3.取出接收队列accept_queue，并释放(链接建立完成，但是没accept)
4.遍历监听队列的hash表syn_table(部分链接)，通过tcp_openreq_free
	将open_req释放，最后通过kfree释放掉监听队列
5.遍历接收队列
	1.通过sk-&gt;sk_prot-&gt;disconnect将req中的sk断开连接
	2.通过sock_orphan设置sk的状态SOCK_DEAD
	3.递增sk-&gt;sk_prot-&gt;orphan_count
	4.通过inet_csk_destroy_sock断开sk和其他对象的链接
	5.通过sk_acceptq_removed递减sk_ack_backlog
	6.通过__reqsk_free释放req
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1618</x>
      <y>1098</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_delete_keepalive_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1627</x>
      <y>1095</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1618</x>
      <y>1104</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过timer_pending查看timer是否被设置
2.如果被设置通过del_timer将timer移除
3.移除后，通过__sock_put递减sk的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1624</x>
      <y>1101</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1649</x>
      <y>1098</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_orphan</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1644</x>
      <y>1095</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1646</x>
      <y>1104</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>sock_set_flag(sk, SOCK_DEAD);
	sk-&gt;sk_socket = NULL;
	sk-&gt;sk_sleep  = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1652</x>
      <y>1101</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1629</x>
      <y>1074</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1658</x>
      <y>1071</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_stream_wait_close</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1652</x>
      <y>1078</y>
      <w>27</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果需要设置睡眠时间
	1.通过DEFINE_WAIT定义wait
	2.循环等待事件
		1.通过prepare_to_wait将wait加入到sk_sleep
		并将task设置为TASK_INTERRUPTIBLE
		2.通过sk_wait_event睡眠等待sk_stream_closing
		注：sk_stream_closing中的三个状态都是在等待对方的ack
		3.知道等到signal_pending或者timeout耗尽
	3.通过finish_wait设置taskTASK_RUNNING
		并且将wait脱链
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1665</x>
      <y>1074</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1628</x>
      <y>1066</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1639</x>
      <y>1066</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>731</x>
      <y>569</y>
      <w>388</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bfs_fs_type
</panel_attributes>
    <additional_attributes>10.0;20.0;3860.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1111</x>
      <y>572</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bfs_read_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>767</x>
      <y>595</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>748</x>
      <y>599</y>
      <w>41</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.根据主次设备号设置blksize_size
2.sync_buffers等待所有的dirty bh同步，lock bh解锁
3.遍历所有的lru_list
	1.对应类型的链表要存在
	2.设备要相同，size不同时才会处理
	3.如果被locked，通过wait_on_buffer等待解锁
	4.如果bh.b_count为0，
		1.buffer_dirty时，警告
		2.remove_inode_queue将bh从inode的i_dirty_buffers中移出
		3.__remove_from_queues将bh从对应的lru中移除
		4.put_last_free将bh放到free_list中
	5.如果还有引用
		1.通过atomic_set_buffer_clean将bh的BH_Dirty清掉
		2.如果之前是BH_Dirty，通过__refile_buffer调整bh在lru中的位置
		3.通过clear_bit将BH_Uptodate清掉
	6.如果之前遍历，有bh locked，重新循环
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>743</x>
      <y>630</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>731</x>
      <y>637</y>
      <w>34</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.遍历lru_list[BUF_DIRTY]
	1.要遍历两遍
	2.bh.dev的设备要相同
	3.如果bh被locked
		1.如果wait为0，不做处理
		2.如果wait为1，第一次pass不做处理
		3.如果需要处理，通过wait_on_buffer等待bh解锁
			解锁之后重新遍历
	4.如果解锁的bh没有uptodate，返回EIO，并不做处理
	5.如果bh没有dirty，或者pass过2次，不做处理
	6.通过ll_rw_block提交写请求
	7.重复遍历dirty lru
2.遍历lru_list[BUF_LOCKED]
	1.如果没有locked，直接退出同步
	2.要遍历两遍
	3.bh.dev的设备要相同
	4.如果bh被locked
		1.如果wait为0，不做处理
		2.如果wait为1，第一次pass不做处理
		3.如果需要处理，通过wait_on_buffer等待bh解锁
			解锁之后重新遍历
3.retry表示之前有被pending的lock，需要重新遍历
	pass表示除了pending的没有dirty和lock的，不能超过两次
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>749</x>
      <y>633</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>775</x>
      <y>631</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_inode_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>781</x>
      <y>634</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>770</x>
      <y>638</y>
      <w>34</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.如果bh.inode有指定
	1.通过__remove_inode_queue将其从其链表中删除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>776</x>
      <y>645</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__remove_inode_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>783</x>
      <y>641</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>768</x>
      <y>652</y>
      <w>30</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.bh-&gt;b_inode = NULL
2.将b_inode_buffers从i_dirty_buffers中脱链
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>783</x>
      <y>648</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>813</x>
      <y>630</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__remove_from_queues</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>807</x>
      <y>637</y>
      <w>39</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.通过__hash_unlink将bh从hash表中删除(b_next,b_pprev)
2.__remove_from_lru_list从lru链表中删除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>823</x>
      <y>633</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>818</x>
      <y>644</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__remove_from_lru_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>826</x>
      <y>640</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>807</x>
      <y>651</y>
      <w>33</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.脱离环形链表
	bh-&gt;b_prev_free-&gt;b_next_free = bh-&gt;b_next_free;
	bh-&gt;b_next_free-&gt;b_prev_free = bh-&gt;b_prev_free;
2.lru链表指向下一个
	lru_list[blist] = bh-&gt;b_next_free;
	nr_buffers_type[blist]--;
	size_buffers_type[blist] -= bh-&gt;b_size;
3.bh-&gt;b_next_free = bh-&gt;b_prev_free = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>827</x>
      <y>647</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>855</x>
      <y>629</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_last_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>848</x>
      <y>636</y>
      <w>27</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.释放bh
	bh-&gt;b_state = 0
	bh-&gt;b_dev = B_FREE
2.链入到free_list
	*bhp = bh;
	bh-&gt;b_prev_free = bh;
	和环形链表
	bh-&gt;b_next_free = *bhp;
	bh-&gt;b_prev_free = (*bhp)-&gt;b_prev_free;
	(*bhp)-&gt;b_prev_free-&gt;b_next_free = bh;
	(*bhp)-&gt;b_prev_free = bh;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>861</x>
      <y>632</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>748</x>
      <y>625</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>767</x>
      <y>625</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>775</x>
      <y>625</y>
      <w>45</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>777</x>
      <y>625</y>
      <w>83</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;810.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1105</x>
      <y>579</y>
      <w>34</w>
      <h>76</h>
    </coordinates>
    <panel_attributes>1.初始化block size
	dev = s-&gt;s_dev;
	set_blocksize(dev, BFS_BSIZE);
	s-&gt;s_blocksize = BFS_BSIZE;
	s-&gt;s_blocksize_bits = BFS_BSIZE_BITS;
2.通过bread获取第0个block
3.s_magic得是BFS_MAGIC
4.初始化sb
	s-&gt;s_magic = BFS_MAGIC;
	s-&gt;su_bfs_sb = bfs_sb;
	s-&gt;su_sbh = bh;
	//last inode num
	s-&gt;su_lasti = (bfs_sb-&gt;s_start - BFS_BSIZE)/sizeof(struct bfs_inode) 
			+ BFS_ROOT_INO - 1
	//申请inode位图
	s-&gt;su_imap = kmalloc(imap_len, GFP_KERNEL);
	memset(s-&gt;su_imap, 0, imap_len);
	for (i=0; i&lt;BFS_ROOT_INO; i++) 
		set_bit(i, s-&gt;su_imap);
	//操作方法
	s-&gt;s_op = &amp;bfs_sops;
	//block数量
	s-&gt;su_blocks = (bfs_sb-&gt;s_end + 1)&gt;&gt;BFS_BSIZE_BITS; /* for statfs(2) */
	//free block的数量（除去sb，inode）
	s-&gt;su_freeb = (bfs_sb-&gt;s_end + 1 - bfs_sb-&gt;s_start)&gt;&gt;BFS_BSIZE_BITS;
	s-&gt;su_freei = 0;
	s-&gt;su_lf_eblk = 0;
	s-&gt;su_lf_sblk = 0;
	s-&gt;su_lf_ioff = 0;
5.通过iget获取root_inode，并申请root
	s-&gt;s_root = d_alloc_root(inode)
6.通过iget获取所有的inode
	1.如果inode号为0
		s-&gt;su_freei++;
	2.如果inode被占用
		1.置位图
			set_bit(i, s-&gt;su_imap);
			s-&gt;su_freeb -= inode-&gt;i_blocks;
		2.sb记录最大的eblock
			s-&gt;su_lf_eblk = inode-&gt;iu_eblock;
			s-&gt;su_lf_sblk = inode-&gt;iu_sblock;
			//最大使用inode的偏移
			s-&gt;su_lf_ioff = BFS_INO2OFF(i);
7.如果不是read_only，因为更改了sb
	1.mark_buffer_dirty将sb的bh置上dirty
	2.s-&gt;s_dirt = 1
8.返回sb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1117</x>
      <y>575</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1093</x>
      <y>231</y>
      <w>198</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bfs_sops</panel_attributes>
    <additional_attributes>10.0;10.0;1960.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1283</x>
      <y>234</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bfs_read_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1269</x>
      <y>241</y>
      <w>40</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>1.inode号要在BFS_ROOT_INO~su_lasti
2.获取inode所在的block号，通过bread读取block
3.算出inode在block中的偏移
	off = (ino - BFS_ROOT_INO) % BFS_INODES_PER_BLOCK;
	di = (struct bfs_inode *)bh-&gt;b_data + off;
4.初始化inode
	1.inode-&gt;i_mode = 0x0000FFFF &amp; di-&gt;i_mode;
	2.如果是BFS_VDIR
		inode-&gt;i_mode |= S_IFDIR;
		inode-&gt;i_op = &amp;bfs_dir_inops;
		inode-&gt;i_fop = &amp;bfs_dir_operations;
	3.如果是BFS_VREG
		inode-&gt;i_mode |= S_IFREG;
		inode-&gt;i_op = &amp;bfs_file_inops;
		inode-&gt;i_fop = &amp;bfs_file_operations;
		inode-&gt;i_mapping-&gt;a_ops = &amp;bfs_aops;
	4.inode-&gt;i_uid = di-&gt;i_uid;
		inode-&gt;i_gid = di-&gt;i_gid;
		inode-&gt;i_nlink = di-&gt;i_nlink;
		inode-&gt;i_size = BFS_FILESIZE(di);
		inode-&gt;i_blocks = BFS_FILEBLOCKS(di);
		inode-&gt;i_blksize = PAGE_SIZE;
		inode-&gt;i_atime = di-&gt;i_atime;
		inode-&gt;i_mtime = di-&gt;i_mtime;
		inode-&gt;i_ctime = di-&gt;i_ctime;
		inode-&gt;iu_dsk_ino = di-&gt;i_ino;
		inode-&gt;iu_sblock = di-&gt;i_sblock;
		inode-&gt;iu_eblock = di-&gt;i_eblock;
5.brelse释放bh
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1289</x>
      <y>237</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1099</x>
      <y>120</y>
      <w>196</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bfs_read_inode
bfs_dir_inops</panel_attributes>
    <additional_attributes>10.0;10.0;1940.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1286</x>
      <y>134</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bfs_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1273</x>
      <y>141</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.名字长度不能超过BFS_NAMELEN
2.bfs_find_entry寻找dir所在的inode num
3.如果找到了inode，通过iget获取inode
4.d_add将inode和dentry关联
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1291</x>
      <y>137</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1281</x>
      <y>152</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bfs_find_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1270</x>
      <y>159</y>
      <w>44</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.文件的名字长度不能超过BFS_NAMELEN
2.从iu_sblock开始读取block
	1.如果之前没读取过block，通过bread读取，如果没获取到bh，遍历下一个block
	2.遍历该block中所有的bfs_dirent(长度是BFS_DIRENT_SIZE)
		通过bfs_namecmp对比name，如果相同即返回
			*res_dir = de;
			return bh;
	3.如果block没遍历完，继续遍历下一个bfs_dirent
	4.否则，遍历下一个block
		brelse(bh);
		bh = NULL;
		offset = 0;
		block++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1286</x>
      <y>155</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1286</x>
      <y>148</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>416</x>
      <y>2242</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>367</x>
      <y>2252</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_scan_one_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>434</x>
      <y>2252</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>376</x>
      <y>2245</y>
      <w>48</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>390</x>
      <y>2253</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__btrfs_open_devices</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>398</x>
      <y>2245</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>382</x>
      <y>2260</y>
      <w>38</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.遍历fs_devices-&gt;devices
	1.bdev不能存在
	2.name要存在
	3.btrfs_get_bdev_and_sb打开设备，并读取sb
	4.比较sb中的devid，uuid，
	5.选取generation最大的device
	6.设置device.writeable
	7.查看QUEUE_FLAG_DISCARD，设置device-&gt;can_discard
	8.device-&gt;bdev = bdev;
		device-&gt;in_fs_metadata = 0;
		device-&gt;mode = flags;
	9.查看QUEUE_FLAG_NONROT，设置fs_devices-&gt;rotating
	10.fs_devices-&gt;open_devices++;
	11.writeable  &amp;&amp;   BTRFS_DEV_REPLACE_DEVID
		fs_devices-&gt;rw_devices++;
		device加入到fs_devices-&gt;alloc_list
2.fs_devices-&gt;seeding = seeding;
	fs_devices-&gt;opened = 1;
	fs_devices-&gt;latest_bdev = latest_dev-&gt;bdev;
	fs_devices-&gt;total_rw_bytes = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>397</x>
      <y>2256</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>381</x>
      <y>2297</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_get_bdev_and_sb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>371</x>
      <y>2304</y>
      <w>34</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.通过blkdev_get_by_path获取并打开bdev
2.如果flush置上，通过filemap_write_and_wait刷写等待
3.set_blocksize设置block_size是4096
4.invalidate_bdev无效化buffer
5.btrfs_read_dev_super读取sb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>388</x>
      <y>2300</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>367</x>
      <y>2316</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_get_by_path</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>357</x>
      <y>2323</y>
      <w>35</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.通过lookup_bdev通过dev_path获取bdev
2.blkdev_get打开bdev
3.如果bdev是readonly，但是需要write，blkdev_put
	将其释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>373</x>
      <y>2319</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>342</x>
      <y>2335</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_bdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>336</x>
      <y>2341</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.pathname要存在
2.通过kern_path查找path
3.inode要是ISBLK
	mnt_flags的MNT_NODEV不能置上
4.通过bd_acquire获取bdev，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>343</x>
      <y>2354</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bd_acquire</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>332</x>
      <y>2361</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果inode-&gt;i_bdev存在，直接返回
2.bdget通过设备号i_rdev获取bdev
3.如果找到
	1.inode-&gt;i_bdev = bdev;
	inode-&gt;i_mapping = bdev-&gt;bd_inode-&gt;i_mapping;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>348</x>
      <y>2357</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>341</x>
      <y>2374</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>346</x>
      <y>2370</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>328</x>
      <y>2382</y>
      <w>39</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.通过iget5_locked查找或者创建inode
2.如果inode的状态是I_NEW，设置bdev_inode.bdev
	1.bdev-&gt;bd_contains = NULL;
	bdev-&gt;bd_super = NULL;
	bdev-&gt;bd_inode = inode;
	bdev-&gt;bd_block_size = (1 &lt;&lt; inode-&gt;i_blkbits);
	bdev-&gt;bd_part_count = 0;
	bdev-&gt;bd_invalidated = 0;
	inode-&gt;i_mode = S_IFBLK;
	inode-&gt;i_rdev = dev;
	inode-&gt;i_bdev = bdev;
	inode-&gt;i_data.a_ops = &amp;def_blk_aops;
	2.将i_data的GFP_USER置上
	3.将bdev加入到链表all_bdevs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>327</x>
      <y>2408</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iget5_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>317</x>
      <y>2415</y>
      <w>36</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.通过find_inode在inode_hashtable中找到inode
2.如果找到inode，通过wait_on_inode等待inode变成__I_NEW
	后返回
3.通过alloc_inode分配inode
4.如果找到
	1.通过find_inode再次在hash表中查找
		1.如果没找到，(bdev_set)设置bdev的设备号
		2.inode-&gt;i_state = I_NEW;
		3.hlist_add_head将inode挂入到hash表
		4.inode_sb_list_add将inode和sb关联
		5.返回inode
	2.如果找到
		1.通过destroy_inode摧毁新申请的inode
		2.返回old
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>332</x>
      <y>2404</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
blockdev_superblock
bdev_test</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>316</x>
      <y>2442</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>306</x>
      <y>2449</y>
      <w>34</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.遍历hash表
	1.找到sb相同的inode
	2.test(bdev_test)检查设备号是否相同
	3.如果inode的状态在I_FREEING或者I_WILL_FREE
		通过__wait_on_freeing_inode等待变成__I_NEW
		然后再次查找hash
	4.找到即返回inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>321</x>
      <y>2438</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>320</x>
      <y>2445</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>332</x>
      <y>2411</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>346</x>
      <y>2377</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>348</x>
      <y>2338</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>347</x>
      <y>2350</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>376</x>
      <y>2335</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>369</x>
      <y>2342</y>
      <w>28</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.通过bd_start_claiming等待claiming
2.__blkdev_get打开bdev
3.如果有whole
	1.如果bdev正确打开
		whole-&gt;bd_holders++;
		whole-&gt;bd_holder = bd_may_claim;
		bdev-&gt;bd_holders++;
		bdev-&gt;bd_holder = holder
	2.whole-&gt;bd_claiming = NULL;
	3.wake_up_bit唤醒bd_claiming为0的
	4.如果
		bdev-&gt;bd_write_holder = true;
		disk_block_events(disk);
	5.bdput释放whole	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>376</x>
      <y>2371</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bd_start_claiming</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>370</x>
      <y>2379</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.通过get_gendisk获取disk
2.如果有partno，通过disk--&gt;part--&gt;dev--&gt;bdev
	否则直接获取bdev
3.bd_prepare_to_claim等待whole.bd_claiming变0
	whole-&gt;bd_claiming = holder
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>382</x>
      <y>2391</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_gendisk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>373</x>
      <y>2397</y>
      <w>34</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果主设备号不是BLOCK_EXT_MAJOR
	1.kobj_lookup在bdev_map中查找
	2.kobj--&gt;dev--&gt;gendisk
2.如果主设备号是BLOCK_EXT_MAJOR
	1.idr_find在ext_devt_idr获取part
	2.part--&gt;disk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>369</x>
      <y>2412</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kobj_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>360</x>
      <y>2419</y>
      <w>33</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.根据主设备号，遍历对应的bucket
	1.设备号要在dev~dev+range-1
	2.找到range最小的best
	3.try_module_get获取probe
	4.p-&gt;lock要能成功
	5.执行p-&gt;get
	6.index返回的是设备号在bucket的偏移
	7.返回kobj
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>375</x>
      <y>2415</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>399</x>
      <y>2412</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>idr_find</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>394</x>
      <y>2418</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果idr-&gt;hint的prefix相同，找到hint-&gt;ary[后缀]
2.idr_find_slowpath
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>406</x>
      <y>2415</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>374</x>
      <y>2407</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>390</x>
      <y>2407</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>387</x>
      <y>2394</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>387</x>
      <y>2387</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>381</x>
      <y>2374</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>417</x>
      <y>2371</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__blkdev_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>411</x>
      <y>2377</y>
      <w>38</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>1.devcgroup_inode_permission
2.get_gendisk获取disk
3.如果bd_openers不存在
	1.bdev-&gt;bd_disk = disk;
		bdev-&gt;bd_queue = disk-&gt;queue;
		bdev-&gt;bd_contains = bdev;
		bdev-&gt;bd_inode-&gt;i_flags 
	2.如果partno为0
		1.设置bdev-&gt;bd_part
		2.disk-&gt;fops-&gt;open
		3.bd_set_size设置size
		4.如果存在bdev-&gt;bd_invalidated
	3.如果不为0
		1.__blkdev_get递归调用
		2.bdev-&gt;bd_contains = whole;
			bdev-&gt;bd_part = disk_get_part
		3.bd_set_size设置size
		4.
4.如果有bd_openers
	1. bdev-&gt;bd_disk-&gt;fops-&gt;open
	2.如果有bdev-&gt;bd_invalidated
	3.
5.bdev-&gt;bd_openers++
6.如果设置了for_part
	bdev-&gt;bd_part_count++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>425</x>
      <y>2420</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bd_set_size</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>425</x>
      <y>2426</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.设置bdev-&gt;bd_inode.i_size
2.bdev-&gt;bd_block_size = bsize;
	bdev-&gt;bd_inode-&gt;i_blkbits = blksize_bits(bsize)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>431</x>
      <y>2423</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>421</x>
      <y>2374</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>430</x>
      <y>2417</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>380</x>
      <y>2365</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>384</x>
      <y>2365</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>381</x>
      <y>2338</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>347</x>
      <y>2331</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>370</x>
      <y>2331</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>401</x>
      <y>2317</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_blocksize</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>398</x>
      <y>2324</y>
      <w>27</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.size要在512~page，并且是2的倍数
2.size不能小于bdev_logical_block_size
3.如果bd_block_size发生改变
	1.sync_blockdev进行同步
	2.bdev-&gt;bd_block_size = size;
		bdev-&gt;bd_inode-&gt;i_blkbits = blksize_bits
	3.kill_bdev将bdev的buffer同步
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>407</x>
      <y>2320</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>372</x>
      <y>2312</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>392</x>
      <y>2312</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>435</x>
      <y>2316</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_read_dev_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>397</x>
      <y>2312</y>
      <w>46</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>428</x>
      <y>2323</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过btrfs_read_dev_one_super读取超级块
2.选取generation最大的sb(但是这里的i是1)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>443</x>
      <y>2319</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>432</x>
      <y>2332</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_read_dev_one_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>425</x>
      <y>2339</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.btrfs_sb_offset计算sb的偏移
2.其长度不能超过bdev-&gt;bd_inode.i_size
3.__bread读取超级块
4.检查sb的偏移和magic
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>440</x>
      <y>2335</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>440</x>
      <y>2328</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>388</x>
      <y>2292</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>423</x>
      <y>2245</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_test_super
btrfs_set_super</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>424</x>
      <y>2259</y>
      <w>33</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.遍历fs_type.fs_supers链表
	1.test(btrfs_test_super)检查到fs_devices相同
	2.grab_super检查到MS_BORN，并且s_active置上
	3.如果之前找到s，通过destroy_super将其释放
	4.返回old
2.如果没找到s
	1.通过alloc_super申请，并初始化sb
	2.申请到之后，跳到1，看是否能找到
3.set(btrfs_set_super)设置s-&gt;s_fs_info
4.和filesystem_type关联
	s-&gt;s_type = type
	s-&gt;s_id=type-&gt;name
	s-&gt;s_instances加入到链表type-&gt;fs_supers
	s-&gt;s_list加入到链表super_blocks
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>438</x>
      <y>2255</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>467</x>
      <y>2253</y>
      <w>33</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果存在s-&gt;s_root
	1.通过btrfs_close_devices关闭fs_devices和fs_devices-&gt;seed
	2.free_fs_info释放fs_info
	3.MS_RDONLY标记要一样
2.如果不存在
	1.s-&gt;s_id= bdevname(bdev, b)
	2.sb-&gt;s_fs_info.bdev_holder=fs_type
	3.btrfs_fill_super填充sb
3.返回s-&gt;s_root
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>423</x>
      <y>2245</y>
      <w>55</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;530.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>477</x>
      <y>2272</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_fill_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>482</x>
      <y>2268</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>465</x>
      <y>2279</y>
      <w>40</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.sb-&gt;s_maxbytes = MAX_LFS_FILESIZE;
	sb-&gt;s_magic = BTRFS_SUPER_MAGIC;
	sb-&gt;s_op = &amp;btrfs_super_ops;
	sb-&gt;s_d_op = &amp;btrfs_dentry_operations;
	sb-&gt;s_export_op = &amp;btrfs_export_ops;
	sb-&gt;s_xattr = btrfs_xattr_handlers;
	sb-&gt;s_time_gran = 1;
	sb-&gt;s_flags |= MS_POSIXACL;
	sb-&gt;s_flags |= MS_I_VERSION;
	sb-&gt;s_iflags |= SB_I_CGROUPWB;
2.open_ctree
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>482</x>
      <y>2275</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>556</x>
      <y>2308</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>open_ctree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>483</x>
      <y>2317</y>
      <w>37</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.申请fs_info-&gt;tree_root和fs_info-&gt;chunk_root
	root-&gt;fs_info = fs_info
2.init_srcu_struct初始化fs_info-&gt;subvol_srcu
3.setup_bdi初始化fs_info-&gt;bdi
4.percpu_counter_init初始化dirty_metadata_bytes
	delalloc_bytes bio_counter
5.设置dirty_metadata_batch
6.设置fs_info-&gt;btree_inode
7.初始化fs_info
	fs_info-&gt;sb = sb;
8.sb-&gt;s_blocksize = 4096;
	sb-&gt;s_blocksize_bits = blksize_bits(4096);
	sb-&gt;s_bdi = &amp;fs_info-&gt;bdi;
9.btrfs_init_btree_inode初始化fs_info-&gt;btree_inode
	1.extent_io_tree_init通过btree_inode-&gt;i_mapping初始化freed_extents
10.btrfs_alloc_stripe_hash_table
11.__setup_root设置tree_root
12.btrfs_read_dev_super读取sb，并根据sb设置fs_info-&gt;super_copy
	super_for_commit
	1.fs_info-&gt;fsid=fs_info-&gt;super_copy-&gt;fsid
	2.btrfs_check_super_valid检查sb
	3.btrfs_super_root要存在
	4.btrfs_super_flags设置fs_state error
	5.find_oldest_super_backup设置backup_root_index
	6.fs_info-&gt;compress_type = BTRFS_COMPRESS_ZLIB
13.btrfs_parse_options根据options设置tree_root
14.设置dirty_metadata_batch delalloc_batch
15.btrfs_init_workqueues设置fs_info
16.设置fs_info-&gt;bdi.ra_pages
17.tree_root-&gt;nodesize = nodesize;
	tree_root-&gt;sectorsize = sectorsize;
	tree_root-&gt;stripesize = stripesize
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>494</x>
      <y>2311</y>
      <w>70</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>680.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>458</x>
      <y>2359</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_bdi</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>462</x>
      <y>2352</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>440</x>
      <y>2366</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdi_setup_and_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>449</x>
      <y>2362</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>461</x>
      <y>2367</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>bdi-&gt;ra_pages = VM_MAX_READAHEAD * 1024 / PAGE_CACHE_SIZE;
	bdi-&gt;congested_fn	= btrfs_congested_fn;
	bdi-&gt;congested_data	= info;
	bdi-&gt;capabilities |= BDI_CAP_CGROUP_WRITEBACK
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>463</x>
      <y>2362</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>496</x>
      <y>2360</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>new_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>501</x>
      <y>2352</y>
      <w>12</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>492</x>
      <y>2367</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.通过new_inode_pseudo申请inode
2.inode_sb_list_add将inode挂入到inode-&gt;i_sb-&gt;s_inodes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>501</x>
      <y>2363</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>499</x>
      <y>2375</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>new_inode_pseudo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>505</x>
      <y>2371</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>505</x>
      <y>2378</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>501</x>
      <y>2382</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>475</x>
      <y>2407</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;alloc_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>505</x>
      <y>2385</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>480</x>
      <y>2410</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_super_ops</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>476</x>
      <y>2413</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_alloc_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>536</x>
      <y>2359</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_init_btree_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>514</x>
      <y>2352</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>528</x>
      <y>2366</y>
      <w>39</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.fs_info-&gt;btree_inode-&gt;i_ino = BTRFS_BTREE_INODE_OBJECTID
	fs_info-&gt;btree_inode.__i_nlink=1
	fs_info-&gt;btree_inode-&gt;i_size = OFFSET_MAX;
	fs_info-&gt;btree_inode-&gt;i_mapping-&gt;a_ops = &amp;btree_aops;
2.btrfs_inode.io_tree
	btrfs_inode.extent_tree
	btrfs_inode.io_tree.ops = &amp;btree_extent_io_ops
3.btrfs_inode.root = tree_root
4.fs_info-&gt;btree_inode挂入到inode_hashtable
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>543</x>
      <y>2362</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>572</x>
      <y>2358</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_read_sys_array</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>568</x>
      <y>2365</y>
      <w>38</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.btrfs_find_create_tree_block查找并创建eb以及其中的page
2.btrfs_set_buffer_uptodate设置eb的所有page uptodate
3.btrfs_set_buffer_lockdep_class
4.如果page超过了block的长度，将sb-&gt;pages[0]设置为uptodate
5.write_extent_buffer将sb写入到eb中
6.遍历sys_chunk_array
	1.以btrfs_disk_key解析(disk_key+ btrfs_chunk + (n-1)*btrfs_stripe)
	2.如果超过了array_size，跳到out_short_read
	3.btrfs_disk_key_to_cpu设置key
	4.如果是BTRFS_CHUNK_ITEM_KEY
		1.长度不能超过array_size
		2.read_one_chunk读取chunk加入到mapping_tree中
7.free_extent_buffer将sb释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>579</x>
      <y>2361</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>554</x>
      <y>2390</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_find_create_tree_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>554</x>
      <y>2396</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>549</x>
      <y>2403</y>
      <w>31</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>1.find_extent_buffer在buffer_radix中看是否能找到eb
	如果找到，直接返回eb
	如果找不到，通过__alloc_extent_buffer申请eb
2.遍历eb的所有page
	1.通过find_or_create_page获取eb的page
	注：mapping指向btree_inode
	2.如果PagePrivate
		1.如果p-&gt;private.refs是0
			1.释放p
			2.将exists中除了p之外的page设置为access
			3.跳到free_eb
	3.ClearPagePrivate，并释放p
	4.attach_extent_buffer_page设置p的eb
		eb-&gt;pages[i] = p
	5.如果有存在!PageUptodate
		uptodate=0
3.如果uptodate置上，将eb的EXTENT_BUFFER_UPTODATE置上
4.通过radix_tree_insert将eb插入到fs_info-&gt;buffer_radix
5.如果返回EEXIST，通过find_extent_buffer再次查找eb，
	如果找到，跳到free_eb，如果没找到，跳到4重新插入eb
6.通过check_buffer_tree_ref检查eb.refs
7.设置eb的EXTENT_BUFFER_IN_TREE
8.将eb的page[0]的PageChecked置上，将其他page 通过PageChecked
	清掉
9.返回eb
10.free_eb
	1.解锁eb所有的page
	2.btrfs_release_extent_buffer释放eb和page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>498</x>
      <y>2451</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>490</x>
      <y>2473</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>radix_tree_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>490</x>
      <y>2480</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__radix_tree_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>494</x>
      <y>2468</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fs_info-&gt;buffer_radix</panel_attributes>
    <additional_attributes>90.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>481</x>
      <y>2487</y>
      <w>37</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.如果root-&gt;rnode为NULL,返回NULL
2.如果node是direct(指针最低位不为1)
	1.如果index&gt;0，返回NULL
	2.如果存在slotp，返回&amp;root-&gt;rnode
	3.返回node
3.将node最低位的1清掉，成为指针
4.index超过了maxindex(由height(path)转化)，返回NULL
5.递归遍历height次node-&gt;slots，返回node
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>497</x>
      <y>2483</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>497</x>
      <y>2476</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>492</x>
      <y>2458</y>
      <w>36</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.radix_tree_lookup在fs_info-&gt;buffer_radix找eb
2.如果找到，并且索引eb-&gt;refs不为0
	1.eb-&gt;refs++
	2.如果eb在EXTENT_BUFFER_STALE，试图上锁
	3.mark_extent_buffer_accessed将eb中的page reference
3.返回eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>520</x>
      <y>2473</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_extent_buffer_accessed</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>518</x>
      <y>2468</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>524</x>
      <y>2486</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>check_buffer_tree_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>522</x>
      <y>2492</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果eb-&gt;refs大于2，并且EXTENT_BUFFER_TREE_REF，直接返回
2.如果不在EXTENT_BUFFER_TREE_REF
	1.置上EXTENT_BUFFER_TREE_REF
	2.递增eb-&gt;refs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>531</x>
      <y>2489</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>520</x>
      <y>2478</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.check_buffer_tree_ref检查ref
2.将数组eb-&gt;pages中的page mark_page_accessed
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>530</x>
      <y>2482</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>504</x>
      <y>2454</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>547</x>
      <y>2453</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__alloc_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>543</x>
      <y>2460</y>
      <w>32</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.申请eb，并初始化
	eb-&gt;start = start;
	eb-&gt;len = len;
	eb-&gt;fs_info = fs_info;
	btrfs_leak_debug_add(&amp;eb-&gt;leak_list, &amp;buffers)
	atomic_set(&amp;eb-&gt;refs, 1);
	atomic_set(&amp;eb-&gt;io_pages, 0)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>554</x>
      <y>2456</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>582</x>
      <y>2453</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_or_create_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>582</x>
      <y>2459</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pagecache_get_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>590</x>
      <y>2456</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>570</x>
      <y>2494</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_get_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>557</x>
      <y>2500</y>
      <w>37</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.radix_tree_lookup_slot在mapping-&gt;page_tree找到对应的offset
	page的指针
2.如果找到
	1.如果page为NULL,跳出
	2.检查page indirect exception有没有置上
		1.如果indirect置上，跳到1重新查找
		2.否则跳出
	3.page_cache_get_speculative检查page.count，如果为0
		跳到1重新查找
	4.如果指针指向的page发生了改变，重新查找
3.返回page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>575</x>
      <y>2497</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>578</x>
      <y>2465</y>
      <w>32</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.通过find_get_entry在mapping中查找缓存page
	1.如果exception，page=NULL
	2.如果FGP_LOCK
		1.如果FGP_NOWAIT
			1.设置PG_locked，如果已经locked，将page释放
		2.否则通过lock_page锁page
		3.如果page-&gt;mapping发生改变，将page解锁，并释放，然后重新在mapping中查找
	3.如果找到page，并且FGP_ACCESSED，通过mark_page_accessed索引page
2.如果没找到page，并且FGP_CREAT
	1.设置gfp_mask
	2.__page_cache_alloc申请page
		fgp_flags |= FGP_LOCK
	3.如果FGP_ACCESSED，将page索引
	4.通过add_to_page_cache_lru添加到，如果出错，释放page
3.返回page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>590</x>
      <y>2462</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>575</x>
      <y>2489</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>602</x>
      <y>2493</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_to_page_cache_lru</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>602</x>
      <y>2500</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__add_to_page_cache_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>610</x>
      <y>2496</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>596</x>
      <y>2489</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>602</x>
      <y>2507</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_tree_insert</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>610</x>
      <y>2503</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>597</x>
      <y>2514</y>
      <w>35</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.__radix_tree_create创建node
2.如果slot有值
	1.exceptional要置上
	2.*shadowp = p;
		mapping-&gt;nrshadows--
	3.递减node-&gt;count
3.*slot= page
	mapping-&gt;nrpages++;
4.如果node存在
	1.node-&gt;count++
	2.如果private_list在链表中，将其脱链
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>610</x>
      <y>2510</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>593</x>
      <y>2537</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__radix_tree_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>598</x>
      <y>2533</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>579</x>
      <y>2544</y>
      <w>40</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.如果index超过了2^height，通过radix_tree_extend对height扩充
2.遍历树root-&gt;rnode
	1.从高到低位遍历index（有height个RADIX_TREE_MAP_SHIFT组）成为offset的slot
	2.如果该slot不存在
		1.通过radix_tree_node_alloc申请一个node
			slot-&gt;path = height;
			slot-&gt;parent = node;
		2.如果存在node
			1.node-&gt;slots[offset]=slot
				node-&gt;count++;
				slot-&gt;path |= offset &lt;&lt; RADIX_TREE_HEIGHT_SHIFT
		3.如果不存在
			root-&gt;rnode= ptr_to_indirect(slot)
3.nodep返回父节点，slotp返回指向slot的指针
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>598</x>
      <y>2540</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>578</x>
      <y>2570</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>radix_tree_extend</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>569</x>
      <y>2577</y>
      <w>39</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.递增root-&gt;height，直到index大于2^height
2.如果rnode为NULL,直接赋值height，并返回
	root-&gt;height = height
3.否则
	1.radix_tree_node_alloc申请node
	2.如果对应的gfp_mask中对应的tag位置上，通过tag_set将
		node-&gt;tags[tag]第0位置上
	3.新申请的node成为rnode的parent
		node-&gt;path = root-&gt;height+1;
		node-&gt;count = 1;
		node-&gt;parent = NULL;
		node-&gt;slots[0]=root-&gt;rnode//根据height看是否转化成ptr
		root-&gt;rnode= node//转换成indirect
		root-&gt;height = newheight
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>564</x>
      <y>2604</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>radix_tree_node_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>556</x>
      <y>2611</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果__GFP_DIRECT_RECLAIM没置上，并且不在中断中
	1.提取链表rtp-&gt;nodes中的node
		rtp-&gt;nr--
2.否则通过kmem_cache_alloc申请node
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>572</x>
      <y>2607</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>571</x>
      <y>2599</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>582</x>
      <y>2573</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>584</x>
      <y>2566</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>619</x>
      <y>2452</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>attach_extent_buffer_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>614</x>
      <y>2459</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果PagePrivate没置上
	1.SetPagePrivate置上page
	2.page_cache_get递增page计数
	3.set_page_private设置page.private=eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>627</x>
      <y>2455</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>656</x>
      <y>2451</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>radix_tree_insert</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>644</x>
      <y>2458</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过__radix_tree_create创建index对应的slot
2.*slot=item
3.如果有父节点
	node.count++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>661</x>
      <y>2454</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>686</x>
      <y>2450</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_release_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>676</x>
      <y>2457</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_release_extent_buffer_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>703</x>
      <y>2457</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__free_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>687</x>
      <y>2453</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>698</x>
      <y>2453</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>676</x>
      <y>2464</y>
      <w>25</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.如果eb的page数为0，直接返回
2.从后向前遍历eb.page
	1.如果PagePrivate，并且private指向eb
		1.ClearPagePrivate
		2.page.private=0
		3.page_cache_release释放page
	2.page_cache_release释放page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>686</x>
      <y>2460</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>703</x>
      <y>2464</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.将eb-&gt;leak_list脱链
2.kmem_cache_free释放eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>711</x>
      <y>2460</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>562</x>
      <y>2399</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>562</x>
      <y>2393</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>582</x>
      <y>2390</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_set_buffer_uptodate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>581</x>
      <y>2404</y>
      <w>31</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.将eb的EXTENT_BUFFER_UPTODATE置上
2.通过SetPageUptodate设置所有的eb-&gt;pages
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>594</x>
      <y>2393</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>584</x>
      <y>2397</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_extent_buffer_uptodate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>593</x>
      <y>2400</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>615</x>
      <y>2389</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>write_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>613</x>
      <y>2396</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.将数据从src赋值到eb.page中，复制的长度不能
	超过page
注：start表示在eb内偏移量
	start_offset表示page内的偏移
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>621</x>
      <y>2392</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>655</x>
      <y>2388</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_disk_key_to_cpu</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>662</x>
      <y>2391</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>649</x>
      <y>2395</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>cpu-&gt;offset = le64_to_cpu(disk-&gt;offset);
cpu-&gt;type = disk-&gt;type;
cpu-&gt;objectid = le64_to_cpu(disk-&gt;objectid)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>685</x>
      <y>2387</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_one_chunk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>680</x>
      <y>2395</y>
      <w>34</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.通过lookup_extent_mapping在mapping_tree.map_tree找disk对应的offset
2.如果找到了，并且在范围内，说明disk已经在map_tree中，通过free_extent_map递减其计数，并返回0
	如果不在返回内，也通过free_extent_map递减其计数，并继续
3.通过alloc_extent_map申请em
4.kmalloc申请map(map_lookup + n* btrfs_bio_stripe)
5.初始化em和map
	set_bit(EXTENT_FLAG_FS_MAPPING, &amp;em-&gt;flags);
	em-&gt;bdev = (struct block_device *)map;
	em-&gt;start = logical;
	em-&gt;len = length;
	em-&gt;orig_start = 0;
	em-&gt;block_start = 0;
	em-&gt;block_len = em-&gt;len;

	//map
	map-&gt;num_stripes = num_stripes;
	map-&gt;io_width = btrfs_chunk_io_width(leaf, chunk);
	map-&gt;io_align = btrfs_chunk_io_align(leaf, chunk);
	map-&gt;sector_size = btrfs_chunk_sector_size(leaf, chunk);
	map-&gt;stripe_len = btrfs_chunk_stripe_len(leaf, chunk);
	map-&gt;type = btrfs_chunk_type(leaf, chunk);
	map-&gt;sub_stripes = btrfs_chunk_sub_stripes(leaf, chunk);
	//stripe
	map-&gt;stripes[i].physical//strip在super中的地址
	map-&gt;stripes[i].dev//chunk.devid，strip.uuid
	map-&gt;stripes[i].dev-&gt;in_fs_metadata = 1
6.add_extent_mapping将em添加到map_tree
7.free_extent_map递减em计数，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>694</x>
      <y>2390</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>506</x>
      <y>2444</y>
      <w>55</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>530.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>556</x>
      <y>2444</y>
      <w>5</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>559</x>
      <y>2444</y>
      <w>32</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>562</x>
      <y>2444</y>
      <w>67</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>566</x>
      <y>2444</y>
      <w>98</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;960.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>573</x>
      <y>2444</y>
      <w>123</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1210.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>562</x>
      <y>2387</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>585</x>
      <y>2387</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>596</x>
      <y>2387</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>597</x>
      <y>2387</y>
      <w>67</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>599</x>
      <y>2386</y>
      <w>96</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;20.0;940.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>577</x>
      <y>2332</y>
      <w>134</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1320.0;10.0;10.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>700</x>
      <y>2422</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_extent_mapping</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>699</x>
      <y>2429</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__lookup_extent_mapping</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>706</x>
      <y>2419</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
root-&gt;fs_info-&gt;mapping_tree</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>706</x>
      <y>2425</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>706</x>
      <y>2436</y>
      <w>35</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.通过__tree_search查找offset所在的rb_node
2.如果没找到,重新设置rb_node
	1.如果存在prev，即为prev
	2.如果存在next，即为next
	3.否则为NULL
3.如果要求stict，表示需要严格在start~end内，如果不在，
	返回NULL
4.递增rb_left，并返回em
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>710</x>
      <y>2432</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>728</x>
      <y>2454</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__tree_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>733</x>
      <y>2450</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>725</x>
      <y>2461</y>
      <w>38</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.遍历root-&gt;rb_node，找到start&lt;=offset&lt;end的rb_node
2.如果没找到
	1.如果有prev_ret，rb_next找到offset&lt;end的rb_node
	2.如果有next_ret，rb_prev找到offset&gt;start的rb_node
注：为什么pre_ret记录的是链表中的next，而next_ret记录的确是
	链表中的prev
3.返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>734</x>
      <y>2457</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>721</x>
      <y>2476</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rb_next</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>726</x>
      <y>2472</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>710</x>
      <y>2483</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果存在rb_right，找到rb_right的最左节点
2.如果不存在，向上找父节点，直到找到左节点的父节点，
	即在链表中为其next（父-左-右）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>726</x>
      <y>2479</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>752</x>
      <y>2476</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rb_prev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>756</x>
      <y>2472</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>747</x>
      <y>2483</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果存在rb_left，找到rb_left的最右节点
2.如果不存在，向上找父节点，直到找到右节点的父节点，
	即在链表中为其prev（父-右-左）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>757</x>
      <y>2479</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>676</x>
      <y>2423</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_extent_map</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>668</x>
      <y>2429</y>
      <w>29</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.kmem_cache_zalloc申请em
2.初始化
	em-&gt;flags = 0;
	em-&gt;compress_type = BTRFS_COMPRESS_NONE;
	em-&gt;generation = 0;
	atomic_set(&amp;em-&gt;refs, 1);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>681</x>
      <y>2426</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>682</x>
      <y>2419</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>753</x>
      <y>2422</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_extent_mapping</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>712</x>
      <y>2419</y>
      <w>49</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>745</x>
      <y>2430</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tree_insert</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>783</x>
      <y>2430</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_extent_mapping</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>748</x>
      <y>2425</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>760</x>
      <y>2425</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>744</x>
      <y>2437</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.遍历root-&gt;rb_node
	1.如果小于start，遍历左节点
	2.如果大于end，遍历右节点
	3.否则该rb_node存在
2.需要再次检查不和链表中next和prev重合
	之前的遍历只做了start的检查，没做end的检查，可能线段重合
3.rb_link_node和rb_insert_color进行红黑树的插入
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>747</x>
      <y>2433</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>779</x>
      <y>2437</y>
      <w>34</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.atomic_inc(&amp;em-&gt;refs);
	em-&gt;mod_start = em-&gt;start;
	em-&gt;mod_len = em-&gt;len;
2.如果modified置上，将em加入modified_extents链表中
3.否则，try_merge_map看em是否能进行合并
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>788</x>
      <y>2433</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>787</x>
      <y>2449</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>try_merge_map</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>793</x>
      <y>2445</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>727</x>
      <y>2388</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>718</x>
      <y>2395</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.不加锁循环递减ref
	1.读取eb-&gt;refs，如果小于3，退出循环
	2.atomic_cmpxchg递减eb-&gt;refs
	3.如果ref之前发生改变，则继续循环，否则直接退出
2.如果有EXTENT_BUFFER_DUMMY或者EXTENT_BUFFER_TREE_REF
	递减ref
3.release_extent_buffer试图释放eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>734</x>
      <y>2391</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>604</x>
      <y>2387</y>
      <w>132</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1300.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>850</x>
      <y>2354</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_tree_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>838</x>
      <y>2360</y>
      <w>35</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过btrfs_find_create_tree_block查询或者申请eb和page
2.btree_read_extent_buffer_pages读取eb.page
3.如果出错，free_extent_buffer释放eb，否则返回eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>854</x>
      <y>2357</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>852</x>
      <y>2370</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btree_read_extent_buffer_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>860</x>
      <y>2366</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>844</x>
      <y>2378</y>
      <w>33</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.清除eb的EXTENT_BUFFER_CORRUPT
2.循环
	1.read_extent_buffer_pages在io_tree中读取eb.page
	2.如果正确返回
		1.通过verify_parent_transid验证，如果成功，退出循环
		2.验证出错，ret=EIO
	3.如果eb的EXTENT_BUFFER_CORRUPT置上，退出循环
	4.通过btrfs_num_copies检查eb有多少备份，如果备份是1，退出循环
	5.如果failed_mirror还没置上
		failed = 1;
		failed_mirror = eb-&gt;read_mirror//read_mirror存储的是最终失败后修复镜像？
	6.mirror_num++，不读取read_mirror，所以读到read_mirror
		mirror_num++
	7.如果出错的镜像超过了备份，退出循环
3.如果读取所有的镜像出错，并且有修复镜像failed_mirror
	通过repair_eb_io_failure利用修复镜像进行修复
4.返回ret
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>818</x>
      <y>2411</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_extent_buffer_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>861</x>
      <y>2373</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>827</x>
      <y>2406</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btree_get_extent</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>821</x>
      <y>2418</y>
      <w>35</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>1.如果EXTENT_BUFFER_UPTODATE置上，直接返回0
2.计算在eb.page内的偏移start_i
3.遍历eb的page(start_i~num_pages)
	1.如果是WAIT_NONE，通过trylock_page锁住page，如果page已经被锁住，解锁其他page，并返回
	2.否则通过lock_page锁住page
	3.locked_pages++;
	4.统计需要读page的数量(!PageUptodate)
		num_reads++;
		all_uptodate = 0;
4.如果全部被更新，将eb的EXTENT_BUFFER_UPTODATE置上，并解锁所有的page，返回
5.清除掉eb的EXTENT_BUFFER_READ_ERR
6.eb-&gt;read_mirror = 0;
	atomic_set(&amp;eb-&gt;io_pages, num_reads)
7.遍历eb的page
	1.如果!PageUptodate
		1.ClearPageError
		2.__extent_read_full_page读取page
	2.否则unlock_page
8.如果返回了bio，通过submit_one_bio提交请求
9.如果出错，或者不用WAIT_COMPLETE，返回ret
10.否则通过wait_on_page_locked等待每个page解锁
	如果page没有uptodate，返回EIO
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>828</x>
      <y>2414</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>826</x>
      <y>2457</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__extent_read_full_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>834</x>
      <y>2454</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>816</x>
      <y>2464</y>
      <w>45</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.循环处理ordered_extent
	1.通过btrfs_lookup_ordered_extent查找ordered_tree是否有对应的ordered_extend
	2.如果有，通过btrfs_start_ordered_extent刷写，并wait到BTRFS_ORDERED_COMPLETE
	3.通过btrfs_put_ordered_extent释放ordered_extend
	4.直到ordered_tree内没有对应的ordered_extent
2.通过__do_readpage读取page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>835</x>
      <y>2460</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>815</x>
      <y>2478</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_lookup_ordered_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>849</x>
      <y>2478</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__do_readpage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>805</x>
      <y>2485</y>
      <w>40</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过tree_search查找inode.ordered_tree的file_offset
2.如果file_offset不在entry范围内，返回NULL
3.递增entry-&gt;refs，并返回entry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>824</x>
      <y>2474</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>823</x>
      <y>2481</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>853</x>
      <y>2474</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>846</x>
      <y>2484</y>
      <w>38</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>1.set_page_extent_mapped设置pageprivate
2.如果page没有uptodate,通过cleancache_get_page获取page
	如果成功，直接返回
3.如果所读取的page超过了inode.size
	1.将page内超过inode.size的部分清零
4.循环读取start~end（一个page）
	1.如果正在读取的长度超过了inode.size
		1.
	2.通过__get_extent_map获取em
	3.如果em的EXTENT_FLAG_COMPRESSED置上
		1.置上this_bio_flag的EXTENT_BIO_COMPRESSED
		2.this_bio_flag合并em-&gt;compress_type
	4.根据EXTENT_BIO_COMPRESSED设置disk_io_size和sector
	5.如果EXTENT_FLAG_PREALLOC置上，
		block_start = EXTENT_MAP_HOLE
	6.如果EXTENT_FLAG_COMPRESSED，prev_em_start不是-1，不是orig_start
		force_bio_submit = true
	7.如果要求prev_em_start
		*prev_em_start = em-&gt;orig_start
	8.free_extent_map释放em
	9.如果block_start在EXTENT_MAP_HOLE
		1.
	10.test_range_bit检查段的所有区域在io_tree中是否EXTENT_UPTODATE都置上
		1.通过check_page_uptodate检查page的相应的段EXTENT_UPTODATE是否置上，
			如果置上SetPageUptodate
		2.更新变量，继续下一次循环
			cur = cur + iosize;
			pg_offset += iosize;
	11.如果block_start是EXTENT_MAP_INLINE
		1.SetPageError
		2.更新变量，继续下一次循环
			cur = cur + iosize;
			pg_offset += iosize;
	12.submit_extent_page申请bio，并根据情况提交上一次bio
	13.如果正确返回
		nr++;
		*bio_flags = this_bio_flag;//保存上一次flag
		否则SetPageError
	14.更新循环变量，并继续循环
		cur = cur + iosize;
		pg_offset += iosize
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>856</x>
      <y>2481</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>776</x>
      <y>2550</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_page_extent_mapped</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>769</x>
      <y>2556</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果PagePrivate没置上
	1.设置PagePrivate
	2.page_cache_get递增page计数
	3.page.private=EXTENT_PAGE_PRIVATE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>786</x>
      <y>2553</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>800</x>
      <y>2550</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_extent_map</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>800</x>
      <y>2556</y>
      <w>35</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果有指定的em_cached，先看cache是否满足要求
	1.extent_map_in_tree检查到extend在tree中欧冠
	2.em.start&lt;start&lt;em.end
	3.如果满足上述两个条件，递增em-&gt;refs，并返回em
	4.否则通过free_extent_map递减em计数，并释放*em_cached
2.通过get_extent获取em
3.如果有指定了em_cached，并且获取em没出错
	atomic_inc(&amp;em-&gt;refs);
	*em_cached = em
4.返回em	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>807</x>
      <y>2553</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>799</x>
      <y>2582</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btree_get_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>804</x>
      <y>2585</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>793</x>
      <y>2588</y>
      <w>28</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.通过lookup_extent_mapping在extent_tree中查找start~start+len
2.如果找到em，设置em-&gt;bdev，并退出
	em-&gt;bdev=fs_info-&gt;fs_devices-&gt;latest_bdev
3.如果没找到
	1.通过alloc_extent_map申请em
	2.em-&gt;start = 0;
		em-&gt;len = (u64)-1;
		em-&gt;block_len = (u64)-1;
		em-&gt;block_start = 0;
		em-&gt;bdev=fs_info-&gt;fs_devices-&gt;latest_bdev
	3.通过add_extent_mapping将em加入到extent_tree
	4.因为之前有lock，需要发现已经存在map_tree
		1.free_extent_map释放em
		2.lookup_extent_mapping查找em
	5.如果添加出现错误，释放em，并返回错误
4.返回em	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>799</x>
      <y>2576</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_extent
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>803</x>
      <y>2579</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>803</x>
      <y>2572</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>868</x>
      <y>2410</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>verify_parent_transid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>898</x>
      <y>2410</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_num_copies</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>893</x>
      <y>2417</y>
      <w>32</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.通过lookup_extent_mapping找到偏移对应的em
2.如果没找到em，返回1
3.如果偏移不在em内，free_extent_map释放em，并返回1
4.检查em-&gt;bdev.type
	1.如果BTRFS_BLOCK_GROUP_DUP，BTRFS_BLOCK_GROUP_RAID1
		ret=map-&gt;num_stripes
	2.如果BTRFS_BLOCK_GROUP_RAID10
		ret = map-&gt;sub_stripes
	3.如果BTRFS_BLOCK_GROUP_RAID5
		ret=2
	4.如果BTRFS_BLOCK_GROUP_RAID6
		ret=3
	5.否则ret=1
5.free_extent_map释放em
6.btrfs_dev_replace_is_ongoing检查fs_info-&gt;dev_replace
	递增ret
7.返回ret
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>906</x>
      <y>2413</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>860</x>
      <y>2417</y>
      <w>31</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果指定了parent_transid要和eb.page[0].generation相同
	即返回0，表示验证通过
注：generation通过BTRFS_SETGET_HEADER_FUNCS进行解析
2.如果atomic置上，返回EAGAIN
3.如果进程的journal_info需要BTRFS_SEND_TRANS_STUB
	1.btrfs_tree_read_lock递增reader
	2.btrfs_set_lock_blocking_rw递增blocking_readers的计数
4.如果eb uptodate，并且generation，返回0，验证通过(因为之前可能有等待)
5.出错
	1.如果extent_buffer_under_io检查其没在io操作，通过
		clear_extent_buffer_uptodate清除eb.page的uptodate
	2.btrfs_tree_read_unlock_blocking释放reader
	3.返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>876</x>
      <y>2413</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>856</x>
      <y>2443</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_tree_read_lock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>864</x>
      <y>2446</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>856</x>
      <y>2450</y>
      <w>28</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果存在blocking_writers，并且当前进程是eb.lock_owner,返回
	eb-&gt;lock_nested = 1;
2.如果存在blocking_writers，但是是其他进程，需要等待
	blocking_writers变为0，想来之后跳到1再次做检测（因为进程竞争）
3.atomic_inc(&amp;eb-&gt;read_locks);
	atomic_inc(&amp;eb-&gt;spinning_readers);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>863</x>
      <y>2438</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>874</x>
      <y>2442</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_set_lock_blocking_rw</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>881</x>
      <y>2438</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>886</x>
      <y>2450</y>
      <w>29</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.如果是eb.lock_owner锁住，直接返回
2.如果是BTRFS_WRITE_LOCK
	1.如果blocking_writers为0
		atomic_dec(&amp;eb-&gt;spinning_writers);
		atomic_inc(&amp;eb-&gt;blocking_writers);
	2.如果是BTRFS_READ_LOCK
		atomic_inc(&amp;eb-&gt;blocking_readers);
		atomic_dec(&amp;eb-&gt;spinning_readers);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>885</x>
      <y>2445</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>863</x>
      <y>2406</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>872</x>
      <y>2406</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>718</x>
      <y>2332</y>
      <w>137</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1350.0;220.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>852</x>
      <y>2549</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>test_range_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>839</x>
      <y>2556</y>
      <w>38</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.如果指定了cached，extent_state_in_tree查看cache是否在io_tree中
	并且看start是否在cache的范围内，如果在
	node = &amp;cached-&gt;rb_node
2.否则通过tree_search在io_tree中查找
3.循环检查start~end是否在io_tree中
	1.如果start&lt;node.start,表示该段不在范围内，并且filled置上(要求所有的段都在范围内)，退出循环，并返回false
		bitset = 0
	2.如果end&lt;node.start，说明tree中没有段相关，根据之前的设置退出
	注：这里会返回0，因为start&lt;end，所以前面只能是filled没置上，filled没置上，但是循环的原因是bitset = 0
	3.如果node.state的相应的bit置上
		1.bitset = 1;
		2.如果filled没置上，退出循环
	4.如果相应bit没置上，并且filled置上，退出循环
		bitset = 0
	5.如果node.end=-1，表示只有之后这个node，所以直接退出循环
	6.更新start = state-&gt;end + 1，如果start超过end，表示段遍历完成，退出循环
	7.通过rb_next遍历下一个node，如果filled置上，说明段有一部分不在io_tree的范围内，
		bitset = 0，退出循环
4.返回bitset
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>857</x>
      <y>2552</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>895</x>
      <y>2548</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>submit_extent_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>902</x>
      <y>2551</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>884</x>
      <y>2555</y>
      <w>42</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.如果存在bio_ret
	1.contig记录两个bio是否连接
		1.如果bio_ret的EXTENT_BIO_COMPRESSED置上，sector相同，contig置上
		2.否则sector紧接着，contig置上
	2.以下情况，submit_one_bio会提交bio_ret,如果失败直接返回，如果成功清除bio_ret，并继续2
		1.现在的要申请的bio的bio_flags和bio_ret不同
		2.两个bio没紧接着
		3.force_bio_submit
		4.merge_bio或者bio_add_page失败
	5.如果成功merge，返回0
2.通过btrfs_bio_alloc申请bio
3.通过bio_add_page将page添加到bio_vec中
	bio-&gt;bi_end_io = end_io_func;
	bio-&gt;bi_private = tree;
4.如果wbc存在
	1.wbc_init_bio
	2.wbc_account_io
5.如果存在bio_ret
	*bio_ret = bio;
6.否则通过submit_one_bio提交bio
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>868</x>
      <y>2546</y>
      <w>36</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
end_bio_extent_readpage</panel_attributes>
    <additional_attributes>10.0;20.0;340.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>881</x>
      <y>2611</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bio_alloc_bioset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>887</x>
      <y>2584</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>870</x>
      <y>2617</y>
      <w>35</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>1.如果没有内存池bs
	1.申请的vec不能超过UIO_MAXIOV
	2.通过kmalloc申请bio + nr_iovecs *bio_vec
		front_pad = 0;//没有pad
		inline_vecs = nr_iovecs
2.如果指定了内存池bs
	1.如果进程的bio_list不为空，将__GFP_DIRECT_RECLAIM去掉
		通过mempool_alloc申请bio
	2.如果没申请到，再将__GFP_DIRECT_RECLAIM加上，
		再次通过mempool_alloc申请bio
	3.front_pad = bs-&gt;front_pad;
		inline_vecs = BIO_INLINE_VECS
3.如果没申请到bio，返回NULL
4.如果申请到
	1.bio = p + front_pad;
	2.bio_init对bio进行初始化
		memset(bio, 0, sizeof(*bio));
		atomic_set(&amp;bio-&gt;__bi_remaining, 1);
		atomic_set(&amp;bio-&gt;__bi_cnt, 1);
	3.如果是在内存池中申请的bio，并且bio_vec内存空间不足
		1.bvec_alloc申请bio_vec
		2.如果没申请到，通过saved_gfp再次通过bvec_alloc申请bio_vec
		3.设置bio.bi_flagsBIO_OWNS_VEC
	4.否则直接指向之前申请的bio_vec空间
		bvl = bio-&gt;bi_inline_vecs;
	5.初始化bio，并返回
		bio-&gt;bi_pool = bs;
		bio-&gt;bi_flags |= idx &lt;&lt; BIO_POOL_OFFSET;
		bio-&gt;bi_max_vecs = nr_iovecs;
		bio-&gt;bi_io_vec = bvl;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>885</x>
      <y>2614</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>878</x>
      <y>2669</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bvec_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>883</x>
      <y>2665</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>883</x>
      <y>2672</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>870</x>
      <y>2676</y>
      <w>34</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.根据申请bio_vec的个数，确定idx
2.如果idx是BIOVEC_MAX_IDX，通过mempool_alloc
	在内存池中申请
3.否则，根据idx选择对应的slab，在slab中申请
	如果没申请到，并且__GFP_DIRECT_RECLAIM，再回到2
	中从内存池中申请
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>882</x>
      <y>2588</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_bio_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>873</x>
      <y>2594</y>
      <w>35</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.通过bio_alloc_bioset申请bio+bio_vec
2.如果没申请到，并且进程的PF_MEMALLOC置上
	bio_vec数量减半，然后再次通过bio_alloc_bioset申请
	直到申请成功
3.bio-&gt;bi_bdev = bdev;
	bio-&gt;bi_iter.bi_sector = first_sector;
	//初始化bio的container btrfs_bio(这里只能是在内存池中申请)
	btrfs_bio-&gt;csum = NULL;
	btrfs_bio-&gt;csum_allocated = NULL;
	btrfs_bio-&gt;end_io = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>885</x>
      <y>2608</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>887</x>
      <y>2591</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>917</x>
      <y>2588</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bio_add_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>921</x>
      <y>2584</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>911</x>
      <y>2594</y>
      <w>33</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.如果之前存有page（bi_vcnt&gt;0）,看是否能和上一个bio_vec合并
	1.page要相同
	2.offset=vec.offset+vec.len
	3.满足上述两个条件可以合并，并跳到4
		bv-&gt;bv_len += len;
2.如果使用bio_vec的数量超过了bi_max_vecs，返回0
3.将page添加到bio_vec中
	bv		= &amp;bio-&gt;bi_io_vec[bio-&gt;bi_vcnt];
	bv-&gt;bv_page	= page;
	bv-&gt;bv_len	= len;
	bv-&gt;bv_offset	= offset;
	bio-&gt;bi_vcnt++;
4.递增bio中的字节数量，并返回len
	bio-&gt;bi_iter.bi_size += len
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>921</x>
      <y>2591</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>854</x>
      <y>2589</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>merge_bio</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>859</x>
      <y>2584</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>839</x>
      <y>2596</y>
      <w>31</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.如果存在tree-&gt;ops-&gt;merge_bio_hook，通过这个函数merge
2.否则返回0，表示merge失败
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>858</x>
      <y>2592</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>847</x>
      <y>2603</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tree-&gt;ops-&gt;merge_bio_hook
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>857</x>
      <y>2599</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>856</x>
      <y>2606</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_init_btree_inode
btree_extent_io_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>846</x>
      <y>2610</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_merge_bio_hook</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>959</x>
      <y>2587</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>submit_one_bio</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>924</x>
      <y>2584</y>
      <w>43</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>949</x>
      <y>2594</y>
      <w>36</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.计算需要进行io的地址page+bv_offset
2.bio-&gt;bi_private = NULL
3.bio_get递增bio的计数
4.如果有tree-&gt;ops-&gt;submit_bio_hook，通过这个函数提交
	否则通过btrfsic_submit_bio提交
5.bio_put释放bio
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>964</x>
      <y>2590</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>945</x>
      <y>2609</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bio_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1008</x>
      <y>2608</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bio_put</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>949</x>
      <y>2604</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>944</x>
      <y>2612</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>930</x>
      <y>2618</y>
      <w>26</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.将bio.bi_flags的BIO_REFFED置上
2.增加bio.__bi_cnt的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1001</x>
      <y>2615</y>
      <w>26</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果BIO_REFFED没置上，通过bio_free将bio释放
2.递减bio.__bi_cnt,如果减到0，通过bio_free释放bio
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1013</x>
      <y>2611</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>981</x>
      <y>2604</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>959</x>
      <y>2608</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tree-&gt;ops-&gt;submit_bio_hook
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>965</x>
      <y>2604</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>959</x>
      <y>2615</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btree_submit_bio_hook</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>965</x>
      <y>2611</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btrfs_init_btree_inode
btree_extent_io_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>983</x>
      <y>2608</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfsic_submit_bio</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>980</x>
      <y>2604</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>887</x>
      <y>2352</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_set_root_node</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>893</x>
      <y>2355</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>880</x>
      <y>2358</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.item.bytenr=node-&gt;start
	item.level=(btrfs_header *)node.page[0]-&gt;level
	item.generation=(btrfs_header *)node.page[0]-&gt;generation
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>684</x>
      <y>2314</y>
      <w>39</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>18.btrfs_read_sys_array根据chunk设置extend_map
19.__setup_root设置chunk_root的size
20.read_tree_block读取chunk_root
21.btrfs_set_root_node根据读取的chunk_root.node设置chunk_root-&gt;root_item
22.chunk_root-&gt;commit_root=chunk_root.node
23.read_extent_buffer设置fs_info-&gt;chunk_tree_uuid
	fs_info-&gt;chunk_tree_uuid=（btrfs_header*）chunk_root-&gt;node-&gt;chunk_tree_uuid
24.btrfs_read_chunk_tree遍历root中的所有dev_item
25.btrfs_close_extra_devices将fs_devices.devices链表中脱链
	fs_devices-&gt;latest_bdev = latest_dev-&gt;bdev
26.如果不存在fs_devices-&gt;latest_bdev，跳到fail_tree_roots

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>564</x>
      <y>2311</y>
      <w>137</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置chunk_root</panel_attributes>
    <additional_attributes>10.0;10.0;1350.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>987</x>
      <y>2346</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_read_chunk_tree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>995</x>
      <y>2349</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>980</x>
      <y>2352</y>
      <w>36</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.通过btrfs_alloc_path在btrfs_path_cachep中申请path
2.btrfs_search_slot查找BTRFS_DEV_ITEMS_OBJECTID
3.循环
	1.如果slot超过了leaf的item的个数，通过btrfs_next_leaf
		遍历下一个leaf
		1.如果返回0，表示下一个leaf还存在，continue
		2.如果出错，跳到error
		3.如果返回1，表示不存在下一个leaf，break
	2.获取slot对应的key
	3.如果key.type是BTRFS_DEV_ITEM_KEY
		1.以btrfs_dev_item解析slot对应的数据
		2.通过read_one_dev初始化dev_item对应的device
	4.如果type是BTRFS_CHUNK_ITEM_KEY
		1.以btrfs_chunk方式解析slot item数据
		2.通过read_one_chunk初始化chunk对应的extent_map
	5.遍历下一个slot
		path-&gt;slots[0]++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>997</x>
      <y>2372</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_search_slot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1003</x>
      <y>2369</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>957</x>
      <y>2377</y>
      <w>38</w>
      <h>48</h>
    </coordinates>
    <panel_attributes>1.如果ins_len&lt;0
	lowest_unlock = 2;
	write_lock_level = 2
	如果ins_len&gt;0
	write_lock_level = 1
2.如果不用cow
	write_lock_level = -1
3.如果要cow，并且path的keep_locks或者lowest_level存在
	write_lock_level = BTRFS_MAX_LEVEL
4.again
	1.如果path存在search_commit_root
		1.b = root-&gt;commit_root//extend_buffer
			level = btrfs_header_level(b)
		2.如果skip_locking没开，通过btrfs_tree_read_lock给其上读锁
	2.否则
		1.如果skip_locking置上
			1.b = btrfs_root_node(root);//选择root.node
				level = btrfs_header_level(b)
		2.否则
			1.通过btrfs_read_lock_root_node给eb上读锁的同时，获取root.node
			2.如果需要上写锁(level小于write_lock_level)
				1.通过btrfs_tree_read_unlock释放读锁,并通过free_extent_buffer释放获取的eb
				2.通过btrfs_lock_root_node上写锁，并重新获取root.node
					level = btrfs_header_level(b)
				3.root_lock = BTRFS_WRITE_LOCK
				注：其他情况默认是BTRFS_READ_LOCK
	3.p-&gt;nodes[level] = b
	4.如果skip_locking没置
		p-&gt;locks[level] = root_lock
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>970</x>
      <y>2375</y>
      <w>36</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>930</x>
      <y>2429</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_set_path_blocking</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>938</x>
      <y>2424</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>928</x>
      <y>2435</y>
      <w>35</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.遍历path
	1.如果没有node或者lock，跳过
	2.btrfs_set_lock_blocking_rw根据lock类型递增以下两个量
		1.blocking_writers或者blocking_readers
		2.spinning_writers或者spinning_readers
	3.将lock转换成blocking
		1.BTRFS_READ_LOCK--&gt;BTRFS_READ_LOCK_BLOCKING
		2.BTRFS_WRITE_LOCK--&gt;BTRFS_WRITE_LOCK_BLOCKING
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>938</x>
      <y>2432</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>965</x>
      <y>2428</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_cow_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>970</x>
      <y>2424</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>983</x>
      <y>2454</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>key_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>988</x>
      <y>2446</y>
      <w>180</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1780.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>974</x>
      <y>2461</y>
      <w>35</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.如果prev_cmp不为0，通过bin_search进行二分查找
2.否则slot返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>988</x>
      <y>2457</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>984</x>
      <y>2468</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bin_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>989</x>
      <y>2464</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>981</x>
      <y>2475</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_bin_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>988</x>
      <y>2471</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>971</x>
      <y>2482</y>
      <w>39</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.循环进行二分查找
	1.以下情况需要重新通过map_private_extent_buffer map新的eb空间
		1)没指定page
		2)要访问的item不在之前map的范围内
		1.key的解析为kaddr + offset -map_start
			1.kaddr-map_start即为eb.start的虚拟地址
		2.如果失败
			1.通过read_extent_buffer读取key到temp，这是允许跨page读取的
	2.如果在map_len范围内，直接赋值kaddr + offset - map_start
	3.comp_keys进行比较，如果key&lt;temp返回1，遍历左边，key&gt;temp返回-1，遍历右边
		如果相同，返回0，*slot = mid
2.如果最后找不到，slot返回low(这里的low应该是相对寻找的slot高)，并返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>783</x>
      <y>2547</y>
      <w>81</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>790.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>804</x>
      <y>2547</y>
      <w>62</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>600.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>856</x>
      <y>2547</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>988</x>
      <y>2478</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>974</x>
      <y>2504</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>map_private_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>982</x>
      <y>2501</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>970</x>
      <y>2510</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果min_len跨了page，返回EINVAL
2.offset记录在page中的偏移量
	map_start是item相对eb.start的偏移量
3.offset+min_len不能超过eb.len
4.map返回其item或者eb的虚拟地址
	map_len返回可供访问的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>982</x>
      <y>2507</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1175</x>
      <y>2449</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_leaf_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>2446</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1175</x>
      <y>2456</y>
      <w>30</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.返回(root.nodesize-header)-(data+item)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1186</x>
      <y>2463</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>leaf_space_used</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1190</x>
      <y>2459</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1175</x>
      <y>2470</y>
      <w>32</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.end默认是start+nr，但是不能超过nritems
2.首先算出start数据的位置
	datalen=offset+size
3.然后减去end_item.offset得到真实的数据长度
注：item和data从两边向中间增长
4.数据长度+item*nr的长度，得到leaf_space
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1191</x>
      <y>2466</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1658</x>
      <y>2444</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>split_leaf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1203</x>
      <y>2443</y>
      <w>463</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;40.0;4610.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1506</x>
      <y>2454</y>
      <w>35</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果在item正好item.offset插入(extend)
	1.如果data(新数据+item.size)+item超过了nodesize，返回EOVERFLOW
2.如果存在要插入的datasize，并且存在node[1]
	1.space_needed默认是需要的datasize
	2.如果slot小于eb.nritems
		space_needed -= btrfs_leaf_free_space
	3.push_leaf_right查看right是否有足够的空间，如果有将node的后半部分item移到right
		头部，item停留到free_space多的eb
	4.如果right没有足够的空间(wret=1)，通过push_leaf_left查看left是否有足够的空间
		如果有，将node前半部分item移到left尾端，item停留在free_space多的eb
	注：push_leaf_right因为移动的是后部分，所以只需要改变right的item.offset
		push_leaf_left移动的是前半部分，所以left和node的item的offset都要改变
	5.如果item所在的node的空间超过了所需要的data_size，返回0
3.如果没有父节点，通过insert_new_root向上提一层
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1525</x>
      <y>2447</y>
      <w>142</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1400.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1282</x>
      <y>2509</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>push_leaf_right</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1266</x>
      <y>2515</y>
      <w>42</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.如果没有path.nodes[1]，返回1
2.如果存储的slot超过了upper的nritems，返回1
3.通过read_node_slot读取upper的slot+1，如果没找到对应的eb，返回1
4.如果找到了eb
	1.通过btrfs_tree_lock和btrfs_set_lock_blocking等待锁
	2.如果right的btrfs_leaf_free_space空间不足，解锁并释放eb，返回1
	3.btrfs_cow_block进行，然后再次检查right的free_space
	4.如果是在left的最后添加，将node[0]换成right，并返回0
		path-&gt;nodes[0] = right;
		path-&gt;slots[0] = 0;
		path-&gt;slots[1]++;
	5.通过__push_leaf_right试着将node[0]中的中的数据复制到
		right的eb中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1286</x>
      <y>2512</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1275</x>
      <y>2541</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_node_slot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1281</x>
      <y>2537</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1263</x>
      <y>2547</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.要读的slot要在0~nritems之前，否则返回NULL
2.通过read_tree_block读取slot中存储的blockptr
3.如果出错，或者读取的eb没有uptodate，返回NULL
	如果是没有uptodate，通过free_extent_buffer将eb释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1279</x>
      <y>2544</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1302</x>
      <y>2541</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__push_leaf_right</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1305</x>
      <y>2537</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1300</x>
      <y>2548</y>
      <w>46</w>
      <h>67</h>
    </coordinates>
    <panel_attributes>1.如果想将左节点删除，将nr=0作为min_slot
	否则最小的nr设置为1
注：这里确定要移到right的最小slot
2.循环遍历node的item直到nr
	1.如果不要求将node清空，并且已经记录了要被转移到right的push_items
		1.不能将小于slot[0]的item移到right
		2.是否移slot[0]的item到right取决于node和right哪边的free_space更大
			如果node更大，就保留到node，否则就移到right
	2.当将slot[0]移到right中时，需要增加其空间
		push_space += data_size//如果slot[0]不在node范围内，在循环之前就相加了
	3.如果将这个item移到right会超过其free_space,退出循环
	4.更新移到right的item及其空间
		push_items++;
		push_space += this_item_size + sizeof(*item);
	5.如果遍历到0item，退出循环（因为i是unsigned的，所以不用循环条件）
	6.i--
	注:push_space记录着需要向right中转移的内存大小
3.如果不需要移到right，跳到out_unlock
4.leaf_data_end返回最后item的offset
注：item.offset是相对item数组的偏移,item.key.offset表示整个文件的offset
5.腾出right数据区，并从left复制
	1.memmove_extent_buffer将数据从right的data_end复制到data_end-push_space
	注：数据到node中是从尾端向前伸展
	2.copy_extent_buffer将left的push_space复制到right的最尾端的push_space
6.memmove_extent_buffer在前面腾出push_items个item的空间
	并且copy_extent_buffer将item从left复制到right
7.btrfs_set_header_nritems设置right.header中的item的数量加上push_items
8.btrfs_set_token_item_offset循环设置每个item.offset
9.通过btrfs_set_header_nritems将left的nritems减去push_items
10.如果还存在left_nritems，通过btrfs_mark_buffer_dirty将eb标记为dirty
	否则通过clean_tree_block清除left的page.dirty
11.btrfs_mark_buffer_dirty标记right的page dirty
12.通过btrfs_item_key提取right.item[0]的key，然后btrfs_set_node_key
	存储到父节点的item[slot+1].key中，并且通过btrfs_mark_buffer_dirty
	标记父节点dirty
13.如果slot[0]超过了left_nritems
	path-&gt;slots[0] -= left_nritems;
	path-&gt;nodes[0] = right;
	path-&gt;slots[1] += 1;
14.btrfs_tree_unlock和free_extent_buffer解锁并释放slot不在的eb，并返回0
15.btrfs_tree_unlock和free_extent_buffer解锁并释放right，返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1308</x>
      <y>2544</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1290</x>
      <y>2618</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memmove_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1298</x>
      <y>2614</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1284</x>
      <y>2625</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.要复制的长度不能超过dst-&gt;len，被复制的段也不能超过dst-&gt;len
2.如果dest的地址低于src的地址，通过memcpy_extent_buffer从前向后复制
3.循环从后向前通过copy_pages复制len长度的数据
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1297</x>
      <y>2621</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1278</x>
      <y>2636</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memcpy_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1285</x>
      <y>2632</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1270</x>
      <y>2643</y>
      <w>34</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.要复制的长度不能超过dst-&gt;len，被复制的段也不能超过dst-&gt;len
2.循环通过copy_pages从src_off_in_page复制数据到dst_off_in_page
	并更新循环变量
	src_offset += cur;
	dst_offset += cur;
	len -= cur
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1284</x>
      <y>2639</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1278</x>
      <y>2657</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1283</x>
      <y>2653</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1269</x>
      <y>2664</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果dst_page和src_page是同一page，通过areas_overlap
	检查两者段是否有重叠的部分，如果重叠使用memmove按字节复制，
	否则直接使用memcpy
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1283</x>
      <y>2660</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1325</x>
      <y>2618</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1331</x>
      <y>2614</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1321</x>
      <y>2625</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.循环通过read_extent_buffer将长度len的数据从
	dst_page[i]+offset读到src+src_offset，并更新循环变量
	src_offset += cur;
	len -= cur;
	offset = 0;
	i++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1333</x>
      <y>2621</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1357</x>
      <y>2618</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_mark_buffer_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1331</x>
      <y>2614</y>
      <w>37</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1357</x>
      <y>2625</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.set_extent_buffer_dirty设置eb.page所有的page为dirty
2.如果之前EXTENT_BUFFER_DIRTY没置上，
	fs_info-&gt;dirty_metadata_bytes+= buf-&gt;len
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1367</x>
      <y>2621</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1394</x>
      <y>2618</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>clean_tree_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1331</x>
      <y>2614</y>
      <w>72</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;700.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1399</x>
      <y>2621</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1392</x>
      <y>2625</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果eb的generation和fs_info-&gt;running_transaction-&gt;transid一致
	1.如果EXTENT_BUFFER_DIRTY置上
		1.dirty_metadata_bytes-=buf-&gt;len
		2.btrfs_set_lock_blocking设置write_lock
		3.clear_extent_buffer_dirty清除page_dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1622</x>
      <y>2484</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>insert_new_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1625</x>
      <y>2490</y>
      <w>50</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.如果是最后一个节点，btrfs_item_key提取btrfs_item.key,
	否则通过btrfs_node_key提取btrfs_key_ptr.key
2.btrfs_alloc_tree_block申请eb，并预留硬盘空间extend
3.root_add_used递增
	root-&gt;root_item.bytes_used+=nodesize
4.设置申请的eb
	1.清空btrfs_header，并设置
		btrfs_header.nritems=1
		btrfs_header.level=level
		btrfs_header.bytenr=c-&gt;start
		btrfs_header.generation=trans-&gt;transid
		btrfs_header.flags=eb | BTRFS_MIXED_BACKREF_REV
		btrfs_header.owner= root-&gt;root_key.objectid
		btrfs_header.fsid=root-&gt;fs_info-&gt;fsid
		btrfs_header.chunk_tree_uuid=fs_info-&gt;chunk_tree_uuid
	2.btrfs_set_node_key设置key
	3.设置eb和leaf的关系
		1.btrfs_set_node_blockptr设置blockptr，
		2.btrfs_set_node_ptr_generation设置gen(lower header中的generation)
	4.btrfs_mark_buffer_dirty将eb标记为dirty
5.tree_mod_log_set_root_pointer申请MOD_LOG_ROOT_REPLACE的log，加入红黑树
6.更新根节点，并通过free_extent_buffer释放原来的根节点
	root-&gt;node=c
7.add_root_to_dirty_list将root加入dirty_cowonly_roots链表
8.extent_buffer_get(c);
	path-&gt;nodes[level] = c;
	path-&gt;locks[level] = BTRFS_WRITE_LOCK_BLOCKING;
	path-&gt;slots[level] = 0;
9.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1627</x>
      <y>2487</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1589</x>
      <y>2540</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_alloc_tree_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1597</x>
      <y>2538</y>
      <w>51</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1593</x>
      <y>2546</y>
      <w>43</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.如果是dummy_root，通过btrfs_init_new_buffer申请alloc_bytenr处的eb
	调整alloc_bytenr，并返回
	root-&gt;alloc_bytenr += blocksize
2.通过use_block_rsv在对应的block_rsv中预留空间
3.btrfs_reserve_extent预留并寻找硬盘空间ins
4.btrfs_init_new_buffer申请ins对应的eb
5.如果root是BTRFS_TREE_RELOC_OBJECTID
	1.如果没有parent
		parent = ins.objectid
	2.将flags的BTRFS_BLOCK_FLAG_FULL_BACKREF置上
6.如果root不是BTRFS_TREE_LOG_OBJECTID
	1.btrfs_alloc_delayed_extent_op申请extent_op
		并通过传参key初始化extent_op-&gt;key
		extent_op-&gt;flags_to_set = flags;
		extent_op-&gt;update_key=!!skinny_metadata
		extent_op-&gt;update_flags = 1;
		extent_op-&gt;is_data = 0;
		extent_op-&gt;level = level
	2.btrfs_add_delayed_tree_ref申请head_ref和ref加入trans链表
7.返回eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1454</x>
      <y>2589</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_init_new_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1462</x>
      <y>2580</y>
      <w>142</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1400.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1448</x>
      <y>2596</y>
      <w>36</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.通过btrfs_find_create_tree_block创建在bytenr中的eb和page
2.通过btrfs_set_header_generation设置btrfs_header.generation为trans-&gt;transid
3.lock和状态设置
	1.btrfs_set_buffer_lockdep_class和btrfs_tree_lock等待并设置lock
	2.clean_tree_block如果transid一致，清除EXTENT_BUFFER_DIRTY
	3.清除buf的EXTENT_BUFFER_STALE
	4.btrfs_set_lock_blocking
	5.btrfs_set_buffer_uptodate设置buf和其中page uptodate
4.如果root的objectid是BTRFS_TREE_LOG_OBJECTID
	1.buf-&gt;log_index = root-&gt;log_transid % 2
	2.如果log_index是0，设置dirty_log_pages中buf段为EXTENT_DIRTY
		否则将其设置为EXTENT_NEW
5.如果不是log_object
	1.buf-&gt;log_index = -1;
	2.设置transaction-&gt;dirty_pages的buf段为EXTENT_DIRTY
6.trans-&gt;blocks_used++
7.返回buf
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1462</x>
      <y>2592</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1459</x>
      <y>2629</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_extent_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1464</x>
      <y>2624</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1464</x>
      <y>2632</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
EXTENT_DIRTY</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1458</x>
      <y>2636</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_extent_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1458</x>
      <y>2643</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__set_extent_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1463</x>
      <y>2639</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1443</x>
      <y>2650</y>
      <w>48</w>
      <h>89</h>
    </coordinates>
    <panel_attributes>1.将bit的EXTENT_FIRST_DELALLOC置上
2.again
	1.如果没有prealloc，并且允许blocking(__GFP_DIRECT_RECLAIM),通过
		alloc_extent_state申请prealloc
	2.如果有cache_state，如果start在state-&gt;start~ state-&gt;end范围内
		并且state在红黑树中，跳到hit_next
		node = &amp;state-&gt;rb_node;
	3.tree_search_for_insert在tree.state中寻找start
	4.如果没找到node
		1.通过alloc_extent_state_atomic申请prealloc
		2.insert_state将state插入到红黑树中，并设置bit
		3.cache_state如果在EXTENT_IOBITS | EXTENT_BOUNDARY置上的时候
			将state存储到cached_state中
		4.重置prealloc，并跳到out
	5.如果找到 hit_next
		1.如果start相同，end超过了state范围
			1.如果不被预期的exclusive_bits置上，跳到out，返回EEXIST
				*failed_start = state-&gt;start
			2.set_state_bits置上state要求的bit，并根据情况插入到changeset
			3.cache_state将state缓存到cached_state，并且通过merge_state看是否能将红黑树中的state合并
			4.如果next_state和之前紧挨着，更换start，重新跳到hit_next，重新设置
				start = last_end + 1
			5.否则跳到search_again
		2.如果start大于state.start
			1.如果不被预期的exclusive_bits置上，跳到out，返回EEXIST
				*failed_start = state-&gt;start
			2.alloc_extent_state_atomic申请prealloc
			3.split_state让prealloc继承state的前半部分，并将prealloc置空
			4.如果end超过了start.end，将
				1.set_state_bits将需要置上的bit置上
				2.cache_state缓存state到cached_state，merge_state将红黑树中的state合并
				3.如果next_state和之前紧挨着，更换start，重新跳到hit_next，重新设置
					start = last_end + 1
			5.跳到search_again
		3.如果start在state.start之前
			1.首先this_end指向start之前所要的段
			2.alloc_extent_state_atomic申请prealloc
			3.将所期望的段在state前面的部分，通过insert_state插入到tree.state中
			4.insert_state缓存state，并释放prealloc
			5.调整start，并重新search_again
				start = this_end + 1
		注：前面改变的是start的位置(这里serch，绝对导致start&lt;state.end)，后面改变的是end的wei'zhi
		4.如果state.starte&lt;=end&lt;=state.end（这里2.5.3，start&gt;=state.start）（和条件1，改变了end的位置）
			1.如果不被预期的exclusive_bits置上，跳到out，返回EEXIST
				*failed_start = state-&gt;start
			2.split_state将prealloc设置为state的前半部分，并插到红黑树中
			3.set_state_bits设置状态，cache_state缓存prealloc，merge_state
				进行红黑树的合并
			4.释放prealloc，跳到out
		5.跳到search_again
3.out：如果存在prealloc，将其释放，并返回err
4.search_again：
	1.如果range遍历完成，跳到out
	2.如果gfpflags_allow_blocking，允许调度
	3.跳到again，重新查找段
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1463</x>
      <y>2646</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1432</x>
      <y>2742</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_extent_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1437</x>
      <y>2738</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1421</x>
      <y>2749</y>
      <w>28</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.通过kmem_cache_alloc申请extent_state
2.初始化
	state-&gt;state = 0;
	state-&gt;private = 0;
	state-&gt;leak_list加入到链表states
	state-&gt;refs=1
	初始化state-&gt;wq
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1437</x>
      <y>2745</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1459</x>
      <y>2742</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>insert_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1464</x>
      <y>2738</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1452</x>
      <y>2749</y>
      <w>37</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.state-&gt;start = start;
	state-&gt;end = end;
2.set_state_bits创建state对应的ulist_node插入到changeset，并设置state-&gt;state
3.通过tree_insert将state插入到红黑树tree-&gt;state中
4.如果有相同的ndoe，返回EEXIST
5.merge_state查看红黑树中的node是否能合并
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1447</x>
      <y>2763</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_state_bits</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1464</x>
      <y>2745</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1453</x>
      <y>2759</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1436</x>
      <y>2770</y>
      <w>34</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.清除要设置bit中的EXTENT_CTLBITS
2.set_state_cb
3.如果之前EXTENT_DIRTY没置上，现在需要置
	tree-&gt;dirty_bytes += range
4.add_extent_changeset添加node到changeset中
5.state-&gt;state |= bits_to_set
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1452</x>
      <y>2766</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1445</x>
      <y>2782</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_extent_changeset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1452</x>
      <y>2779</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1433</x>
      <y>2789</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果不存在changeset，直接返回
2.如果state和要求bits相同，直接返回
3.changeset-&gt;bytes_changed +=range
4.ulist_add创建node插入到红黑树
	changeset-&gt;range_changed中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1452</x>
      <y>2785</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1441</x>
      <y>2801</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ulist_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1441</x>
      <y>2808</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ulist_add_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1446</x>
      <y>2797</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1446</x>
      <y>2804</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1445</x>
      <y>2811</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1429</x>
      <y>2815</y>
      <w>33</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.ulist_rbtree_search在ulist寻找val
2.如果找到对应的node，
	1.如果要求返回之前的end，通过old_aux返回
	2.返回0
3.申请node
	node-&gt;val = val;
	node-&gt;aux = aux;
4.ulist_rbtree_insert将node插入到红黑树中，并且
	插入到链表ulist-&gt;nodes中
	ulist-&gt;nnodes++
5.返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1475</x>
      <y>2763</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>merge_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1480</x>
      <y>2759</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1472</x>
      <y>2770</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果state的EXTENT_IOBITS | EXTENT_BOUNDARY置上，直接返回
2.如果rb_prev和state可以合并，将两者合并，然后将prev从红黑树中移除
	并释放prev
3.如果有rb_next可以和state合并，将两个段合并，然后将next从红黑树
	中移除，并释放next
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1480</x>
      <y>2766</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1501</x>
      <y>2742</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>split_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1482</x>
      <y>2738</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1496</x>
      <y>2750</y>
      <w>21</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.split_cb
2.prealloc继承orig前半部分
	prealloc-&gt;start = orig-&gt;start;
	prealloc-&gt;end = split - 1;
	prealloc-&gt;state = orig-&gt;state
3.调整orig
	orig-&gt;start = split
4.tree_insert插入prealloc
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1506</x>
      <y>2745</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1598</x>
      <y>2543</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1495</x>
      <y>2589</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>use_block_rsv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1500</x>
      <y>2580</y>
      <w>104</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1020.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1486</x>
      <y>2596</y>
      <w>43</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.get_block_rsv获取block_rsv，如果size为0，跳到try_reserve
2.如果有足够的空间直接返回block_rsv
3.如果failfast，返回
4.如果BTRFS_BLOCK_RSV_GLOBAL，并且之前没更新，通过update_global_block_rsv
	更新，并跳到2重新查看空间
5.try_reserve
	1.reserve_metadata_bytes
	2.如果不是BTRFS_BLOCK_RSV_GLOBAL，并且space_info是global_rsv-&gt;space_info
		通过block_rsv_use_bytes向global_rsv申请
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1501</x>
      <y>2592</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1487</x>
      <y>2616</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_block_rsv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1492</x>
      <y>2611</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1486</x>
      <y>2623</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.以下情况下取trans-&gt;block_rsv
	1.root的BTRFS_ROOT_REF_COWS置上
	2.root是csum_root，并且adding_csums
	3.root是uuid_root
2.否则取root-&gt;block_rsv
3.否则取root-&gt;fs_info-&gt;empty_block_rsv
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1493</x>
      <y>2619</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1517</x>
      <y>2616</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_rsv_use_bytes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1520</x>
      <y>2611</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1516</x>
      <y>2623</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果reserved超过要求的bytes
	1.block_rsv-&gt;reserved -= num_bytes
	2.如果block_rsv的reserved低于其size
		block_rsv-&gt;full = 0;
	3.返回0
2.返回ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1526</x>
      <y>2619</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1552</x>
      <y>2617</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>update_global_block_rsv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1527</x>
      <y>2611</y>
      <w>36</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1544</x>
      <y>2624</y>
      <w>45</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.calc_global_metadata_size计算extend_tree,checksum_tree和root_tree的空间
2.用这个空间更新block_rsv-&gt;size，不能低于52M
3.如果sinfo.total_bytes超过了已经所有的空间
	block_rsv-&gt;reserved += num_bytes;
	sinfo-&gt;bytes_may_use += num_bytes;
4.如果block_rsv.reserved超过了其size
	1.sinfo-&gt;bytes_may_use -= num_bytes
	2.block_rsv-&gt;reserved = block_rsv-&gt;size;
		block_rsv-&gt;full = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1561</x>
      <y>2620</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1536</x>
      <y>2642</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>calc_global_metadata_size</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1545</x>
      <y>2638</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1602</x>
      <y>2587</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_reserve_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1605</x>
      <y>2580</y>
      <w>3</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1591</x>
      <y>2594</y>
      <w>38</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.btrfs_get_alloc_profile获取配置
2.find_free_extent查找空间充足的extend
3.如果返回ENOSPC
	1.如果还没final_tried，并且返回最大extend空间
		1.申请size   num_bytes/2(max_size)&lt;=size&lt;min_alloc_size
		2.如果到达了min_alloc_size
			final_tried = true
		3.跳到2，重新申请
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1609</x>
      <y>2590</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1594</x>
      <y>2613</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_get_alloc_profile</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1601</x>
      <y>2608</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1590</x>
      <y>2620</y>
      <w>36</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果是data，BTRFS_BLOCK_GROUP_DATA
2.如果是chunk_root，BTRFS_BLOCK_GROUP_SYSTEM
3.其他情况，BTRFS_BLOCK_GROUP_METADATA
4.get_alloc_profile
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1601</x>
      <y>2616</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1599</x>
      <y>2631</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_alloc_profile</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1604</x>
      <y>2627</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1588</x>
      <y>2638</y>
      <w>39</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.seq_lock读下面变量，如果发现seq有更改说明写了，循环读
	1.如果BTRFS_BLOCK_GROUP_DATA，将avail_data_alloc_bits置上
	2.如果BTRFS_BLOCK_GROUP_SYSTEM，将avail_system_alloc_bits置上
	3.如果BTRFS_BLOCK_GROUP_METADATA，将avail_metadata_alloc_bits置上
2.btrfs_reduce_alloc_profile
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1603</x>
      <y>2634</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1597</x>
      <y>2651</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_reduce_alloc_profile</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1604</x>
      <y>2647</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1645</x>
      <y>2612</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_free_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1623</x>
      <y>2608</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1636</x>
      <y>2615</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1628</x>
      <y>2619</y>
      <w>40</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.__find_space_info遍历链表root-&gt;fs_info-&gt;space_info，找到
	和flags一致的space_info
2.如果space_info.max_extent_size存在
	1.如果申请的空间超过了max_extent_size，返回最大空间和ENOSPC
		ins-&gt;offset = space_info-&gt;max_extent_size
	2.否则
		use_cluster = false
3.通过fetch_cluster_info获取cluster，如果找到
	1.如果存在block_group
		hint_byte = last_ptr-&gt;window_start
	2.如果fragmented
		hint_byte = last_ptr-&gt;window_start;
		use_cluster = false;
4.search_start是hint_byte和first_logical_byte的最大值
5.如果hint_byte是这个最大值
	1.btrfs_lookup_block_group找到包含search_start的block_group
	2.如果找到了block_group，其flag和要求的一致，并且cached不是BTRFS_CACHE_NO
		1.如果其链表block_group-&gt;list是空，或者ro(readonly?)将block_group释放
		2.通过get_block_group_index获取其raid_index,并跳到have_block_group
	3.如果其他情况不一致，直接将block_group释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1591</x>
      <y>2659</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fetch_cluster_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1580</x>
      <y>2666</y>
      <w>41</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果是btrfs_mixed_space_info(METADATA &amp;&amp;  DATA),返回NULL
3.如果是METADATA
	ret=meta_alloc_cluster
	empty_cluster=64k//不是ssd,是ssd则是2M
4.DATA，并且是ssd
	ret=data_alloc_cluster
	empty_cluster=2M
5.其他情况
	ret=NULL
	empty_cluster=2M//是ssd
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1596</x>
      <y>2662</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1629</x>
      <y>2659</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>first_logical_byte</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1634</x>
      <y>2662</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1623</x>
      <y>2666</y>
      <w>38</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.获取缓存fs_info-&gt;first_logical_byte，如果有效，直接返回
2.btrfs_lookup_first_block_group找最小block_group的cache(传参是0)
3.获取其起始byte，并通过btrfs_put_block_group释放cache
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1625</x>
      <y>2676</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_lookup_first_block_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1634</x>
      <y>2671</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1616</x>
      <y>2691</y>
      <w>44</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.遍历红黑树fs_info.block_group_cache_tree
	1.如果contain=0，ret记录不包含bytenr的最小node
	2.如果contain=1,ret记录包含bytenr的node
	3.如果找到start相同的node，ret则是改node
2.如果有ret
	1.通过btrfs_get_block_group递增cache.count
	2.如果是从0开始查找，first_logical_byte超过了cache的起始objectid，记录
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1634</x>
      <y>2679</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
0</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1652</x>
      <y>2655</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_lookup_block_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1652</x>
      <y>2661</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_group_cache_tree_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1624</x>
      <y>2684</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_group_cache_tree_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1634</x>
      <y>2687</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1662</x>
      <y>2658</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1649</x>
      <y>2652</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1635</x>
      <y>2652</y>
      <w>7</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1599</x>
      <y>2652</y>
      <w>43</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1651</x>
      <y>2614</y>
      <w>148</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
search</panel_attributes>
    <additional_attributes>10.0;20.0;1460.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1789</x>
      <y>2617</y>
      <w>39</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.如果index(之前获取flag的raid)为0，或者其index没发生改变
	full_search = true
2.遍历链表space_info-&gt;block_groups[index]
	1.btrfs_grab_block_group递增block_group计数，并且根据delalloc是否申请data_rwsem
	2.如果flag在extra上不一致（用户要求，但是没提供），跳到loop，继续下一个block_group
	3.have_block_group
		1.确定block_group(数组中的，last_ptr中的？)
		2.当cluster不满足要求，要release_cluster，并加以填充
		3.如果cluster中不能申请，unclustered_alloc直接从block_group中申请
		4.如果成功申请到free_space，checks
3.如果CACHING_NOWAIT，并且期间有cached
	orig_have_caching_bg = true
4.如果没找到，并且CACHING_WAIT，期间有cached(have_caching_bg),跳到search
5.如果没找到，index低于BTRFS_NR_RAID_TYPES，递增index之后，跳到search
6.如果没找到，loop没超过限制
	1.index = 0
	2.如果是CACHING_NOWAIT 
		1.如果期间有被cache(orig_have_caching_bg)，或者没有full_search
			状态变为CACHING_WAIT，否则为ALLOC_CHUNK
	3.否则loop++
	4.如果是ALLOC_CHUNK
		1.查看current-&gt;journal_info是否存在，如果不存在，通过btrfs_join_transaction开启trans
		2.通过do_chunk_alloc申请chunk，如果ENOSPC，LOOP_NO_EMPTY_SIZE
		3.如果出错，但是不是ENOSPC，btrfs_abort_transaction，否则返回0
		4.如果join_transaction,btrfs_end_transaction
		5.如果出错，跳到out
	5.如果LOOP_NO_EMPTY_SIZE
		1.如果empty_size和empty_cluster，返回ENOSPC
		2.否则将empty清空，在search一遍
			empty_size = 0;
			empty_cluster = 0
	6.跳到search
7.如果没找到，loop超过限制，返回ENOSPC
8.如果找到
	1.若是在cluster申请
		last_ptr-&gt;window_start = ins-&gt;objectid
	2.返回0
9.如果ENOSPC
	space_info-&gt;max_extent_size = max_extent_size
	ins-&gt;offset = max_extent_size	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1714</x>
      <y>2652</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>have_block_group
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1720</x>
      <y>2650</y>
      <w>77</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>750.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1714</x>
      <y>2659</y>
      <w>32</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.如果没有cached(cached:BTRFS_CACHE_FINISHED   BTRFS_CACHE_ERROR)
	1.have_caching_bg = true
	2.cache_block_group加载blockgroup的free_space的inode，并加载free_space到caching_ctl
2.错误检查，如果不通过，跳到loop，继续下一个block_group
	1.不能有BTRFS_CACHE_ERROR
	2.不能是read_only（block_group-&gt;ro）
3.如果使用cluster
	1.btrfs_lock_cluster找到last_ptr对应的block_group
	2.如果找到，跳到refill_cluster
	3.如果找到的和block_group不同，并且
		是read_only或者和要求的flag不同
		跳到release_cluster
	4.btrfs_alloc_from_cluster以链表方式遍历红黑树last_ptr.root
		申请extend
	5.如果成功申请
		1.btrfs_release_block_group要将之前找到的block_group释放
			block_group = used_block_group
		2.跳到checks
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1719</x>
      <y>2655</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1663</x>
      <y>2694</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cache_block_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1667</x>
      <y>2687</y>
      <w>52</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>500.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1662</x>
      <y>2701</y>
      <w>46</w>
      <h>76</h>
    </coordinates>
    <panel_attributes>1.申请caching_ctl，并初始化
	caching_ctl-&gt;block_group = cache;
	caching_ctl-&gt;progress = cache-&gt;key.objectid;
	atomic_set(&amp;caching_ctl-&gt;count, 1);
	btrfs_init_work(&amp;caching_ctl-&gt;work, btrfs_cache_helper,
			caching_thread, NULL, NULL);
2.如果cached状态是BTRFS_CACHE_FAST，循环等待cache-&gt;caching_ctl.wait被唤醒
3.如果不是BTRFS_CACHE_NO，将申请的caching_ctl释放，并返回0
4.关联cache和cache_control
	cache-&gt;caching_ctl = caching_ctl;
	cache-&gt;cached = BTRFS_CACHE_FAST;
5.如果在挂载时，BTRFS_MOUNT_SPACE_CACHE置上
	1.load_free_space_cache加载cache到caching_ctl
	2.如果返回1，表示成功加载
		1.cache-&gt;caching_ctl = NULL;
			cache-&gt;cached = BTRFS_CACHE_FINISHED;
			cache-&gt;last_byte_to_unpin = (u64)-1;
			caching_ctl-&gt;progress = (u64)-1;
	3.如果没加载
		1.如果只是load_cache_only
			cache-&gt;caching_ctl = NULL;
			cache-&gt;cached = BTRFS_CACHE_NO;
		2.否则
			cache-&gt;cached = BTRFS_CACHE_STARTED;
			cache-&gt;has_caching_ctl = 1;
	4.唤醒caching_ctl-&gt;wait
	5.如果成功加载
		1.put_caching_control递减caching_ctl计数，必要时释放
		2.free_excluded_extents清除freed_extents数组EXTENT_UPTODATE标志
		3.返回0
6.否则
	1.如果只是load_cache_only
			cache-&gt;caching_ctl = NULL;
			cache-&gt;cached = BTRFS_CACHE_NO;
	2.否则
		cache-&gt;cached = BTRFS_CACHE_STARTED;
		cache-&gt;has_caching_ctl = 1;
	3.唤醒caching_ctl-&gt;wait
7.如果是load_cache_only
	1.put_caching_control释放caching_ctl，并返回0
8.否则
	1.递增caching_ctl-&gt;count，并将caching_ctl.list加入链表caching_block_groups
	2.btrfs_get_block_group增加cache计数
	3.btrfs_queue_work将caching_ctl-&gt;work加入队列caching_workers
	4.返回ret
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1671</x>
      <y>2697</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1616</x>
      <y>2780</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>load_free_space_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1627</x>
      <y>2776</y>
      <w>41</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1601</x>
      <y>2787</y>
      <w>41</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.如果disk_cache_state被标记为清除或不被trust(!BTRFS_DC_WRITTEN)，返回0
2.btrfs_alloc_path申请path
	path-&gt;search_commit_root = 1;
	path-&gt;skip_locking = 1;
3.lookup_free_space_inode获取对应block_group-&gt;key.objectid偏移的inode
4.如果上锁之后，发现disk_cache_state不在BTRFS_DC_WRITTEN，释放path之后，跳到out
5.__load_free_space_cache读取inode的free_space信息插入到ctl-&gt;free_space_offset
6.如果ctl-&gt;free_space和block_group的记录不同
	1.__btrfs_remove_free_space_cache将cluster_list和红黑树中ctl-&gt;free_space_offset
		的元素btrfs_free_space全部释放
7.out:
	1.如果失败
		1.block_group-&gt;disk_cache_state = BTRFS_DC_CLEAR
	2.释放inode，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1623</x>
      <y>2783</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1592</x>
      <y>2813</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_free_space_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1601</x>
      <y>2809</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1583</x>
      <y>2820</y>
      <w>37</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果block_group-&gt;inode不是I_FREEING|I_WILL_FREE，直接返回
2.__lookup_free_space_inode获取偏移为block_group-&gt;key.objectid的inode
注：1.block_group中btrfs_key中object_id是block_group的offset，offset是size
	2.如果偏移不在范围内，btrfs_search_slot找offset较大的eb
3.如果inode的BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW没全置上
	BTRFS_I(inode)-&gt;flags |= BTRFS_INODE_NODATASUM |
			BTRFS_INODE_NODATACOW;
	block_group-&gt;disk_cache_state = BTRFS_DC_CLEAR;
4.如果block_group-&gt;iref没置上
	block_group-&gt;inode = igrab(inode);
	block_group-&gt;iref = 1;
5.返回inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1598</x>
      <y>2816</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1592</x>
      <y>2840</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__lookup_free_space_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1601</x>
      <y>2836</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1579</x>
      <y>2847</y>
      <w>42</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.通过btrfs_search_slot查找下面的key
	key.objectid = BTRFS_FREE_SPACE_OBJECTID;
	key.offset = offset;
	key.type = 0;
2.btrfs_item_ptr是slot对应的数据
3.以btrfs_free_space_header解析header，读取header.location到disk_key中
4.btrfs_release_path释放path
5.btrfs_iget根据location获取inode
6.错误处理
	1.没有申请到inode，返回ENOENT
	2.如果出错，直接返回错误
	3、如果是is_bad_inode，释放inode，并返回ENOENT
7.mapping_set_gfp_mask将inode-&gt;i_mapping.flags
	的__GFP_FS | __GFP_HIGHMEM清掉
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1601</x>
      <y>2843</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1181</x>
      <y>2452</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1084</x>
      <y>2454</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_nodes_for_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1092</x>
      <y>2446</y>
      <w>75</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>730.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1074</x>
      <y>2461</y>
      <w>47</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.如果满足以下两个条件
	1)search_for_split或者需要插入数据ins_len
	2)eb.nritems到达了限制
	1.write_lock_level不能小于level+1，否则调整并释放path，返回EAGAIN
	2.btrfs_set_path_blocking设置blocking
	3.reada_for_balance对左右node进行预读
	4.split_node
	5.btrfs_clear_path_blocking清除blocking
	6.如果出错，返回错误，否则获取p-&gt;nodes[level]，返回0
2.如果满足以下条件
	1）如果要删除data，
	2)eb的free_space小于总大小的一半
	1.write_lock_level不能小于level+1，否则调整并释放path，返回EAGAIN
	2.btrfs_set_path_blocking设置blocking
	3.reada_for_balance对左右node进行预读
	4.balance_level根据item的数量进行合并(主要向左合并)，并尽量递减level
	5.btrfs_clear_path_blocking清除blocking
	6.如果出错，返回错误，否则获取p-&gt;nodes[level]，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1093</x>
      <y>2457</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1017</x>
      <y>2495</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reada_for_balance</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1024</x>
      <y>2490</y>
      <w>65</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>630.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1006</x>
      <y>2502</y>
      <w>35</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.找到父节点所在的eb(parent)和所在的item(slot)
2.如果slot&gt;0
	1.找slot-1的blockptr和gen，通过btrfs_find_tree_block
	在buffer_radix找到对应的子eb
	2.如果已经更新并且检查通过，不再读
	3.并且通过free_extent_buffer释放eb
3.再读slot+1
	1.同样获取slot+1的blockptr和gen，通过btrfs_find_tree_block
		查找
	2.如果找到，并且更新和验证通过，不在读
	3.通过free_extent_buffer释放
4.上述两个block如果需要读，通过readahead_tree_block读取
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1023</x>
      <y>2498</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1009</x>
      <y>2525</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>readahead_tree_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1017</x>
      <y>2521</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>999</x>
      <y>2532</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.btrfs_find_create_tree_block查找或者创建eb
2.read_extent_buffer_pages读取eb
3.free_extent_buffer释放eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1015</x>
      <y>2528</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1046</x>
      <y>2495</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>split_node</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1051</x>
      <y>2490</y>
      <w>40</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>380.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1043</x>
      <y>2502</y>
      <w>38</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.如果所在的level是root，通过insert_new_root插入新的root
2.否则通过push_nodes_for_insert将node中item移到left或者right中
	如果成功将node的item数量腾出来，即返回
3.btrfs_node_key读取node的key
4.btrfs_alloc_tree_block申请eb和extent
	1.root_add_used递增root.root_item.bytes_used
	2.	清空split的btrfs_header
		btrfs_header.level=btrfs_header_level(c)
		btrfs_header.bytenr=split-&gt;start
		btrfs_header.generation=trans-&gt;transid
		btrfs_header.flags=eb | BTRFS_MIXED_BACKREF_REV
		btrfs_header.owner= root-&gt;root_key.objectid
		btrfs_header.fsid=root-&gt;fs_info-&gt;fsid
		btrfs_header.chunk_tree_uuid=fs_info-&gt;chunk_tree_uuid
5.tree_mod_log_eb_copy记录log，如果失败，通过btrfs_abort_transaction
	结束trans，并返回
6.通过copy_extent_buffer将c中一半的item(这里可以看出这个函数不适用于leaf)复制到split中,
	并通过btrfs_mark_buffer_dirty标记c和split为dirty
	split.btrfs_header.nritems=c_nritems - mid
	c.btrfs_header.nritems=c_nritems - mid
7.insert_ptr将split插入到parent.slot[level+1]+1的slot中
8.如果原来在c的右边
	1.更新path
		path-&gt;slots[level] -= mid;
		path-&gt;nodes[level] = split;
		path-&gt;slots[level + 1] += 1;
	2.free_extent_buffer释放对c的应用
9.如果在c的左边，直接通过free_extent_buffer释放对split的引用
10.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1051</x>
      <y>2498</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1112</x>
      <y>2494</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>balance_level</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1101</x>
      <y>2490</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1086</x>
      <y>2501</y>
      <w>44</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.level为0，直接返回0
2.如果有父节点，获取其parent
	parent = path-&gt;nodes[level + 1];
	pslot = path-&gt;slots[level + 1];
3.如果父节点不存在
	1.如果该节点的item不止一个，返回0
	2.read_node_slot读取改item对应的eb
	3.如果没读到，返回EROFS，跳到enospc
	4.btrfs_tree_lock，btrfs_set_lock_blocking和btrfs_cow_block设置锁
	5.tree_mod_log_set_root_pointer申请log插入红黑树
	6.将root变换为child
		root-&gt;node=child
	7.clean_tree_block和btrfs_tree_unlock解锁
	8.释放mid
		1.free_extent_buffer递减mid计数
		2.root_sub_used设置
			root.root_item.bytes_used -=size
		3.free_extent_buffer_stale真正释放mid
	9.返回0

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1095</x>
      <y>2497</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1104</x>
      <y>2537</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tree_mod_log_set_root_pointer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1103</x>
      <y>2544</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tree_mod_log_insert_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1112</x>
      <y>2540</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1094</x>
      <y>2551</y>
      <w>43</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.tree_mod_need_log检查不需要log，返回0
2.需要移除log，并且old_root.level&gt;0
	1.申请数组tm_list
	2.alloc_tree_mod_elem对old_root申请tm
		tm_list[i] =i
3.kzalloc申请tm并初始化
	tm-&gt;index = new_root-&gt;start &gt;&gt; PAGE_CACHE_SHIFT;
	tm-&gt;old_root.logical = old_root-&gt;start;
	tm-&gt;old_root.level = btrfs_header_level(old_root);
	tm-&gt;generation = btrfs_header_generation(old_root);
	tm-&gt;op = MOD_LOG_ROOT_REPLACE;
4.如果存在tm_list，通过__tree_mod_log_free_eb
5.如果插入成功。在将tm通过__tree_mod_log_insert插入到红黑树
6.如果中间失败，跳到free_tms
7.释放tm_list，并返回
8.free_tms：
	1.释放tm_list中所有的tm释放，并释放tm_list
	2.释放单独申请的tm
	3.返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1111</x>
      <y>2547</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1038</x>
      <y>2590</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tree_mod_need_log</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1043</x>
      <y>2581</y>
      <w>56</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>540.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1029</x>
      <y>2597</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.以下情况返回0
	1.链表tree_mod_seq_list为空
	2.eb的level为0
2.其他情况返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1042</x>
      <y>2593</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1057</x>
      <y>2590</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_tree_mod_elem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1065</x>
      <y>2581</y>
      <w>36</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1054</x>
      <y>2597</y>
      <w>34</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.申请tm
2.tm-&gt;index = eb-&gt;start &gt;&gt; PAGE_CACHE_SHIFT
3.如果操作不是MOD_LOG_KEY_ADD
	1.btrfs_node_key读取slot的key到tm-&gt;key中
	2.tm-&gt;blockptr记录slot的blockptr
4.tm-&gt;op = op;
	tm-&gt;slot = slot;
	tm-&gt;generation = btrfs_node_ptr_generation
	RB_CLEAR_NODE(&amp;tm-&gt;node)//红黑树初始化
5.返回tm
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1064</x>
      <y>2593</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1093</x>
      <y>2587</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tree_mod_dont_log</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1099</x>
      <y>2581</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1090</x>
      <y>2594</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.以下情况返回1
	1.tree_mod_seq_list链表为空
	2.eb的level为0
	3.上锁后tree_mod_seq_list为空
2.其他情况返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1101</x>
      <y>2590</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1123</x>
      <y>2586</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__tree_mod_log_free_eb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1117</x>
      <y>2593</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.遍历tm_list
	1.__tree_mod_log_insert将tm插入到红黑树tree_mod_log
	2.如果tm存在，将之前插入的节点删除，并返回
2.如果成功插入，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1132</x>
      <y>2589</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1130</x>
      <y>2581</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1118</x>
      <y>2604</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__tree_mod_log_insert</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1125</x>
      <y>2600</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1108</x>
      <y>2611</y>
      <w>36</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.btrfs_inc_tree_mod_seq设置tm-&gt;seq为tree_mod_seq
	并递增tree_mod_seq
2.将tm插入到红黑树tree_mod_seq中按照tm-&gt;index 和tm-&gt;seq
3.如果tm在红黑树中存在，返回EEXIST，否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1126</x>
      <y>2607</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1112</x>
      <y>2531</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1159</x>
      <y>2503</y>
      <w>39</w>
      <h>79</h>
    </coordinates>
    <panel_attributes>4.如果parent存在
	1.如果mid的item超过了1/4,返回0
	2.read_node_slot读left(parent的pslot-1),
		和right(parent的pslot+1)，并对两者上锁
	3.如果left存在，通过push_node_left将mid的item移到left(如果能清空，需要将mid清空)
		并更改orig_slot相对于left偏移
	4.如果right存在
		1.通过push_node_left将right的item移到mid(如果能清空right，将其清空)
		2.如果right被清空
			1.del_ptr
			2.root_sub_used设置root的bytes_used
				root.root_item.bytes_used -=right-&gt;len
			3.free_extent_buffer_stale释放right
		3.如果没被清空
			1.btrfs_node_key提取right.slot[0]的key
			2.tree_mod_log_set_node_key记录log parent.slot[pslot+1]
				MOD_LOG_KEY_REPLACE
			3.btrfs_set_node_key通过right_key设置pslot+1的key
			4.btrfs_mark_buffer_dirty标记parent dirty
	5.如果mid还有1个item
		1.如果不存在left，必然从right中移动一部分到mid，所以不可能为1，返回EROFS
		2.balance_node_right将left的item移到mid
		3.如果没有足够的item，通过push_node_left将mid的item移到left
	6.如果mid的item被移完
		1.del_ptr删除mid
		2.root_sub_used递减root.root_item.bytes_used中mid的长度
		3.free_extent_buffer_stale释放mid
			mid=NULL
	7.如果mid还存在item
		1.btrfs_node_key提取mid.slot[0]的key
		2.tree_mod_log_set_node_key记录parent.slot[pslot]key的变化
		3.btrfs_set_node_key设置parent.slot[pslot]key
		4.btrfs_mark_buffer_dirty标记parent dirty
	8.如果left存在
		1.如果slot到了left中
			1.extent_buffer_get增加left计数
			2.path-&gt;nodes[level] = left;
				path-&gt;slots[level + 1] -= 1;
				path-&gt;slots[level] = orig_slot;
			3.如果mid还存在，free_extent_buffer递减mid计数
		2.如果还在mid中，更新其path.slot
			orig_slot -= btrfs_header_nritems(left);
			path-&gt;slots[level] = orig_slot
	9.如果发现path中slot指向的blockptr和之前不一致，博爱错
	10.enospc
		1.如果right存在，free_extent_buffer递减right家属
		2.如果left存在
			1.只有在left没被path引用时才解锁
			2.free_extent_buffer递减left计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1117</x>
      <y>2497</y>
      <w>54</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;520.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1166</x>
      <y>2585</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>push_node_left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1170</x>
      <y>2581</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1153</x>
      <y>2592</y>
      <w>42</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果不把src清空，并且src的item数小于8，直接返回1
2.如果能移到left的item数量小于0，返回1
3.确定push_items
	1.如果要清空src
		1.push_items不能超过src_item
		2.如果src没全部移除，至少给src保留8个item，否则直接返回1
	2.如果不需要清空，push_items不能超过src_item-8
4.tree_mod_log_eb_copy将item的移动log记录到红黑树中
5.copy_extent_buffer移动btrfs_key_ptr到dst中
6.如果src没全部移除，通过memmove_extent_buffer将src中
	item调整其位置
7.btrfs_set_header_nritems重新设置dst和src的item数量
8.btrfs_mark_buffer_dirty标记dst和src dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1172</x>
      <y>2588</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1162</x>
      <y>2617</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tree_mod_log_eb_copy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1169</x>
      <y>2613</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1156</x>
      <y>2624</y>
      <w>39</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.tree_mod_need_log检查不需要log，即返回0
2.如果dst和src的level是0，返回0
3.申请数组tm_list
4.通过alloc_tree_mod_elem申请tm，src的放到tm_list_rem中
	dst放到tm_list_add
5.tree_mod_dont_log检查是否需要log，并上锁
6.通过__tree_mod_log_insert将tm_list_rem和tm_list_add
	插入到红黑树中
7.释放tm_list，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1172</x>
      <y>2620</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1240</x>
      <y>2586</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>balance_node_right</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1196</x>
      <y>2581</y>
      <w>54</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;520.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1240</x>
      <y>2593</y>
      <w>37</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果不能移动，返回1
2.如果src数量小于4个，返回1
3.最多只能移动src/2，但是不能清空src，否则返回1
4.tree_mod_log_eb_move记录dst item移动的log
	1.记录move的keys
	2.记录移动过程中删除的keys
5.memmove_extent_buffer将dst的item移到偏移量为push_items的地方
6.tree_mod_log_eb_copy记录copy的log，copy_extent_buffer复制
	src的src_nritems - push_items到dst的0
7.btrfs_set_header_nritems设置dst和src的nritems
8.btrfs_mark_buffer_dirty标记src和dst dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1247</x>
      <y>2589</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1204</x>
      <y>2586</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>del_ptr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1194</x>
      <y>2581</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1197</x>
      <y>2592</y>
      <w>39</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果slot不是parent最后一个item
	1.如果level不是0，通过tree_mod_log_eb_move记录parent slot的移动
	2.memmove_extent_buffer填充删除的slot
2.如果时最后一个item，并且level不是0，通过tree_mod_log_insert_key
	记录slot被移除
3.btrfs_set_header_nritems重新设置parent的nritems
4.如果整个node被清除，btrfs_set_header_level设置node的level为0
5.如果删除的slot为0
	1.btrfs_node_key读取parent.slot[0].key
	2.fixup_low_keys循环取修复上层的key
6.btrfs_mark_buffer_dirty标记parent为dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1210</x>
      <y>2589</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1209</x>
      <y>2614</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fixup_low_keys</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1214</x>
      <y>2610</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1197</x>
      <y>2621</y>
      <w>37</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.向上遍历level
	1.tree_mod_log_set_node_key表示上层eb的key被更改
	2.btrfs_set_node_key设置上层item的key
	3.btrfs_mark_buffer_dirty标记上层eb dirty
	4.如果上层slot不是0，退出循环
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1214</x>
      <y>2617</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1157</x>
      <y>2378</y>
      <w>48</w>
      <h>69</h>
    </coordinates>
    <panel_attributes>5.循环处理b
	1.重新获取level
		level = btrfs_header_level(b)
	2.如果需要cow
		1.如果通过should_cow_block检查到不用block，跳到cow_done
		2.需要对该节点和parent上锁
			1.如果level大于write_lock_level，说明node没上锁
			2.如果write_lock_level&lt;level+1&lt;BTRFS_MAX_LEVEL，说明parent没上锁
			3.如果满足上述两个条件
				1.write_lock_level = level + 1;
				2.btrfs_release_path释放path，并跳到again
		3.btrfs_cow_block
	3.cow_done
		1.p-&gt;nodes[level] = b
		2.btrfs_clear_path_blocking
		3.如果ins_len为0，并且不存在keep_locks，清除p-&gt;locks[level+1]
		4.key_search在eb中查找key
		5.如果level不为0
			1.如果正确返回，并且所处的slot不是最小(这里在二分查找中找到的时high)
				dec = 1;
				slot -= 1;
			2.p-&gt;slots[level] = slot;
			3.setup_nodes_for_search对即将到来的插入或者删除动作左split或者合并操作
			4.如果要对slot0进行插入或者删除，因为需要改上一层的key
				write_lock_level不能小于level + 1
			5.如果遍历到了期望的level，还原slot，跳到done
				p-&gt;slots[level]++
			6.read_block_for_search读取子eb
			注：如果是现读，b不会发生改变，然后循环重新查找就能找到了
			7.如果skip_locking没置上
				1.如果level在write_lock_level范围内，通过btrfs_try_tree_write_lock
					对其上锁，如果上锁失败，通过btrfs_tree_lock等待上锁
					p-&gt;locks[level] = BTRFS_WRITE_LOCK
				2.否则上读锁
					p-&gt;locks[level] = BTRFS_READ_LOCK
				3.p-&gt;nodes[level] = b
		6.如果level=0
			1.p-&gt;slots[level] = slot
			2.如果btrfs_leaf_free_space剩余的空间低于ins_len
				1.如果write_lock_level低于1，释放path，跳到again重新寻找path
				2.btrfs_set_path_blocking设置path blocking
				3.split_leaf为node[0]腾出足够的空间(如果恰好在item.offset上插入数据，extend置上
					否则offset在查找item.offset的左边)
				4.btrfs_clear_path_blocking清除path blocking
			3.如果没有search_for_split，通过unlock_up调整write_lock_level
			4.跳到done
6.如果没找到，返回1		
7.done
	1.如果leave_spinning没置上，btrfs_set_path_blocking将path block
	2.如果出错，但是skip_release_on_error没置上，btrfs_release_path释放path
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1222</x>
      <y>2451</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_block_for_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1203</x>
      <y>2446</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1212</x>
      <y>2457</y>
      <w>42</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.读取slot的blockptr和gen
2.btrfs_find_tree_block查找slot对应的eb
3.如果找到
	1.如果btrfs_buffer_uptodate检查eb uptodate，返回0
		*eb_ret = tmp
	2.btrfs_read_buffer读取eb，如果成功，返回0
		*eb_ret = tmp
	3.否则通过free_extent_buffer递减eb计数，并btrfs_release_path
		释放path，返回EIO
4.如果没找到
	1.如果path要求预读(reada),reada_for_search根据reada向前或者向后预读
	2.通过btrfs_release_path将path清掉
	注：如果leaf没读进来，是不能清掉的，因为是从0level开始遍历
	3.read_tree_block读取blockptr对应的子节点
	4.如果正确读取
		1.如果eb没有uptodate，返回EIO
		2.free_extent_buffer递减temp计数
	注：这里并没有返回temp，只有找到时，才将temp作为eb_ret返回
		不更新eb_ret，让其重新再次查找
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1229</x>
      <y>2454</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1234</x>
      <y>2494</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reada_for_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1240</x>
      <y>2487</y>
      <w>3</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1228</x>
      <y>2502</y>
      <w>31</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.只对leaf进行预读
2.nodes[level]不存在，返回
3.btrfs_find_tree_block查找slot对应的eb
4.如果找到，递减eb计数，返回
5.循环
	1.确定预读的slot nr
		1.如果是向后预读，nr不为0，
			nr--
		2.如果是向前预读，nr不超过nritems
			nr++
	2.如果向后预读，后面eb的objectid要和node相同，
		否则退出循环
	3.预读范围不能超过65535
		1.readahead_tree_block进行预读
		2.nread += blocksize
	4.预读长度不能超过65535，遍历slot不能超过32
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1240</x>
      <y>2497</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1005</x>
      <y>2375</y>
      <w>164</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1620.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1578</x>
      <y>2875</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_iget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1563</x>
      <y>2882</y>
      <w>39</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.btrfs_iget_locked获取inode
2.如果inode是新创建的(I_NEW)
	1.如果不是is_bad_inode(bad_inode_ops)，inode_tree_add
		*new = 1
	2.否则释放inode，并返回ESTALE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1583</x>
      <y>2878</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1557</x>
      <y>2894</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_iget_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1563</x>
      <y>2890</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1543</x>
      <y>2901</y>
      <w>29</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.通过location-&gt;objectid(inode号)计算hash
2.iget5_locked获取inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1562</x>
      <y>2897</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1536</x>
      <y>2908</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_find_actor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1542</x>
      <y>2905</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1526</x>
      <y>2915</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.inode的location-&gt;objectid要和arg相同
2.inode.root要和arg相同
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1539</x>
      <y>2911</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1559</x>
      <y>2909</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_init_locked_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1565</x>
      <y>2905</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1555</x>
      <y>2916</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.inode-&gt;i_ino = args-&gt;location-&gt;objectid
2.arg的location复制到inode.location中
3.设置root
	BTRFS_I(inode)-&gt;root = args-&gt;root
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1567</x>
      <y>2912</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>464</x>
      <y>2420</y>
      <w>38</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.申请btrfs_inode
2.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>481</x>
      <y>2416</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>487</x>
      <y>2389</y>
      <w>39</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.通过sb-&gt;s_op-&gt;alloc_inode申请inode，或者直接通过
	kmem_cache_alloc申请
2.inode_init_always进行inode的初始化
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>483</x>
      <y>2402</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>509</x>
      <y>2406</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_init_always</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>516</x>
      <y>2402</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>504</x>
      <y>2413</y>
      <w>33</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op = &amp;empty_iops;
inode-&gt;i_fop = &amp;no_open_fops;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>515</x>
      <y>2409</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1587</x>
      <y>2893</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_tree_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1583</x>
      <y>2890</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1583</x>
      <y>2900</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果inode没连接到hash中，直接返回
2.遍历红黑树root-&gt;inode_tree
	1.按照ino的大小进行插入
	2.如果有ino相同的inode，通过rb_replace_node进行替换
3.最后插入到红黑树中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1591</x>
      <y>2896</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1595</x>
      <y>2911</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_ino</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1598</x>
      <y>2908</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1583</x>
      <y>2918</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.默认是BTRFS_I(inode)-&gt;location.objectid
2.如果这个ino不存在，或者type是BTRFS_ROOT_ITEM_KEY
	ino = inode-&gt;i_ino
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1598</x>
      <y>2914</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1628</x>
      <y>2911</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rb_replace_node</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1608</x>
      <y>2908</y>
      <w>26</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1621</x>
      <y>2918</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.__rb_change_child将parent的left或者right改成new
2.rb_set_parent重新设置子节点的父节点为new
3.更新new的红黑树特性(左右子节点和clolor)
	*new = *victim
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1633</x>
      <y>2914</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1584</x>
      <y>2870</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1687</x>
      <y>2815</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__load_free_space_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1632</x>
      <y>2809</y>
      <w>67</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1686</x>
      <y>2826</y>
      <w>34</w>
      <h>46</h>
    </coordinates>
    <panel_attributes>1.如果读取inode.size不为0，直接返回
2.btrfs_search_slot在free_space中搜索offset，如果没找到，返回0
3.以btrfs_free_space_header解析slot数据，获取其num_entries num_bitmaps generation
4.btrfs_release_path释放path
5.如果btrfs_inode.generation为0或者和free_space不同，并且num_entries要存在，否则直接返回0
6.io_ctl_init初始化io_ctl
7.readahead_cache将整个inode.i_size读进来
8.io_ctl_check_crc检查首页的crc
9.循环申请num_entries个btrfs_free_space
	1.kmem_cache_zalloc申请btrfs_free_space e
	2.io_ctl_read_entry通过io_ctl.cur中的page初始化e
	3.e-&gt;bytes要存在
	4.如果entry type是BTRFS_FREE_SPACE_EXTENT
		1.将e通过link_free_space加入ctl中
	5.否则
		1.为e-&gt;bitmap申请bitmap
			num_bitmaps--
		2.link_free_space将e加入到ctl
		3.ctl-&gt;total_bitmaps++;
			ctl-&gt;op-&gt;recalc_thresholds
		4.list_add_tail将e.list加入到链表bitmaps
10.io_ctl_unmap_page将cur unmmap
11.遍历链表bitmaps
	1.通过list_del_init将e.list从链表中移除
	2.io_ctl_read_bitmap读取page中的bitmap
12.io_ctl_drop_pages释放io_ctl中的page
13.merge_space_tree
14.io_ctl_free释放pages数组，并返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1698</x>
      <y>2818</y>
      <w>3</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1635</x>
      <y>2879</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>io_ctl_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1641</x>
      <y>2871</y>
      <w>56</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>540.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1633</x>
      <y>2886</y>
      <w>32</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.读取inode.size并对page向上取整得出其io_ctl_init
2.inode.i_ino不是BTRFS_FREE_INO_OBJECTID，需要check_crcs
3.如果写操作，并且需要check_crc，其crc的大小要小于1page
4.将io_ctl清0
5.为io_ctl-&gt;pages申请num_pages数组
	io_ctl-&gt;num_pages = num_pages;
	io_ctl-&gt;root = root;
	io_ctl-&gt;check_crcs = check_crcs;
	io_ctl-&gt;inode = inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1639</x>
      <y>2882</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1672</x>
      <y>2879</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>readahead_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1676</x>
      <y>2871</y>
      <w>39</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1666</x>
      <y>2886</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.申请ra，并通过file_ra_state_init进行初始化
	1.从inode.sb.sbdi.ra_pages读取预读的page的数目ra-&gt;ra_pages
	2.ra-&gt;prev_pos = -1
2.last_index是inode.size的page数
3.page_cache_sync_readahead进行同步预读
4.释放ra，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1678</x>
      <y>2882</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1674</x>
      <y>2899</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_sync_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1682</x>
      <y>2895</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1661</x>
      <y>2906</y>
      <w>45</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果没有预读的page数ra-&gt;ra_pages，直接返回
2.如果存在file，并且是FMODE_RANDOM，通过force_page_cache_readahead
	直接读，不进行预读
3.否则通过ondemand_readahead预读
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1682</x>
      <y>2902</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1706</x>
      <y>2916</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ondemand_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1700</x>
      <y>2913</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1692</x>
      <y>2923</y>
      <w>40</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>1.如果读的地方offset是file start，直接跳到initial_readahead
2.如果到达了异步预读的点((ra-&gt;start + ra-&gt;size - ra-&gt;async_size)
	或者所有的预读均已读完(ra-&gt;start + ra-&gt;size)
	1.更新预读窗口
		ra-&gt;start += ra-&gt;size;
		ra-&gt;size = get_next_ra_size(ra, max);
		ra-&gt;async_size = ra-&gt;size;
	2.跳到readit
3.如果是异步预读(同步预读，hit_readahead_marker为false，异步预读，为true)
	1.page_cache_next_hole寻找了从offset+1开始的没被缓存的page
	2.如果超过index的bit限制(start=0),或者遍历的长度（start-offset）超过了max
		1.ra-&gt;start = start
			//ra-&gt;size变换为pre_async_size+req_size之后，在get_next_ra_size
			ra-&gt;size = get_next_ra_size
			ra-&gt;async_size = ra-&gt;size
		2.跳到readit
4.如果req_size超过了max，跳到initial_readahead
5.如果和之前读取的位置ra-&gt;prev_pos只相差一页，跳到initial_readahead
6.try_context_readahead查看是否进行了预读，但是因为long-run没读进来
	如果是，跳到readit
7.否则通过__do_page_cache_readahead进行读取req_size，预读传参为0
8.initial_readahead
	1.ra-&gt;start = offset;
		ra-&gt;size = get_init_ra_size(req_size, max);
		ra-&gt;async_size = ra-&gt;size &gt; req_size ? ra-&gt;size - req_size : ra-&gt;size;
9.readit：
	1.如果此时满足异步读取条件，增加next_size
		1.ra-&gt;async_size = get_next_ra_size
			ra-&gt;size += ra-&gt;async_size
	2.通过ra_submit提交预读请求
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1713</x>
      <y>2919</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1665</x>
      <y>2975</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_next_ra_size</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1671</x>
      <y>2971</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1656</x>
      <y>2982</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果当前窗口偏小(相对于max)，next为当前窗口的4倍
2.如果当前窗口偏大，则为当前窗口的2倍
3.不能超过max
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1670</x>
      <y>2978</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1723</x>
      <y>2976</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>try_context_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1721</x>
      <y>2971</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1722</x>
      <y>2983</y>
      <w>31</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.从count_history_pages计算被缓存的page数
2.如果缓存的page数不错过req_size,直接返回0
3.如果offset在size的范围内，但是没达到size-async_size
	说明是一个long-run stream（size相对async_size较大），
	size *=2
4.ra-&gt;start = offset;
	ra-&gt;size = min(size + req_size, max);
	ra-&gt;async_size = 1
5.返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1731</x>
      <y>2979</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1726</x>
      <y>3002</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>count_history_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1720</x>
      <y>3009</y>
      <w>34</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.page_cache_prev_hole找到最小被cache的page_index
2.返回其到offset-1的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1733</x>
      <y>3005</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1730</x>
      <y>3017</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_prev_hole</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1735</x>
      <y>3013</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1720</x>
      <y>3024</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.遍历mapping-&gt;page_tree的radix_tree，最多只能遍历max_scan
	1.如果通过radix_tree_lookup找不到page或者有exception，直接退出
	2.index--,index遍历到~0（溢出）,直接退出
2.返回index
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1737</x>
      <y>3020</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1732</x>
      <y>2998</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1694</x>
      <y>2976</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_next_hole</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1700</x>
      <y>2971</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1689</x>
      <y>2982</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.从index开始遍历mapping-&gt;page_tree，最多只能遍历max_scan
	1.radix_tree_lookup如果找不到page或者page exception，退出
	2.index++，直到index溢出
2.返回index
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1701</x>
      <y>2979</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1758</x>
      <y>2975</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ra_submit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1754</x>
      <y>2981</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__do_page_cache_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1763</x>
      <y>2978</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1728</x>
      <y>2971</y>
      <w>37</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1764</x>
      <y>2984</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1755</x>
      <y>2988</y>
      <w>34</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果inode.i_size是0，直接返回
2.循环读nr_to_read个page
	1.如果超过了inode.i_size，退出循环
	2.radix_tree_lookup在mapping-&gt;page_tree寻找对应的page
		如果找到，并且不是exception，继续下一个
	3.page_cache_alloc_readahead申请page，并将page.lru加入page_pool
		page-&gt;index = page_offset;
	4.如果到达了size-asyncsize,SetPageReadahead
3.如果有要读的pgae，通过read_pages读取，并返回读取的page数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1768</x>
      <y>3007</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1760</x>
      <y>3014</y>
      <w>32</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果有mapping-&gt;a_ops-&gt;readpages，通过这个函数读取pages
2.否则向后遍历pages，读取nr_pages
	1.将page-&gt;lru从pages中断开
	2.如果add_to_page_cache_lru插入到mapping.page_tree成功，
		通过mapping-&gt;a_ops-&gt;readpage读取page
	3.page_cache_release释放page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1773</x>
      <y>3003</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1773</x>
      <y>3010</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1765</x>
      <y>3028</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;readpage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1773</x>
      <y>3024</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1657</x>
      <y>2917</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>force_page_cache_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1665</x>
      <y>2913</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1656</x>
      <y>2923</y>
      <w>36</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.readpage和readpages至少有一个存在，否则返回EINVAL
2.nr_to_read不能超过inode.sb.sbdi.ra_pages
3.循环读nr_to_read
	1.一次不能超过2k
	2.通过__do_page_cache_readahead直接读（预读传参是0）
	3.更新循环变量
		offset += this_chunk;
		nr_to_read -= this_chunk;
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1665</x>
      <y>2920</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1705</x>
      <y>2877</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>io_ctl_prepare_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1711</x>
      <y>2871</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1701</x>
      <y>2884</y>
      <w>32</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.循环检查io_ctl-&gt;num_pages个page
	1.通过find_or_create_page寻找或者创建page
		io_ctl-&gt;pages[i] = page
	2.如果需要page_uptodate,并且PageUptodate检查
		page没有更新
		1.通过btrfs_readpage将page都进来
		2.lock_page后，检查page是否更新，如果没更新，报错EIO
2.遍历所有的num_pages
	1.clear_page_dirty_for_io
	2.set_page_extent_mapped设置page.private
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1712</x>
      <y>2880</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1746</x>
      <y>2876</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>io_ctl_check_crc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1714</x>
      <y>2871</y>
      <w>40</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1735</x>
      <y>2883</y>
      <w>39</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果不需要check_crcs，通过io_ctl_map_page初始化，并返回0
2.如果是首页，要排除crc的空间，其他页offset为0
	offset = sizeof(u32) * io_ctl-&gt;num_pages
3.取出首页中，对应index的crc
4.io_ctl_map_page对ioctl进行初始化
5.btrfs_csum_data和btrfs_csum_final计算crc，与page记录的
	进行比较，如果不同，返回EIO
6.如果成功，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1749</x>
      <y>2879</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1735</x>
      <y>2899</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>io_ctl_map_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1740</x>
      <y>2896</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1731</x>
      <y>2905</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.io_ctl-&gt;page取io_ctl-&gt;pages[io_ctl-&gt;index]
	io_ctl-&gt;index++
2.io_ctl-&gt;cur = page_address(io_ctl-&gt;page);
	io_ctl-&gt;orig = io_ctl-&gt;cur;
	io_ctl-&gt;size = PAGE_CACHE_SIZE;
3.如果设置了clear，将io_ctl-&gt;cur清0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1741</x>
      <y>2902</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1780</x>
      <y>2875</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>io_ctl_check_generation</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1715</x>
      <y>2871</y>
      <w>73</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;710.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1776</x>
      <y>2882</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.确定generation的位置
	1.如果需要check_crcs，io_ctl-&gt;cur和io_ctl-&gt;size排除crc的空间
	2.否则，io_ctl-&gt;cur和io_ctl-&gt;size排除一个64位的chunk
2.读取generation并对比，如果不同，返回EIO
3.把generation的空间排除，并返回0
	io_ctl-&gt;cur += sizeof(u64)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1787</x>
      <y>2878</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1820</x>
      <y>2874</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>io_ctl_read_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1714</x>
      <y>2871</y>
      <w>113</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1110.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1811</x>
      <y>2881</y>
      <w>37</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果没有io_ctl-&gt;cur，通过io_ctl_check_crc去map_page
2.以btrfs_free_space_entry方式解析io_ctl-&gt;cur
	1.entry-&gt;offset = le64_to_cpu(e-&gt;offset);
		entry-&gt;bytes = le64_to_cpu(e-&gt;bytes);
		*type = e-&gt;type;
	2.更新io_ctl-&gt;cur和io_ctl-&gt;size
3.如果该page内还存在e，直接返回0
4.否则通过io_ctl_unmap_page将cur释放，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1826</x>
      <y>2877</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1864</x>
      <y>2874</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>link_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1868</x>
      <y>2877</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1852</x>
      <y>2881</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过tree_insert_offset将info插入红黑树ctl-&gt;free_space_offset
2.ctl-&gt;free_space += info-&gt;bytes;
	ctl-&gt;free_extents++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1717</x>
      <y>2871</y>
      <w>153</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1510.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1860</x>
      <y>2890</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tree_insert_offset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1865</x>
      <y>2886</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1864</x>
      <y>2893</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1852</x>
      <y>2897</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.根据offset遍历红黑树
	1.如果找到offset相同的，有bitmap的要在没有的右边
	2.如果红黑树中有和info.bitmap性质相同的entry，返回EEXIST
2.rb_link_node和rb_insert_color进行红黑树插入
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1897</x>
      <y>2873</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>io_ctl_read_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1921</x>
      <y>2872</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>io_ctl_drop_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1949</x>
      <y>2872</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>merge_space_tree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1974</x>
      <y>2872</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>io_ctl_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1892</x>
      <y>2880</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.io_ctl_check_crc检查crc，并且给cur map到page io_ctl-&gt;index
2.复制整页cur给entry-&gt;bitmap
3.io_ctl_unmap_page释放cur
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1904</x>
      <y>2876</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1928</x>
      <y>2875</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1922</x>
      <y>2879</y>
      <w>23</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.io_ctl_unmap_page释放cur
2.遍历数组io_ctl-&gt;pages中的page
	1.ClearPageChecked
	2.unlock_page
	3.page_cache_release释放page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1981</x>
      <y>2875</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1973</x>
      <y>2878</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.释放数组io_ctl-&gt;pages
	io_ctl-&gt;pages = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1718</x>
      <y>2871</y>
      <w>187</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1850.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1718</x>
      <y>2871</y>
      <w>212</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2100.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1714</x>
      <y>2871</y>
      <w>246</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2440.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1715</x>
      <y>2871</y>
      <w>266</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2640.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1956</x>
      <y>2875</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1946</x>
      <y>2879</y>
      <w>26</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.以链表的形式遍历红黑树
	1.两个指针：当前e 以及pre
	2.两个bitmap要都不存在
	3.如果prev.offset+prev.bytes=e.offset
		1.unlink_free_space将e和prev从红黑树中删除
		2.将两者合并
			prev-&gt;bytes += e-&gt;bytes;
		3.释放e
		4.link_free_space将prev重新加入红黑树
		5.prev = NULL，并重新遍历整个红黑树链表
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1706</x>
      <y>2782</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_excluded_extents</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1704</x>
      <y>2776</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1699</x>
      <y>2789</y>
      <w>38</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.通过clear_extent_bits清除freed_extents数组从cache.start~cache.end的
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1716</x>
      <y>2785</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1712</x>
      <y>2795</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>clear_extent_bits</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1717</x>
      <y>2791</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1709</x>
      <y>2801</y>
      <w>29</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.如果EXTENT_LOCKED置上，将wake置上
2.通过clear_extent_bit清除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1719</x>
      <y>2798</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1743</x>
      <y>2807</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>clear_extent_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1735</x>
      <y>2804</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1745</x>
      <y>2813</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__clear_extent_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1750</x>
      <y>2810</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1721</x>
      <y>2819</y>
      <w>40</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.设置bits
	1.如果EXTENT_DELALLOC置上，将EXTENT_NORESERVE也置上
	2.如果需要delete，将EXTENT_CTLBITS置上
	3.将EXTENT_FIRST_DELALLOC置上
	4.如果EXTENT_IOBITS或者EXTENT_BOUNDARY置上，clear置上
2.again
	1.如果没有prealloc，并且内存申请允许__GFP_DIRECT_RECLAIM
		通过alloc_extent_state申请prealloc
	2.如果有cache_state
		1.如果clear，将cached_state清掉
		2.如果之前的cached正常，并且start在其范围内
			1.如果clear，递减cached-&gt;refs
			2.state = cached，并跳到hit_next
		3.如果clear置上，通过free_extent_state将cached释放
	3.直接通过tree_search在红黑树tree中查找
	注：__tree_search如果没找到，先向后找到offset&lt;end，在向前找offset&gt;start
	4.如果没找到，跳到out，如果找到，转换为state
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1734</x>
      <y>2816</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1753</x>
      <y>2816</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1763</x>
      <y>2819</y>
      <w>39</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>3.hit_next
	1.如果end&lt;state.start(没有重叠的部分)，跳到out
	2.如果state.state要清的bit没置上，跳到next继续下一个state
	3.如果start在state.start~end之间(由tree_search可知不可能找到一个offset&gt;end的node)
		1.alloc_extent_state_atomic申请prealloc
		2.split_state将state从start分为两段，并将后面一段插入红黑树
			后面一段作为orig返回
		3.如果后段state完全在要clear的范围内，通过clear_state_bit清除state内对应的bit
			并跳到next
		4.跳到search_again
	4.如果end在state的范围内
		1.alloc_extent_state_atomic申请prealloc
		2.split_state将state从end+1分为两部分
		3.如果需要wake，唤醒state-&gt;wq
		4.通过clear_state_bit清除前段的state的bit
		5.prealloc = NULL，并跳到out
	5.如果和state完全重合，直接通过clear_state_bit清除
	6.next：
		1.如果state之后没有next，直接跳到out
		2.如果有nextstate，并且要求的段没遍历完，跳到hit_next
		3.否则重新search_again
	7.out
		1.如果有prealloc，通过free_extent_state释放
		2.返回0
4.search_again
	1.如果段被遍历完，直接跳到out
	2.如果gfpflags_allow_blocking，考虑schedule
	3.跳到again
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1766</x>
      <y>2850</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>clear_state_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1757</x>
      <y>2857</y>
      <w>34</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.不能清EXTENT_CTLBITS
2.如果要清EXTENT_DIRTY
	tree-&gt;dirty_bytes -= range
3.clear_state_cb
4.add_extent_changeset更新changeset-&gt;bytes_changed
	并通过ulist_add将chang插入红黑树range_changed
5.state-&gt;state &amp;= ~bits_to_clear;
6.如果要wake，唤醒state-&gt;wq
7.如果state的状态被清空
	1.返回next_state
	2.将state冲红黑树中删除，并释放
8.否则
	1.merge_state合并state和其他node
	2.返回next_state
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1770</x>
      <y>2847</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1771</x>
      <y>2853</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1753</x>
      <y>2782</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_queue_work</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1706</x>
      <y>2776</y>
      <w>54</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;520.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1746</x>
      <y>2788</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果work的WORK_HIGH_PRIO_BIT置上，并且wq-&gt;high存在
	即用队列wq-&gt;high，否则使用队列wq-&gt;normal
2.__btrfs_queue_work将work挂入队列
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1758</x>
      <y>2785</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1767</x>
      <y>2797</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__btrfs_queue_work</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1774</x>
      <y>2794</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1761</x>
      <y>2804</y>
      <w>38</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.work-&gt;wq = wq
2.thresh_queue_hook在不是NO_THRESHOLD的情况下
	递增wq-&gt;pending
3.如果work.ordered_func存在
	1.work加入链表wq-&gt;ordered_list
4.queue_work将work(normal_work)加入队列wq-&gt;normal_wq
5.trace_btrfs_work_queued
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1774</x>
      <y>2800</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1711</x>
      <y>2696</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_lock_cluster</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1715</x>
      <y>2687</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1710</x>
      <y>2702</y>
      <w>35</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.如果used_bg之前被lock
	1.如果used_bg没发生改变，直接返回used_bg
	2.否则释放其信号量data_rwsem，btrfs_put_block_group
		递减其计数后，向下重新查找
2.查看used_bg，如果不存在，返回NULL
	used_bg = cluster-&gt;block_group
3.如果和正在遍历的block_group相同，直接返回
4.否则
	1.btrfs_get_block_group递增used_bg计数
	2.如果不需要delalloc，直接返回
	3.如果需要
		1.首先利用down_read_trylock尝试申请信号量，如果成功，直接返回
		2.如果失败，再用down_read申请，置上lock之后，跳到1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1716</x>
      <y>2699</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1803</x>
      <y>2695</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_alloc_from_cluster</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1743</x>
      <y>2687</y>
      <w>69</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1793</x>
      <y>2701</y>
      <w>39</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.如果要申请的空间超过了cluster.max_size，直接跳到out
2.如果cluster-&gt;block_group发生改变，跳到out
3.以链表的方式遍历cluster-&gt;root
	1.如果entry的空间不足，但是超过之前遍历的max_extent_size
		*max_extent_size = entry-&gt;bytes
	2.如果entry空间不足，或者
		bitmap不存在，其offset小于min_start
		1.选择rb_next，继续下一个循环
	3.如果空间充足
		1.如果有bitmap
			1.btrfs_alloc_from_bitmap在bitmap中申请extend
			2.如果没成功，继续遍历rb_next
			3.如果成功
				cluster-&gt;window_start += bytes
		2.起始的extend为ret = entry-&gt;offset
			entry-&gt;offset += bytes;
			entry-&gt;bytes -= bytes;
		3.如果entry的free_space被申请完，将其从红黑树中删除
		4.退出循环
4.out:
	1.如果没申请成功，返回0
	2.更新ctl
		1.ctl-&gt;free_space -= bytes
		2.如果entry的free_space被申请完
			1.ctl-&gt;free_extents--;
			2.如果存在bitmap
				kfree(entry-&gt;bitmap);
				ctl-&gt;total_bitmaps--;
				ctl-&gt;op-&gt;recalc_thresholds(ctl);
			3.释放entry
	3.返回extend的offset
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1809</x>
      <y>2698</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1802</x>
      <y>2753</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_alloc_from_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1795</x>
      <y>2760</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.确认start和空间大小后，通过search_bitmap查找是否有充足空间可以被申请
2.如果没有，max_extent_size返回遍历查找的max_extent_size
3.如果成功，通过__bitmap_clear_bits清除对应bitmap，并返回offset
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1821</x>
      <y>2768</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>search_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1823</x>
      <y>2774</y>
      <w>34</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.如果for_alloc置上(申请bitmap?),但是max_extent_size达不到要求，返回-1
2.从offset对应的bit开始，通过find_next_bit查找空闲的(标为1？)，直到BITS_PER_BITMAP
	1.如果for_alloc置上，并且只申请1个extend，退出循环
		found_bits = 1
	2.否则find_next_zero_bit找已经被申请的，并计算空闲extend数量
		extent_bits = next_zero - i
	3.如果extent_bits超过了要求，退出循环
		found_bits = extent_bits
	4.如果其超过了max_bits，更新
		max_bits = extent_bits
	5.然后从next_zero+1开始find_next_bit
3.如果找到对应的extend_size
	1.*offset = (u64)(i * ctl-&gt;unit) + bitmap_info-&gt;offset;
		*bytes = (u64)(found_bits) * ctl-&gt;unit;
	2.返回0
4.如果没找到，返回max_bits，并返回-1
	*bytes = (u64)(max_bits) * ctl-&gt;unit;
	bitmap_info-&gt;max_extent_size = *bytes
疑问：1.for_alloc仅仅是在申请1个extend和不满足max_extent_size会更快一点，还有其他作用吗？
		2.如果要读的bytes是unit多一点，那么那多的那些空间不会申请extend?
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1794</x>
      <y>2768</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__bitmap_clear_bits</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1787</x>
      <y>2774</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.bitmap_clear清除offset对应bit，大小为bytes对应的bits
2.更新free_space空间大小
	info-&gt;bytes -= bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1795</x>
      <y>2782</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bitmap_clear</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1786</x>
      <y>2788</y>
      <w>34</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.准备第一次(没对齐)要清的bit(bits_to_clear)和mask(mask_to_clear)
2.循环清除bit，直到本次清完还有剩余(尾端没对齐的情况，3进行处理)
	1.清除bit
		*p &amp;= ~mask_to_clear;
		len -= bits_to_clear;
	2.更新下次要清楚的长度和mask
		bits_to_clear = BITS_PER_LONG;
		mask_to_clear = ~0UL;
		p++;
3.如果还有没对齐的没请
	1.BITMAP_LAST_WORD_MASK更新尾端的mask，并清除
		*p &amp;= ~mask_to_clear
	注：这个size是end=start+len
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1827</x>
      <y>2771</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1801</x>
      <y>2771</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1800</x>
      <y>2779</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1800</x>
      <y>2785</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1825</x>
      <y>2765</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1801</x>
      <y>2765</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1809</x>
      <y>2756</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1808</x>
      <y>2750</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1931</x>
      <y>2664</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>release_cluster
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1823</x>
      <y>2650</y>
      <w>115</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1130.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1925</x>
      <y>2670</y>
      <w>35</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.如果循环次数超过了LOOP_NO_EMPTY_SIZE
	并且used_block_group和遍历的block_group不同
	1.btrfs_release_block_group将used_block_group释放
	2.跳到unclustered_alloc，不用cluster申请extend
2.btrfs_return_cluster_to_free_space将last_ptr中所有的free_space
	释放给last_ptr.block_group
3.如果used_block_group和遍历的block_group不同，
	1.通过btrfs_release_block_group将其释放
	2.refill_cluster：
		1.如果loop次数超过了限制，不从cluster中申请，跳到unclustered_alloc
4.btrfs_find_space_cluster在block_group中为last_ptr申请要求的free_space
5.如果成功返回0
	1.btrfs_alloc_from_cluster从cluster中申请extend，如果成功，跳到checks
6.如果block_group没有cached，并且loop次数超过限制，failed_cluster_refill没置上
	1.failed_cluster_refill = true
	2.wait_block_group_cache_progress等待block_group cached完成，并且其空间超过要求
	3.跳到have_block_group
7.如果继续失败，btrfs_return_cluster_to_free_space将free_space归还给block_group
8.跳到loop
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1938</x>
      <y>2667</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1888</x>
      <y>2699</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_return_cluster_to_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1900</x>
      <y>2694</y>
      <w>35</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1895</x>
      <y>2702</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1885</x>
      <y>2706</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.block_group要是cluster-&gt;block_group，否则返回0
2.递增block_group.count
3.__btrfs_return_cluster_to_free_space
4.btrfs_put_block_group释放block_group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1890</x>
      <y>2717</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__btrfs_return_cluster_to_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1901</x>
      <y>2713</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1901</x>
      <y>2720</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1885</x>
      <y>2724</y>
      <w>39</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.如果不是cluster-&gt;block_group，跳到out
2.重置cluster
	cluster-&gt;block_group = NULL;
	cluster-&gt;window_start = 0;
	list_del_init(&amp;cluster-&gt;block_group_list);
3.以链表的方式遍历cluster-&gt;root
	1.首先将entry从红黑树中删除
	2.如果entry没有bitmap
		1.try_merge_free_space将左右紧挨着的free_space合并
		2.steal_from_bitmap从bitmap中合并紧挨着的free_space
	3.将entry插入block_group.free_space_ctl.free_space_offset
4.清空cluster-&gt;root
5.btrfs_put_block_group释放block_group后，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1868</x>
      <y>2749</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>try_merge_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1858</x>
      <y>2756</y>
      <w>45</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.通过tree_search_offset查看红黑树中右边是否有何其重合的right_info
2.如果找到了right_info，并且其rb_prev存在
	left_info=rb_entry
	否则通过tree_search_offset查找于entry左边界(offset-1)相重合的left_info
3.如果right_info存在，并且其bitmap不存在
	1.如果update_stat置上，需要通过unlink_free_space释放right_info
		否则直接通过__unlink_free_space释放right_info
		info-&gt;bytes += right_info-&gt;bytes
	2.释放right_info
		merged = true
4.如果left_info存在，并且其bitmap不存在,并且其left_info紧挨着entry
	1.如果update_stat置上，需要通过unlink_free_space释放left_info
		否则直接通过__unlink_free_space释放left_info
		info-&gt;offset = left_info-&gt;offset;
		info-&gt;bytes += left_info-&gt;bytes
	2.释放left_info
		merged = true
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1862</x>
      <y>2786</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tree_search_offset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1867</x>
      <y>2781</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1857</x>
      <y>2793</y>
      <w>32</w>
      <h>53</h>
    </coordinates>
    <panel_attributes>1.在红黑树free_space_offset中查找offset
2.如果bitmap_only
	1.如果没找到entry，返回NULL
	2.如果entry的bitmap存在，直接返回entry
	3.查找其链表的下一个rb_next，
		1.如果offset不同，表示这个offset没有bitmap类型，返回NULL
		2.否则将rb_next返回
3.如果不是bitmap_only,并且entry找到了
	1.如果entry的bitmap要存在
		1.如果rb_prev的bitmap不存在，并且prev覆盖了offset，
			优先将没有bitmap的prev返回
	2.返回entry
4.如果红黑树是空，返回NULL
5.否则
	1.如果offset在entry的左边
		1.如果rb_prev存在，entry置换成prev
		2.如果不存在，在fuzzy置上，返回entry，否则返回NULL
	2.此时offset在entry的右边
		1.如果entry.bitmap存在
			1.如果rb_prev的bitmap不存在，并且其范围覆盖了offset，将其返回
			2.如果entry的bitmap返回覆盖了offset，将entry返回
		2.如果其bitmap不存在，并且其范围覆盖了offset,将其返回
		3.如果fuzzy没置上，返回NULL
	//这里entry在offset左边,并且其end&lt;offset
	3.rb_next进行循环
		1.检查entry的范围是否覆盖了offset，如果覆盖，退出循环
		注：这里可能不是真的覆盖，可能entry.offset&gt;offset
		2.rb_next进行循环
	4.返回entry	
注：1.如果fuzzy没置上，如果entry范围覆盖了offset即返回，否则返回NULL
		如果fuzzy置上，只能说明offset&lt;entry.end
	2.bitmap_only置上，表示必须offset相同，并且bitmap存在的entry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1867</x>
      <y>2789</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1893</x>
      <y>2786</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unlink_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1897</x>
      <y>2781</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1899</x>
      <y>2789</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1891</x>
      <y>2793</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.通过__unlink_free_space释放info
2.ctl-&gt;free_space -= info-&gt;bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1899</x>
      <y>2800</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__unlink_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1906</x>
      <y>2796</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1896</x>
      <y>2807</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.将info从红黑树中删除
2.ctl-&gt;free_extents--
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1907</x>
      <y>2803</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1926</x>
      <y>2748</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>steal_from_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1918</x>
      <y>2755</y>
      <w>33</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.ctl存在bitmap(ctl.total_bitmaps)
	1.steal_from_bitmap_to_end从尾端bitmap中拿一部分free_space过来
	2.如果total_bitmaps还有
		1.steal_from_bitmap_to_front从前端拿free_space
	注：如果info本来在ctl中，只是进行合并update_stat设置为false
		如果info不在ctl中，要和ctl中原有的进行合并，update_stat设置为true
	3.如果有steal过来，因为改变了info的范围，所以通过
	try_merge_free_space进行合并
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1931</x>
      <y>2751</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
info.bitmap不能存在</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1917</x>
      <y>2772</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>steal_from_bitmap_to_end</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1925</x>
      <y>2768</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1915</x>
      <y>2779</y>
      <w>37</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.通过tree_search_offset寻找包含(end bitmap page对齐)的bitmap
2.如果没找到，返回false
3.计算info.end在bitmap中的位偏移
4.find_next_zero_bit寻找从end开始第一个0的位置
5.如果end之后的区域都被占用，返回false
6.否则递增info的free_space空间的大小
	bytes = (j - i) * ctl-&gt;unit;
	info-&gt;bytes += bytes
7.如果update_stat置上，通过bitmap_clear_bits比较bitmap中bytes的空间被占用(因为分配到info)
	否则通过__bitmap_clear_bits标记
8.如果bitmap没有剩余空间，通过free_bitmap将其释放
9.返回true
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1926</x>
      <y>2775</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1952</x>
      <y>2771</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>steal_from_bitmap_to_front</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1953</x>
      <y>2778</y>
      <w>36</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.如果bitmap_offset(offset bitmap page对齐的位置)刚好是info.offset
	要找相对前一点的bitmap_offset
2.通过tree_search_offset寻找包含bitmap_offset的bitmap
3.遍历bitmap.bitmap,找到离info.offset最近的没被分配的prev_j
4.如果前面没有free_space，返回false
5.如果整个bitmap全是空闲的
	bytes = (i + 1) * ctl-&gt;unit
	否则，空闲空间为
	bytes = (i - prev_j) * ctl-&gt;unit
6.扩充info前端
	info-&gt;offset -= bytes;
	info-&gt;bytes += bytes;
7.如果update_stat置上，通过bitmap_clear_bits将bitmap移动的free_space清掉
	否则通过__bitmap_clear_bits清
8.如果bitmap的free_space被清空，通过free_bitmap将其释放
9.返回true
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1963</x>
      <y>2774</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1946</x>
      <y>2768</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1877</x>
      <y>2752</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1875</x>
      <y>2746</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1921</x>
      <y>2746</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1995</x>
      <y>2699</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_find_space_cluster</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1954</x>
      <y>2694</y>
      <w>49</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1990</x>
      <y>2706</y>
      <w>41</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.设置cont1_bytes和min_bytes
2.如果block_group的free_space不够，返回ENOSPC
3.如果cluster.block_group还存在，返回0
4.setup_cluster_no_bitmap首先查找block_group中没有bitmap的
	free_space，并加入cluster中
5.如果没bitmap的，没有足够的空间，通过setup_cluster_bitmap查找不带bitmap的
注：setup_cluster_no_bitmap添加的free_space可能是不连续的entry，
	setup_cluster_bitmap只添加一个entry
6.遍历bitmaps链表，将其全部删除
7.如果成功返回0
	1.递增block_group-&gt;count
	2.将cluster-&gt;block_group_list加入block_group.cluster_list尾端
	3.cluster-&gt;block_group = block_group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2005</x>
      <y>2702</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1982</x>
      <y>2730</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_cluster_no_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1992</x>
      <y>2727</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1975</x>
      <y>2736</y>
      <w>35</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>1.通过tree_search_offset模糊搜寻offset，如果没搜到
2.不要bitmap，空间不能小于min_bytes，否则一直循环
	1.如果bitmap存在，并且entry.list没加入链表，通过
		list_add_tail将entry加入bitmaps链表
	2.遍历rb_next
3.继续遍历rb_next，找到符合条件的entry窗口
	1.如果存在bitmap，并且其没被加入到链表，将其加入bitmaps，并继续下一个循环
	2.如果entry空间不足，继续下一个循环
	3.记录last，并调整窗口
		last = entry;
		window_free += entry-&gt;bytes
	4.更新窗口的max_extent
4.如果窗口大小window_free小于要申请的内存，或者
	最大的max_extent低于cont1_bytes(这个要在一个extend中),返回ENOSPC
5.更新cluster
	1.cluster-&gt;window_start = first-&gt;offset
	2.循环将first~last从红黑树block_group中移除，并且加到cluster中
		1.检查bitmap不能存在，空间要大于min_bytes
		2.将entry从红黑树中删除
		3.tree_insert_offset将entry插入红黑树cluster-&gt;root中
			total_size += entry-&gt;bytes
		4.遍历rb_next
	3.cluster-&gt;max_size = max_extent
6.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1989</x>
      <y>2733</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2019</x>
      <y>2731</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_cluster_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2014</x>
      <y>2737</y>
      <w>37</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果block_group不存在bitmap，返回ENOSPC
2.如果bitmaps不为空，将entry赋值为其第一个node
3.如果entry不存在，或者其offset没和bitmap对齐
	1.tree_search_offset找到和offset对齐的带有bitmap的entry
	2.如果其没加入链表，将其头插至bitmaps
4.遍历bitmaps
	1.如果entry空间小于bytes，继续下一个
	2.btrfs_bitmap_cluster查看entry内的空间是否满足最后三个传参的要求
	3.如果成功，返回0，否则继续循环
5.返回ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2027</x>
      <y>2758</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_bitmap_cluster</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2017</x>
      <y>2764</y>
      <w>42</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.如果entry.max_extent_size低于cont1_bytes，返回ENOSPC
2.again:
	1.从offset所在的bit遍历entry-&gt;bitmap
		1.find_next_zero_bit找到从i之后首个标记为0的位置
		2.如果其大小超过了min_bits
			1.更新found_bits，max_bits，并退出循环
		3.否则更新max_bits
		4.然后从next_zero+1开始遍历
	注：entry的连续free_space大小至少要大于min_bits
	2.如果没找到足够的空间容纳min_bits，返回ENOSPC
		entry-&gt;max_extent_size = (u64)max_bits * ctl-&gt;unit
	3.如果之前没记录total_found
		start = i;
		cluster-&gt;max_size = 0;
	4.total_found += found_bits
	5.更新cluster-&gt;max_size
	注：这个max_size不一定是entry的最大连续空间，只要满足2.1.2和2.6的要求即可
	6.如果total_found低于要求的空间，或者目前最大的连续空间max_size低于cont1_bytes
		从next_zero + 1，跳到again继续查找
3.更新cluster
	cluster-&gt;window_start = start * ctl-&gt;unit + entry-&gt;offset
4.将entry从block_group中删除，并通过tree_insert_offset插入cluster-&gt;root中
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2033</x>
      <y>2761</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2034</x>
      <y>2754</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2026</x>
      <y>2734</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2024</x>
      <y>2727</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2034</x>
      <y>2655</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unclustered_alloc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2038</x>
      <y>2658</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2028</x>
      <y>2662</y>
      <w>35</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果是从cluster中申请失败
	last_ptr-&gt;fragmented = 1;
2.如果block_group被cached，但是空间不足，查看是否
	要更新max_extent_size，然后跳到loop
3.btrfs_find_space_for_alloc在block_group中寻找free_space
4.如果没申请到(!offset),并且之前没有failed_alloc，block_group没被cached
	循环次数超过限制
	1.wait_block_group_cache_progress等待block_group cached对应的size
	2.failed_alloc = true
	3.跳到have_block_group
5.如果仅是申请失败，跳到loop遍历下一个block_group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2038</x>
      <y>2685</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_find_space_for_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2045</x>
      <y>2680</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2046</x>
      <y>2688</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2035</x>
      <y>2691</y>
      <w>38</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.find_free_space查找block_group中空间充足的entry(更新了offset和bytes_search)
2.如果entry有bitmap，通过bitmap_clear_bits将bit清掉，表示空间被占用，如果没剩余空间，free_bitmap将其释放
3.否则
	1.unlink_free_space将entry从红黑树中删除
	2.因为被占用，所以更新entry的offset和size
		entry-&gt;offset = offset + bytes;//这里的offset是对齐的
		entry-&gt;bytes -= bytes + align_gap_len
	3.如果entry没空间，将其释放，否则通过link_free_space重新加入红黑树
4.如果对齐过，将对齐没被申请的空间通过__btrfs_add_free_space加入红黑树
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2060</x>
      <y>2710</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2054</x>
      <y>2717</y>
      <w>34</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.如果红黑树free_space_offset中没有free_space，返回NULL
2.tree_search_offset模糊查找bitmap对齐的offset，如果没找到entry，返回NULL
3.从entry开始以链表遍历红黑树
	1.如果entry空间不足，更新max_extent_size，并继续下一个循环
	2.申请空间要对齐，align_off是相对于entry.offset的位置，tmp是其对齐后的offset
		1.如果申请空间超过了align，需要对齐，否则不用对齐
	3.如果对齐后需要的空间超过了entry.bytes，更新max_extent_size，并继续下一个循环
	4.如果存在bitmap
		1.search_bitmap在bitmap找查找相应size的free_space
		2.如果成功，更新找到的offset和size，并返回entry
			*offset = tmp;
			*bytes = size;
		3.否则更新max_extent_size
		4.继续下一个循环
	5.否则，直接更新offset和size，并返回entry
		*offset = tmp;
		*bytes = entry-&gt;bytes - align_off
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2065</x>
      <y>2713</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2064</x>
      <y>2706</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2098</x>
      <y>2709</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__btrfs_add_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2069</x>
      <y>2706</y>
      <w>39</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2089</x>
      <y>2716</y>
      <w>40</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.申请free_space info
	info-&gt;offset = offset;
	info-&gt;bytes = bytes;
2.try_merge_free_space将info左右两端进行合并，如果合并成功，跳到link
3.否则，通过insert_into_bitmap将ctl(或者对应的private的cluster)中的bitmap释放
4.如果失败，直接返回，如果成功，返回0
5.link
	1.steal_from_bitmap进行bitmap的合并
	2.link_free_space将info加入到ctl中
	3.如果失败，释放info
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2107</x>
      <y>2712</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2096</x>
      <y>2736</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>insert_into_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2101</x>
      <y>2732</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2089</x>
      <y>2743</y>
      <w>43</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.ctl-&gt;op-&gt;use_bitmap
2.如果ctl-&gt;op指向free_space_op
	block_group = ctl-&gt;private
3.again
	1.如果block_group存在，并且其cluster_list链表上有cluster
		1.找到第一个cluster
		2.找到红黑树cluster-&gt;root的rb_first
		3.如果这个entry没有bitmap，跳到no_cluster_bitmap
		4.如果info和entry的bitmap offset相同
			1.通过add_bytes_to_bitmap置上相应的bytes
			2.更新info中没被释放的空间
				bytes -= bytes_added;
				offset += bytes_added;
		5.如果info都被释放，跳到out，返回1
4.no_cluster_bitmap：
	1.tree_search_offset搜寻offset对应的bitmap，如果没有跳到new_bitmap
	2.通过add_bytes_to_bitmap将info的空间加入bitmap
	3.更新没被释放的info空间
		bytes -= bytes_added;
		offset += bytes_added;
	4.如果info被完全释放，跳到out，返回1
	5.否则跳到again，重新搜寻bitmap
5.new_bitmap
	1.如果info.bitmap存在
		1.add_new_bitmap将info的free_space清空，加入到ctl中
		2.info置NULL,并跳到again
	2.否则
		1.如果info不存在，申请
		2.申请info-&gt;bitmap
		3.跳到again
6.out
	1.释放info，bitmap
	2.返回ret
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2100</x>
      <y>2739</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2083</x>
      <y>2771</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_bytes_to_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2090</x>
      <y>2767</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2075</x>
      <y>2778</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.需要被bytes_to_set不能超过bitmap的end
2.bitmap_set_bits将offset~offset+bytes_to_set置上
3.info-&gt;max_extent_size = 0
4.返回被set的bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2090</x>
      <y>2774</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2108</x>
      <y>2771</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_new_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2113</x>
      <y>2767</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2105</x>
      <y>2778</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.更新info(空间全部被占用)
	info-&gt;offset = offset_to_bitmap(ctl, offset);
	info-&gt;bytes = 0;
	INIT_LIST_HEAD(&amp;info-&gt;list);
2.link_free_space加入到ctl
	ctl-&gt;total_bitmaps++
3.ctl-&gt;op-&gt;recalc_thresholds
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2112</x>
      <y>2774</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2104</x>
      <y>2654</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>checks
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2092</x>
      <y>2660</y>
      <w>41</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果offset在stripesize对齐后，其空间超过了block_group的空间
	1.btrfs_add_free_space将free_space归还
	2.跳到loop,继续下一个循环
2.将对其后不用的空间，通过btrfs_add_free_space释放给block_group
3.btrfs_update_reserved_bytes更新block_group和space_info的reserved
4.如果失败，btrfs_add_free_space释放free_space给block_group，并跳到loop，继续下一个循环
5.更新返回变量
	ins-&gt;objectid = search_start;
	ins-&gt;offset = num_bytes;
6.btrfs_release_block_group释放block_group，并退出循环
7.loop
	1.重置变量
		failed_cluster_refill = false;
		failed_alloc = false;
	2.btrfs_release_block_group释放block_group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2122</x>
      <y>2686</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_update_reserved_bytes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2128</x>
      <y>2681</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2108</x>
      <y>2657</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2130</x>
      <y>2693</y>
      <w>37</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.如果不是RESERVE_FREE
	1.如果block_group是read_only,返回EAGAIN
	2.否则
		1.更新reserved
			cache-&gt;reserved += num_bytes;
			space_info-&gt;bytes_reserved += num_bytes;
		2.如果是RESERVE_ALLOC
			1.space_info-&gt;bytes_may_use -= num_bytes
		3.如果delalloc置上
			cache-&gt;delalloc_bytes += num_bytes
2.如果是RESERVE_FREE
	1.如果是read_only
		space_info-&gt;bytes_readonly += num_bytes
	2.更新reserved
		cache-&gt;reserved -= num_bytes;
		space_info-&gt;bytes_reserved -= num_bytes;
	3.如果delalloc置上
		cache-&gt;delalloc_bytes -= num_bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2135</x>
      <y>2689</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2186</x>
      <y>2649</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_join_transaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2174</x>
      <y>2662</y>
      <w>38</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>1.如果fs_info的STATE_ERROR置上，报EROFS
2.如果current-&gt;journal_info存在
	1.更新journal_info
		h = current-&gt;journal_info;
		h-&gt;use_count++;
		h-&gt;orig_rsv = h-&gt;block_rsv;
		h-&gt;block_rsv = NULL;
	2.跳到got_it
3.如果存在num_items，并且root不是chunk_root
	1.btrfs_qgroup_reserve_meta更新reserved
	2.btrfs_calc_trans_metadata_size更新items需要的meta空间
	3.如果need_reserve_reloc_root
		1.num_bytes += root-&gt;nodesize;
			reloc_reserved = true;
	4.btrfs_block_rsv_add增加fs_info-&gt;trans_block_rsv
4.again
	1.申请trans_handle
	2.如果__TRANS_FREEZABLE置上，sb_start_intwrite申请信号量
	3.may_wait_transaction查看是否需要等待，如果需要，通过
		wait_current_trans等待
	4.循环使用join_transaction，如果期间返回EBUSY，通过wait_current_trans
		等待，但是type是TRANS_ATTACH，返回ENOENT
	5.获取join的cur_trans
		1.h-&gt;transid = cur_trans-&gt;transid;
			h-&gt;transaction = cur_trans;
			h-&gt;root = root;
			h-&gt;use_count = 1;
			h-&gt;type = type;
			h-&gt;can_flush_pending_bgs = true;
			INIT_LIST_HEAD(&amp;h-&gt;qgroup_ref_list);
			INIT_LIST_HEAD(&amp;h-&gt;new_bgs);
	6.如果状态在TRANS_STATE_BLOCKED之前，并且may_wait_transaction检查需要等待
		1.current-&gt;journal_info = h
		2.btrfs_commit_transaction提交h
		3.跳到again
	7.如果有reserved，
		h-&gt;block_rsv = &amp;root-&gt;fs_info-&gt;trans_block_rsv;
		h-&gt;bytes_reserved = num_bytes;
		h-&gt;reloc_reserved = reloc_reserved
5.btrfs_record_root_in_trans
6.如果不是在TRANS_USERSPACE，更新
	current-&gt;journal_info = h
7.返回h
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2194</x>
      <y>2659</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2144</x>
      <y>2736</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_qgroup_reserve_meta</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2150</x>
      <y>2731</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2151</x>
      <y>2739</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2138</x>
      <y>2742</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果fs_info.quota_enabled没打开，或者不是is_fstree
	或者num_bytes为0，返回0
2.qgroup_reserve设置fs_info-&gt;qgroup_ulist链表中所有qgroup.reserved
3.root-&gt;qgroup_meta_rsv +=num_bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2144</x>
      <y>2753</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>is_fstree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2149</x>
      <y>2749</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2137</x>
      <y>2760</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果是BTRFS_FS_TREE_OBJECTID
	或者在BTRFS_FIRST_FREE_OBJECTID范围内并且btrfs_qgroup_level存在
	返回1
2.否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2149</x>
      <y>2756</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2174</x>
      <y>2753</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qgroup_reserve</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2172</x>
      <y>2760</y>
      <w>34</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.不是is_fstree，或者没有num_bytes，返回0
2.如果没有fs_info-&gt;quota_root，返回0
3.find_qgroup_rb在root-&gt;root_key.objectid寻找qgroup
4.ulist_add将qgroup设置为相应node加入fs_info-&gt;qgroup_ulist的
	红黑树和链表中
5.遍历fs_info-&gt;qgroup_ulist.nodes链表
	1.获取node的qgroup
	2.如果LIMIT_MAX_RFER置上，并且其所要的空间(reserved+rfer+num_bytes)
		超过了max_rfer，返回EDQUOT
	3.如果LIMIT_MAX_EXCL置上，其空间(reserved+excl+num_bytes)超过了max_excl
		返回EDQUOT
	4.遍历qgroup所在的qgroup_list(groups),将glist-&gt;group添加到fs_info-&gt;qgroup_ulist中
	5.如果出错，直接返回
6.返回0
7.再次遍历fs_info-&gt;qgroup_ulist，给其中的每个qgroup
	qg-&gt;reserved += num_bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2179</x>
      <y>2756</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2171</x>
      <y>2790</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_qgroup_rb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2175</x>
      <y>2786</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2157</x>
      <y>2797</y>
      <w>36</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.遍历红黑树fs_info-&gt;qgroup_tree(按照qgroupid)
	找到对应的qgroupid
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2175</x>
      <y>2793</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2165</x>
      <y>2749</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2187</x>
      <y>2738</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>need_reserve_reloc_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2186</x>
      <y>2745</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果fs_info-&gt;reloc_ctl不能存在
	或者BTRFS_ROOT_REF_COWS没置上
	或者是BTRFS_TREE_RELOC_OBJECTID
	或者reloc_root存在
	返回false
2.否则返回true
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2195</x>
      <y>2741</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2195</x>
      <y>2731</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2224</x>
      <y>2738</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_block_rsv_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2222</x>
      <y>2745</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果不存在num_bytes，返回0
2.reserve_metadata_bytes
3.block_rsv_add_bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2232</x>
      <y>2741</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2242</x>
      <y>2755</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_rsv_add_bytes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2243</x>
      <y>2751</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2241</x>
      <y>2762</y>
      <w>28</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.block_rsv-&gt;reserved += num_bytes
2.如果update_size置上
	block_rsv-&gt;size += num_bytes
3.update_size没置上，reserved超过了size
	block_rsv-&gt;full = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2252</x>
      <y>2758</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2218</x>
      <y>2755</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reserve_metadata_bytes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2225</x>
      <y>2751</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2208</x>
      <y>2731</y>
      <w>25</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2323</x>
      <y>2655</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_chunk_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2189</x>
      <y>2656</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_transaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2193</x>
      <y>2652</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2208</x>
      <y>2762</y>
      <w>32</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.如果要求BTRFS_RESERVE_FLUSH_ALL，但是不是本进程flush，但是其他进程在flush(space_info-&gt;flush)
	1.如果有journal_info，返回EAGAIN
	2.wait_event_killable等待space_info-&gt;flush被清掉
2.综合space_info被used的空间
3.如果还有剩余空间
	1.如果space_info还存在orig_bytes空间
		space_info-&gt;bytes_may_use += orig_bytes;
		ret=0
	2.否则
		num_bytes = orig_bytes;
4.如果空间不足
	num_bytes = used - space_info-&gt;total_bytes +
			(orig_bytes * 2);
5.如果空间不足，can_overcommit看是否能overcommit
	space_info-&gt;bytes_may_use += orig_bytes
	ret = 0
6.如果空间不足，并且不是BTRFS_RESERVE_NO_FLUSH，本进程要进行flush
	flushing = true;
	space_info-&gt;flush = 1
7.如果空间充足，并且是BTRFS_BLOCK_GROUP_METADATA
	1.used += orig_bytes
	2.如果没有log_root_recovering，并且need_do_async_reclaim，但是没有work_busy
		调度system_unbound_wq
8.如果空间充足，或者不用flush(BTRFS_RESERVE_NO_FLUSH)，跳到out
9.根据flush_state，通过flush_space进行flush
	flush_state++
10.如果是BTRFS_RESERVE_FLUSH_LIMIT，并且
	FLUSH_DELALLOC或者FLUSH_DELALLOC_WAIT
		flush_state = ALLOC_CHUNK
11.如果flush成功，跳到1
12.如果没成功，
	1.是BTRFS_RESERVE_FLUSH_LIMIT，或者BTRFS_RESERVE_FLUSH_ALL
		但是没有COMMIT_TRANS，跳到1
13.out:
	1.如果是ENOSPC，并且ORPHAN_CLEANUP_STARTED
		1.如果不是global_block_rsv，通过block_rsv_use_bytes
			递减block_rsv-&gt;reserved，如果能清掉block_rsv-&gt;full，返回0
	2.如果进程flushing，清除space_info-&gt;flush，并唤醒space_info-&gt;wait
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2224</x>
      <y>2758</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2203</x>
      <y>2794</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>can_overcommit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2194</x>
      <y>2801</y>
      <w>35</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.calc_global_rsv_need_space计算需要保留的空间(global_block_rsv&lt;&lt;1)
2.如果used+space_size超过了total_bytes，返回0
3.调整可控分配的free_chunk_space
	1.如果是DUP RAID1 RAID10,减小一半
	2.如果是BTRFS_RESERVE_FLUSH_ALL，减小到1/8
	3.否则减小一半
4.如果空间低于total_bytes + avail，返回1
5.否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2207</x>
      <y>2797</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2208</x>
      <y>2789</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2272</x>
      <y>2737</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>may_wait_transaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2209</x>
      <y>2731</y>
      <w>73</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;710.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2265</x>
      <y>2744</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果log_root_recovering置上，返回0，不用等待
2.等待条件(返回1)
	1.TRANS_USERSPACE
	2.TRANS_START，并且open_ioctl_trans为0
3.其他情况，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2278</x>
      <y>2740</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2304</x>
      <y>2736</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait_current_trans</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2298</x>
      <y>2743</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.is_transaction_blocked检查running_transaction是否需要blocked
	如果需要
	1.递增cur_trans-&gt;use_count
	2.等待cur_trans-&gt;state或者cur_trans-&gt;aborted
	3.醒来之后释放use_count
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2311</x>
      <y>2739</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2339</x>
      <y>2736</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>join_transaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2334</x>
      <y>2743</y>
      <w>39</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.如果fs_state的BTRFS_FS_STATE_ERROR置上返回EROFS
2.如果存在running_transaction
	1.如果存在aborted，返回aborted
	2.如果type满足state条件下的btrfs_blocked_trans_types，返回EBUSY
	3.递增use_count，num_writers，num_extwriters(TRANS_EXTWRITERS)
	4.返回0
3.如果type是TRANS_ATTACH，返回ENOENT
4.申请cur_trans，并初始化
	1.设置num_writers，num_extwriters
	2.初始化writer_wait，commit_wait，pending_wait
	3.cur_trans-&gt;state = TRANS_STATE_RUNNING
	4.设置use_count(2),pending_ordered(0),flags,start_time
	5.初始化delayed_refs
	6.初始化pending_snapshots，pending_chunks，switch_commits，dirty_bgs
		io_bgs，dropped_roots，cache_write_mutex
	7.设置dirty_bgs_lock，deleted_bgs，dropped_roots_lock，deleted_bgs，dropped_roots_lock
		cur_trans-&gt;num_dirty_bgs = 0;
	8.将其加入链表fs_info-&gt;trans_list
	9.初始化io_tree dirty_pages
	10.fs_info-&gt;generation++;
		cur_trans-&gt;transid = fs_info-&gt;generation;
		fs_info-&gt;running_transaction = cur_trans;
		cur_trans-&gt;aborted = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2344</x>
      <y>2739</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2386</x>
      <y>2736</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_commit_transaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2378</x>
      <y>2743</y>
      <w>35</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2392</x>
      <y>2739</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2425</x>
      <y>2736</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_record_root_in_trans</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2417</x>
      <y>2743</y>
      <w>40</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果root.state的BTRFS_ROOT_REF_COWS没置上，返回0
2.如果last_trans和当前trans相同，并且BTRFS_ROOT_IN_TRANS_SETUP没置上(已经被recorde)，返回0
3.record_root_in_trans
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2430</x>
      <y>2752</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>record_root_in_trans</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2420</x>
      <y>2759</y>
      <w>40</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果BTRFS_ROOT_REF_COWS置上，last_trans小于当前trans
	1.将root.state的BTRFS_ROOT_IN_TRANS_SETUP置上
	2.radix_tree_tag_set在radix数的路径中设置BTRFS_ROOT_TRANS_TAG
	3.root-&gt;last_trans = trans-&gt;transid
	4.btrfs_init_reloc_root
	5.清掉BTRFS_ROOT_IN_TRANS_SETUP
2.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2432</x>
      <y>2774</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_init_reloc_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2435</x>
      <y>2739</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2437</x>
      <y>2749</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2437</x>
      <y>2755</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2439</x>
      <y>2770</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2420</x>
      <y>2781</y>
      <w>44</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果存在root.reloc_root,更新trans，并返回0
	reloc_root-&gt;last_trans = trans-&gt;transid
2.如果fs_info-&gt;reloc_ctl.create_reloc_tree不存在
	或者root是BTRFS_TREE_RELOC_OBJECTID，返回0
3.如果trans不用reloc_reserved，使用rc-&gt;block_rsv进行4
4.create_reloc_root
5.__add_reloc_root
6.root-&gt;reloc_root = reloc_root
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2440</x>
      <y>2777</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2413</x>
      <y>2798</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_reloc_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2417</x>
      <y>2794</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2403</x>
      <y>2805</y>
      <w>34</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2417</x>
      <y>2801</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1825</x>
      <y>2650</y>
      <w>217</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1825</x>
      <y>2650</y>
      <w>285</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2830.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1825</x>
      <y>2648</y>
      <w>370</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;30.0;3680.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1825</x>
      <y>2645</y>
      <w>506</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;60.0;3750.0;10.0;5040.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2209</x>
      <y>2731</y>
      <w>104</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1020.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2210</x>
      <y>2731</y>
      <w>136</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1340.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2209</x>
      <y>2731</y>
      <w>188</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1860.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2209</x>
      <y>2731</y>
      <w>224</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2220.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1641</x>
      <y>2580</y>
      <w>216</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2140.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1848</x>
      <y>2586</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_add_delayed_tree_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1840</x>
      <y>2593</y>
      <w>39</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.申请delayed_tree_ref，head_ref
	如果quota_enabled并且ref_root是is_fstree，申请record
	head_ref-&gt;extent_op = extent_op
2.add_delayed_ref_head将head_ref插入trans-&gt;transaction-&gt;delayed_refs
3.add_delayed_tree_ref插入ref插入head_ref
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1857</x>
      <y>2589</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1836</x>
      <y>2605</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_delayed_ref_head</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1831</x>
      <y>2612</y>
      <w>37</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.根据action设置count_mod和must_insert_reserved
2.设置ref和其container head_ref
	ref-&gt;bytenr = bytenr;
	ref-&gt;num_bytes = num_bytes;
	ref-&gt;ref_mod = count_mod;
	ref-&gt;type  = 0;
	ref-&gt;action  = 0;
	ref-&gt;is_head = 1;
	ref-&gt;in_tree = 1;
	ref-&gt;seq = 0;
	head_ref = btrfs_delayed_node_to_head(ref);
	head_ref-&gt;must_insert_reserved = must_insert_reserved;
	head_ref-&gt;is_data = is_data;
	INIT_LIST_HEAD(&amp;head_ref-&gt;ref_list);
	head_ref-&gt;processing = 0;
	head_ref-&gt;total_ref_mod = count_mod;
	head_ref-&gt;qgroup_reserved = 0;
	head_ref-&gt;qgroup_ref_root = 0;
3.如果有qrecord
	1.如果有ref_root，reserved
		head_ref-&gt;qgroup_ref_root = ref_root;
		head_ref-&gt;qgroup_reserved = reserved;
	2.qrecord-&gt;bytenr = bytenr;
		qrecord-&gt;num_bytes = num_bytes;
		qrecord-&gt;old_roots = NULL;
	3.btrfs_qgroup_insert_dirty_extent将qrecord加入到红黑树dirty_extent_root中
4.htree_insert将head_ref插入到trans-&gt;transaction-&gt;delayed_refs中
5.如果head_ref之前存在
	1.通过update_existing_head_ref更新exting为ref内容，并释放head_ref
	2.head_ref = existing
6.如果正常插入
	1.如果is_data，并且count_mod小于0
		delayed_refs-&gt;pending_csums += num_bytes
	2.delayed_refs-&gt;num_heads++;
		delayed_refs-&gt;num_heads_ready++;
		atomic_inc(&amp;delayed_refs-&gt;num_entries);
		trans-&gt;delayed_ref_updates++;
7.返回head_ref
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1843</x>
      <y>2608</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1844</x>
      <y>2601</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1874</x>
      <y>2605</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_delayed_tree_ref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1870</x>
      <y>2612</y>
      <w>41</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.action  BTRFS_ADD_DELAYED_EXTENT  --&gt;BTRFS_ADD_DELAYED_REF
2.如果是is_fstree，读取tree_mod_seq设置seq
3.设置ref和其container full_ref
	atomic_set(&amp;ref-&gt;refs, 1);
	ref-&gt;bytenr = bytenr;
	ref-&gt;num_bytes = num_bytes;
	ref-&gt;ref_mod = 1;
	ref-&gt;action = action;
	ref-&gt;is_head = 0;
	ref-&gt;in_tree = 1;
	ref-&gt;seq = seq;
	full_ref-&gt;parent = parent;
	full_ref-&gt;root = ref_root;
4.如果有parent，设置ref-&gt;type为BTRFS_SHARED_BLOCK_REF_KEY
	否则设置为BTRFS_TREE_BLOCK_REF_KEY
5.full_ref-&gt;level = level
6.add_delayed_ref_tail_merge将ref加入trans-&gt;transaction-&gt;delayed_refs中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1877</x>
      <y>2601</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1883</x>
      <y>2608</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1919</x>
      <y>2612</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_delayed_ref_tail_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1915</x>
      <y>2618</y>
      <w>41</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果href为空，直接跳到add_tail
2.否则取出最后一个prev
	1.如果type或者seq不一样，直接跳到add_tail
	2.如果type是BTRFS_TREE_BLOCK_REF_KEY或者BTRFS_SHARED_BLOCK_REF_KEY
		通过comp_tree_refs对比，不同跳到add_tail
	3.如果type是BTRFS_EXTENT_DATA_REF_KEY或者BTRFS_SHARED_DATA_REF_KEY
		通过comp_data_refs对比，不同跳到add_tail
	4.设置mod
		1.如果action相同，
			mod = ref-&gt;ref_mod
		2.如果exit&lt;ref
			exist-&gt;action = ref-&gt;action;
			mod = -exist-&gt;ref_mod;
			exist-&gt;ref_mod = ref-&gt;ref_mod;
		3.否则mod = -ref-&gt;ref_mod
		4.exist-&gt;ref_mod += mod
		5.如果ref_mod为0，drop_delayed_ref将href从红黑树或者链表中删除
3.add_tail
	1.将ref加入到href-&gt;ref_list链表中
	2.trans-&gt;delayed_ref_updates++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1928</x>
      <y>2615</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1910</x>
      <y>2612</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;20.0;90.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1656</x>
      <y>2541</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_root_to_dirty_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1648</x>
      <y>2547</y>
      <w>43</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果root的BTRFS_ROOT_DIRTY置上，或者BTRFS_ROOT_TRACK_DIRTY没置上，直接返回
2.置上BTRFS_ROOT_DIRTY
	1.如果是BTRFS_EXTENT_TREE_OBJECTID，list_move_tail将root加入
		链表dirty_cowonly_roots的尾端
	2.否则list_move将其加入到dirty_cowonly_roots链表的前端
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1665</x>
      <y>2544</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1660</x>
      <y>2538</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1745</x>
      <y>2549</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>insert_ptr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1737</x>
      <y>2555</y>
      <w>38</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果插入的slot不是最后一个
	1.如果level不为0，tree_mod_log_eb_move记录log MOD_LOG_MOVE_KEYS
	2.memmove_extent_buffer将lower的item向后移动一个位置
2.如果level不为0，通过tree_mod_log_insert_key添加log MOD_LOG_KEY_ADD
3.btrfs_set_node_key设置第slot个item的key
4.btrfs_set_node_blockptr设置item的bytenr
5.btrfs_set_node_ptr_generation设置item generation(trans-&gt;transid)
6.lower.btrfs_header.nritems+=1
7.btrfs_mark_buffer_dirty标记lower dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1751</x>
      <y>2552</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1745</x>
      <y>2459</y>
      <w>58</w>
      <h>87</h>
    </coordinates>
    <panel_attributes>4.again
	1.如果slot在mid右边
		1.如果只有一个item，或者后半段使用空间+data_size超过eb大小
			1.如果slot超过nritems
				split = 0;//不做分割
			2.否则
				1.mid = slot;
				2.slot~nritems使用空间+data_size超过eb大小
					1.如果有data_size，并且不用tried_avoid_double(之前没跳过)，跳到push_for_double
					2.否则
						split = 2
	2.如果在mid左边
		1.左半段空间+data_size超过eb
			1.如果在slot 0之前(!extend)开始插入data_size
				split = 0//不做分割
			2.如果在slot中间插入，或者干脆不插入数据
				mid = 1
			3.否则
				1.mid = slot
				2.左半段没满，并且左半段空间插入数据后超过eb的长度
					1.如果有data_size，但是不用tried_avoid_double(之前没跳过)，跳到push_for_double
					2.否则split = 2
	3.如果split为0，通过btrfs_cpu_key_to_disk利用ins_key设置disk_key
		否则通过btrfs_item_key读取eb[mid]处的disk_key
	4.通过btrfs_alloc_tree_block申请eb right
		1.root_add_used递增root-&gt;root_item.bytes_used+=nodesize
		2.btrfs_header.nritems=1
			btrfs_header.level=0
			btrfs_header.bytenr=right-&gt;start
			btrfs_header.generation=trans-&gt;transid
			btrfs_header.flags=eb | BTRFS_MIXED_BACKREF_REV
			btrfs_header.owner= root-&gt;root_key.objectid
			btrfs_header.fsid=root-&gt;fs_info-&gt;fsid
			btrfs_header.chunk_tree_uuid=fs_info-&gt;chunk_tree_uuid
	5.如果split为0，将right和父节点和path关联
		1.如果在右半段
			1.btrfs_header.nritems=0
			2.insert_ptr在将right-&gt;start插入level 1的右半段(slots[1] + 1)
			3.free_extent_buffer释放node[0]
			4.更新path
				path-&gt;nodes[0] = right;
				path-&gt;slots[0] = 0;
				path-&gt;slots[1] += 1;
		2.如果在左半段
			1.btrfs_header.nritems=0
			2.insert_ptr在将right-&gt;start插入level 1的右半段(slots[1])
			3.free_extent_buffer释放node[0]
			4.path-&gt;nodes[0] = right;
				path-&gt;slots[0] = 0;
			5.如果right所在的slot为0，fixup_low_keys更新父节点中的key
		3.btrfs_mark_buffer_dirty标记right dirty，并返回
	6.copy_for_split对l进行分段，将mid~nritems分到right中
5.如果还需要split，递增num_doubles，跳到again
6.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1794</x>
      <y>2549</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_for_split</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1780</x>
      <y>2556</y>
      <w>45</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.right.btrfs_header.nritems=nritems - mid
2.copy_extent_buffer复制mid~nritems的item到right
3.copy_extent_buffer复制mid~nritems的数据到right
4.循环更改right item中的offset
5.l.btrfs_header.nritems=mid
6.读取right的disk_key，并通过insert_ptr在parent中插入和right的关系(slot+1)
	并通过btrfs_mark_buffer_dirty标记right和l
7.如果slot在mid的右边
	1.释放原有的node[0]
	2.建立新的path关系
		path-&gt;nodes[0] = right;
		path-&gt;slots[0] -= mid;
		path-&gt;slots[1] += 1;
8.如果在mid左边，直接释放对right的引用
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1812</x>
      <y>2459</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>7.push_for_double：
	1.push_for_double_split向左右两个leaf腾出data_size的空间
	2.tried_avoid_double = 1
	3.如果node[0]的free_space超过了data_size直接返回0
	4.否则跳到again
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1822</x>
      <y>2473</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>push_for_double_split</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1829</x>
      <y>2468</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1813</x>
      <y>2481</y>
      <w>38</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果slot在node[0]范围内，更新需要的space
	space_needed -=node[0] free_space
2.push_leaf_right向右压缩space_needed的空间，如果出错，直接返回
	如果成功压缩，progress++
3.只要所在的slot在0，或者最后一个，直接返回0，再做split
4.如果node[0]剩余空间超过了data_size，直接返回0
5.通过push_leaf_left再向左leaf压缩空间，如果成功progress++
6.如果有成功压缩过，返回0，否则返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1830</x>
      <y>2476</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1799</x>
      <y>2552</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1798</x>
      <y>2545</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1750</x>
      <y>2545</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1287</x>
      <y>2477</y>
      <w>224</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2220.0;10.0;10.0;320.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1537</x>
      <y>2477</y>
      <w>95</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;930.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1664</x>
      <y>2447</y>
      <w>95</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;930.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1665</x>
      <y>2447</y>
      <w>165</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1630.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1034</x>
      <y>2526</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>push_nodes_for_insert</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1043</x>
      <y>2522</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1030</x>
      <y>2533</y>
      <w>33</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>1.读取父节点，如果不存在，直接返回1
	parent = path-&gt;nodes[level + 1];
	pslot = path-&gt;slots[level + 1];
2.read_node_slot读取parent[pslot-1] left
	1.btrfs_tree_lock和btrfs_set_lock_blocking对left上锁
	2.如果left的item数量超过限制，或者btrfs_cow_block上锁失败
		wret = 1
	3.否则上锁后，push_node_left将mid中的item移部分到left中
3.如果成功
	1.btrfs_node_key读取mid[0]的key，通过btrfs_set_node_key写入parent[pslot]
		并通过tree_mod_log_set_node_key记录log，btrfs_mark_buffer_dirty标记
		parent为dirty
	2.如果node在left
		1.更新path
			path-&gt;nodes[level] = left;
			path-&gt;slots[level + 1] -= 1;
			path-&gt;slots[level] = orig_slot;//之前已经加上了left中的item的数量
		2.free_extent_buffer释放对mid的引用
	3.如果node还在mid中
		1.path-&gt;slots[level] -=btrfs_header_nritems(left)
		2.free_extent_buffer释放对left的引用
	4.返回0
4.这里没对mid进行push_left操作，free_extent_buffer释放对left的引用
5.读取right，通过balance_node_right将mid的item移到right中，如果成功返回0
6.如果失败，返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1041</x>
      <y>2529</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2050</x>
      <y>2391</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_next_old_leaf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2040</x>
      <y>2398</y>
      <w>41</w>
      <h>89</h>
    </coordinates>
    <panel_attributes>1.如果node[0]不存在item，返回1
2.读取node[0]最后一个item的key
3.again
	1.btrfs_release_path释放path
	2.path-&gt;keep_locks = 1;
		path-&gt;leave_spinning = 1;
	3.如果存在time_seq，通过btrfs_search_old_slot查找key
		否则直接通过btrfs_search_slot查找
	4.path-&gt;keep_locks = 0
	5.所寻找的slot在 nritems - 1范围内
		1.如果段正好找到(ret=0),选取下一个slot
			path-&gt;slots[0]++
		2.如果返回1，因为在search_slot时选取的是前一个，所以当前slot[0]
			是next_leaf
	6.还有slot就在nritems - 1的情况没讨论，如果此时返回1，和3.5.2情况一致
	注：运行到这里只有一种情况，slot[0]在nritems-1上，但是ret=0
	7.循环path树，找到parent[right]
		1.如果没有父节点，说明这个leaf是最后一个，返回1
		2.如果right所在slot超过了parent c的nritems
			1.level++
			2.如果到达最大level，返回1，表示不存在
			3.否则continue
		3.如果存在next，先通过free_extent_buffer将其释放
		4.通过read_block_for_search读取c[slot],如果返回EAGAIN，说明有磁盘IO
			跳到again重新建立path，如果出错，释放path，并跳到done
		5.如果不能skip_locking
			1.通过btrfs_try_tree_read_lock上读锁
			2.如果出错
				1.如果有time_seq
					1.释放path和next，并跳到again
				2.如果没有
					1.通过btrfs_tree_read_lock上读锁
			3.next_rw_lock = BTRFS_READ_LOCK
		6.退出循环
	8.path-&gt;slots[level] = slot;
	9.向下循环，找到parent[right][0][0]...
		1.level--
		2.释放path-&gt;locks[level]
		3.释放对原有path.node的引用
		4.更新path
			path-&gt;nodes[level] = next;
			path-&gt;slots[level] = 0
		5.如果不能skip_locking
			path-&gt;locks[level] = next_rw_lock
		6.如果遍历到leaf，退出循环
		7.read_block_for_search查找next[0],如果返回EAGAIN，跳到again重新查找
			如果出错，释放path，并跳到done
		8.如果不能skip_locking
			1.通过btrfs_try_tree_read_lock对next上锁
			2.如果出错，通过btrfs_tree_read_lock上锁
		9.next_rw_lock = BTRFS_READ_LOCK
	10.返回0
4.done
	1.还原path-&gt;leave_spinning
	2.如果old_spinning没置上，btrfs_set_path_blocking
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2057</x>
      <y>2394</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2104</x>
      <y>2384</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_one_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2052</x>
      <y>2385</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_next_leaf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2057</x>
      <y>2388</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2090</x>
      <y>2392</y>
      <w>43</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.读取dev_item中的devid，dev_uuid，fs_uuid
2.如果fs_uuid和fs_info-&gt;fsid不同，通过open_seed_devices获取
	fs_devices
3.btrfs_find_device遍历fs_info-&gt;fs_devices链表中fs_device.devices
	链表，找到devid和uuid相同的device
4.如果没找到
	1.如果MOUNT_DEGRADED没置上，返回EIO
	2.add_missing_dev申请device加入到fs_devices中
5.如果找到
	1.bdev不存在，并且MOUNT_DEGRADED没置上，返回EIO
	2.如果bdev不存在，并且missing没置上
		device-&gt;fs_devices-&gt;missing_devices++;
		device-&gt;missing = 1
	3.如果所在的fs_devices和指定的不同
		1.将其迁到指定的fs_devices
6.如果不是fs_info-&gt;fs_devices，当generation不同时，返回EINVAL
7.fill_device_from_item通过dev_item填充device
	device-&gt;in_fs_metadata = 1;
8.如果device的writeable置上，但是is_tgtdev_for_dev_replace没置上
	device-&gt;fs_devices-&gt;total_rw_bytes += device-&gt;total_bytes
	root-&gt;fs_info-&gt;free_chunk_space += device-&gt;total_bytes -
			device-&gt;bytes_used;
9.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2108</x>
      <y>2387</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2090</x>
      <y>2433</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>open_seed_devices</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2095</x>
      <y>2429</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2095</x>
      <y>2436</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2086</x>
      <y>2441</y>
      <w>37</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.遍历链表fs_info-&gt;fs_devices-&gt;seed，如果找到fsid相同的
	fs_devices，即返回
2.再次通过find_fsid遍历fs_uuids链表，看是否能找到对应的fs_devices
3.如果还没找到
	1.root的MOUNT_DEGRADED要置上
	2.alloc_fs_devices申请fs_devices，并返回
		fs_devices-&gt;seeding = 1;
		fs_devices-&gt;opened = 1;
4.如果能找到，通过clone_fs_devices复制一份fs_devices
5.__btrfs_open_devices打开链表fs_devices-&gt;devices中的device
6.如果不用seeding
	1.__btrfs_close_devices关闭链表fs_devices-&gt;devices中的所有device
	2.释放fs_device
	3.返回EINVAL
7.将fs_devices加入链表root-&gt;fs_info-&gt;fs_devices-&gt;seed
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2047</x>
      <y>2490</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_search_old_slot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2053</x>
      <y>2486</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2094</x>
      <y>2469</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>clone_fs_devices</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2098</x>
      <y>2465</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2099</x>
      <y>2472</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2087</x>
      <y>2476</y>
      <w>31</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.alloc_fs_devices申请fs_devices
	fs_devices-&gt;total_devices = orig-&gt;total_devices
2.遍历orig-&gt;devices
	1.btrfs_alloc_device申请device
	2.通过rcu_string_strdup指定device-&gt;name
	3.加入fs_devices-&gt;devices链表
		device-&gt;fs_devices = fs_devices;
		fs_devices-&gt;num_devices++;
3.返回fs_devices
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2095</x>
      <y>2495</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_alloc_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2100</x>
      <y>2491</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2086</x>
      <y>2501</y>
      <w>34</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.__alloc_device申请device
2.如果没指定devid，通过find_next_devid寻找最大devid+1
注：如果devid最大为-1，没做处理
3.dev-&gt;devid = tmp
4.设置dev-&gt;uuid
5.btrfs_init_work初始化dev-&gt;work
6.返回dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2100</x>
      <y>2498</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2096</x>
      <y>2515</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_next_devid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2100</x>
      <y>2512</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2101</x>
      <y>2518</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2087</x>
      <y>2521</y>
      <w>30</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.通过btrfs_search_slot找到nritms
2.btrfs_previous_item寻找最后一个DEV_ITEM
3.如果没找到
	devid_ret = 1
4.否则获取最后一个item的key
	devid_ret = found_key.offset + 1
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2097</x>
      <y>2535</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_previous_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2102</x>
      <y>2532</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2102</x>
      <y>2538</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2087</x>
      <y>2541</y>
      <w>36</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.循环向前查找item
	1.如果leaf在slot 0，通过btrfs_prev_leaf获取prev_leaf
	2.否则直接path-&gt;slots[0]--
	3.如果leaf中nritems是0，返回1，表示不存在
	4.如果slots[0]是nritems
		path-&gt;slots[0]--
	5.获取该slot的key
		1.不能小于min_objectid
		2.type相同，直接返回0，表示找到
		3.如果是min_objectid，但是type小于预期值，直接退出循环
2.如果退出循环，返回1，表示没找到
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2098</x>
      <y>2562</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_prev_leaf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2103</x>
      <y>2559</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2104</x>
      <y>2565</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2089</x>
      <y>2568</y>
      <w>34</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.读取slot 0的key
2.指定prev_leaf中的特征
	1.如果offset&gt;0
		offset--
	2.offset=0 type&gt;0
		key.type--;
		key.offset = (u64)-1;
	3.offset=0 type=0 objectid&gt;0
		key.objectid--;
		key.type = (u8)-1;
		key.offset = (u64)-1;
	4.否则返回1，表示没找到
3.btrfs_search_slot查找对应的key
4.获取prev_leaf的slot 0的key，通过comp_keys和查找的可以进行对比
	如果小于要查找的key，返回0，否则返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2039</x>
      <y>2497</y>
      <w>42</w>
      <h>44</h>
    </coordinates>
    <panel_attributes>1.如果search_commit_root没置上，直接通过btrfs_search_slot获取
2.again
	1.get_old_root获取&gt;=time_seq的最小的root，并上读锁
		p-&gt;locks[level] = BTRFS_READ_LOCK
	2.循环获取path
		1.p-&gt;nodes[level] = b
		2.btrfs_clear_path_blocking，btrfs_unlock_up_safe清锁
		3.key_search查找key
		4.如果不是leaf
			1.如果没找到offset，offset所在的slot是找到的slot-1
				dec = 1;
				slot -= 1;
			2.p-&gt;slots[level] = slot;
			3.如果到最低的level，复原slot，并跳到done
			4.read_block_for_search查找slot对应的eb
			5.如果返回EAGAIN，不在缓存中，跳到again
				如果出错，返回err，跳到done
			6.btrfs_tree_read_lock_atomic和btrfs_tree_read_lock给新的eb上读锁
			7.tree_mod_log_rewind对新eb进行回滚
			8.p-&gt;locks[level] = BTRFS_READ_LOCK;
				p-&gt;nodes[level] = b;
		5.如果是leaf，跳到done
			p-&gt;slots[level] = slot
	3.返回1
3.done
	1.如果leave_spinning没置上，btrfs_set_path_blocking
	2.如果出错，btrfs_release_path释放path
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2055</x>
      <y>2493</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2033</x>
      <y>2544</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_old_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1995</x>
      <y>2590</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__tree_mod_log_oldest_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1984</x>
      <y>2596</y>
      <w>36</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果没有time_seq，返回NULL
2.循环
	1.tree_mod_log_search_oldest在log的红黑树中寻找
		在&gt;=time_seq的范围内找最小的tm
	2.如果之前没loop，并且没找到tm，返回NULL
	3.如果此次没找到tm，退出循环
	4.如果记录log的操作不是MOD_LOG_ROOT_REPLACE，退出循环
	5.记录找到的tm
		found = tm;
		root_logical = tm-&gt;old_root.logical;
		looped = 1;
3.如果没found，如果op不对，还是记录found
3.返回found
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1990</x>
      <y>2621</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tree_mod_log_search_oldest</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1990</x>
      <y>2627</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__tree_mod_log_search</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1999</x>
      <y>2617</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1998</x>
      <y>2624</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1998</x>
      <y>2630</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1979</x>
      <y>2633</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历红黑树fs_info-&gt;tree_mod_log
	1.依次按start，min_seq进行查找
注：1.由__tree_mod_log_insert可知大值存在左边，小值存在右边
	2.smallest没置上，找seq最大的node；
		如果置上，找seq最小的node(不能小于min_seq)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2003</x>
      <y>2593</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2005</x>
      <y>2588</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2024</x>
      <y>2551</y>
      <w>37</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.btrfs_read_lock_root_node上读锁，获取root.node(eb_root)
2.__tree_mod_log_oldest_root寻找&gt;=time_seq最小的tm
	如果没找到，直接返回原来的eb_root
3.如果是MOD_LOG_ROOT_REPLACE
	old_root = &amp;tm-&gt;old_root;
	old_generation = tm-&gt;generation;
	logical = old_root-&gt;logical;
4.否则
	logical = eb_root-&gt;start
5.tree_mod_log_search搜寻&gt;=time_seq最大的seq
6.如果两次都找到正常的tm
	1.free_extent_buffer释放eb_root
	2.read_tree_block读取old_root
	3.如果old有uptodate，通过btrfs_clone_extent_buffer
		复制一份eb，并释放old
7.如果只是第一次正常，释放eb_root，alloc_dummy_extent_buffer申请eb
8.否则
	1.btrfs_clone_extent_buffer复制eb_root
	2.free_extent_buffer释放eb_root
9.如果没eb，返回NULL,否则extent_buffer_get递增eb计数
10.设置eb的header
11.__tree_mod_log_rewind从最大seq进行log回滚
12.返回eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2029</x>
      <y>2591</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_clone_extent_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2036</x>
      <y>2588</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2036</x>
      <y>2594</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2021</x>
      <y>2598</y>
      <w>34</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.__alloc_extent_buffer申请eb
2.为eb循环申请page，并将eb和page关联
	attach_extent_buffer_page(new, p)
	SetPageUptodate(p);
	new-&gt;pages[i] = p
3.copy_extent_buffer复制src到new.page
4.将new的EXTENT_BUFFER_UPTODATE和EXTENT_BUFFER_DUMMY置上
	并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2052</x>
      <y>2588</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2064</x>
      <y>2591</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__tree_mod_log_rewind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2057</x>
      <y>2598</y>
      <w>34</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.遍历tm红黑树链表
	1.进行tm.op的回滚
		1.如果是MOD_LOG_KEY_REMOVE恢复其key，blockptr，gen
			n++
		注：后面增加的item会在后续会有其他动作，比如move
		2.如果是MOD_LOG_KEY_REPLACE恢复其key，blockptr，gen
		3.如果是MOD_LOG_KEY_ADD
			n--
		4.如果是MOD_LOG_MOVE_KEYS，将item移回原来的slot
		5.如果是MOD_LOG_ROOT_REPLACE，不做处理
	2.遍历rb_next，如果index不同，退出循环
2.btrfs_set_header_nritems重新设置eb的nritems
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2072</x>
      <y>2594</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2037</x>
      <y>2547</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2038</x>
      <y>2540</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1008</x>
      <y>2369</y>
      <w>1052</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10500.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1008</x>
      <y>2369</y>
      <w>1104</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;11020.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>564</x>
      <y>2311</y>
      <w>1760</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
retry_root_backup
设置</panel_attributes>
    <additional_attributes>10.0;10.0;17580.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2307</x>
      <y>2318</y>
      <w>37</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>1.read_tree_block读取tree_root-&gt;node
2.btrfs_set_root_node设置tree_root-&gt;root_item
3.tree_root-&gt;commit_root=tree_root.node
4.tree_root-&gt;root_item.refs= 1
5.btrfs_read_roots读取tree_root中的extent，dev,csum,quota,uuid树
6.fs_info-&gt;generation = disk_super.generation;
	fs_info-&gt;last_trans_committed = disk_super.generation;
7.btrfs_recover_balance读取并设置fs_info-&gt;balance_ctl
8.btrfs_init_dev_stats读取DEV_STATS填充dev.dev_stat_values数组
9.btrfs_init_dev_replace设置fs_info-&gt;dev_replace
10.btrfs_close_extra_devices关闭fs_devices上的device
11.btrfs_sysfs_add_fsid初始化fs_devices.fsid_kobj()
12.btrfs_sysfs_add_device在fsid_kobj下创建device_dir_kobj(名称：devices)
13.btrfs_sysfs_add_mounted在fsid_kobj下添加文件夹及属性
14.btrfs_init_space_info添加space_info
15.btrfs_read_block_groups读取extent_root中存储的block_group
	信息，并和space_info关联
16.btrfs_calc_num_tolerated_disk_barrier_failures计算fs_info.num_tolerated_disk_barrier_failures
	如果missing_devices超过了这个数，并且sb不是readonly，报错
17.为tree_root开启两个线程fs_info-&gt;cleaner_kthread   fs_info-&gt;transaction_kthread
18.如果tree_root的MOUNT_SSD和MOUNT_NOSSD都没置上，并且不是rotating
	btrfs_set_opt(fs_info-&gt;mount_opt, SSD)
19.btrfs_apply_pending_changes根据pending_changes设置或者清除fs_info.mount_opt
	的INODE_MAP_CACHE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>720</x>
      <y>2332</y>
      <w>176</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1740.0;200.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>721</x>
      <y>2332</y>
      <w>278</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2760.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2191</x>
      <y>2364</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_read_roots</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2196</x>
      <y>2358</y>
      <w>115</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1130.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2181</x>
      <y>2370</y>
      <w>36</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.btrfs_read_tree_root在tree_root中搜索EXTENT_TREE
	1.设置root的BTRFS_ROOT_TRACK_DIRTY
	2.fs_info-&gt;extent_root = root
2.btrfs_read_tree_root搜索DEV_TREE
	1.设置root的BTRFS_ROOT_TRACK_DIRTY
	2.fs_info-&gt;dev_root = root
	3.btrfs_init_devices_late遍历fs_info-&gt;fs_devices链表
		设置device-&gt;dev_root = fs_info-&gt;dev_root
3.btrfs_read_tree_root搜索CSUM_TREE
	1.设置root的BTRFS_ROOT_TRACK_DIRTY
	2.fs_info-&gt;csum_root = root
4.btrfs_read_tree_root搜索QUOTA_TREE
	1.设置root的BTRFS_ROOT_TRACK_DIRTY
	2.fs_info-&gt;quota_enabled = 1;
		fs_info-&gt;pending_quota_state = 1;
		fs_info-&gt;quota_root = root;
5.btrfs_read_tree_root搜索UUID_TREE
	1.设置root的BTRFS_ROOT_TRACK_DIRTY
	2.fs_info-&gt;uuid_root = root
6.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2196</x>
      <y>2367</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2177</x>
      <y>2406</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_read_tree_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2183</x>
      <y>2402</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2182</x>
      <y>2409</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2165</x>
      <y>2412</y>
      <w>35</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_path申请path
2.btrfs_alloc_root申请root
	root-&gt;fs_info = fs_info
3.__setup_root初始化root
4.btrfs_find_root查找key对应的eb，并且
	设置root-&gt;root_item
5.read_tree_block根据root_item读取root所在的eb
	root-&gt;node
6.如果没有uptodate，释放root.node，并返回EIO
7.root-&gt;commit_root=root.node
8.返回root
9.find_fail：
	1.释放root，并返回错误
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2161</x>
      <y>2436</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_find_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2166</x>
      <y>2433</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2150</x>
      <y>2443</y>
      <w>35</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot搜寻search_key
2.如果offset对不上，直接跳到out，返回1
	如果是搜寻最大的
	path-&gt;slots[0]--;
	ret = 0;
3.如果搜寻的objectid不同，或者type不是BTRFS_ROOT_ITEM_KEY
	直接返回1
4.btrfs_read_root_item设置root_item
5.root_key返回found_key
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2165</x>
      <y>2439</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2157</x>
      <y>2462</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_read_root_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2150</x>
      <y>2469</y>
      <w>35</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.以btrfs_root_item的方式解析slot对应的数据，通过read_extent_buffer
	读取到item中
2.如果长度不够
	need_reset=1
3.generation和generation_v2不同
	need_reset = 1
4.如果need_reset置上
	1.将item.generation_v2的空间清空
	2.设置item-&gt;uuid
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2165</x>
      <y>2458</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2164</x>
      <y>2465</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2233</x>
      <y>2362</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_recover_balance</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2240</x>
      <y>2358</y>
      <w>81</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fs_info-&gt;balance_ctl</panel_attributes>
    <additional_attributes>790.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2222</x>
      <y>2369</y>
      <w>38</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_path申请path，并通过btrfs_search_slot在tree_root中
	查找BTRFS_BALANCE_OBJECTID，如果不为0，跳到out
2.申请bctl
	1.以btrfs_balance_item解析查找到的path数据
	2.bctl-&gt;fs_info = fs_info
		bctl-&gt;flags =item.flags |BTRFS_BALANCE_RESUME
	3.btrfs_balance_data读取item.data到disk_bargs
		并根据disk_bargs设置bctl-&gt;data
	4.btrfs_balance_meta和btrfs_disk_balance_args_to_cpu
		读取item.meta,并设置bctl-&gt;meta
	5.btrfs_balance_sys和btrfs_disk_balance_args_to_cpu
		读取item.sys,并依此设置bctl-&gt;sys
	6.set_balance_control设置
		fs_info-&gt;balance_ctl = bctl;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2239</x>
      <y>2365</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2265</x>
      <y>2362</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_init_dev_stats</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2268</x>
      <y>2358</y>
      <w>71</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fs_devices-&gt;devices</panel_attributes>
    <additional_attributes>690.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2272</x>
      <y>2365</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2261</x>
      <y>2369</y>
      <w>32</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_path申请path
2.遍历fs_devices-&gt;devices链表
	1.btrfs_search_slot查找对应devid
	2.如果没有正好找到
		1.__btrfs_reset_dev_stats重置dev_stat_values数组
		2.device-&gt;dev_stats_valid = 1;
		3.btrfs_release_path重置path，并continue
	3.根据slot的数据通过btrfs_dev_stat_set设置数组
		dev_stat_values，如果数据中没描述的通过btrfs_dev_stat_reset重置
	注：以btrfs_dev_stats_item方式解析数据，获取其中的values数组
	4.device-&gt;dev_stats_valid = 1;
	5.重置path
3.out:
	1.重置path，并返回ret（只有错误和0）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2250</x>
      <y>2395</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__btrfs_reset_dev_stats</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2258</x>
      <y>2392</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2249</x>
      <y>2401</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_dev_stat_set</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2256</x>
      <y>2398</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2240</x>
      <y>2407</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.dev-&gt;dev_stat_values[index]=val
2.dev-&gt;dev_stats_ccnt++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2256</x>
      <y>2404</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2299</x>
      <y>2362</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_init_dev_replace</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2296</x>
      <y>2369</y>
      <w>34</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_path申请path，并通过btrfs_search_slot
	查找DEV_REPLACE
2.如果没找到合适的(no_valid_dev_replace_entry_found)
	1.重置fs_info-&gt;dev_replace
	2.跳到out
3.slot对应的数据通过btrfs_dev_replace_item解析
	1.size要完全相同
	2.设置fs_info-&gt;dev_replace
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2307</x>
      <y>2365</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2307</x>
      <y>2358</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fs_info-&gt;dev_replace</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2343</x>
      <y>2361</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_sysfs_add_mounted</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2334</x>
      <y>2368</y>
      <w>35</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.btrfs_set_fs_info_ptr设置fs_info-&gt;fs_devices链表中的fs_info
2.btrfs_sysfs_add_device_link在device_dir_kobj下为fs_devices中的dev
	创建link
3.为fsid_kobj创建btrfs_attrs
4.sysfs_create_group在fsid_kobj下创建文件夹btrfs_feature_attr_group
5.addrm_unknown_feature_attrs在fsid_kobj下创建btrfs_feature_attrs
6.kobject_create_and_add在fsid_kobj下创建space_info_kobj
7.sysfs_create_files在space_info_kobj添加allocation_attrs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2350</x>
      <y>2364</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2339</x>
      <y>2358</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sysfs</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2382</x>
      <y>2361</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_init_space_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2389</x>
      <y>2364</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2374</x>
      <y>2368</y>
      <w>37</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.获取fs_info-&gt;super_copy
2.如果没有root，返回1
3.如果其incompat_flags中BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS置上
	mixed = 1
4.update_space_info以BTRFS_BLOCK_GROUP_SYSTEM方式添加space_info
5.如果mixed
	1.update_space_info以METADATA |DATA的方式添加space_info
6.否则METADATA和DATA单独添加
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2364</x>
      <y>2386</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>update_space_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2369</x>
      <y>2382</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2370</x>
      <y>2389</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2356</x>
      <y>2393</y>
      <w>32</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.如果是DUP , RAID1,RAID10
	factor = 2
	否则
	factor = 1
2.__find_space_info遍历fs_info.space_info，找到
	flags相容的space_info
3.如果找到
	1.更新
		found-&gt;total_bytes += total_bytes;
		found-&gt;disk_total += total_bytes * factor;
		found-&gt;bytes_used += bytes_used;
		found-&gt;disk_used += bytes_used * factor;
	2.返回found，并返回0
4.如果没找到，申请并初始化
	found-&gt;flags = flags &amp; BTRFS_BLOCK_GROUP_TYPE_MASK;
	found-&gt;total_bytes = total_bytes;
	found-&gt;disk_total = total_bytes * factor;
	found-&gt;bytes_used = bytes_used;
	found-&gt;disk_used = bytes_used * factor;
5.kobject_init_and_add将found加入到space_info_kobj
6.返回found，并将其加入链表fs_info.space_info
7.如果BTRFS_BLOCK_GROUP_DATA置上
	info-&gt;data_sinfo = found;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2424</x>
      <y>2361</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_read_block_groups</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2414</x>
      <y>2368</y>
      <w>42</w>
      <h>82</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_path申请path
	path-&gt;reada = 1
2.need_clear置上的条件
	1.如果root的MOUNT_SPACE_CACHE置上，并且super_copy的gen和cache_gen相同
	2.或者MOUNT_CLEAR_CACHE置上
3.循环
	1.find_first_block_group搜寻第一个BLOCK_GROUP_ITEM
	2.如果没找到，退出循环，如果出错，跳到error
	3.根据找到的item的found_key，通过btrfs_create_block_group_cache创建cache
	4.如果need_clear，在MOUNT_SPACE_CACHE置上的情况
		cache-&gt;disk_cache_state = BTRFS_DC_CLEAR
	5.以cache-&gt;item的方式解析slots[0]的数据到cache-&gt;item
	6.cache-&gt;flags=cache-&gt;item.flags
	7.更新key.objectid
	8.btrfs_release_path重置path
	9.exclude_super_stripes统计cache中super的长度，如果失败
		1.free_excluded_extents清除freed_extents中的state
		2.btrfs_put_block_group释放cache
		3.跳到error
	10.如果cache已经全部被用
		1.cache-&gt;last_byte_to_unpin = (u64)-1;
			cache-&gt;cached = BTRFS_CACHE_FINISHED;
		2.free_excluded_extents清除freed_extents中state树
	11.如果cache完全没用
		1.cache-&gt;last_byte_to_unpin = (u64)-1;
			cache-&gt;cached = BTRFS_CACHE_FINISHED;
		2.add_new_free_space为block_group添加这段free_space
		3.free_excluded_extents清除freed_extents中state树
	12.btrfs_add_block_group_cache将block_group插入到红黑树中
		如果失败
		1.btrfs_remove_free_space_cache释放cache中的free_space
		2.btrfs_put_block_group释放cache
		3.跳到error
	13.update_space_info更新flags对应的space_info的长度信息
		cache-&gt;space_info = space_info
		cache-&gt;space_info-&gt;bytes_readonly += cache-&gt;bytes_super
		__link_block_group(space_info, cache)
	14.set_avail_alloc_bits设置fs_info-&gt;avail_data_alloc_bits
	15.如果是btrfs_chunk_readonly，inc_block_group_ro递增cache-&gt;ro
	16.如果cache完全没用
		1.btrfs_get_block_group递增cache
		2.list_add_tail将cache.bg_list连接到fs_info.unused_bgs
4.遍历fs_info-&gt;space_info
	1.检查space_info-&gt;flags)
	2.对space_info-&gt;block_groups中的BTRFS_RAID_RAID0和BTRFS_RAID_SINGLE
		两个bucket做inc_block_group_ro
5.init_global_block_rsv
	1.初始化block_rsv.space_info 
	2.初始化各个root-&gt;block_rsv
	3.update_global_block_rsv
6.释放path，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2431</x>
      <y>2364</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2328</x>
      <y>2457</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_first_block_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2335</x>
      <y>2449</y>
      <w>87</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>850.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2334</x>
      <y>2460</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2318</x>
      <y>2463</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot寻找key
2.从path.slot[0]开始遍历slot
	1.如果超过了leaf的nritems，btrfs_next_leaf更新path到下一个leaf
	2.btrfs_item_key_to_cpu读取slot的found_key
	3.如果objectid&gt;=指定值，type是BLOCK_GROUP即找到，返回0跳到out
	4.path-&gt;slots[0]++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2356</x>
      <y>2457</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_create_block_group_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2365</x>
      <y>2449</y>
      <w>75</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>730.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2366</x>
      <y>2460</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2356</x>
      <y>2463</y>
      <w>33</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.申请cache，和cache.free_space_ctl,并初始化
	cache-&gt;key.objectid = start;
	cache-&gt;key.offset = size;
	cache-&gt;key.type = BTRFS_BLOCK_GROUP_ITEM_KEY;
	cache-&gt;sectorsize = root-&gt;sectorsize;
	cache-&gt;fs_info = root-&gt;fs_info;
	cache-&gt;full_stripe_len = btrfs_full_stripe_len(root,
					       &amp;root-&gt;fs_info-&gt;mapping_tree,
					       start);
	atomic_set(&amp;cache-&gt;count, 1);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2365</x>
      <y>2483</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_full_stripe_len</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2372</x>
      <y>2480</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2371</x>
      <y>2486</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2358</x>
      <y>2490</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.lookup_extent_mapping搜寻logical所在的em
2.如果em.bdev的RAID56_MASK置上
	len = map-&gt;stripe_len * nr_data_stripes(map);
3.否则默认返回root-&gt;sectorsize
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2397</x>
      <y>2456</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>exclude_super_stripes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2404</x>
      <y>2449</y>
      <w>43</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2390</x>
      <y>2462</y>
      <w>33</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.如果cache在BTRFS_SUPER_INFO_OFFSET之前
	1.记录cache在super中的长度
		cache-&gt;bytes_super += stripe_len
	2.add_excluded_extent将在super中的长度加入
		fs_info-&gt;freed_extents数组
2.循环读取super镜像
	1.btrfs_sb_offset获取super镜像的偏移
	2.btrfs_rmap_block计算sb的逻辑偏移
	3.遍历返回的logical数组
		1.其逻辑偏移不在cache范围内，这里stripe_len的含义不清楚(raid56放在一个磁盘上)
		2.计算在cache范围内的长度len
		3.统计super在cache中的长度
			1.cache-&gt;bytes_super += len
			2.add_excluded_extent设置freed_extents数组中的两颗state树
	4.释放logical
3.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2405</x>
      <y>2459</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2392</x>
      <y>2491</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_rmap_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2397</x>
      <y>2487</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2397</x>
      <y>2494</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2390</x>
      <y>2498</y>
      <w>32</w>
      <h>65</h>
    </coordinates>
    <panel_attributes>1.lookup_extent_mapping寻找chunk_start的em
2.根据em-&gt;bdev的类型设置length和rmap_len
	1.默认是
		length = em-&gt;len;
		rmap_len = map-&gt;stripe_len;
	2.如果是RAID10(分组)
		length/=map-&gt;num_stripes / map-&gt;sub_stripes（一组的strips的数量）
	3.RAID0
		length/= map-&gt;num_stripes
	4.如果是RAID56_MASK(奇偶校验)
		length/= nr_data_stripes
		rmap_len = map-&gt;stripe_len * nr_data_stripes
3.根据num_stripes申请buf
4.遍历num_stripes
	1.stripes的devid对不上，遍历下一个
	2.physical不在stripes范围内，遍历下一个
	3.计算不在physical在strip的那个磁盘上
		offset/stripe_len
	4.计算physical的逻辑偏移
		1.如果是raid10，其物理偏移/组数量
		2.如果是raid0，直接是其物理偏移
		3.如果是raid56，前面已经加在rmap_len上
	5.计算其物理偏移量
		bytenr = chunk_start + stripe_nr * rmap_len
	6.将pysical的逻辑偏移存在buf
		1.查看buf中是否有和bytenr相同的
		2.如果没有，保存
			buf[nr++] = bytenr
	注：这里既然已经找到了pysical，为什么不直接退出，还要继续查找，难道physical可以对应不同的strip？
5.变量返回
	*logical = buf;
	*naddrs = nr;
	*stripe_len = rmap_len;
6.释放em，并返回0
注：num_stripes表示一块磁盘的stripe数目
	sub_stripes表示raid1备份共用的strip
	stripe_len表示strip在一块磁盘上的长度
	length表示一条strip的长度
	raid5时，奇偶校验每个磁盘需要一个content，总共需要一个strip，所以一个磁盘可用长度为
	stripe_len * nr_data_stripes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2437</x>
      <y>2455</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_new_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2445</x>
      <y>2449</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2442</x>
      <y>2458</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2425</x>
      <y>2461</y>
      <w>37</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.循环处理free_space
	1.find_first_extent_bit在pinned_extents从start开始找EXTENT_DIRTY | EXTENT_UPTODATE
		置上的state，如果没找到，退出循环
	2.如果是下面情况，更新start，继续下一次循环
		start = extent_end + 1;
	extend_start			extend_end
						start						end
	3.如果是下述情况，将不在pinned_extents中的部分通过btrfs_add_free_space
		加入到block_group,并更新start重新循环
			start = extent_end + 1;
		start							end
					extend_start				extend_end
	4.如果完全不在state范围内，退出循环(由find_first_extent_bit可知，start&lt;extend_end)
2.如果还存在长度，btrfs_add_free_space添加free_space到block_group中
3.返回添加的free_space的大小
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2425</x>
      <y>2489</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_first_extent_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2430</x>
      <y>2485</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2424</x>
      <y>2495</y>
      <w>32</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果有cached_state
	1.如果cache_state紧挨着start，并且在红黑树中
		1.遍历红黑树链表，如果有state相似的跳到got_it
		2.否则free_extent_state释放cache_state，跳到out
	2.否则free_extent_state释放cache_state，跳到out
2.find_first_extent_bit_state从start开始，在红黑树链表中
	找出和bits相似的state
3.got_it
	1.cache_state_if_flags 缓存state
	2.*start_ret = state-&gt;start;
		*end_ret = state-&gt;end;
		ret = 0;
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2430</x>
      <y>2492</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2429</x>
      <y>2519</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_first_extent_bit_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2437</x>
      <y>2516</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2437</x>
      <y>2522</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2424</x>
      <y>2525</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.tree_search查找start
2.遍历红黑树链表
	1.如果找到state相似的，即返回
	2.否则rb_next
3.找不到，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2464</x>
      <y>2455</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_add_block_group_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2464</x>
      <y>2462</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.遍历fs_info.block_group_cache_tree，
	如果block_group存在，返回EEXIST
2.插入红黑树
3.更新fs_info-&gt;first_logical_byte,返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2474</x>
      <y>2458</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2446</x>
      <y>2449</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2496</x>
      <y>2454</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__link_block_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2503</x>
      <y>2457</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2491</x>
      <y>2461</y>
      <w>33</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.get_block_group_index根据cache.flags获取存储的bucket
2.如果space_info-&gt;block_groups bucket为空
	first = true
3.将cache连接到bucket中
4.如果是first
	1.申请rkobj
		rkobj-&gt;raid_type = index
		rkobj-&gt;ktype = btrfs_raid_ktype
	2.kobject_add添加到space_info的sysfs下
	3.space_info-&gt;block_group_kobjs[index] = &amp;rkobj-&gt;kobj
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2454</x>
      <y>2449</y>
      <w>51</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;490.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2532</x>
      <y>2453</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_chunk_readonly</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2539</x>
      <y>2456</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2525</x>
      <y>2460</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.lookup_extent_mapping在map_tree中查找chunk_offset
2.遍历em.bdev的stripes
	1.统计dev-&gt;missing
	2.如果有dev.writeable没置上，readonly置上，并直接返回
3.如果miss_ndevs超过了限值，readonly置上
4.释放em，并返回readonly
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2564</x>
      <y>2453</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inc_block_group_ro</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2560</x>
      <y>2459</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.确定space_info的min_allocable_bytes
2.如果cache.ro存在，直接递增cache-&gt;ro，并返回0
3.如果space_info需要保存的空间没超过total_bytes
	1.sinfo-&gt;bytes_readonly += num_bytes;
		cache-&gt;ro++;
	2.cache-&gt;ro_list连接到sinfo-&gt;ro_bgs
	3.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2571</x>
      <y>2456</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2454</x>
      <y>2449</y>
      <w>90</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;880.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2454</x>
      <y>2449</y>
      <w>121</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2341</x>
      <y>2358</y>
      <w>53</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2341</x>
      <y>2358</y>
      <w>94</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2464</x>
      <y>2360</y>
      <w>33</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_calc_num_tolerated_disk_barrier_failures</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2460</x>
      <y>2367</y>
      <w>41</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.遍历链表fs_info-&gt;space_info，找到和type相同的space_info
2.遍历所有的sinfo-&gt;block_groups
	1.btrfs_get_block_group_info统计空间信息
	2.如果没有用，继续遍历下一个
	3.找到最小的btrfs_get_num_tolerated_disk_barrier_failures
		1.根据flags在btrfs_raid_array找到最小的tolerance
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2479</x>
      <y>2363</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2341</x>
      <y>2357</y>
      <w>137</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;20.0;1350.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2569</x>
      <y>2319</y>
      <w>36</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.btrfs_read_qgroup_config读取并建立qgroup和之间的关系
2.如果disk_super.log_root不为0，btrfs_replay_log
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2527</x>
      <y>2352</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_read_qgroup_config</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2535</x>
      <y>2348</y>
      <w>42</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>400.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2519</x>
      <y>2355</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读取status info limit</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2503</x>
      <y>2359</y>
      <w>37</w>
      <h>45</h>
    </coordinates>
    <panel_attributes>1.如果quota_enabled没开启，返回0
2.ulist_alloc为fs_info-&gt;qgroup_ulist申请ulist
3.btrfs_alloc_path申请path
4.btrfs_search_slot_for_read优先搜寻大于key的path
5.循环
	1.如果找到的是BTRFS_QGROUP_STATUS_KEY
		1.以btrfs_qgroup_status_item的方式解析slot的数据
		2.检查ptr.version ptr.generation
		3.fs_info-&gt;qgroup_flags=ptr.flags
		4.rescan_progress=ptr.rescan
		5.跳到next1
	2.如果不是BTRFS_QGROUP_INFO_KEY 也不是 BTRFS_QGROUP_LIMIT_KEY
		跳到next1
	3.find_qgroup_rb查找found_key.offset，
		1.BTRFS_QGROUP_INFO_KEY不在红黑树
		2.BTRFS_QGROUP_LIMIT_KEY要在红黑树中
		3.这个函数要满足以上两个条件，否则BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT置上
	4.如果没找到，通过add_qgroup_rb将其添加至红黑树
	5.如果是BTRFS_QGROUP_INFO_KEY
		1.以btrfs_qgroup_info_item方式解析slot数据
		2.根据ptr设置rfer rfer_cmpr excl excl_cmpr
	6.如果是BTRFS_QGROUP_LIMIT_KEY
		1.以btrfs_qgroup_limit_item方式解析slot数据
		2.根据ptr设置lim_flags max_rfer max_excl rsv_rfer rsv_excl
	7.next1
		1.btrfs_next_item遍历下一个slot
		2.如果出错，跳到out。如果没有，退出循环
6.释放path
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2463</x>
      <y>2406</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_search_slot_for_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2472</x>
      <y>2403</y>
      <w>34</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2471</x>
      <y>2409</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2458</x>
      <y>2413</y>
      <w>33</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot搜寻key
2.如果正好找到，或者出错，直接返回
注；下面都是返回1，slot是大于key的
3.如果find_higher置上
	1.如果slot超过leaf的nritems
		1.btrfs_next_leaf查找下一个leaf
		2.如果是0，或者出错直接返回
		3.如果不用一定要返回slot，返回1
		4.否则清掉return_any find_higher后，释放path
			跳到1
4.如果find_higher没置上
	1.如果在slot 0
		1.btrfs_prev_leaf寻找prev_leaf(这里通过keysearch找到的是nritems)
		2.如果出错，直接返回
		3.如果能找到
			1.如果找到nritems
				p-&gt;slots[0]--
			2.返回0
		4.这里没找到
			1.如果没置return_any，直接返回1
			2.如果置上
				1.清掉return_any，更改find_higher，跳到1重试
	2.如果不在slot 0
		--p-&gt;slots[0]
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2502</x>
      <y>2403</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2496</x>
      <y>2407</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_qgroup_rb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2492</x>
      <y>2414</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.遍历fs_info-&gt;qgroup_tree，找到qgroupid
	相同的node，否则返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2502</x>
      <y>2410</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2525</x>
      <y>2407</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_qgroup_rb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2528</x>
      <y>2403</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2521</x>
      <y>2414</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.遍历红黑树，如果找到qgroupid，直接返回
2.否则
	1.申请qgroup
		qgroup-&gt;qgroupid = qgroupid;
	2.插入到红黑树后，返回qgroup
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2530</x>
      <y>2410</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2536</x>
      <y>2355</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读取qgroup relation</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2541</x>
      <y>2359</y>
      <w>36</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot_for_read向上搜寻BTRFS_QGROUP_RELATION_KEY
2.训话
	1.要是BTRFS_QGROUP_RELATION_KEY
	2.子id(objectid)要小于父id(offset)
	3.add_relation_rb添加member和parent之间的list
	4.btrfs_next_item遍历下一个slot
3.out
	1.fs_info-&gt;qgroup_flags |= flags
	2.如果qgroup_flags的BTRFS_QGROUP_STATUS_FLAG_ON没置上
		fs_info-&gt;quota_enabled = 0;
		fs_info-&gt;pending_quota_state = 0;
	3.如果qgroup_flags的BTRFS_QGROUP_STATUS_FLAG_RESCAN置上
		并且之前遍历没出错，qgroup_rescan_init初始化
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2543</x>
      <y>2384</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_relation_rb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2548</x>
      <y>2380</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2541</x>
      <y>2390</y>
      <w>30</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.find_qgroup_rb找到member parent
2.申请btrfs_qgroup_list
	list-&gt;group = parent;
	list-&gt;member = member;
3.将list(next_group)添加到member-&gt;groups链表中
	将list(next_member)添加到parent-&gt;members链表中
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2549</x>
      <y>2387</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2573</x>
      <y>2380</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2574</x>
      <y>2384</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qgroup_rescan_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2572</x>
      <y>2390</y>
      <w>33</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果没有init_flags，BTRFS_QGROUP_STATUS_FLAG_RESCAN
	和BTRFS_QGROUP_STATUS_FLAG_ON要置上
2.如果有init_flags
	1.BTRFS_QGROUP_STATUS_FLAG_RESCAN不能置上
	2.BTRFS_QGROUP_STATUS_FLAG_ON要置上
	3.fs_info-&gt;qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_RESCAN
3.初始化
	1.fs_info-&gt;qgroup_rescan_progress=0
	2.fs_info-&gt;qgroup_rescan_progress.objectid = progress_objectid
	3.初始化qgroup_rescan_completion
	4.fs_info-&gt;qgroup_rescan_work=0
	5.btrfs_init_work初始化qgroup_rescan_work
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2581</x>
      <y>2387</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2605</x>
      <y>2351</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_replay_log</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2601</x>
      <y>2348</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2599</x>
      <y>2358</y>
      <w>35</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.fs_devices-&gt;rw_devices不能为0
2.btrfs_alloc_root申请root，并使用__setup_root依据
	tree_root设置log_tree_root
3.read_tree_block在tree_root中偏移为disk_super.log_root
	位置读取log_tree_root-&gt;node
4.btrfs_recover_log_trees
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2611</x>
      <y>2354</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2617</x>
      <y>2386</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_recover_log_trees</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2625</x>
      <y>2382</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2606</x>
      <y>2393</y>
      <w>37</w>
      <h>70</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_path申请path
2.fs_info-&gt;log_root_recovering = 1
3.btrfs_start_transaction
	wc.trans = trans;
	wc.pin = 1;
4.walk_log_tree根据wc的方法处理log_root_tree的所有eb
5.again
	1.循环搜寻log
		1.btrfs_search_slot在log_root_tree查找BTRFS_TREE_LOG_OBJECTID
		2.如果没有正好找到
			1.如果找到的high是slot 0，退出循环
			2.否则
				path-&gt;slots[0]--
		3.找到的slot得是BTRFS_TREE_LOG_OBJECTID
		4.btrfs_read_fs_root根据找到的key再次读取root
		5.通过btrfs_read_fs_root_no_name读取wc.replay_dest
		注：found_key.objectid存储BTRFS_TREE_LOG_OBJECTID
			found_key.offset存储的是replay_root
		6.将两者root关联
			wc.replay_dest-&gt;log_root = log
		7.btrfs_record_root_in_trans更新 wc.replay_dest的last_trans
		8.walk_log_tree根据wc处理log
		9.如果处理完成，并且LOG_WALK_REPLAY_ALL
			1.fixup_inode_link_counts根据wc.replay_dest中的记录
				修复BTRFS_TREE_LOG_FIXUP_OBJECTID中所有对应的inode.i_nlink
		10.更新循环变量		
			key.offset = found_key.offset - 1;
			wc.replay_dest-&gt;log_root = NULL;
		11.释放log
6.如果wc.pin
	1.清除wc.pin
	2.更新wc
		wc.process_func = replay_one_buffer;
		wc.stage = LOG_WALK_REPLAY_INODES;
	3.跳到again
7.如果wc.stage没到LOG_WALK_REPLAY_ALL，更新wc.stage，跳到again
8.btrfs_commit_transaction
9.释放log_root_tree
	free_extent_buffer(log_root_tree-&gt;node);
	log_root_tree-&gt;log_root = NULL;
	fs_info-&gt;log_root_recovering = 0;
	kfree(log_root_tree);
10.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2624</x>
      <y>2389</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2594</x>
      <y>2464</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>walk_log_tree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2599</x>
      <y>2462</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2582</x>
      <y>2471</y>
      <w>34</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.btrfs_alloc_path申请path
2.根据log.node设置path
	path-&gt;nodes[level] = log-&gt;node;
	path-&gt;slots[level] = 0
3.循环，通过wc的方法处理log
	1.walk_down_log_tree根据wc处理path对应的首个leaf
		如果正确返回level应该为1
	2.walk_up_log_tree在循环遍历上一层level的其他slot
		以便通过3.1处理root的其他leaf
4.如果log没处理完
	1.wc-&gt;process_func处理root
	2.如果wc-&gt;free
		1.clean_tree_block清理dirty
		2.btrfs_wait_tree_block_writeback等待文件写完
		3.btrfs_free_and_pin_reserved_extent释放reserved
5.释放path，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2597</x>
      <y>2467</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2593</x>
      <y>2501</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>walk_down_log_tree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2598</x>
      <y>2497</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2593</x>
      <y>2508</y>
      <w>35</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.循环遍历level
	1.如果path遍历完node的slot，退出循环
	2.btrfs_find_create_tree_block查找slot对应的eb
	3.如果查找到了level 1，也就是现在子eb到了leaf
		1.wc-&gt;process_func根据wc处理eb
		2.path-&gt;slots[*level]++
		3.如果wc-&gt;free
			1.btrfs_read_buffer读取next
			2.如果存在trans
				1.clean_tree_block提交dirty的next
				2.btrfs_wait_tree_block_writeback等待next
			3.btrfs_free_and_pin_reserved_extent将段pin到pinned_extents
		4.释放next之后，继续下一个循环
	4.否则btrfs_read_buffer直接读取next
		path-&gt;nodes[*level-1] = next
	5.读取next的slot0，继续循环
		*level = btrfs_header_level(next);
		path-&gt;slots[*level] = 0;
2.最后leaf遍历完之后，其slot赋值为其nritems
	path-&gt;slots[*level] = btrfs_header_nritems(path-&gt;nodes[*level])
3.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2600</x>
      <y>2504</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2477</x>
      <y>2556</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>process_one_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2484</x>
      <y>2549</y>
      <w>78</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>760.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2483</x>
      <y>2559</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2471</x>
      <y>2563</y>
      <w>33</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果disk_super的MIXED_GROUPS没置上，通过
	btrfs_read_buffer读取eb
2.如果wc-&gt;pin置上，btrfs_pin_extent_for_log_replay
	将eb的段从free_space移到pinned_extents
3.如果成功pinned，并且uptodate
	1.如果wc-&gt;pin，并且eb是leaf，通过btrfs_exclude_logged_extents
		将leaf数据中描述的log段释放，不能用于分配
	2.如果wc-&gt;write，通过btrfs_write_tree_block写eb
	3.如果wc-&gt;wait，通过btrfs_wait_tree_block_writeback
		等待eb写完
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2393</x>
      <y>2584</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_pin_extent_for_log_replay</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2402</x>
      <y>2580</y>
      <w>74</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>720.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2402</x>
      <y>2587</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2386</x>
      <y>2591</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.btrfs_lookup_block_group搜寻包含bytenr的cache
2.通过cache_block_group加载cache内(传参1，表示如果加载不进来不设置work)
3.pin_down_extent将段pinned到pinned_extents中
4.btrfs_remove_free_space清除free_space中的段
5.btrfs_put_block_group释放对cache的引用
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2383</x>
      <y>2604</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pin_down_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2388</x>
      <y>2600</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2371</x>
      <y>2611</y>
      <w>38</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.调整cache和space_info中pinned计数
	cache-&gt;pinned += num_bytes;
	cache-&gt;space_info-&gt;bytes_pinned += num_bytes
2.如果reserved置上(是从reserved中pinned？)
	cache-&gt;reserved -= num_bytes;
	cache-&gt;space_info-&gt;bytes_reserved -= num_bytes;
3.set_extent_dirty将pinned_extents中的传入的段设置为dirty
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2388</x>
      <y>2607</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2416</x>
      <y>2604</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_remove_free_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2421</x>
      <y>2600</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2411</x>
      <y>2610</y>
      <w>38</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>1.tree_search_offset在ctl中查找对应的offset，如果找不到
	再找offset对应的bitmap
2.如果info没有bitmap
	1.unlink_free_space将info从ctl中删除
	2.如果offset正好是info的偏移
		1.删除需要的free_space
			info-&gt;bytes -= to_free;
			info-&gt;offset += to_free;
		2.如果info还存在剩余空间，通过link_free_space将info连接到ctl中
			否则将info释放
		3.更新，再次查找下一个free_space
			offset += to_free;
			bytes -= to_free;
		4.跳到1重新查找
	3.如果offset在info的范围内
		1.link_free_space将info的前段连接到ctl中
		2.如果end&gt;old_end
			1.更新变量跳到again重新查找
				bytes -= old_end - offset;
				offset = old_end;
		3.如果end和old_end相同，直接跳到out_lock
		4.如果end&lt;old_end
			1.btrfs_add_free_space将info后端重新添加到block_group
		5.跳到out
3.remove_from_bitmap清除段中的bitmap
4.如果返回EAGAIN，跳到1重新查找其他段

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2424</x>
      <y>2607</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2420</x>
      <y>2655</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_from_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2426</x>
      <y>2651</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2426</x>
      <y>2658</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2411</x>
      <y>2662</y>
      <w>39</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.search_bitmap查找从offset开始的bitmap段
2.如果没找到，或者start不是offset，返回EINVAL
3.bitmap_clear_bits将查找到的段清掉
4.更新循环变量
	*offset += search_bytes;
	*bytes -= search_bytes;
5.如果还有段需要清除
	1.读取bitmap_info的rb_next
	2.如果bitmap_info剩余空间不存在，通过free_bitmap将其释放
	3.如果没有next，返回EINVAL，如果next没有bitmap，返回EAGAIN
	4.再次通过search_bitmap以一小段尝试查找，如果没找到或者查找的start不同，返回EAGAIN
		(因为这里不知道是free_space还是bitmap，所以给caller决定)
	5.跳到1，重新循环
6.如果bitmap全部清空，free_bitmap将bitmap_info释放
7.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2453</x>
      <y>2585</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_exclude_logged_extents</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2462</x>
      <y>2580</y>
      <w>39</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2463</x>
      <y>2588</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2451</x>
      <y>2592</y>
      <w>39</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果fs_info的MIXED_GROUPS没置上，返回0
2.循环读取eb中的slot
	1.读取slot的key
	2.如果不是BTRFS_EXTENT_DATA_KEY，继续下一个slot
	3.以btrfs_file_extent_item解析slot数据
	4.item.type是BTRFS_FILE_EXTENT_INLINE，继续下一个
	5.如果item.disk_byrenr是0，继续下一个
	6.设置key
		key.objectid =item.disk_bytenr
		key.offset = item.disk_num_bytes
	7.__exclude_logged_extent
3.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2462</x>
      <y>2615</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__exclude_logged_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2469</x>
      <y>2611</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2470</x>
      <y>2618</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2452</x>
      <y>2622</y>
      <w>46</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.btrfs_lookup_block_group查找block_group
2.cache_block_group缓存
3.如果不存在cache.caching_ctl，btrfs_remove_free_space将段释放
4.如果存在
	1.如果段在caching_ctl-&gt;progress范围内，通过add_excluded_extent
		在freed_extents数组中设置该段为EXTENT_UPTODATE
	2.如果完全不在progress范围内，btrfs_remove_free_space将这段删除
	3.否则
		1.btrfs_remove_free_space将progress之前的删除
		2.之后的add_excluded_extent在freed_extents数组中设置该段为EXTENT_UPTODATE
5.释放cache之后返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2506</x>
      <y>2584</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_write_tree_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2500</x>
      <y>2580</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2506</x>
      <y>2591</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filemap_fdatawrite_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2514</x>
      <y>2587</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2506</x>
      <y>2598</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__filemap_fdatawrite_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2514</x>
      <y>2594</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2499</x>
      <y>2605</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.根据参数设置wbc
2.mapping_cap_writeback_dirty检查bdev的BDI_CAP_NO_WRITEBACK
	没置上，返回0
3.do_writepages写page后返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2514</x>
      <y>2601</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2511</x>
      <y>2616</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_writepages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2516</x>
      <y>2612</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2516</x>
      <y>2619</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2500</x>
      <y>2622</y>
      <w>42</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果nr_to_write&lt;0，返回0
2.如果mapping有方法，通过mapping-&gt;a_ops-&gt;writepages写page
	否则直接通过generic_writepages写
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2503</x>
      <y>2631</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;writepages
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2529</x>
      <y>2631</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_writepages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2512</x>
      <y>2627</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2537</x>
      <y>2627</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2511</x>
      <y>2634</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
btree_aops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2505</x>
      <y>2638</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btree_writepages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2494</x>
      <y>2645</y>
      <w>32</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果sync_mode是NONE
	1.如果for_kupdate存在，返回0
	2.dirty_metadata_bytes要超过限制，否则返回0
2.btree_write_cache_pages
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2511</x>
      <y>2641</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2502</x>
      <y>2656</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btree_write_cache_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2511</x>
      <y>2652</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2511</x>
      <y>2659</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2489</x>
      <y>2663</y>
      <w>42</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>System
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2551</x>
      <y>2584</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_wait_tree_block_writeback</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2563</x>
      <y>2587</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2551</x>
      <y>2591</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filemap_fdatawait_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2563</x>
      <y>2594</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2550</x>
      <y>2598</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.__filemap_fdatawait_range
2.filemap_check_errors检查ENOSPC和EIO
	错误
3.检查ret的错误和2中的两种错误，返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2546</x>
      <y>2608</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__filemap_fdatawait_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2553</x>
      <y>2604</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2555</x>
      <y>2611</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2544</x>
      <y>2614</y>
      <w>36</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2501</x>
      <y>2580</y>
      <w>65</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;630.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2756</x>
      <y>2546</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_free_and_pin_reserved_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2618</x>
      <y>2541</y>
      <w>150</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1480.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2758</x>
      <y>2553</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__btrfs_free_reserved_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2768</x>
      <y>2549</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2768</x>
      <y>2556</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2749</x>
      <y>2560</y>
      <w>42</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.btrfs_lookup_block_group查找start所在的cache
2.如果pin置上，通过pin_down_extent将段空间设置到pinned_extents
3.否则
	1.如果root的DISCARD置上，通过btrfs_discard_extent
	2.btrfs_add_free_space将段释放给cache
	3.btrfs_update_reserved_bytes更新cache和space_info的reserved
4.释放block_group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2745</x>
      <y>2575</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_discard_extent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2753</x>
      <y>2572</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2740</x>
      <y>2582</y>
      <w>34</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.btrfs_map_block
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2753</x>
      <y>2578</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2740</x>
      <y>2607</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_map_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2739</x>
      <y>2613</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__btrfs_map_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2746</x>
      <y>2604</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2745</x>
      <y>2610</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2731</x>
      <y>2620</y>
      <w>38</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.通过lookup_extent_mapping搜索完全包含段的em
	如果没找到，返回EINVAL，如果logical不在em范围内，返回EINVAL
2.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2744</x>
      <y>2616</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2786</x>
      <y>2576</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_update_reserved_bytes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2786</x>
      <y>2572</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2776</x>
      <y>2583</y>
      <w>43</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.如果不是RESERVE_FREE
	1.如果cache是readonly，返回EAGAIN
	2.reserve bytes
		cache-&gt;reserved += num_bytes;
		space_info-&gt;bytes_reserved += num_bytes;
	3.如果RESERVE_ALLOC
		space_info-&gt;bytes_may_use -= num_bytes
	4.如果delalloc
		cache-&gt;delalloc_bytes += num_bytes
2.如果是free
	1.如果cache是readonly
		space_info-&gt;bytes_readonly += num_bytes
	2.释放reserve
		cache-&gt;reserved -= num_bytes;
		space_info-&gt;bytes_reserved -= num_bytes;
	3.如果delalloc
		cache-&gt;delalloc_bytes -= num_bytes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2795</x>
      <y>2579</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2641</x>
      <y>2501</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>walk_up_log_tree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2646</x>
      <y>2504</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2630</x>
      <y>2508</y>
      <w>38</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.遍历level
	1.如果该level还有数据没处理完，返回0，让caller循环处理
	2.如果该level已经处理完
		1.wc-&gt;process_func处理该level上的eb
		2.如果wc-&gt;free
			1.clean_tree_block提交dirty_io
			2.btrfs_wait_tree_block_writeback等待
			3.btrfs_free_and_pin_reserved_extent释放reserved的bytes
		3.free_extent_buffer将本层eb释放
			path-&gt;nodes[*level] = NULL;
			*level = i + 1;
2.返回1，表示root的所有eb都处理完成
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2627</x>
      <y>2465</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_read_fs_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2633</x>
      <y>2462</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2631</x>
      <y>2468</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2619</x>
      <y>2472</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.btrfs_read_tree_root读取root
2.如果不是BTRFS_TREE_LOG_OBJECTID
	1.将root.state的BTRFS_ROOT_REF_COWS置上
	2.btrfs_check_and_init_root_item设置root_item
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2751</x>
      <y>2468</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_read_fs_root_no_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2638</x>
      <y>2462</y>
      <w>125</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1230.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2760</x>
      <y>2471</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2739</x>
      <y>2483</y>
      <w>44</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.查看location-&gt;objectid是否是特定的root，如果是直接返回
2.again
	1.通过btrfs_lookup_fs_root根据rootid在fs_info-&gt;fs_roots_radix中查找
	2.如果找到
		1.如果需要check_ref，root_item.refs不能为0
		2.返回root
	3.否则通过btrfs_read_fs_root读取磁盘中的root信息，如果有check_ref，需要检查root_item.refs
	4.btrfs_init_fs_root初始化root
	5.btrfs_search_slot在tree_root中查找BTRFS_ORPHAN_OBJECTID，其offset指向rootid
		如果正好找到将root.state的BTRFS_ROOT_ORPHAN_ITEM_INSERTED置上
	6.btrfs_insert_fs_root将root插入fs_roots_radix中
3.返回root
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2754</x>
      <y>2475</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_get_fs_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2760</x>
      <y>2478</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2750</x>
      <y>2505</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_init_fs_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2754</x>
      <y>2502</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2755</x>
      <y>2508</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2746</x>
      <y>2512</y>
      <w>34</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.申请root-&gt;free_ino_ctl，root-&gt;free_ino_pinned
	和root-&gt;subv_writers
2.btrfs_init_free_ino_ctl初始化free_ino_ctl和free_ino_pinned
	ctl-&gt;unit = 1
	ctl-&gt;op = &amp;free_ino_op
	pinned-&gt;unit = 1
	pinned-&gt;op = &amp;pinned_free_ino_op
3.获取root-&gt;anon_dev
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2782</x>
      <y>2505</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_insert_fs_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2776</x>
      <y>2502</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2782</x>
      <y>2512</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.radix_tree_preload查看内存池radix_tree_preloads是否
	需要申请内存
2.将root按照rootid插入到fs_roots_radix中
3.如果正确插入，将root.state的BTRFS_ROOT_IN_RADIX置上

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2790</x>
      <y>2508</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2609</x>
      <y>2497</y>
      <w>40</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2814</x>
      <y>2466</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fixup_inode_link_counts</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2824</x>
      <y>2469</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2814</x>
      <y>2492</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_del_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2820</x>
      <y>2488</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2821</x>
      <y>2495</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2816</x>
      <y>2506</y>
      <w>32</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>1.计算要删除的dsize
2.如果slot之后的没有全部删完
	1.memmove_extent_buffer将后面的数据移到删除的要删除的位置
	2.更新后面slot的offset
	3.memmove_extent_buffer将后面slot移到要删除的位置
注：这里处理后，相当于把要删除的部分平移到最后
3.btrfs_set_header_nritems重新设置leaf的nritems
4.如果leaf中的slot完全被删完
	1.如果leaf是root，将其level设置为0
	2.否则
		1.clean_tree_block处理dirty的eb
		2.btrfs_del_leaf
5.如果没删完
	1.如果是最slot 0开始删，通过fixup_low_keys根据最新的slot 0
		修复父node的key
	2.如果leaf所使用的空间不到1/3
		1.push_leaf_left将leaf的数据向左leaf迁移
		2.如果leaf还剩内容，通过push_leaf_right向右leaf迁移
		3.如果leaf被清空
			1.path-&gt;slots[1] = slot
			2.btrfs_del_leaf删除leaf
			3.free_extent_buffer释放leaf
			4.ret=0
		4.如果leaf还在path中，标记leaf dirty，并释放leaf
	3.否则，btrfs_mark_buffer_dirty标记leafdirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2816</x>
      <y>2499</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_del_items</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2823</x>
      <y>2502</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2823</x>
      <y>2550</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_del_leaf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2829</x>
      <y>2546</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2804</x>
      <y>2473</y>
      <w>42</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.循环
	1.btrfs_search_slot循环搜寻BTRFS_TREE_LOG_FIXUP_OBJECTID
	2.根据返回值调整slot
	3.找到slot的objectid和type要和可以完全一致
	4.btrfs_del_item将path中的slot及其数据删除
	5.read_one_inode读取inode，inode号是找到slot的key.offset
	6.fixup_inode_link_count
	7.再次从后向前搜寻其他inode
2.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2842</x>
      <y>2488</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2851</x>
      <y>2492</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fixup_inode_link_count</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2861</x>
      <y>2495</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2850</x>
      <y>2499</y>
      <w>42</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.count_inode_refs统计索引inode对应的BTRFS_INODE_REF_KEY
2.count_inode_extrefs统计inode对应的ext_ref
3.nlink为ref和ext_ref的和
4.如果nlink和inode-&gt;i_nlink不同
	1.set_nlink设置inode-&gt;i_nlink
	2.btrfs_update_inode
5.BTRFS_I(inode)-&gt;index_cnt = (u64)-1
6.如果inode-&gt;i_nlink为0
	1.如果是dir
		1.replay_dir_deletes
	2.insert_orphan_item插入一个空白的BTRFS_ORPHAN_ITEM_KEY
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2852</x>
      <y>2522</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>count_inode_refs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2857</x>
      <y>2518</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2857</x>
      <y>2525</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2850</x>
      <y>2529</y>
      <w>28</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.循环向后查找inode对应ref的个数
	1.btrfs_search_slot根据inode号，搜索BTRFS_INODE_REF_KEY
		并根据ret调整slot
	2.process_slot：
		1.如果slot的key不是搜索的，退出循环
		2.循环处理slot对应的数据(btrfs_inode_ref+name)
			1.以btrfs_inode_ref方式解析数据
			2.统计数据中name的个数nlink
		3.如果key.offset为0，退出循环
		4.跳到process_slot，继续遍历这个offset对应的slot，直到slot遍历完成
			path-&gt;slots[0]--
		5.key.offset--
2.返回nlink
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2880</x>
      <y>2522</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>count_inode_extrefs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2886</x>
      <y>2518</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2887</x>
      <y>2525</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2879</x>
      <y>2529</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.循环从0向前开始查找inode对应extref的个数
	1.btrfs_find_one_extref查找inode对应的BTRFS_INODE_EXTREF_KEY
	2.统计slot数据对应extref个数
	3.offset递增，继续循环查找
2.返回nlink
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2886</x>
      <y>2541</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_find_one_extref</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2892</x>
      <y>2538</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2893</x>
      <y>2544</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2883</x>
      <y>2548</y>
      <w>30</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot搜寻inode对应的BTRFS_INODE_EXTREF_KEY
2.循环
	1.如果leaf遍历完成，btrfs_next_leaf继续遍历下一个leaf
		如果遍历完成，退出循环
	2.slot对应的inode号和type要是规定的
	3.以btrfs_inode_extref方式解析slot对应的数据
		返回对应的extref和found_key.offset，并退出循环
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2916</x>
      <y>2521</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_update_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2923</x>
      <y>2524</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2912</x>
      <y>2528</y>
      <w>34</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>System
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2890</x>
      <y>2518</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2954</x>
      <y>2521</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>replay_dir_deletes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2889</x>
      <y>2518</y>
      <w>74</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2977</x>
      <y>2521</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>insert_orphan_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2890</x>
      <y>2518</y>
      <w>98</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;960.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2984</x>
      <y>2524</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ino为offset</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2978</x>
      <y>2528</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_insert_orphan_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2985</x>
      <y>2537</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2979</x>
      <y>2534</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_insert_empty_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2986</x>
      <y>2531</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
BTRFS_ORPHAN_OBJECTID</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2979</x>
      <y>2541</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_insert_empty_items</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2987</x>
      <y>2544</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2976</x>
      <y>2548</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.统计要插入的total_data，以及total_size(total_data+管理结构)
2.btrfs_search_slot搜寻key
3.setup_items_for_insert
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2983</x>
      <y>2558</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_items_for_insert</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2990</x>
      <y>2554</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2991</x>
      <y>2561</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2975</x>
      <y>2565</y>
      <w>36</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.如果要从slot 0开始插入，fixup_low_keys将第一个要插入的key向上修复
2.如果leaf的空间不足，bug
3.如果不是从最后一个item插入
	1.检查其插入的位置
	2.重新设置要移动item(slot之后的item)的offset
	3.memmove_extent_buffer向后移动slot之后的item
		并且也将其对应的数据也移动
4.设置插入item的offset和size
5.重新更新leaf的nritems
6.btrfs_mark_buffer_dirty标记leaf dirty
7.如果leaf的空间不足，报错
注：这里并没有更新数据
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2639</x>
      <y>2462</y>
      <w>184</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1820.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2555</x>
      <y>2546</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>.wc-&gt;process_func
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2561</x>
      <y>2541</y>
      <w>37</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2560</x>
      <y>2549</y>
      <w>67</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2619</x>
      <y>2553</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>replay_one_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2816</x>
      <y>2557</y>
      <w>28</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.del_ptr删除leaf的父slot
2.root_sub_used更新root_item.size
3.extent_buffer_get递增leaf的计数
4.btrfs_free_tree_block释放leaf的空间
5.free_extent_buffer_stale释放leaf
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2828</x>
      <y>2553</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2824</x>
      <y>2569</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_free_tree_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2829</x>
      <y>2565</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2830</x>
      <y>2572</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2820</x>
      <y>2576</y>
      <w>46</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.如果不是BTRFS_TREE_LOG_OBJECTID，btrfs_add_delayed_tree_ref
	在trans中添加指向root中eb的ref(BTRFS_DROP_DELAYED_REF)
2.如果当前trans和eb.gen相同
	1.如果不是BTRFS_TREE_LOG_OBJECTID，check_ref_cleanup清除ref
		如果返回0，跳到out
	2.btrfs_lookup_block_group搜寻cache
	3.如果eb的BTRFS_HEADER_FLAG_WRITTEN置上
		1.pin_down_extent将段加入pinned_extents中
		2.释放cache后，跳到out
	4.btrfs_add_free_space将段添加到block_group的free_space
	5.btrfs_update_reserved_bytes释放段的reserved
	6.pin = 0
3.如果pin置上
	1.add_pinned_bytes增加对应space_info.total_bytes_pinned的计数
4.清除eb的EXTENT_BUFFER_CORRUPT标记
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2838</x>
      <y>2603</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>check_ref_cleanup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2844</x>
      <y>2600</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2842</x>
      <y>2606</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2829</x>
      <y>2610</y>
      <w>34</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.btrfs_find_delayed_ref_head在红黑树delayed_refs中找到对应的head_ref
2.如果head_ref不存在，或者为空，跳到out
3.如果存在extent_op
	1.如果must_insert_reserved没置上，跳到out
	2.btrfs_free_delayed_extent_op释放extent_op
		head-&gt;extent_op = NULL
4.将head_ref从红黑树中删除
	1.head-&gt;node.in_tree = 0;
	2.rb_erase
	3.delayed_refs-&gt;num_entries--
		delayed_refs-&gt;num_heads--
	4.processing为0时
		delayed_refs-&gt;num_heads_ready--
	5.head-&gt;processing = 0
5.如果must_insert_reserved置上，返回1，否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2869</x>
      <y>2568</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_extent_buffer_stale</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2868</x>
      <y>2575</y>
      <w>29</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果eb不存在，直接返回
2.将eb的EXTENT_BUFFER_STALE置上
3.如果eb.ref只有2个，并且不在io，EXTENT_BUFFER_TREE_REF置上
	1.EXTENT_BUFFER_TREE_REF清除
	2.递减eb.ref
4.release_extent_buffer释放eb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2878</x>
      <y>2571</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2843</x>
      <y>2565</y>
      <w>37</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2607</x>
      <y>2560</y>
      <w>39</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.btrfs_read_buffer读取eb
2.如果不是leaf，直接返回0
3.遍历eb的所有slot
	1.如果type是BTRFS_INODE_ITEM_KEY，并且wc处于LOG_WALK_REPLAY_INODES
		1.以btrfs_inode_item方式解析slot数据(key.objectid存储ino)
		2.replay_xattr_deletes在log中没找到就删除replay_dest中的xattr，否则不做处理
		3.如果inode_item.mode是dir
			1.replay_dir_deletes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2624</x>
      <y>2556</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2600</x>
      <y>2586</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>replay_xattr_deletes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2608</x>
      <y>2582</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2590</x>
      <y>2593</y>
      <w>37</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.again
	1.btrfs_search_slot查找ino对应的BTRFS_XATTR_ITEM_KEY
2.process_leaf
	1.从path的slot遍历leaf
		1.slot对应的ino和type要和查找的相同
		2.以btrfs_dir_item方式解析slot数据
		3.遍历slot的数据
			1.根据di.name_len申请name
			2.read_extent_buffer读取name(紧跟着di)
			3.btrfs_lookup_xattr在log中搜寻dir_item(hash索引)
			注：之前的slot是在root中，这里又在log_root中搜寻
			4.如果没找到di
				1.btrfs_lookup_xattr再次在root中搜寻
				2.释放name
				3.btrfs_delete_one_dir_name将对应的item删除
				4.更新search_key，跳到again再次查找
			5.释放name，遍历下一个btrfs_dir_item
	2.如果btrfs_next_leaf找到下一个leaf，跳到process_leaf继续处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2606</x>
      <y>2589</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2583</x>
      <y>2626</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_lookup_xattr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2590</x>
      <y>2622</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2588</x>
      <y>2629</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2581</x>
      <y>2633</y>
      <w>34</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.btrfs_search_slot查找btrfs_name_hash，要正好找到
2.btrfs_match_dir_item_name找到name相同的dir_item
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2583</x>
      <y>2642</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_match_dir_item_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2592</x>
      <y>2637</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2592</x>
      <y>2645</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2580</x>
      <y>2649</y>
      <w>36</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.以btrfs_dir_item方式解析slot数据
2.verify_dir_item验证出错，返回NULL
3.依次处理slot的数据，直到找到和name相同的dir_item
4.如果没找到，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2594</x>
      <y>2659</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>verify_dir_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2599</x>
      <y>2656</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2599</x>
      <y>2662</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2582</x>
      <y>2666</y>
      <w>34</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果dir_item.type大于verify_dir_item，返回1
2.默认name_len是BTRFS_NAME_LEN，在BTRFS_FT_XATTR时
	XATTR_NAME_MAX
3.dir_item.name_len不能大于namelen，否则返回1
4.dir_item的data_len+name_len不能大于限制，否则返回1
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2620</x>
      <y>2625</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_delete_one_dir_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2624</x>
      <y>2622</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2629</x>
      <y>2628</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2617</x>
      <y>2632</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果slot数据的长度和di描述的长度一致，通过btrfs_del_item
	将这个slot删除
2.否则
	1.memmove_extent_buffer将超过di规定的数据长度覆盖
	2.btrfs_truncate_item
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2627</x>
      <y>2646</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>btrfs_truncate_item</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2633</x>
      <y>2642</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2619</x>
      <y>2653</y>
      <w>34</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.如果前后item的长度一致，直接返回
2.调整slot~nritems的offset
3.如果from_end置上，memmove_extent_buffer将slot~
	nritems的数据向后移
注：1.caller已经将slot剩余的数据前移了，这里只要连着slot
	的数据一起移动就好了
	2.from_end表示从后面开始截取，保留前面数据
		否则是从前面截取，保留后面数据
4.否则
	1.如果slot是BTRFS_EXTENT_DATA_KEY，要保留前面的数据
		1.以btrfs_file_extent_item方式解析slot数据，因为之前
			slot的offset已经调整过，现在将其调整到原来原来的位置
		2.如果fi.extent_type是BTRFS_FILE_EXTENT_INLINE
			将fi.bytenr之前的数据移到新的offset
	2.memmove_extent_buffer将(slot,nritem-1]的数据移到新的offset
	3.重新设置slot.key,如果是slot 0，还要通过fixup_low_keys修复
		上层的key
5.btrfs_set_item_size重新设置slot的size
6.btrfs_mark_buffer_dirty标记leaf dirty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2632</x>
      <y>2649</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2661</x>
      <y>2586</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>replay_dir_deletes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2644</x>
      <y>2582</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2666</x>
      <y>2589</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2651</x>
      <y>2593</y>
      <w>37</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.read_one_inode读取inode，如果没找到返回0
2.again
	1.循环
		1.如果del_all，range_end=-1，否则通过find_dir_range
			确定range_end
		
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2656</x>
      <y>2624</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_dir_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2661</x>
      <y>2620</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2661</x>
      <y>2627</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2654</x>
      <y>2631</y>
      <w>31</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>System
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
</diagram>
