<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram program="umlet" version="14.3.0">
  <zoom_level>1</zoom_level>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>795</x>
      <y>0</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__user_walk
（返回0说明正常）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>615</x>
      <y>38</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>620</x>
      <y>3</y>
      <w>183</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1810.0;10.0;10.0;350.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>643</x>
      <y>38</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>649</x>
      <y>3</y>
      <w>154</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1520.0;10.0;10.0;350.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>836</x>
      <y>13</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>800</x>
      <y>3</y>
      <w>44</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1281</x>
      <y>14</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>putname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>802</x>
      <y>3</y>
      <w>485</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放name slab</panel_attributes>
    <additional_attributes>10.0;10.0;4830.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>616</x>
      <y>46</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>nd-&gt;last_type = LAST_ROOT
nd-&gt;flags = flags;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>625</x>
      <y>41</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>641</x>
      <y>47</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>walk_init_root
（返回1说明继续查找
返回0说明不用继续）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>647</x>
      <y>41</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果通过根目录寻址</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>657</x>
      <y>47</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nd-&gt;mnt = mntget(current-&gt;fs-&gt;pwdmnt);
nd-&gt;dentry = dget(current-&gt;fs-&gt;pwd);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>647</x>
      <y>41</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果通过当前目录寻址</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>619</x>
      <y>50</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果current-&gt;fs-&gt;altroot不为空
!(nd-&gt;flags &amp; LOOKUP_NOALT)
并且规定不在altroot上寻址</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>587</x>
      <y>62</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>nd-&gt;mnt = mntget(current-&gt;fs-&gt;altrootmnt);
nd-&gt;dentry = dget(current-&gt;fs-&gt;altroot);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>595</x>
      <y>57</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>617</x>
      <y>64</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__emul_lookup_dentry
（返回0说明存在问题）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>620</x>
      <y>57</y>
      <w>8</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>638</x>
      <y>60</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nd-&gt;mnt = mntget(current-&gt;fs-&gt;rootmnt);
nd-&gt;dentry = dget(current-&gt;fs-&gt;root);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>643</x>
      <y>50</y>
      <w>26</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
表示在系统的根目录下开始寻址</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>601</x>
      <y>74</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk
（返回非0说明存在问题）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>609</x>
      <y>67</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>623</x>
      <y>67</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果path_walk正常</panel_attributes>
    <additional_attributes>30.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>674</x>
      <y>16</y>
      <w>171</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果‘/’之后name结束</panel_attributes>
    <additional_attributes>1690.0;10.0;10.0;380.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>670</x>
      <y>54</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>681</x>
      <y>55</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode = nd-&gt;dentry-&gt;d_inode
if (current-&gt;link_count)
		lookup_flags = LOOKUP_FOLLOW;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>689</x>
      <y>16</y>
      <w>156</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1540.0;10.0;10.0;390.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>713</x>
      <y>16</y>
      <w>132</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查看目录的权限</panel_attributes>
    <additional_attributes>1300.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>707</x>
      <y>56</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>permission(inode, MAY_EXEC)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>730</x>
      <y>55</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>this.name = name;
this.len = name - (const char *) this.name;
this.hash = end_name_hash(hash)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>739</x>
      <y>16</y>
      <w>106</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1040.0;10.0;10.0;390.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>758</x>
      <y>56</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>last_component
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>762</x>
      <y>16</y>
      <w>83</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
最后一个节点最后一个字符是‘\0’
就是文件</panel_attributes>
    <additional_attributes>810.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>774</x>
      <y>56</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>last_with_slashes
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>778</x>
      <y>16</y>
      <w>68</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
最后一个节点最后一个如果是‘\’
就是目录</panel_attributes>
    <additional_attributes>660.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>797</x>
      <y>16</y>
      <w>48</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
第一个字符如果是'.'</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>788</x>
      <y>55</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果长度只有1个
找到当前目录
就跳出本次循环</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>786</x>
      <y>62</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>continue
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>796</x>
      <y>55</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
长度为2</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>797</x>
      <y>61</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有两个'.'</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>780</x>
      <y>73</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>follow_dotdot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>794</x>
      <y>73</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode = nd-&gt;dentry-&gt;d_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>805</x>
      <y>61</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果只有一个‘.’
另一个是其他字符
解析为普通文件名</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>785</x>
      <y>67</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>797</x>
      <y>67</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>812</x>
      <y>68</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>break
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>796</x>
      <y>55</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
长度如果更长
则不是特殊
解析为普通文件名</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>822</x>
      <y>64</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>break
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>725</x>
      <y>80</y>
      <w>60</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
nd-&gt;dentry == current-&gt;fs-&gt;root
&amp;&amp;nd-&gt;mnt == current-&gt;fs-&gt;rootmnt
如果是根目录，上层就是本目录
</panel_attributes>
    <additional_attributes>580.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>721</x>
      <y>87</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>break
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>761</x>
      <y>80</y>
      <w>28</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
	//mnt_root是设备的mount目录
nd-&gt;dentry != nd-&gt;mnt-&gt;mnt_root
如果不是本设备的根目录，就向上找parent</panel_attributes>
    <additional_attributes>220.0;10.0;50.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>757</x>
      <y>92</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //nd-&gt;dentry-&gt;d_parent是目录的parent
dentry = dget(nd-&gt;dentry-&gt;d_parent);
dput(nd-&gt;dentry);
nd-&gt;dentry = dentry;
break;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>782</x>
      <y>76</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
死循环</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>797</x>
      <y>95</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>parent=nd-&gt;mnt-&gt;mnt_parent
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>782</x>
      <y>80</y>
      <w>27</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
本设备的父设备
即设备安装在父设备上</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>782</x>
      <y>80</y>
      <w>50</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
parent == nd-&gt;mnt
如果是系统根目录
不向上查找，直接退出</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>823</x>
      <y>94</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>break;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>845</x>
      <y>91</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>mntget(parent);
dentry=dget(nd-&gt;mnt-&gt;mnt_mountpoint);
dput(nd-&gt;dentry);
nd-&gt;dentry = dentry;
mntput(nd-&gt;mnt);
nd-&gt;mnt = parent;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>782</x>
      <y>80</y>
      <w>69</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
运行到这里是
当前目录是当前设备的根目录
但是存在父设备，所以在父设备中查找
父设备中的安装目录和当前设备的根目录
是同一个节点，所以这里不退出，直接通过死循环
继续前面的过程查找</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>842</x>
      <y>16</y>
      <w>26</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 nd-&gt;dentry-&gt;d_op-&gt;d_hash
 如果文件系统存在计算哈希值的函数
 就让文件系统自己计算哈希值</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>830</x>
      <y>56</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_hash(nd-&gt;dentry, &amp;this)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>873</x>
      <y>51</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cached_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>843</x>
      <y>16</y>
      <w>38</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在内存中搜索当前节点对应的dentry结构
nd-&gt;dentry, &amp;this, LOOKUP_CONTINUE</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;350.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>862</x>
      <y>61</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>867</x>
      <y>54</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
parent，this</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>839</x>
      <y>72</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>844</x>
      <y>64</y>
      <w>24</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
parent hash
dentry_hashtable
将父节点加入哈希值的计算
可以有效减少hash表的链表长度
比如不同目录中有相同的目录名
但是这也只是上升了一层，因为
全路径的计算代价太大</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>874</x>
      <y>70</y>
      <w>52</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.因为此时的hash是经过原来的hash经过变换得到的，所以需要比较原来的hash
	dentry-&gt;d_name.hash == hash
2.查看父节点是否相同dentry-&gt;d_parent = parent
3.查看名字是否相同（因为同一目录下允许有name相同的文件）
	如果文件系统提供了d_compare就通过文件系统本身的去比较
	d_compare(parent, &amp;dentry-&gt;d_name, name)
	如果没提供，就比较name的长度和名字
	dentry-&gt;d_name.len = len
	memcmp(dentry-&gt;d_name.name, str, len)
4.如果在hash表中找到了dentry就返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>861</x>
      <y>64</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果向下找到了dentry_hashtable的头
就返回NULL</panel_attributes>
    <additional_attributes>60.0;10.0;180.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>876</x>
      <y>92</y>
      <w>41</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>memcmp：
	"repe\n\t"	////重复ecx次，每次ecx减1，直到ecx=0或者zf=0
	"cmpsb\n\t" //将esi和edi的字符比较，直到两者不相同	
					//相同时zf=1，不同时zf=0			
	"je 1f\n\t" //如果相同，res为0直接返回（cf=1）
	"sbbl %0,%0\n\t" //-cf
	"orb $1,%b0\n" //res=0xFFFFFFFF
	"1:"
	//esi=cs edi=ct __res是返回值 ecx=count
	:"=a" (__res), "=&amp;S" (d0), "=&amp;D" (d1), "=&amp;c" (d2)
	:"0" (0), "1" (cs), "2" (ct), "3" (count));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>893</x>
      <y>87</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>878</x>
      <y>54</y>
      <w>70</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果文件系统存在重新认证这个dentry的函数
就通过d_revalidate重新认证（例如NFS,会判断访问时间）
然后通过d_invalidate断开连接</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>942</x>
      <y>68</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput(dentry);
			dentry = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>843</x>
      <y>16</y>
      <w>144</w>
      <h>51</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果内存中没找到
就要到磁盘中查找</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;300.0;1420.0;490.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>978</x>
      <y>65</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>real_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>931</x>
      <y>68</y>
      <w>53</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;370.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>918</x>
      <y>105</y>
      <w>23</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>down(&amp;dir-&gt;i_sem)
	//因为前面可能因为down而sleep
	//所以这里醒来之后需要查看一下
	//dentry是否在内存中
d_lookup(parent, name)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>956</x>
      <y>68</y>
      <w>28</w>
      <h>43</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果还是没找到</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;410.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>948</x>
      <y>108</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>942</x>
      <y>112</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>929</x>
      <y>115</y>
      <w>18</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请dentry结构</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>920</x>
      <y>123</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>945</x>
      <y>115</y>
      <w>3</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>934</x>
      <y>126</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>930</x>
      <y>121</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
name-&gt;len &gt; DNAME_INLINE_LEN-1
如果name的长度过长，就从通用cache中
申请内存
16字节对齐</panel_attributes>
    <additional_attributes>160.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>949</x>
      <y>126</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>str = dentry-&gt;d_iname
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>942</x>
      <y>121</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否则就用dentry中的name结构</panel_attributes>
    <additional_attributes>40.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>968</x>
      <y>124</y>
      <w>38</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>memcpy(str, name-&gt;name, name-&gt;len);
str[name-&gt;len] = 0;

atomic_set(&amp;dentry-&gt;d_count, 1);
dentry-&gt;d_flags = 0;
dentry-&gt;d_inode = NULL;
dentry-&gt;d_parent = NULL;
dentry-&gt;d_sb = NULL;
dentry-&gt;d_name.name = str;
dentry-&gt;d_name.len = name-&gt;len;
dentry-&gt;d_name.hash = name-&gt;hash;
dentry-&gt;d_op = NULL;
dentry-&gt;d_fsdata = NULL;
	//如果dentry有安装在某个节点，这里是安装信息
INIT_LIST_HEAD(&amp;dentry-&gt;d_vfsmnt);
	//这个链接在hash表中
INIT_LIST_HEAD(&amp;dentry-&gt;d_hash);
	//如果没被用到，链接在unused_dentry中
INIT_LIST_HEAD(&amp;dentry-&gt;d_lru);
	//其子目录链接在下面，链表头
INIT_LIST_HEAD(&amp;dentry-&gt;d_subdirs);
	//如果一个inode有多个dentry，这个链接在inode的链表中
INIT_LIST_HEAD(&amp;dentry-&gt;d_alias);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>946</x>
      <y>115</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化dentry</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1007</x>
      <y>127</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>dentry-&gt;d_parent = dget(parent);
 //继承父节点的super_block
dentry-&gt;d_sb = parent-&gt;d_sb;
list_add(&amp;dentry-&gt;d_child, &amp;parent-&gt;d_subdirs);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>948</x>
      <y>115</y>
      <w>76</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注意找到节点的dentry会放到父目录下的d_subdirs
有可能目录的显示就是通过遍历这个链表
</panel_attributes>
    <additional_attributes>10.0;10.0;740.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1012</x>
      <y>121</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果该节点有父目录</panel_attributes>
    <additional_attributes>100.0;10.0;40.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1041</x>
      <y>128</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>INIT_LIST_HEAD(&amp;dentry-&gt;d_child)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1020</x>
      <y>121</y>
      <w>28</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没有</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1067</x>
      <y>128</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry_stat.nr_dentry++;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>947</x>
      <y>115</y>
      <w>136</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;750.0;40.0;1340.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1028</x>
      <y>155</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>956</x>
      <y>108</y>
      <w>145</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果分配好了dentry内存结构
就通过文件系统的函数到磁盘中查找</panel_attributes>
    <additional_attributes>10.0;10.0;1430.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1090</x>
      <y>117</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_op-&gt;lookup
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1032</x>
      <y>120</y>
      <w>76</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_dir_inode_operations
</panel_attributes>
    <additional_attributes>670.0;10.0;480.0;230.0;10.0;350.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>957</x>
      <y>108</y>
      <w>163</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1610.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1109</x>
      <y>112</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
result有error
没找到，释放dentry</panel_attributes>
    <additional_attributes>90.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1111</x>
      <y>117</y>
      <w>9</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>dput(dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1117</x>
      <y>112</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到了</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1121</x>
      <y>117</y>
      <w>11</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>result = dentry;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1133</x>
      <y>117</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>up(&amp;dir-&gt;i_sem);
		return result;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1117</x>
      <y>112</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
退出</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>981</x>
      <y>68</y>
      <w>45</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在之前的d_lookup中
找到了dentry，如果文件系统有要求
需要认证</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;290.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1020</x>
      <y>97</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput(dentry);
			dentry = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>881</x>
      <y>158</y>
      <w>154</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>1520.0;10.0;10.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>869</x>
      <y>188</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry-&gt;d_name.len &gt; EXT2_NAME_LEN
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>904</x>
      <y>188</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_find_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>908</x>
      <y>158</y>
      <w>127</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将父目录的内容读取到内存中
存在bh为管理单元的缓冲区中
并找到对应（name inode）项</panel_attributes>
    <additional_attributes>1250.0;10.0;10.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>930</x>
      <y>185</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>933</x>
      <y>158</y>
      <w>102</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据inode号找到要找目录的inode</panel_attributes>
    <additional_attributes>1000.0;10.0;10.0;270.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1093</x>
      <y>189</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1032</x>
      <y>158</y>
      <w>67</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;310.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1084</x>
      <y>197</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_instantiate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1103</x>
      <y>196</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_rehash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1097</x>
      <y>192</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1087</x>
      <y>192</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1075</x>
      <y>205</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>if (inode)
	//将dentry加入到inode的链表中
	list_add(&amp;entry-&gt;d_alias, &amp;inode-&gt;i_dentry);
 //指明dentry中的d_inode
entry-&gt;d_inode = inode;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1085</x>
      <y>200</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1108</x>
      <y>205</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>list = d_hash(entry-&gt;d_parent, entry-&gt;d_name.hash)
list_add(&amp;entry-&gt;d_hash, list);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1103</x>
      <y>199</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将新申请的dentry链接到hash中</panel_attributes>
    <additional_attributes>40.0;10.0;160.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>817</x>
      <y>210</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>*res_dir = NULL
sb = dir-&gt;i_sb
filter：namelen &gt; EXT2_NAME_LEN
memset (bh_use, 0, sizeof (bh_use))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>830</x>
      <y>191</y>
      <w>80</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
NAMEI_RA_SIZE：预读的size</panel_attributes>
    <additional_attributes>780.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>861</x>
      <y>191</y>
      <w>51</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过ext2_getblk填充
bh_use和bh_read
</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>843</x>
      <y>211</y>
      <w>41</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.block是读取目录inode的第block块
2.预读的大小不能大于目录的size
	(block &lt;&lt; EXT2_BLOCK_SIZE_BITS (sb)) &gt;= dir-&gt;i_size
		break；
	这里可知，目录的i_size是以bit为单位
3.通过ext2_getblk填充预读的buffer_head bh_use
4.如果这个buffer没从磁盘读进来（bh &amp;&amp; !buffer_uptodate(bh)），
	就将bh_read[toread++] = bh
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>886</x>
      <y>216</y>
      <w>61</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.采取流水线预读：处理0 block的时候，所有没到内存中的block
  都通过ll_rw_block读到内存中，在读到第4个block的时候，再将
  第8~12个block中没到内存中的读到内存中，以此类推。因为cpu处理buffer
  与从硬盘中读取是异步操作，这样就可以使在操作buffer的时候就可以同步的从
  硬盘中读取数据，如果这个过程合理，wait_on_buffer就可能不需要有任何的等待
2.错误处理：如果当前的size没有内容，就不处理，并将offset加上s_blocksize
	如果数据没有更新到内存中，那么直接退出，返回NULL
3.ext2的每个目录项都是和block对齐的，并且不能跨block。所以这里依次取出block
	中的目录项通过ext2_match比较name，和ext2_check_dir_entry进行检查，如果都通过
	了就将其他的bh释放，返回当前的bh。如果没找到，就遍历下一个目录项（de+de-&gt;rec_len），
	这里注意ext2的目录项是大小是不定的。
4.如果遍历完整个block没找到，就将当前的bh释放，并看block + NAMEI_RA_SIZE有没有超过
	dir的size，如果超过了，就不需要对其就行预读，否者需要通过ext2_getblk将bh读进来，
	并判断是否要预读，以便形成流水线的操作。
5.如果遍历完整个dir没找到，就返回NULL。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>905</x>
      <y>191</y>
      <w>22</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
block指的是读取的block，
但是在bh_use中的额位置是
block % NAMEI_RA_SIZE

offset是目录项在dir中的偏移</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;250.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>944</x>
      <y>192</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iget4</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>934</x>
      <y>188</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
超级块
inode号</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>930</x>
      <y>203</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>923</x>
      <y>195</y>
      <w>39</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在hash表inode_hashtable中查找
1.是否有inode号和超级块和当前查找的inode相同的inode，
2.如果有find_actor，则通过find_actor进行比较</panel_attributes>
    <additional_attributes>260.0;10.0;120.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>963</x>
      <y>206</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__iget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>949</x>
      <y>195</y>
      <w>20</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在内存中找到</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>951</x>
      <y>209</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果之前又被引用</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>947</x>
      <y>216</y>
      <w>19</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;inode-&gt;i_count)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>967</x>
      <y>215</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;inode-&gt;i_count)
 //如果dirty，这个链表会连在s_dirty
 //如果不是dirty，且count为0，则连在inode_unused
if !I_DIRTY
	将inode从原来的链表中删除，并且
	添加到inode_in_use中
inodes_stat.nr_unused--
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>968</x>
      <y>209</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没被引用</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1032</x>
      <y>209</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_new_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>949</x>
      <y>195</y>
      <w>91</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在内存中没找到</panel_attributes>
    <additional_attributes>10.0;10.0;890.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>953</x>
      <y>232</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>957</x>
      <y>212</y>
      <w>84</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>820.0;10.0;350.0;150.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>970</x>
      <y>234</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>975</x>
      <y>212</y>
      <w>66</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为前面有spinlock
所以此时内存中可能已经存在了inode</panel_attributes>
    <additional_attributes>640.0;10.0;10.0;220.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>984</x>
      <y>236</y>
      <w>20</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>__iget(old);//增加inode计数
 //因为内存中已经存在inode
 //所以将新申请的inode释放
 //如果inode的dirty_buffer中
 //存在成员，应该报错
destroy_inode(inode);
inode = old;
wait_on_inode(inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>994</x>
      <y>212</y>
      <w>47</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
内存中存在inode</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;240.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1038</x>
      <y>212</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
内存中还是不存在inode
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1023</x>
      <y>220</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化inode</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1010</x>
      <y>229</y>
      <w>40</w>
      <h>46</h>
    </coordinates>
    <panel_attributes>inodes_stat.nr_inodes++;
list_add(&amp;inode-&gt;i_list, &amp;inode_in_use);
list_add(&amp;inode-&gt;i_hash, head);
inode-&gt;i_sb = sb;
inode-&gt;i_dev = sb-&gt;s_dev;
inode-&gt;i_ino = ino;
inode-&gt;i_flags = 0;
atomic_set(&amp;inode-&gt;i_count, 1);
inode-&gt;i_state = I_LOCK;

 //注意clean_inode中的empty的操作
 //这些申明是static是保存在data段
 //没经初始化，是NULL,所以这里全部初始化为NULL
clean_inode
	memset(&amp;inode-&gt;u, 0, sizeof(inode-&gt;u));
	inode-&gt;i_sock = 0;
	inode-&gt;i_op = &amp;empty_iops;
	inode-&gt;i_fop = &amp;empty_fops;
	inode-&gt;i_nlink = 1;
	atomic_set(&amp;inode-&gt;i_writecount, 0);
	inode-&gt;i_size = 0;
	inode-&gt;i_generation = 0;
	memset(&amp;inode-&gt;i_dquot, 0, sizeof(inode-&gt;i_dquot));
	inode-&gt;i_pipe = NULL;
	inode-&gt;i_bdev = NULL;
	inode-&gt;i_data.a_ops = &amp;empty_aops;
	inode-&gt;i_data.host = inode;
	inode-&gt;i_mapping = &amp;inode-&gt;i_data;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1127</x>
      <y>226</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_state &amp;= ~I_LOCK;
wake_up(&amp;inode-&gt;i_wait);
return inode;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1042</x>
      <y>220</y>
      <w>96</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
当从硬盘中读到inode
并将进程唤醒</panel_attributes>
    <additional_attributes>10.0;10.0;940.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1085</x>
      <y>228</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;read_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1042</x>
      <y>220</y>
      <w>52</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
利用具体文件系统的方法
将inode读取到内存</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1102</x>
      <y>236</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_read_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1093</x>
      <y>231</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 ext2_sops</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1051</x>
      <y>246</y>
      <w>66</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.检查inode号
	如果小于EXT2_FIRST_INO，但是不是EXT2_ROOT_INO EXT2_ACL_IDX_INO EXT2_ACL_DATA_INO
	如果inode号大于最大的inode---s_inodes_count
2.检查block_group( (inode-&gt;i_ino - 1) / EXT2_INODES_PER_GROUP )
`大于最大的group号s_groups_count
3.inode号被分为3段，最低的一段为offset（有些许不同，offset为其字节数）
	中间一段为group的号desc。最高的一段为group_desc
	首先在group_desc中存储的信息存在在buffer中，通过s_group_desc[group_desc]取出（不能为空）
	其次拿到inode所在组的block偏移s_group_desc[group_desc][desc].bg_inode_table
	最后将其加上inode在组内偏移的block号offset&gt;&gt;EXT2_BLOCK_SIZE_BITS
	即为inode的block号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1077</x>
      <y>239</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1125</x>
      <y>247</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1107</x>
      <y>239</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1108</x>
      <y>239</y>
      <w>46</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将offset对blocksize取余
这里的blocksize应该是2的整数次幂
offset &amp;= (EXT2_BLOCK_SIZE(inode-&gt;i_sb) - 1)</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1145</x>
      <y>247</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>raw_inode=bh-&gt;b_data + offset
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1109</x>
      <y>239</y>
      <w>69</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据raw_inode中的数据
对inode进行填充
包括inode-&gt;u.ext2_i.i_data</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1172</x>
      <y>246</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>inode：
	VFS
	ext2_inode_info
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1109</x>
      <y>239</y>
      <w>97</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将文件系统的操作方法
和VFS链接</panel_attributes>
    <additional_attributes>10.0;10.0;950.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1194</x>
      <y>243</y>
      <w>34</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>ACL：不做处理
S_ISREG：
inode-&gt;i_op = &amp;ext2_file_inode_operations;
inode-&gt;i_fop = &amp;ext2_file_operations;
inode-&gt;i_mapping-&gt;a_ops = &amp;ext2_aops;

S_ISDIR：
inode-&gt;i_op = &amp;ext2_dir_inode_operations;
inode-&gt;i_fop = &amp;ext2_dir_operations;

S_ISLNK：
if (!inode-&gt;i_blocks)
	inode-&gt;i_op = &amp;ext2_fast_symlink_inode_operations;
else {
	inode-&gt;i_op = &amp;page_symlink_inode_operations;
	inode-&gt;i_mapping-&gt;a_ops = &amp;ext2_aops;
}

特殊文件：
init_special_inode(inode, inode-&gt;i_mode,
				   le32_to_cpu(raw_inode-&gt;i_block[0]));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1239</x>
      <y>250</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_attr_flags
inode-&gt;i_flags
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1108</x>
      <y>238</y>
      <w>140</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据inode-&gt;u.ext2_i.i_flag
设置</panel_attributes>
    <additional_attributes>10.0;20.0;1220.0;20.0;1380.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>980</x>
      <y>54</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>d_mountpoint(dentry) 
&amp;&amp; __follow_down(&amp;nd-&gt;mnt, &amp;dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>844</x>
      <y>16</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查当前节点是否是安装节点</panel_attributes>
    <additional_attributes>10.0;10.0;970.0;280.0;1480.0;380.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1061</x>
      <y>42</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>842</x>
      <y>16</y>
      <w>224</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2220.0;220.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1065</x>
      <y>45</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
最多嵌套调用8次</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1024</x>
      <y>56</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>UPDATE_ATIME
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1030</x>
      <y>51</y>
      <w>39</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1084</x>
      <y>54</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry-&gt;d_inode-&gt;i_op-&gt;follow_link
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1066</x>
      <y>51</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1071</x>
      <y>57</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_fast_symlink_inode_operations</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1066</x>
      <y>66</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1071</x>
      <y>73</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1073</x>
      <y>69</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
此时data中存储的路径名</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1077</x>
      <y>80</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__vfs_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1080</x>
      <y>75</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1067</x>
      <y>83</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果符号链接到根目录</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1056</x>
      <y>87</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放当前节点</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1050</x>
      <y>90</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1035</x>
      <y>97</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput(nd-&gt;dentry)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1057</x>
      <y>97</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mntput(nd-&gt;mnt)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1039</x>
      <y>93</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1054</x>
      <y>93</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1074</x>
      <y>97</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1079</x>
      <y>83</y>
      <w>20</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查找符号链接对应的inode</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1120</x>
      <y>92</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>name = __getname();
strcpy(name, nd-&gt;last.name);
nd-&gt;last.name = name;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1082</x>
      <y>83</y>
      <w>49</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
看不懂，last.name为什么直接指向
原来的name，而需要新建一个
需要之后看这个的应用场景</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1083</x>
      <y>83</y>
      <w>29</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;link_count
|| res //有错
|| nd-&gt;last_type!=LAST_NORM
这里因为有link_count,所以推出</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1103</x>
      <y>98</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return res
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1062</x>
      <y>37</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
follow_link
符号链接</panel_attributes>
    <additional_attributes>20.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1065</x>
      <y>40</y>
      <w>5</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1067</x>
      <y>40</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1081</x>
      <y>42</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>dput(dentry)
inode = nd-&gt;dentry-&gt;d_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1063</x>
      <y>37</y>
      <w>57</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
普通的inode</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1108</x>
      <y>42</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>dput(nd-&gt;dentry);
nd-&gt;dentry = dentry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1196</x>
      <y>23</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>last_component
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1150</x>
      <y>23</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>last_with_slashes
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1131</x>
      <y>42</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>continue
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1063</x>
      <y>37</y>
      <w>75</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
继续循环查找</panel_attributes>
    <additional_attributes>10.0;10.0;730.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1138</x>
      <y>31</y>
      <w>40</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1155</x>
      <y>26</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是链接目录
要到所在的链接对象</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1190</x>
      <y>26</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
LOOKUP_PARENT
要找的是父节点</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1183</x>
      <y>32</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_parent
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1150</x>
      <y>40</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>nd-&gt;last = this
nd-&gt;last_type = LAST_NORM //普通名称
nd-&gt;last_type = LAST_DOT //‘.’
nd-&gt;last_type = LAST_DOTDOT //'..'
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1162</x>
      <y>35</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1186</x>
      <y>40</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果是'..'，通过follow_dotdot，
	然后返回节点
2.如果是'.',直接返回
3,，如果是其他名称，继续查找inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1196</x>
      <y>26</y>
      <w>17</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
解析最后一个名称</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1216</x>
      <y>41</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>nd-&gt;dentry-&gt;d_op-&gt;d_hash
cached_lookup
real_lookup

d_mountpoint(dentry) 
&amp;&amp; __follow_down(&amp;nd-&gt;mnt, &amp;dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1203</x>
      <y>26</y>
      <w>25</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
和查找中间节点的方法类似
但是注意real_lookup和cached_lookup
的flag变为了0
但是d_revalidate在ext2中没有</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1244</x>
      <y>49</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_follow_link
（refrence）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1204</x>
      <y>26</y>
      <w>67</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1253</x>
      <y>40</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
只有在LOOKUP_FOLLOW
的时候采取找符号链接</panel_attributes>
    <additional_attributes>160.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1280</x>
      <y>50</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>dput(nd-&gt;dentry);
			nd-&gt;dentry = dentry;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1258</x>
      <y>49</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>dput(dentry)
inode = nd-&gt;dentry-&gt;d_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1248</x>
      <y>45</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1255</x>
      <y>45</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1268</x>
      <y>40</y>
      <w>22</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1299</x>
      <y>40</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>no_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1297</x>
      <y>43</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
只有在LOOKUP_POSITIVE|LOOKUP_DIRECTORY
的时候在报错</panel_attributes>
    <additional_attributes>90.0;10.0;250.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1314</x>
      <y>52</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_release(nd)
return err
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1204</x>
      <y>26</y>
      <w>105</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1030.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1204</x>
      <y>26</y>
      <w>146</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1440.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1314</x>
      <y>36</y>
      <w>43</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
存在inode
当LOOKUP_DIRECTORY的时候，但是没有	inode-&gt;i_op-&gt;lookup
会报错</panel_attributes>
    <additional_attributes>340.0;10.0;80.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>843</x>
      <y>16</y>
      <w>314</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3120.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>842</x>
      <y>16</y>
      <w>362</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3600.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>685</x>
      <y>66</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op-&gt;permission
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>691</x>
      <y>59</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果文件系统规定了permission</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>714</x>
      <y>68</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_permission
1.首先看超级块的权限，只读/mute等
2.其次看进程的权限
	2.1如果可执行文件的setuid位置上，可以改变进程的uid gid（参考prepare_binprm和compute_creds）
	2.2.CAP_DAC_OVERRIDE/CAP_DAC_READ_SEARCH可以将uid的权限覆盖
3.看uid的权限（即DAC）,和文件主是同一个用户？同组用户？还是其他用户

inode 的mode位：
0~8：其他用户、同组用户、文件主权限
10 11：setuid setgrd
12~15：文件类型
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>719</x>
      <y>59</y>
      <w>19</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否则就用vfs的permission</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>575</x>
      <y>71</y>
      <w>146</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(mask &amp; S_IWOTH) &amp;&amp; IS_RDONLY(inode) &amp;&amp;
(S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))
需要写权限||磁盘是只读安装 ||（是常规文件 || 目录 ||链接）</panel_attributes>
    <additional_attributes>1440.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>570</x>
      <y>90</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>EROFS
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>598</x>
      <y>71</y>
      <w>123</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(mask &amp; S_IWOTH) &amp;&amp; IS_IMMUTABLE(inode)
写 || 不可更改
IS_IMMUTABLE和用户无关</panel_attributes>
    <additional_attributes>1210.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>593</x>
      <y>90</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>EACCES
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>579</x>
      <y>83</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mode = inode-&gt;i_mode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>587</x>
      <y>71</y>
      <w>133</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1310.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>612</x>
      <y>91</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mode &gt;&gt;= 6
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>618</x>
      <y>71</y>
      <w>104</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;fsuid == inode-&gt;i_uid
fsuid大部分和euid相同
但是在NFS中可能会不一样</panel_attributes>
    <additional_attributes>1020.0;10.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>633</x>
      <y>71</y>
      <w>89</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>870.0;10.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>628</x>
      <y>91</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>in_group_p</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>619</x>
      <y>94</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode-&gt;i_gid == current-&gt;fsgid</panel_attributes>
    <additional_attributes>150.0;10.0;50.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>612</x>
      <y>102</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>supplemental_group_member</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>614</x>
      <y>109</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>遍历current-&gt;groups
看是否有组号一样的
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>621</x>
      <y>105</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
一个用户可能在不同的组中</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>641</x>
      <y>94</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mode &gt;&gt;= 3
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>636</x>
      <y>90</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>663</x>
      <y>71</y>
      <w>59</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
此时判断权限
(mode &amp; mask &amp; S_IRWXO) == mask) || capable(CAP_DAC_OVERRIDE)
others已经在最后三位上所以不用移
CAP_DAC_OVERRIDE：授权进程
</panel_attributes>
    <additional_attributes>570.0;10.0;10.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>657</x>
      <y>95</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>689</x>
      <y>94</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>686</x>
      <y>71</y>
      <w>44</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(mask == S_IROTH) ||
 (S_ISDIR(inode-&gt;i_mode)  &amp;&amp; !(mask &amp; ~(S_IROTH | S_IXOTH))))
	if (capable(CAP_DAC_READ_SEARCH)
读||
（目录 || 没要写权限）
</panel_attributes>
    <additional_attributes>340.0;10.0;90.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>649</x>
      <y>162</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_setuid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>638</x>
      <y>165</y>
      <w>17</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CAP_SETUID</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>638</x>
      <y>172</y>
      <w>12</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>643</x>
      <y>180</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;suid = uid
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>630</x>
      <y>172</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uid != old_ruid</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>625</x>
      <y>179</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>592</x>
      <y>189</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_uid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>597</x>
      <y>182</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>562</x>
      <y>192</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从uidhash_table对应的哈希值
处查找，直到为空，或者找到user的uid
和想找的相同，并将user.count++</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>556</x>
      <y>198</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uid_hash_find</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>586</x>
      <y>192</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果哈希表中没找到</panel_attributes>
    <additional_attributes>120.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>559</x>
      <y>205</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>564</x>
      <y>199</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uid_cachep
申请user</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>575</x>
      <y>206</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>new-&gt;uid = uid;
atomic_set(&amp;new-&gt;__count, 1);
atomic_set(&amp;new-&gt;processes, 0);
atomic_set(&amp;new-&gt;files, 0)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>586</x>
      <y>199</y>
      <w>5</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>603</x>
      <y>207</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uid_hash_find</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>586</x>
      <y>199</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为在操作哈希表的时候有spinlock
所以这里再查查哈希表中是否有对应的
user</panel_attributes>
    <additional_attributes>30.0;10.0;210.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>588</x>
      <y>199</y>
      <w>35</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>617</x>
      <y>205</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有将申请到的user释放</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>610</x>
      <y>211</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>630</x>
      <y>211</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //注意pprev指向的是（指向自己的）箭头
uid_hash_insert(new, hashent);
up = new;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>620</x>
      <y>205</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>609</x>
      <y>190</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>old_user = current-&gt;user;
atomic_dec(&amp;old_user-&gt;processes);
atomic_inc(&amp;new_user-&gt;processes);
current-&gt;uid = new_ruid;
current-&gt;user = new_user;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>624</x>
      <y>182</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>646</x>
      <y>192</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_uid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>631</x>
      <y>182</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
old_user</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>630</x>
      <y>195</y>
      <w>40</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
up &amp;&amp; atomic_dec_and_lock(&amp;up-&gt;__count, &amp;uidhash_lock)</panel_attributes>
    <additional_attributes>230.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>642</x>
      <y>200</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //注意pprev的操作
uid_hash_remove
kmem_cache_free
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>661</x>
      <y>179</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>EPERM
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>652</x>
      <y>165</y>
      <w>19</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没有权限
设置的uid又不是
current-&gt;uid
current-&gt;suid</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>673</x>
      <y>179</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;fsuid = current-&gt;euid = uid
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>652</x>
      <y>165</y>
      <w>32</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>702</x>
      <y>179</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes> //越界访问不产生dump文件
current-&gt;dumpable = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>652</x>
      <y>165</y>
      <w>58</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
old_euid != uid</panel_attributes>
    <additional_attributes>10.0;10.0;560.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>664</x>
      <y>109</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>capable</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>664</x>
      <y>118</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cap_raised</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>669</x>
      <y>112</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;cap_effective
相应的位有没有置上</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>675</x>
      <y>118</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果置上</panel_attributes>
    <additional_attributes>10.0;20.0;100.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>685</x>
      <y>118</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>current-&gt;flags |= PF_SUPERPRIV;
return 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>652</x>
      <y>165</y>
      <w>82</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!issecure(SECURE_NO_SETUID_FIXUP)
SECUREBITS_DEFAULT中这一位没置上</panel_attributes>
    <additional_attributes>10.0;10.0;800.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>727</x>
      <y>178</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cap_emulate_setxuid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>711</x>
      <y>181</y>
      <w>26</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 {r,e,s}uid == 0 _to_ all of
 *  {r,e,s}uid != 0
 !current-&gt;keep_capabilities
 //r=uid e=euid s=suid
 </panel_attributes>
    <additional_attributes>240.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>690</x>
      <y>189</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //keep_capabilities可以通过prctl
 	//变成1，这样在setuid的时候，就不会
 	//将permitted清空，当返回的时候
 	//相应的cap_effective也会恢复
cap_clear(current-&gt;cap_permitted);
cap_clear(current-&gt;cap_effective);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>731</x>
      <y>181</y>
      <w>23</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
from_ euid == 0 _to_ euid != 0</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>719</x>
      <y>194</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cap_clear(current-&gt;cap_effective)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>735</x>
      <y>181</y>
      <w>20</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
from_ euid != 0 _to_ euid == 0</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>744</x>
      <y>193</y>
      <w>31</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;cap_effective = current-&gt;cap_permitted
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1200</x>
      <y>282</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_special_inode
i_rdev表示索引节点
代表的设备号
存在i_block[0]</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1208</x>
      <y>278</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1190</x>
      <y>285</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISCHR</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1179</x>
      <y>290</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_fop = &amp;def_chr_fops;
inode-&gt;i_rdev = to_kdev_t(rdev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1208</x>
      <y>285</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISBLK</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1202</x>
      <y>290</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_fop = &amp;def_blk_fops;
inode-&gt;i_rdev = to_kdev_t(rdev);
inode-&gt;i_bdev = bdget(rdev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1208</x>
      <y>285</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISFIFO</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1226</x>
      <y>291</y>
      <w>20</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_fop = &amp;def_fifo_fops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1208</x>
      <y>285</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISSOCK</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1247</x>
      <y>291</y>
      <w>20</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_fop = &amp;bad_sock_fops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1118</x>
      <y>259</y>
      <w>61</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_mode = le16_to_cpu(raw_inode-&gt;i_mode);
inode-&gt;i_uid = (uid_t)le16_to_cpu(raw_inode-&gt;i_uid_low);
inode-&gt;i_gid = (gid_t)le16_to_cpu(raw_inode-&gt;i_gid_low);
if(!(test_opt (inode-&gt;i_sb, NO_UID32))) {
	inode-&gt;i_uid |= le16_to_cpu(raw_inode-&gt;i_uid_high) &lt;&lt; 16;
	inode-&gt;i_gid |= le16_to_cpu(raw_inode-&gt;i_gid_high) &lt;&lt; 16;
}
inode-&gt;i_nlink = le16_to_cpu(raw_inode-&gt;i_links_count);
inode-&gt;i_size = le32_to_cpu(raw_inode-&gt;i_size);
inode-&gt;i_atime = le32_to_cpu(raw_inode-&gt;i_atime);
inode-&gt;i_ctime = le32_to_cpu(raw_inode-&gt;i_ctime);
inode-&gt;i_mtime = le32_to_cpu(raw_inode-&gt;i_mtime);
inode-&gt;u.ext2_i.i_dtime = le32_to_cpu(raw_inode-&gt;i_dtime);
inode-&gt;i_blksize = PAGE_SIZE;	/* This is the optimal IO size (for stat), not the fs block size */
inode-&gt;i_blocks = le32_to_cpu(raw_inode-&gt;i_blocks);
inode-&gt;i_version = ++event;
inode-&gt;u.ext2_i.i_flags = le32_to_cpu(raw_inode-&gt;i_flags);
inode-&gt;u.ext2_i.i_faddr = le32_to_cpu(raw_inode-&gt;i_faddr);
inode-&gt;u.ext2_i.i_frag_no = raw_inode-&gt;i_frag;
inode-&gt;u.ext2_i.i_frag_size = raw_inode-&gt;i_fsize;
inode-&gt;u.ext2_i.i_file_acl = le32_to_cpu(raw_inode-&gt;i_file_acl);
if (S_ISDIR(inode-&gt;i_mode))
	inode-&gt;u.ext2_i.i_dir_acl = le32_to_cpu(raw_inode-&gt;i_dir_acl);
else {
	inode-&gt;u.ext2_i.i_high_size = le32_to_cpu(raw_inode-&gt;i_size_high);
	inode-&gt;i_size |= ((__u64)le32_to_cpu(raw_inode-&gt;i_size_high)) &lt;&lt; 32;
}
inode-&gt;i_generation = le32_to_cpu(raw_inode-&gt;i_generation);
inode-&gt;u.ext2_i.i_block_group = block_group;
inode-&gt;u.ext2_i.i_data[block] = raw_inode-&gt;i_block[block]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1157</x>
      <y>252</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1098</x>
      <y>120</y>
      <w>52</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在proc_read_super中完成了连接
proc_root.proc_root_inode_operations</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1140</x>
      <y>144</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_root_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1094</x>
      <y>158</y>
      <w>27</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_nlink =proc_root.nlink +nr_threads
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1102</x>
      <y>147</y>
      <w>51</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果父节点dir是proc的根节点
更新/proc的nlink</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1137</x>
      <y>158</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1143</x>
      <y>147</y>
      <w>10</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1100</x>
      <y>169</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de = dir-&gt;u.generic_ip
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1106</x>
      <y>161</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取inode对应的proc_dir_entry
proc_dir_entry被抽象成硬盘上的数据</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1121</x>
      <y>168</y>
      <w>41</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果链表遍历完或者子节点的ino为0，退出遍历
2.如果子节点的名称长度和当前寻找的dentry的名字长度
	不相等，就查找下一个
3.如果长度相同，并且查找的dentry的名称和子节点的名称相同
	通过proc_get_inode获取节点的inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1136</x>
      <y>161</y>
      <w>26</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历父目录de的子节点链表subdir</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1164</x>
      <y>169</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>dentry-&gt;d_op = &amp;proc_dentry_operations;
 //将dentry加到inode的i_dentry的链表中
 //并将dentry加到hash中
d_add(dentry, inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1142</x>
      <y>161</y>
      <w>39</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1206</x>
      <y>156</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_pid_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1150</x>
      <y>147</y>
      <w>67</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在dir中没找到</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1204</x>
      <y>159</y>
      <w>18</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要查找self文件</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1195</x>
      <y>168</y>
      <w>31</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>inode = new_inode(dir-&gt;i_sb)
inode-&gt;i_mtime = inode-&gt;i_atime = 
inode-&gt;i_ctime = CURRENT_TIME;
inode-&gt;i_ino = fake_ino(0, PROC_PID_INO);
inode-&gt;u.proc_i.file = NULL;
inode-&gt;u.proc_i.task = NULL;
inode-&gt;i_mode = S_IFLNK|S_IRWXUGO;
inode-&gt;i_uid = inode-&gt;i_gid = 0;
inode-&gt;i_size = 64;
inode-&gt;i_op = &amp;proc_self_inode_operations;
d_add(dentry, inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1231</x>
      <y>169</y>
      <w>31</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.将name转化成pid号
2.通过find_task_by_pid在hash中找到task
3.通过get_task_struct增加task的计数
3.通过proc_pid_make_inode创建inode，并对其
	属性赋值（该task要有父进程）
4.通过free_task_struct释放task
5.赋值inode相应的属性
	inode-&gt;i_mode = S_IFDIR|S_IRUGO|S_IXUGO;
	inode-&gt;i_op = &amp;proc_base_inode_operations;
	inode-&gt;i_fop = &amp;proc_base_operations;
	inode-&gt;i_nlink = 3;
	inode-&gt;i_flags|=S_IMMUTABLE;

	dentry-&gt;d_op = &amp;pid_base_dentry_operations;
	d_add(dentry, inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1212</x>
      <y>159</y>
      <w>29</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
name可能是数字，如果不是，返回-ENOENT</panel_attributes>
    <additional_attributes>40.0;10.0;240.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1235</x>
      <y>198</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_pid_make_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1245</x>
      <y>193</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要查找self文件</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1230</x>
      <y>205</y>
      <w>31</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.通过new_inode申请inode
2.属性赋值（）
	inode-&gt;i_mtime = inode-&gt;i_atime = 
	inode-&gt;i_ctime = CURRENT_TIME;
	inode-&gt;i_ino = fake_ino(task-&gt;pid, ino);
	inode-&gt;u.proc_i.file = NULL;
	//创建的节点增加了task的计数
	inode-&gt;u.proc_i.task = task;
	get_task_struct(task);

	inode-&gt;i_uid = 0;
	inode-&gt;i_gid = 0;
	//dumpable表示进程访问出错会残生dump文件
	if (ino == PROC_PID_INO || task-&gt;dumpable) {
		inode-&gt;i_uid = task-&gt;euid;
		inode-&gt;i_gid = task-&gt;egid;
	}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1243</x>
      <y>201</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1098</x>
      <y>57</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_self_inode_operations
访问/proc/self时
在vfs_follow_link中去path_walk
找/proc/pid，然后再通过proc_pid_lookup配置相关的pid的
inode</panel_attributes>
    <additional_attributes>10.0;10.0;390.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1126</x>
      <y>68</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_self_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1126</x>
      <y>71</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
换算成字符类型</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1119</x>
      <y>76</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tmp=current-&gt;pid
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1137</x>
      <y>76</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1134</x>
      <y>71</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1098</x>
      <y>119</y>
      <w>286</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在proc_pid_lookup中完成了连接
proc_base_inode_operations</panel_attributes>
    <additional_attributes>10.0;20.0;2840.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1373</x>
      <y>122</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_base_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1324</x>
      <y>134</y>
      <w>35</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.遍历base_stuff，找到相同name长度和name的entry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1338</x>
      <y>125</y>
      <w>43</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1364</x>
      <y>134</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_pid_make_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1373</x>
      <y>125</y>
      <w>19</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建访问节点的inode</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1393</x>
      <y>133</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>PROC_PID_CWD：
inode-&gt;i_op = &amp;proc_pid_link_inode_operations;
inode-&gt;u.proc_i.op.proc_get_link = proc_cwd_link;
PROC_PID_MAPS:
inode-&gt;i_fop = &amp;proc_maps_operations;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1383</x>
      <y>125</y>
      <w>16</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据访问节点的类型</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1098</x>
      <y>57</y>
      <w>84</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;820.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1178</x>
      <y>51</y>
      <w>70</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果找到最后，发现inode时link
比如找到了cwd的inode</panel_attributes>
    <additional_attributes>680.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1178</x>
      <y>59</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1179</x>
      <y>66</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_pid_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1157</x>
      <y>76</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.释放寻找过来的dentry和mnt  path_release(nd)
2.进程的fsuid==i_uid，或者CAP_DAC_OVERRIDE至少
	满足一个
3.proc_check_root检查inode指向task.fs的root
	要是current.fs.root的子目录
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1172</x>
      <y>69</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1196</x>
      <y>78</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;u.proc_i.op.proc_get_link
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1223</x>
      <y>78</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nd-&gt;last_type = LAST_BIND
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1187</x>
      <y>69</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1186</x>
      <y>69</y>
      <w>48</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;460.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1199</x>
      <y>87</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_cwd_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1206</x>
      <y>81</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1198</x>
      <y>95</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>fs = inode-&gt;u.proc_i.task-&gt;fs
*mnt = mntget(fs-&gt;pwdmnt);
*dentry = dget(fs-&gt;pwd);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1206</x>
      <y>90</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将nd中的mnt和dentry更新</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1206</x>
      <y>299</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1211</x>
      <y>295</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1192</x>
      <y>305</y>
      <w>35</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.首先通过bdfind在bdev_hashtable中查找
2.如果没找到，通过alloc_bdev在slab中申请数据结构
	并将其属性赋值
	new_bdev-&gt;bd_dev = dev;
	new_bdev-&gt;bd_op = NULL;
3.因为alloc_bdev有可能休眠，所以通过bdfind在找一遍
4.如果没找到，将其加入hash表中
	list_add(&amp;new_bdev-&gt;bd_hash, head);
5.如果找到了，将新申请的inode释放
	destroy_bdev(new_bdev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1210</x>
      <y>302</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>276</x>
      <y>490</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_from_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>245</x>
      <y>499</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__constant_copy_to_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>269</x>
      <y>499</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__generic_copy_to_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>260</x>
      <y>493</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
__builtin_constant_p</panel_attributes>
    <additional_attributes>210.0;10.0;18.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>278</x>
      <y>493</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里因为__copy_user_zeroing是一个宏
所以这里返回的是发生异常的剩余的字节数</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>264</x>
      <y>502</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
access_ok
（检查是否所要复制的是否在用户空间）
</panel_attributes>
    <additional_attributes>160.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>263</x>
      <y>507</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__copy_user_zeroing</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>245</x>
      <y>513</y>
      <w>45</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>"0:	rep; movsl\n"					\//将esi中的内容复制到edi中，直到ecx=0
											//每次复制为4个字节
"	movl %3,%0\n"					\//令ecx=size&amp;3，
"1:	rep; movsb\n"					\//每次复制为1个字节
"2:\n"							\
".section .fixup,\"ax\"\n"				\//将链接到fixup 段
"3:	lea 0(%3,%0,4),%0\n"				\//ecx=size&amp;3+size(剩下的)*4
"4:	pushl %0\n"					\
"	pushl %%eax\n"					\
"	xorl %%eax,%%eax\n"				\
"	rep; stosb\n"					\将eax中的值填充到edi对应的地址
"	popl %%eax\n"					\
"	popl %0\n"					\
"	jmp 2b\n"					\
".previous\n"						\
".section __ex_table,\"a\"\n"				\//因为这一段虚拟内存可能并没有映射
					//所以可能会产生缺页中断，但是这里不能直接给进程分配页面，所以
					//在do_page_fault中，有着search_exception_table去寻找着此时应该
					//返回的ip地址，这一段是在链接的时候链接到__ex_table段，然后通过
					//遍历module_list中的module，再在每个段中通过二分法查找到对应发生
					//异常的位置，查找出要fix_up的ip
"	.align 4\n"					\
"	.long 0b,3b\n"					//在0地址发生异常，则跳到3出执行
"	.long 1b,4b\n"					\//在1处发生异常，则跳到4处
".previous"						\
: "=&amp;c"(size), "=&amp;D" (__d0), "=&amp;S" (__d1)		\
: "r"(size &amp; 3), "0"(size / 4), "1"(to), "2"(from)	\
: "memory");

ecx=size/4   edi=to   esi=from 

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>264</x>
      <y>510</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>401</x>
      <y>457</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>262</x>
      <y>478</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_mount_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>271</x>
      <y>460</y>
      <w>138</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
type</panel_attributes>
    <additional_attributes>1360.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>249</x>
      <y>492</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_free_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>256</x>
      <y>481</y>
      <w>14</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请一页内存</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>262</x>
      <y>481</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1.data不能超过3G
2.copy的最大内存最大为1页
3.如果copy的不到一页，就将其他内存清零
</panel_attributes>
    <additional_attributes>60.0;10.0;210.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>284</x>
      <y>478</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>289</x>
      <y>460</y>
      <w>120</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dir_name</panel_attributes>
    <additional_attributes>1180.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>303</x>
      <y>479</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_mount_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>307</x>
      <y>460</y>
      <w>102</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dev_name
data</panel_attributes>
    <additional_attributes>1000.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>503</x>
      <y>478</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>406</x>
      <y>460</y>
      <w>106</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
之前将数据copy到系统空间，
这里真正做mount</panel_attributes>
    <additional_attributes>10.0;10.0;1040.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>290</x>
      <y>494</y>
      <w>43</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果magic是MS_MGC_VAL，就将magic清掉
2.dir_name存在，不为空字符串，一个页面内存在结束字符0
	memchr
	if (!count)
	return NULL;
__asm__ __volatile__(
	"repne\n\t"
	"scasb\n\t" //edi++,ecx--,比较edi和eax（al）,不同继续，相同退出
	"je 1f\n\t" //如果相同，说明存在结束字符，跳到1将edi--
	"movl $1,%0\n" //如果不同，说明没结束字符，结合下一句将res=0
	"1:\tdecl %0"
	:"=D" (__res), "=&amp;c" (d0)
	:"a" (c), "0" (cs), "1" (count))
3.错误：dev_name存在但是一个页面内不存在结束字符
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>310</x>
      <y>481</y>
      <w>199</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dir_name</panel_attributes>
    <additional_attributes>1970.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>333</x>
      <y>496</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_remount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>341</x>
      <y>481</y>
      <w>170</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flags &amp; MS_REMOUNT
如果需要将设备重新安装
（因为安装方式改变，eg:只读-&gt;可写）</panel_attributes>
    <additional_attributes>1680.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>361</x>
      <y>497</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_loopback</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>367</x>
      <y>481</y>
      <w>145</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flags &amp; MS_BIND
回接
将普通文件通过losetup回接成设备
可以将这个设备加密或者mkfs格式化
然后再将这个设备进行安装
这里只是安装过程</panel_attributes>
    <additional_attributes>1430.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>433</x>
      <y>498</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>filter：
1.type_page不为空并且在一页内结束
2.进程capable(CAP_SYS_ADMIN)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>440</x>
      <y>481</y>
      <w>74</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>720.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>460</x>
      <y>505</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_fs_type</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>464</x>
      <y>481</y>
      <w>50</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>420</x>
      <y>510</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_filesystem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>426</x>
      <y>507</y>
      <w>41</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历file_systems链表
找到名字相同的file_system_type</panel_attributes>
    <additional_attributes>390.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>391</x>
      <y>516</y>
      <w>37</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>strcmp
"1:\tlodsb\n\t"//将esi指向的字节存到al中，并esi++
"scasb\n\t"//edi++，比较edi和al，
"jne 2f\n\t"
"testb %%al,%%al\n\t"//eax&amp;eax
"jne 1b\n\t"//不为0
"xorl %%eax,%%eax\n\t"//eax清零
"jmp 3f\n"
"2:\tsbbl %%eax,%%eax\n\t"//-cf
"orb $1,%%al\n"//eax|=1
"3:"
:"=a" (__res), "=&amp;S" (d0), "=&amp;D" (d1)
	     :"1" (cs),"2" (ct));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>412</x>
      <y>513</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>434</x>
      <y>519</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>try_inc_mod_count</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>440</x>
      <y>508</y>
      <w>28</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果找到了
fs-&gt;owner</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>431</x>
      <y>528</y>
      <w>8</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>res=1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>433</x>
      <y>522</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是通过
register_filesystem
注册</panel_attributes>
    <additional_attributes>90.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>441</x>
      <y>522</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是通过模块安装</panel_attributes>
    <additional_attributes>20.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>439</x>
      <y>526</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mod-&gt;flags &amp; MOD_DELETED</panel_attributes>
    <additional_attributes>130.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>441</x>
      <y>530</y>
      <w>8</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>res=0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>453</x>
      <y>530</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__MOD_INC_USE_COUNT
res=1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>450</x>
      <y>526</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>455</x>
      <y>518</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>461</x>
      <y>508</y>
      <w>12</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没找到</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>475</x>
      <y>518</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_filesystem
try_inc_mod_count
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>462</x>
      <y>508</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
然后再次查找，并且增加模块计数</panel_attributes>
    <additional_attributes>40.0;10.0;180.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>476</x>
      <y>504</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>493</x>
      <y>504</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>480</x>
      <y>481</y>
      <w>34</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
LOOKUP_FOLLOW
|LOOKUP_POSITIVE
|LOOKUP_DIRECTORY</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>499</x>
      <y>481</y>
      <w>15</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>510</x>
      <y>481</y>
      <w>5</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;210.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>499</x>
      <y>500</y>
      <w>30</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fstype-&gt;fs_flags &amp; FS_NOMOUNT
虚拟文件系统（pipe 共享内存）
不能通过mount安装</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>495</x>
      <y>514</y>
      <w>6</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>EINVAL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>500</x>
      <y>526</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_sb_bdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>412</x>
      <y>529</y>
      <w>98</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>960.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>506</x>
      <y>501</y>
      <w>27</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FS_REQUIRES_DEV
普通的文件系统
（不同设备有不同超级块）
通过DECLARE_FSTYPE_DEV申明
其他的通过DECLARE_FSTYPE申明</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;250.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>509</x>
      <y>500</y>
      <w>38</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FS_SINGLE
文件系统只有一个超级块
（即使是不同设备）</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>537</x>
      <y>519</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_sb_single</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>560</x>
      <y>513</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_sb_nodev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>509</x>
      <y>500</y>
      <w>58</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
虚拟文件系统
没有设备
用于实现相应的规程
生成超级块</panel_attributes>
    <additional_attributes>10.0;10.0;560.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>409</x>
      <y>548</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>filter:
dev_name存在
且不为空字符串
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>424</x>
      <y>548</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>437</x>
      <y>548</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>429</x>
      <y>529</y>
      <w>81</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到dev_name的inode</panel_attributes>
    <additional_attributes>790.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>442</x>
      <y>529</y>
      <w>68</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>660.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>429</x>
      <y>555</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode = nd.dentry-&gt;d_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>429</x>
      <y>551</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>437</x>
      <y>551</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>450</x>
      <y>548</y>
      <w>47</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.要是块设备S_ISBLK(inode-&gt;i_mode)
2.inode的super_block要有dev
	IS_NODEV(inode)
3.bdev = inode-&gt;i_bdev;
4.如果dev的主次设备号是通过节点的路径名来表示
	1.devfs_get_handle_from_inode
		1.inode和inode的超级块不为空
		2.超级块的s_magic位DEVFS_SUPER_MAGIC
		3.inode号大于文件系统的第一个inode号
		4. inode-&gt;i_sb-&gt;u.generic_sbp不为空
		5.inode号在fs的最大inode号之内
		6.返回inode-&gt;i_sb-&gt;u.generic_sbp-&gt;table[inode-&gt;i_ino - FIRST_INODE]
	2.通过devfs_get_ops得到块设备的驱动函数
		1.第一步返回不为空
		2.de-&gt;registered为1
		3.是字符设备/块设备/常规文件 返回de-&gt;u.fcb.ops，否则返回NULL
	如果是通过一个平面结构（16位主设备号，16位次设备号）mknod表示，
	返回NULL
5.bdev-&gt;bd_op = bdops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>456</x>
      <y>529</y>
      <w>54</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>529</y>
      <w>6</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>504</x>
      <y>547</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>498</x>
      <y>556</y>
      <w>41</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历super_blocks，如果s-&gt;s_dev不等于查找的设备dev
·就查找链表的下一个
2.如果等于dev，就wait_on_super查看lock，如果有lock，
就sleep，如果没lock，直接返回
3.醒来之后如果发现dev不同了，就重新再遍历一遍super_blocks
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>510</x>
      <y>550</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>529</y>
      <w>53</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;180.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>542</x>
      <y>546</y>
      <w>20</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果内存中存在super_block
</panel_attributes>
    <additional_attributes>160.0;10.0;30.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>540</x>
      <y>556</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.sb的type要和安装时候格式化的fs_type相同
2.安装的flag和sb-&gt;s_flags要在MS_RDONLY位相同
满足上面两条条件，返回sb，否则返回错误
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>557</x>
      <y>546</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不存在sb
</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>577</x>
      <y>552</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FMODE_READ
如果不是只读安装
就把FMODE_WRITE置上
打开设备文件</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>574</x>
      <y>560</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>502</x>
      <y>571</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rdev = to_kdev_t(bdev-&gt;bd_dev)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>512</x>
      <y>563</y>
      <w>70</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>680.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>528</x>
      <y>571</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_blkfops</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>534</x>
      <y>563</y>
      <w>48</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!bdev-&gt;bd_op
如果不是devfs设备
（devfs之前已经设置过bd_op）</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>533</x>
      <y>574</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
主设备号</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>508</x>
      <y>578</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!blkdevs[major].bdops
如果没在这里注册，有可能是可安装设备
</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>502</x>
      <y>581</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>535</x>
      <y>583</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdevs[major].bdops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>533</x>
      <y>578</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果
blkdevs中存在</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>577</x>
      <y>563</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里无论是devfs还是主次设备号
bd_op正常都执行驱动函数</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>556</x>
      <y>572</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_empty_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>561</x>
      <y>568</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>544</x>
      <y>578</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>548</x>
      <y>575</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>558</x>
      <y>579</y>
      <w>34</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>inodes_stat.nr_inodes++;
list_add(&amp;inode-&gt;i_list, &amp;inode_in_use);
inode-&gt;i_sb = NULL;
inode-&gt;i_dev = 0;
 //atten:last_ino是static
inode-&gt;i_ino = ++last_ino;
inode-&gt;i_flags = 0;
atomic_set(&amp;inode-&gt;i_count, 1);
inode-&gt;i_state = 0;
clean_inode(inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>562</x>
      <y>575</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>577</x>
      <y>568</y>
      <w>23</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>593</x>
      <y>579</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //file--dentry---inode
fake_file.f_mode = mode;
fake_file.f_flags = flags;
fake_file.f_dentry = &amp;fake_dentry;
fake_dentry.d_inode = fake_inode;
fake_inode-&gt;i_rdev = rdev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>621</x>
      <y>580</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdev-&gt;bd_op-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>577</x>
      <y>568</y>
      <w>53</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>577</x>
      <y>568</y>
      <w>69</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>634</x>
      <y>577</y>
      <w>12</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
正确返回</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>626</x>
      <y>585</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;bdev-&gt;bd_openers)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>643</x>
      <y>577</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
错误返回
并且bd_openers没有</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>649</x>
      <y>585</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdev-&gt;bd_op = NULL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>667</x>
      <y>585</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iput(fake_inode)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>643</x>
      <y>577</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放申请的inode</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>603</x>
      <y>558</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>check_disk_change</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>581</x>
      <y>552</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查介质是否变动</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>623</x>
      <y>557</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>!(flags &amp; MS_RDONLY) 
&amp;&amp; 
is_read_only(dev)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>581</x>
      <y>552</y>
      <w>53</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不是只读安装
但是设备却设置成只读</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>621</x>
      <y>566</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>blkdev_put(bdev, BDEV_FS)
path_release(&amp;nd)
return ERR_PTR(error) 
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>630</x>
      <y>562</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>665</x>
      <y>555</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>581</x>
      <y>552</y>
      <w>91</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;890.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>643</x>
      <y>562</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_empty_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>648</x>
      <y>558</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>643</x>
      <y>569</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.遍历链表super_blocks
2.如果存在s_dev为0，且
	s_lock没有锁住，则在链表
	中找到了空闲的sb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>649</x>
      <y>565</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>649</x>
      <y>565</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在super_blocks
中没找到空闲的sb</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>666</x>
      <y>576</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>669</x>
      <y>568</y>
      <w>8</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>683</x>
      <y>582</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>nr_super_blocks++;
memset(s, 0, sizeof(struct super_block));
INIT_LIST_HEAD(&amp;s-&gt;s_dirty);
list_add (&amp;s-&gt;s_list, super_blocks.prev);
init_waitqueue_head(&amp;s-&gt;s_wait);
INIT_LIST_HEAD(&amp;s-&gt;s_files);
INIT_LIST_HEAD(&amp;s-&gt;s_mounts);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>674</x>
      <y>568</y>
      <w>18</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请到了内存
就初始化sb</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>686</x>
      <y>563</y>
      <w>28</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>s-&gt;s_dev = dev;//设备号
s-&gt;s_bdev = bdev;//具体的设备
s-&gt;s_flags = flags;
s-&gt;s_dirt = 0;
sema_init(&amp;s-&gt;s_vfs_rename_sem,1);
sema_init(&amp;s-&gt;s_nfsd_free_path_sem,1);
s-&gt;s_type = type;
sema_init(&amp;s-&gt;s_dquot.dqio_sem, 1);
sema_init(&amp;s-&gt;s_dquot.dqoff_sem, 1);
s-&gt;s_dquot.flags = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>670</x>
      <y>558</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>717</x>
      <y>567</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>type-&gt;read_super(s, data, silent)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>670</x>
      <y>558</y>
      <w>66</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
type是从file_systems中
找到的file_system_type</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;30.0;640.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>744</x>
      <y>568</y>
      <w>21</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;bdev-&gt;bd_count)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>670</x>
      <y>556</y>
      <w>87</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是块设备，则增加计数</panel_attributes>
    <additional_attributes>10.0;30.0;510.0;20.0;850.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>735</x>
      <y>555</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>get_filesystem(fs_type);
path_release(&amp;nd);
return sb;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>581</x>
      <y>552</y>
      <w>160</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到了sb</panel_attributes>
    <additional_attributes>10.0;10.0;1580.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>512</x>
      <y>481</y>
      <w>39</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在read_super的过程中发现安装点已经被
其他的设备安装了，那么将会在已经安装的dentry上
继续安装现在的设备（管理上应该避免）</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>543</x>
      <y>494</y>
      <w>49</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.通过d_mountpoint检测nd.dentry是否安装了其他设备
 	（检测d_vfsmnt是否为空）
2.通过follow_down查找d_vfsmnt链表，如果检查安装点
	的mnt_parent，如果与将要安装的相同，则安装点mnt和dentry
	都变成下一层的mnt和dentry，将原来的dentry和mnt释放，并返回1
3.如果mnt_parent不相同，就遍历链表的下一个，重复2步骤，如果最后没有
	返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>551</x>
      <y>455</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfsmount
valign=center
bg=red</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>563</x>
      <y>455</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_mountpoint
安装的节点</panel_attributes>
    <additional_attributes>10.0;30.0;190.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>582</x>
      <y>455</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>535</x>
      <y>458</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_root
要安装设备的根目录</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>523</x>
      <y>453</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>super_block
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>584</x>
      <y>458</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
d_vfsmount
安装在这个目录下的所有vfsmount
（同一个设备可以有不同的安装点，
所以到这个dentry的路径可能不同
所以这里是可以有不同的安装点指向不同的设备
因为mnt_parent不同）</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>556</x>
      <y>458</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过mnt_clash链入</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>523</x>
      <y>461</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>535</x>
      <y>453</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_sb
要安装设备的超级块</panel_attributes>
    <additional_attributes>160.0;30.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>524</x>
      <y>446</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
s_mounts
这个设备所有要安装的安装点</panel_attributes>
    <additional_attributes>60.0;70.0;130.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>535</x>
      <y>446</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过
mnt_instances
链入</panel_attributes>
    <additional_attributes>210.0;90.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>559</x>
      <y>443</y>
      <w>25</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_parent
安装的节点的安装点</panel_attributes>
    <additional_attributes>10.0;120.0;230.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>582</x>
      <y>442</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfsmount
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>587</x>
      <y>445</y>
      <w>8</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_root</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>559</x>
      <y>440</y>
      <w>31</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_mounts
链接所有安装在这个设备上的安装点</panel_attributes>
    <additional_attributes>290.0;20.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>548</x>
      <y>441</y>
      <w>19</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过mnt_child链入</panel_attributes>
    <additional_attributes>100.0;140.0;10.0;10.0;120.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>589</x>
      <y>428</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfsmntlist
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>592</x>
      <y>431</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
系统中所有安装点的链表</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>594</x>
      <y>442</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=&lt;.&gt;
通过mnt_list链入</panel_attributes>
    <additional_attributes>10.0;20.0;160.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>563</x>
      <y>445</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=&lt;.&gt;
通过mnt_list链入</panel_attributes>
    <additional_attributes>10.0;100.0;200.0;70.0;230.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>610</x>
      <y>442</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfsmount
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>592</x>
      <y>435</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=&lt;.&gt;
通过mnt_list链入</panel_attributes>
    <additional_attributes>250.0;70.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>590</x>
      <y>445</y>
      <w>28</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_root</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>511</x>
      <y>481</y>
      <w>105</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1030.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>595</x>
      <y>495</y>
      <w>49</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>filter:
1.nd.mnt &amp;&amp; nd.mnt-&gt;mnt_sb == sb
   &amp;&amp; nd.mnt-&gt;mnt_root == nd.dentry
   同一设备不能安装到同一个安装点
2.nd.dentry-&gt;d_inode
 	安装目录的inode要存在

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>511</x>
      <y>481</y>
      <w>175</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
nd.dentry-&gt;d_inode.i_flags中S_DEAD没置上</panel_attributes>
    <additional_attributes>10.0;10.0;1730.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>676</x>
      <y>493</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_vfsmnt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>630</x>
      <y>496</y>
      <w>53</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请mnt,并将内存清0</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>626</x>
      <y>510</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc
memset
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>644</x>
      <y>510</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mnt-&gt;mnt_flags = MNT_VISIBLE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>654</x>
      <y>496</y>
      <w>29</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
nd || dev_name</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>678</x>
      <y>496</y>
      <w>10</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dev_name</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>670</x>
      <y>510</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>kmalloc
strcpy(name, dev_name);
mnt-&gt;mnt_devname = name;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>693</x>
      <y>510</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>mnt-&gt;mnt_owner = current-&gt;uid;
atomic_set(&amp;mnt-&gt;mnt_count,1);
mnt-&gt;mnt_sb = sb;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>680</x>
      <y>496</y>
      <w>26</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>681</x>
      <y>496</y>
      <w>44</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>719</x>
      <y>509</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>nd &amp;&amp; 
 //dentry不是root
!IS_ROOT(nd-&gt;dentry) 
 //dentry没装入hash
&amp;&amp; d_unhashed(nd-&gt;dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>741</x>
      <y>511</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>mnt-&gt;mnt_root = dget(root);
 //nd为空表示mount_root kern_mount
mnt-&gt;mnt_mountpoint = nd ? dget(nd-&gt;dentry) : dget(root);
mnt-&gt;mnt_parent = nd ? mntget(nd-&gt;mnt) : mnt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>681</x>
      <y>496</y>
      <w>72</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;700.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>780</x>
      <y>509</y>
      <w>33</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>if (nd) {
list_add(&amp;mnt-&gt;mnt_child, &amp;nd-&gt;mnt-&gt;mnt_mounts);
	list_add(&amp;mnt-&gt;mnt_clash, &amp;nd-&gt;dentry-&gt;d_vfsmnt);
} else {
	INIT_LIST_HEAD(&amp;mnt-&gt;mnt_child);
	INIT_LIST_HEAD(&amp;mnt-&gt;mnt_clash);
}
INIT_LIST_HEAD(&amp;mnt-&gt;mnt_mounts);
list_add(&amp;mnt-&gt;mnt_instances, &amp;sb-&gt;s_mounts);
list_add(&amp;mnt-&gt;mnt_list, vfsmntlist.prev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>682</x>
      <y>496</y>
      <w>109</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1070.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>335</x>
      <y>506</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>!old_name || !*old_name
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>342</x>
      <y>500</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设备dev_name不为空</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>354</x>
      <y>506</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init
path_walk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>357</x>
      <y>500</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
寻找设备的dentry</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>366</x>
      <y>506</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init
path_walk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>367</x>
      <y>500</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
寻找安装目录的dentry</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>367</x>
      <y>500</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>378</x>
      <y>503</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.检查进程和安装目录的权限
	mount_is_safe
2.S_ISDIR(new_nd.dentry-&gt;d_inode-&gt;i_mode) !=
	      S_ISDIR(old_nd.dentry-&gt;d_inode-&gt;i_mode)
3.如果安装设备的file_system的fs_flags中FS_SINGLE
  增加file_system的计数
4.new_nd.dentry-&gt;d_inode的i_flags中S_DEAD没置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>414</x>
      <y>503</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_vfsmnt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>369</x>
      <y>500</y>
      <w>53</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里传参，相当于将sb再次安装到其他的安装点
理解：这里只是将格式化好的sb和root传给要安装的目录</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>792</x>
      <y>580</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_read_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>729</x>
      <y>570</y>
      <w>71</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_fs_type
因为只有在有sb的时候
才能有ext2_sops，所以
现在只能通过文件系统的方法
将sb读进来</panel_attributes>
    <additional_attributes>10.0;10.0;690.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>711</x>
      <y>592</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_hardblocksize</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>716</x>
      <y>583</y>
      <w>84</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从hardsect_size中获取
最小为BLOCK_SIZE</panel_attributes>
    <additional_attributes>820.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>726</x>
      <y>593</y>
      <w>22</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>sb-&gt;u.ext2_sb.s_mount_opt = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>736</x>
      <y>583</y>
      <w>64</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>749</x>
      <y>592</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>parse_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>754</x>
      <y>583</y>
      <w>46</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>763</x>
      <y>592</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_blocksize</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>768</x>
      <y>583</y>
      <w>32</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>780</x>
      <y>583</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果blocksize大于BLOCK_SIZE</panel_attributes>
    <additional_attributes>180.0;10.0;30.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>778</x>
      <y>592</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //超级块物理上在sb_block*BLOCK_SIZE的位置
logic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;
offset = (sb_block*BLOCK_SIZE) % blocksize;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>818</x>
      <y>593</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>797</x>
      <y>583</y>
      <w>30</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>797</x>
      <y>583</y>
      <w>44</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>833</x>
      <y>592</y>
      <w>40</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>es=(char *)bh-&gt;b_data + offset
sb-&gt;u.ext2_sb.s_es = es
sb-&gt;s_magic = le16_to_cpu(es-&gt;s_magic)
  //check
1.check magic EXT2_SUPER_MAGIC
2.le32_to_cpu(es-&gt;s_rev_level) == EXT2_GOOD_OLD_REV
 &amp;&amp;(COMPAT  ||  RO_COMPAT  || INCOMPAT)
3.INCOMPAT没有INCOMPAT_SUPP位
4.sb-&gt;s_flags不是MS_RDONLY
	但是RO_COMPAT没置

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>876</x>
      <y>593</y>
      <w>40</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_blocksize_bits =
	le32_to_cpu(EXT2_SB(sb)-&gt;s_es-&gt;s_log_block_size) + 10;
sb-&gt;s_blocksize = 1 &lt;&lt; sb-&gt;s_blocksize_bits
 //在不等于BLOCK_SIZE，但是是1k，2k，4k的时候
1.s_blocksize要大于get_hardblocksize
2.将s_blocksize保存在logic_sb_block
3.通过bread在读一整个大小为s_blocksize的记录块
注：ext2在sb_block*BLOCK_SIZE总是是超级块
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>923</x>
      <y>594</y>
      <w>63</w>
      <h>95</h>
    </coordinates>
    <panel_attributes>sb-&gt;u.ext2_sb.s_inode_size
sb-&gt;u.ext2_sb.s_first_ino
sb-&gt;u.ext2_sb.s_frag_size=EXT2_MIN_FRAG_SIZE &lt;&lt;
				   le32_to_cpu(es-&gt;s_log_frag_size)
sb-&gt;u.ext2_sb.s_frags_per_block
sb-&gt;s_magic
 //这个block的数量包含inode/描述结构/管理结构/超级块的block
sb-&gt;u.ext2_sb.s_blocks_per_group = le32_to_cpu(es-&gt;s_blocks_per_group);
sb-&gt;u.ext2_sb.s_frags_per_group = le32_to_cpu(es-&gt;s_frags_per_group);
sb-&gt;u.ext2_sb.s_inodes_per_group = le32_to_cpu(es-&gt;s_inodes_per_group);
sb-&gt;u.ext2_sb.s_inodes_per_block = sb-&gt;s_blocksize /
				   EXT2_INODE_SIZE(sb);
sb-&gt;u.ext2_sb.s_itb_per_group = sb-&gt;u.ext2_sb.s_inodes_per_group /
			        sb-&gt;u.ext2_sb.s_inodes_per_block;
sb-&gt;u.ext2_sb.s_desc_per_block = sb-&gt;s_blocksize /
				 sizeof (struct ext2_group_desc);
sb-&gt;u.ext2_sb.s_sbh = bh;
sb-&gt;u.ext2_sb.s_resuid
sb-&gt;u.ext2_sb.s_resgid
sb-&gt;u.ext2_sb.s_mount_state = le16_to_cpu(es-&gt;s_state);
 //log2是第一个1所在位的索引 bsfl op1 op2， 计算op1中第一个1，索引放在op2中
sb-&gt;u.ext2_sb.s_addr_per_block_bits =
	log2 (EXT2_ADDR_PER_BLOCK(sb));
sb-&gt;u.ext2_sb.s_desc_per_block_bits =
	log2 (EXT2_DESC_PER_BLOCK(sb));
	//check
1.sb-&gt;s_magic = EXT2_SUPER_MAGIC
2.sb-&gt;s_blocksize = bh-&gt;b_size
3.sb-&gt;s_blocksize = sb-&gt;u.ext2_sb.s_frag_size
4.不能有超过一个记录块记录block的数量
 sb-&gt;u.ext2_sb.s_blocks_per_group &gt; sb-&gt;s_blocksize * 8
5.sb-&gt;u.ext2_sb.s_frags_per_group &gt; sb-&gt;s_blocksize * 8
6.不能超过一个记录块记录inoe
	sb-&gt;u.ext2_sb.s_inodes_per_group &gt; sb-&gt;s_blocksize * 8

 //一个desc描述一个组，前面检查过blocksize和bh的b_size相同
sb-&gt;u.ext2_sb.s_groups_count = (le32_to_cpu(es-&gt;s_blocks_count) -
			        le32_to_cpu(es-&gt;s_first_data_block) +
			       EXT2_BLOCKS_PER_GROUP(sb) - 1) /
			       EXT2_BLOCKS_PER_GROUP(sb);
db_count = (sb-&gt;u.ext2_sb.s_groups_count + EXT2_DESC_PER_BLOCK(sb) - 1) /
	   EXT2_DESC_PER_BLOCK(sb);
sb-&gt;u.ext2_sb.s_group_desc = kmalloc (db_count * sizeof (struct buffer_head *), GFP_KERNEL);
 //填充group信息
sb-&gt;u.ext2_sb.s_group_desc[i] = bread (dev, logic_sb_block + i + 1,
					       sb-&gt;s_blocksize);
 //检查每个group的bg_block_bitmap  bg_block_bitmap   	bg_inode_table是否在合适的块
ext2_check_descriptors
 //先初始化8个bitmap和块号
sb-&gt;u.ext2_sb.s_inode_bitmap_number[i] = 0;
sb-&gt;u.ext2_sb.s_inode_bitmap[i] = NULL;
sb-&gt;u.ext2_sb.s_block_bitmap_number[i] = 0;
sb-&gt;u.ext2_sb.s_block_bitmap[i] = NULL;

sb-&gt;u.ext2_sb.s_loaded_inode_bitmaps = 0;
sb-&gt;u.ext2_sb.s_loaded_block_bitmaps = 0;
 //所有desc占的所有block总数
sb-&gt;u.ext2_sb.s_gdb_count = db_count;
sb-&gt;s_op = &amp;ext2_sops;
sb-&gt;s_root = d_alloc_root(iget(sb, EXT2_ROOT_INO));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>798</x>
      <y>583</y>
      <w>95</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;930.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>799</x>
      <y>583</y>
      <w>137</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1350.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1002</x>
      <y>595</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_alloc_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>798</x>
      <y>583</y>
      <w>213</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sb-&gt;s_root
为根目录inode建立dentry
iget(sb, EXT2_ROOT_INO)</panel_attributes>
    <additional_attributes>10.0;10.0;2110.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>987</x>
      <y>603</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>991</x>
      <y>598</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请并初始化dentry
{ "/", 1, 0 }</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1003</x>
      <y>602</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>res-&gt;d_sb = root_inode-&gt;i_sb;
res-&gt;d_parent = res;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1007</x>
      <y>598</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1029</x>
      <y>602</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_instantiate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1007</x>
      <y>598</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1017</x>
      <y>609</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //dentry连接到inode中
list_add(&amp;entry-&gt;d_alias, &amp;inode-&gt;i_dentry)
entry-&gt;d_inode = inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1031</x>
      <y>605</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1051</x>
      <y>595</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_setup_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1047</x>
      <y>604</y>
      <w>52</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>es-&gt;s_state = cpu_to_le16(le16_to_cpu(es-&gt;s_state) &amp; ~EXT2_VALID_FS);
if (!(__s16) le16_to_cpu(es-&gt;s_max_mnt_count))
	es-&gt;s_max_mnt_count = (__s16) cpu_to_le16(EXT2_DFL_MAX_MNT_COUNT);
es-&gt;s_mnt_count=cpu_to_le16(le16_to_cpu(es-&gt;s_mnt_count) + 1);
es-&gt;s_mtime = cpu_to_le32(CURRENT_TIME);
mark_buffer_dirty(sb-&gt;u.ext2_sb.s_sbh);
sb-&gt;s_dirt = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1056</x>
      <y>598</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置管理信息</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>798</x>
      <y>583</y>
      <w>261</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2590.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>518</x>
      <y>527</y>
      <w>22</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>sb = fs_type-&gt;kern_mnt-&gt;mnt_sb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>528</x>
      <y>522</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取init_proc_fs设置的sb</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>542</x>
      <y>526</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_filesystem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>540</x>
      <y>522</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加file_system计数</panel_attributes>
    <additional_attributes>50.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>560</x>
      <y>526</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_remount_sb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>544</x>
      <y>522</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>530</x>
      <y>534</y>
      <w>43</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果要以MS_RDONLY安装，sb-&gt;s_dev要是read_only
	(procfs是NULL,这个检测不存在)
2.如果以MS_RDONLY安装，但是sb却不是read_only的，此时需要
	检测sb中的所有文件，查看inode是否只读，如果不是，返回-EBUSY

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>550</x>
      <y>529</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>575</x>
      <y>536</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;remount_fs
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>565</x>
      <y>529</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sb-&gt;s_op-&gt;remount_fs存在</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>595</x>
      <y>535</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_flags = 
(sb-&gt;s_flags &amp; ~MS_RMT_MASK) | 
(flags &amp; MS_RMT_MASK)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>566</x>
      <y>529</y>
      <w>40</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果flag中MS_RMT_MASK置上，
就将sb-&gt;s_flags置上
否则将其清掉</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1142</x>
      <y>490</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_umount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1069</x>
      <y>511</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1074</x>
      <y>493</y>
      <w>76</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>740.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1086</x>
      <y>512</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1090</x>
      <y>493</y>
      <w>60</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
LOOKUP_POSITIVE|LOOKUP_FOLLOW</panel_attributes>
    <additional_attributes>580.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1105</x>
      <y>512</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1109</x>
      <y>493</y>
      <w>41</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1122</x>
      <y>512</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>putname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1126</x>
      <y>493</y>
      <w>24</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
已经得到了nd
将name释放</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1136</x>
      <y>510</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>filter
1.要释放的目录必须是设备的根目录
	nd.dentry != nd.mnt-&gt;mnt_root时报错
2.检查进程卸载的权限
 !capable(CAP_SYS_ADMIN)
 &amp;&amp; current-&gt;uid!=nd.mnt-&gt;mnt_owner
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1147</x>
      <y>493</y>
      <w>6</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1166</x>
      <y>511</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput(nd.dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1145</x>
      <y>493</y>
      <w>29</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放文件的根目录
atomic_dec_and_lock只有counter为0的时候
返回true</panel_attributes>
    <additional_attributes>30.0;10.0;250.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1181</x>
      <y>510</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_umount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1147</x>
      <y>493</y>
      <w>42</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放nd.mnt</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;170.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1149</x>
      <y>513</y>
      <w>40</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt == current-&gt;fs-&gt;rootmnt &amp;&amp; 
!umount_root
如果用户进程要删除进程的跟设备，那就把跟设备设置为只读</panel_attributes>
    <additional_attributes>380.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1138</x>
      <y>524</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1134</x>
      <y>529</y>
      <w>11</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mntput(mnt)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1148</x>
      <y>529</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_remount_sb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1149</x>
      <y>524</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果sb-&gt;s_flags &amp; MS_RDONLY没置上
那么将sb进行只读安装</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1186</x>
      <y>513</y>
      <w>37</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果sb上安装在多个vfsmnt
mnt-&gt;mnt_instances.next != mnt-&gt;mnt_instances.prev</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1161</x>
      <y>527</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
atomic_read(&amp;mnt-&gt;mnt_count) &gt; 2
nd中一次，vfsmnt自身一次
这里大于2次，说明有其他地方引用这个vfsmnt</panel_attributes>
    <additional_attributes>280.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1159</x>
      <y>533</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //释放nd中的一次
mntput(mnt)
return -EBUSY
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1182</x>
      <y>527</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sb-&gt;s_type-&gt;fs_flags &amp; FS_SINGLE
文件系统只有一个超级块</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1175</x>
      <y>535</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes> //释放文件系统的引用
put_filesystem(sb-&gt;s_type)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1188</x>
      <y>527</y>
      <w>17</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放其中一个（nd的）</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1197</x>
      <y>535</y>
      <w>11</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mntput(mnt)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1210</x>
      <y>534</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_vfsmnt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1188</x>
      <y>527</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1205</x>
      <y>541</y>
      <w>23</w>
      <h>25</h>
    </coordinates>
    <panel_attributes> //mnt脱离sb链表
list_del(&amp;mnt-&gt;mnt_instances);
 //脱离dentry链表
list_del(&amp;mnt-&gt;mnt_clash);
	//脱离mnt总的链表
list_del(&amp;mnt-&gt;mnt_list);
 //解除和parent的关系
list_del(&amp;mnt-&gt;mnt_child);
if (mnt-&gt;mnt_parent != mnt)
	mntput(mnt-&gt;mnt_parent);
dput(mnt-&gt;mnt_mountpoint);
dput(mnt-&gt;mnt_root);
if (mnt-&gt;mnt_devname)
	kfree(mnt-&gt;mnt_devname);
kfree(mnt);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1214</x>
      <y>537</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1186</x>
      <y>513</y>
      <w>70</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果sb上只安装在一个vfsmnt</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1230</x>
      <y>525</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
磁盘空间分配</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1224</x>
      <y>533</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>DQUOT_OFF(sb);
acct_auto_close(sb-&gt;s_dev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1245</x>
      <y>534</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;umount_begin(sb)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1253</x>
      <y>525</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(flags&amp;MNT_FORCE) &amp;&amp; sb-&gt;s_op-&gt;umount_begin
有些设备要求拆卸之前先执行这个函数</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1273</x>
      <y>534</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shrink_dcache_sb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1253</x>
      <y>525</y>
      <w>29</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1262</x>
      <y>537</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1239</x>
      <y>541</y>
      <w>47</w>
      <h>55</h>
    </coordinates>
    <panel_attributes>1.遍历dentry_unused，如果dentry.d_sb和要卸载的sb相同
	就先通过list_del删除其当前的链接关系，再通过list_add
	将这个dentry头插到dentry_unused（注意这里因为时头插
	所以不会无限循环）
	如果sb不相同，就遍历下一个
2.再次遍历dentry_unused，将d_sb相同，d_count为0的删掉
	dentry_stat.nr_unused--;
	list_del(tmp);
	INIT_LIST_HEAD(tmp);
	prune_one_dentry：真正释放

	
		list_del_init(&amp;dentry-&gt;d_hash);
		list_del(&amp;dentry-&gt;d_child);
		dentry_iput(dentry);//释放inode
		parent = dentry-&gt;d_parent;

		
		d_free(dentry)：
			if (dentry-&gt;d_op &amp;&amp; dentry-&gt;d_op-&gt;d_release)
				dentry-&gt;d_op-&gt;d_release(dentry);
			if (dname_external(dentry)) 
				kfree(dentry-&gt;d_name.name);
			kmem_cache_free(dentry_cache, dentry); 
			dentry_stat.nr_dentry--;

			
		if (parent != dentry)
			dput(parent);
疑问：这里虽然将要删除的dentry都移到了最前面，在second pass
的时候只需要遍历一次(我感觉不repreat也是可以的？)，但是first_pass
和second_pass也是要遍历2次，为什么不在first_pass的时候将dentry删了？
这里又是spinlock，不会被打断。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1318</x>
      <y>534</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fsync_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1186</x>
      <y>513</y>
      <w>141</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1390.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1297</x>
      <y>542</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1302</x>
      <y>537</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dev,0</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1317</x>
      <y>543</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_supers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1321</x>
      <y>537</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1339</x>
      <y>544</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_inodes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1364</x>
      <y>544</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DQUOT_SYNC</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1385</x>
      <y>544</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1322</x>
      <y>537</y>
      <w>69</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dev,1</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1322</x>
      <y>537</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1322</x>
      <y>537</y>
      <w>49</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1299</x>
      <y>551</y>
      <w>41</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.遍历super_blocks
2，筛选出sb-&gt;s_dev不为0，dev存在 &amp;&amp; sb-&gt;s_dev == dev，
	sb-&gt;s_dirt（sb是脏的）的sb
3.筛选出之后lock_super,因为在lock的时候可能睡着，所以再次
  检测上面的条件，如果提供了write_super的函数通过
  sb-&gt;s_op-&gt;write_super(sb)，然后unlock_super.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1315</x>
      <y>546</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1341</x>
      <y>551</y>
      <w>41</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历super_blocks
2，筛选出sb-&gt;s_dev不为0，dev存在 &amp;&amp; sb-&gt;s_dev == dev，
	的sb
3.通过sync_list去同步sb中s_dirty管理的inode
	sync_list通过sync_one去处理s_dirty中的每一个inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1340</x>
      <y>547</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里只是设标志，并没向磁盘写
因为sync_one中syn的传参是0</panel_attributes>
    <additional_attributes>40.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1358</x>
      <y>564</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_one</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1362</x>
      <y>560</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1346</x>
      <y>567</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
i_state &amp; I_LOCK
如果inode正在向磁盘写</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1302</x>
      <y>571</y>
      <w>47</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1297</x>
      <y>577</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__iget
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1316</x>
      <y>577</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__wait_on_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1323</x>
      <y>571</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
等待向磁盘写完</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1287</x>
      <y>585</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DECLARE_WAITQUEUE(wait, current)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1299</x>
      <y>580</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申明wait
将其中的唤醒进程设置为current</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1317</x>
      <y>585</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_wait_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1322</x>
      <y>580</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将wait加在inode-&gt;i_wait</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1291</x>
      <y>593</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait-&gt;flags = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1296</x>
      <y>588</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1312</x>
      <y>593</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__add_wait_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1316</x>
      <y>588</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将task_list链表连接</panel_attributes>
    <additional_attributes>80.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1334</x>
      <y>585</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>repeat：
TASK_UNINTERRUPTIBLE
if (inode-&gt;i_state &amp; I_LOCK) {
	schedule();
	goto repeat;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1323</x>
      <y>580</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查锁</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1358</x>
      <y>586</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_wait_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1323</x>
      <y>580</y>
      <w>44</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1358</x>
      <y>592</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__remove_wait_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1365</x>
      <y>589</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将task_list解开</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1374</x>
      <y>586</y>
      <w>14</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>TASK_RUNNING
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1323</x>
      <y>580</y>
      <w>61</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为repeat的时候将task的状态设置成
TASK_UNINTERRUPTIBLE</panel_attributes>
    <additional_attributes>10.0;10.0;590.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1405</x>
      <y>581</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iput
猜想：
1.如果count有计数，则放在inode_in_use中
2.如果count=0，则放在inode_unused中
3.以上两种情况都是!dirty，如果dirty
	则不管count，直接放在s_dirty中
3.i_nlink表示物理上有多少个链接，在文件
	刚创建的时候，i_nlink为1，其后创建链接
	会增加计数，如果这个链接为0，表示要在物理硬盘上
	将这个inode删除，通过clear_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1346</x>
      <y>571</y>
      <w>66</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;640.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1383</x>
      <y>584</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode-&gt;i_sb-&gt;s_op
如果sb规定了put_inode
先通过sb的函数处理</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1378</x>
      <y>591</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>op-&gt;put_inode(inode)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1400</x>
      <y>591</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>atomic_dec_and_lock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1408</x>
      <y>584</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将wait加在inode-&gt;i_wait</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1410</x>
      <y>584</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1417</x>
      <y>590</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!i_nlink
猜想：没有符号链接的时候</panel_attributes>
    <additional_attributes>120.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1389</x>
      <y>596</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1378</x>
      <y>600</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>list_del(&amp;inode-&gt;i_hash);
INIT_LIST_HEAD(&amp;inode-&gt;i_hash);
list_del(&amp;inode-&gt;i_list);
INIT_LIST_HEAD(&amp;inode-&gt;i_list);
inode-&gt;i_state|=I_FREEING;
inodes_stat.nr_inodes--;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1410</x>
      <y>596</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode-&gt;i_data.nrpages</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1403</x>
      <y>601</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>truncate_inode_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1422</x>
      <y>596</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1415</x>
      <y>601</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果sb提供了
op-&gt;delete_inode</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1407</x>
      <y>606</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>op-&gt;delete_inode(inode)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1427</x>
      <y>601</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;58.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1428</x>
      <y>606</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>clear_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1428</x>
      <y>590</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
i_nlink不为0
有符号链接？</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1437</x>
      <y>595</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果inode连在hash中</panel_attributes>
    <additional_attributes>100.0;10.0;48.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1437</x>
      <y>604</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>list_del(&amp;inode-&gt;i_list);
list_add(&amp;inode-&gt;i_list,
	 &amp;inode_unused);
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1441</x>
      <y>599</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果inode没脏
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1457</x>
      <y>605</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inodes_stat.nr_unused++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1441</x>
      <y>599</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;218.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1446</x>
      <y>595</y>
      <w>42</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没连在hash中
将inode清掉</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1477</x>
      <y>602</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>list_del(&amp;inode-&gt;i_list);
INIT_LIST_HEAD(&amp;inode-&gt;i_list);
inode-&gt;i_state|=I_FREEING;
inodes_stat.nr_inodes--;
clear_inode(inode)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1362</x>
      <y>567</y>
      <w>108</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果inode没有在向磁盘写</panel_attributes>
    <additional_attributes>10.0;10.0;1060.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1449</x>
      <y>570</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1431</x>
      <y>573</y>
      <w>37</w>
      <h>18</h>
    </coordinates>
    <panel_attributes> //从s_dirty中删除，加到其他两个链表中
list_del(&amp;inode-&gt;i_list);
list_add(&amp;inode-&gt;i_list, atomic_read(&amp;inode-&gt;i_count)
					? &amp;inode_in_use
					: &amp;inode_unused);
 //将dirty标志提取
dirty = inode-&gt;i_state &amp; I_DIRTY;
 //将inode上锁，表示要想磁盘写
inode-&gt;i_state |= I_LOCK;
 //将dirty清掉
inode-&gt;i_state &amp;= ~I_DIRTY;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1472</x>
      <y>576</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filemap_fdatasync</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1467</x>
      <y>570</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1491</x>
      <y>576</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>write_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1467</x>
      <y>570</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1508</x>
      <y>576</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filemap_fdatawait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1524</x>
      <y>576</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_state &amp;= ~I_LOCK;
wake_up(&amp;inode-&gt;i_wait)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1467</x>
      <y>570</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1467</x>
      <y>570</y>
      <w>65</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;630.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1503</x>
      <y>584</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_write_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1496</x>
      <y>579</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1516</x>
      <y>594</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_update_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1510</x>
      <y>587</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1500</x>
      <y>604</y>
      <w>46</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.检查i_ino
2.三段；group_desc  desc  offset
	每个inode都分组成为一个desc，而desc作为一个数据结构存在磁盘中
	首先通过group_desc找到存储当前inode 的desc的bh，再通过desc找到
	相应的desc结构，最后通过desc中的基础block bg_inode_table和offset
	找到inode对应的block
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1515</x>
      <y>597</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1555</x>
      <y>605</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1523</x>
      <y>597</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1570</x>
      <y>609</y>
      <w>42</w>
      <h>48</h>
    </coordinates>
    <panel_attributes>raw_inode-&gt;i_mode = cpu_to_le16(inode-&gt;i_mode);
raw_inode-&gt;i_uid_low 
raw_inode-&gt;i_gid_low
raw_inode-&gt;i_uid_high 
raw_inode-&gt;i_gid_high
raw_inode-&gt;i_links_count = cpu_to_le16(inode-&gt;i_nlink);
raw_inode-&gt;i_size = cpu_to_le32(inode-&gt;i_size);
raw_inode-&gt;i_atime = cpu_to_le32(inode-&gt;i_atime);
raw_inode-&gt;i_ctime = cpu_to_le32(inode-&gt;i_ctime);
raw_inode-&gt;i_mtime = cpu_to_le32(inode-&gt;i_mtime);
raw_inode-&gt;i_blocks = cpu_to_le32(inode-&gt;i_blocks);
raw_inode-&gt;i_dtime = cpu_to_le32(inode-&gt;u.ext2_i.i_dtime);
raw_inode-&gt;i_flags = cpu_to_le32(inode-&gt;u.ext2_i.i_flags);
raw_inode-&gt;i_faddr = cpu_to_le32(inode-&gt;u.ext2_i.i_faddr);
raw_inode-&gt;i_frag = inode-&gt;u.ext2_i.i_frag_no;
raw_inode-&gt;i_fsize = inode-&gt;u.ext2_i.i_frag_size;
raw_inode-&gt;i_file_acl = cpu_to_le32(inode-&gt;u.ext2_i.i_file_acl);
if (S_ISDIR(inode-&gt;i_mode))
	raw_inode-&gt;i_dir_acl = cpu_to_le32(inode-&gt;u.ext2_i.i_dir_acl);
else {
	raw_inode-&gt;i_size_high = cpu_to_le32(inode-&gt;i_size &gt;&gt; 32);
...
	}
raw_inode-&gt;i_generation = cpu_to_le32(inode-&gt;i_generation);
if (S_ISCHR(inode-&gt;i_mode) || S_ISBLK(inode-&gt;i_mode))
	raw_inode-&gt;i_block[0] = cpu_to_le32(kdev_t_to_nr(inode-&gt;i_rdev));
else for (block = 0; block &lt; EXT2_N_BLOCKS; block++)
	raw_inode-&gt;i_block[block] = inode-&gt;u.ext2_i.i_data[block];
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1619</x>
      <y>606</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_buffer_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1523</x>
      <y>597</y>
      <w>106</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;860.0;50.0;1040.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1523</x>
      <y>596</y>
      <w>129</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
do_sync</panel_attributes>
    <additional_attributes>10.0;20.0;1110.0;30.0;1270.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1635</x>
      <y>609</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ll_rw_block </panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1655</x>
      <y>610</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait_on_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1640</x>
      <y>604</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
WRITE</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1649</x>
      <y>604</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1523</x>
      <y>597</y>
      <w>75</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;60.0;730.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>439</x>
      <y>852</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>220</x>
      <y>889</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>224</x>
      <y>855</y>
      <w>223</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filename</panel_attributes>
    <additional_attributes>2210.0;10.0;10.0;340.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>291</x>
      <y>891</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_unused_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>295</x>
      <y>855</y>
      <w>152</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1500.0;10.0;10.0;360.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>237</x>
      <y>898</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_next_zero_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>246</x>
      <y>894</y>
      <w>53</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>226</x>
      <y>901</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 next_fd表示空置的fd最小偏移量
 (注意__put_unused_fd)
addr=open_fds
size=max_fdset
offset=next_fd</panel_attributes>
    <additional_attributes>190.0;10.0;30.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>203</x>
      <y>907</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>199</x>
      <y>912</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //所在的word
p=addr+(offset&gt;&gt;5)
 //在word中的偏移
bit = offset &amp; 31
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>215</x>
      <y>914</y>
      <w>21</w>
      <h>13</h>
    </coordinates>
    <panel_attributes> //看*p中的第一个0的索引位
"bsfl %1,%0\n\t" //低到高直到1
"jne 1f\n\t"
"movl $32, %0\n"
"1:"
: "=r" (set)
: "r" (~(*p &gt;&gt; bit)))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>226</x>
      <y>907</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果偏移不为0</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>227</x>
      <y>910</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
set &lt; (32 - bit)
32位内找到了0</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>221</x>
      <y>910</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>239</x>
      <y>915</y>
      <w>14</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>return set + offset
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>227</x>
      <y>910</y>
      <w>37</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否者推到下一个word</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>254</x>
      <y>914</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set = 32 - bit;
		p++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>267</x>
      <y>913</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_first_zero_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>228</x>
      <y>907</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>245</x>
      <y>920</y>
      <w>54</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>"movl $-1,%%eax\n\t"//0xffffffff
"xorl %%edx,%%edx\n\t"
 //edi和eax比较（ecx计数），相等继续（repe，如果是repne，就是不相等继续）
"repe; scasl\n\t" 
"je 1f\n\t"
 //这里异或，（edi-4）中为0的会置为1
"xorl -4(%%edi),%%eax\n\t"
"subl $4,%%edi\n\t"
 //找出eax中第一个1，即（edi）中第一个0
"bsfl %%eax,%%edx\n"
 //偏移量 edi=edi-ebx 如果ecx减到0，此时的偏移量大于size
"1:\tsubl %%ebx,%%edi\n\t"
 //算出字节的偏移量，左移（shr右移）
"shll $3,%%edi\n\t"
 //算出总的偏移量
"addl %%edi,%%edx"
:"=d" (res), "=&amp;c" (d0), "=&amp;D" (d1), "=&amp;a" (d2)
:"1" ((size + 31) &gt;&gt; 5), "2" (addr), "b" (addr))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>270</x>
      <y>916</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>264</x>
      <y>894</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fd&gt;rlim[RLIMIT_NOFILE]
如果文件打开的数量超出了进程的限制</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>261</x>
      <y>904</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>277</x>
      <y>907</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expand_fdset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>279</x>
      <y>894</y>
      <w>20</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fd &gt;= files-&gt;max_fdset
扩展fd位图</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>290</x>
      <y>908</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expand_fdset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>296</x>
      <y>894</y>
      <w>15</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fd &gt;= files-&gt;max_fds
扩展file数组</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>306</x>
      <y>906</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>FD_SET(fd, files-&gt;open_fds);（btsl将偏移值设置为1，将原来的值存在CF）
FD_CLR(fd, files-&gt;close_on_exec);（btrl将偏移值设置为0，将原来的值存在CF）
files-&gt;next_fd = fd + 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>297</x>
      <y>894</y>
      <w>17</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>333</x>
      <y>907</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>files-&gt;fd[fd] == NULL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>297</x>
      <y>894</y>
      <w>44</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fd对应的file要NULL</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>445</x>
      <y>864</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>444</x>
      <y>855</y>
      <w>9</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1240</x>
      <y>885</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fd_install</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>444</x>
      <y>855</y>
      <w>804</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;8020.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1240</x>
      <y>892</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>files-&gt;fd[fd] = file
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1246</x>
      <y>888</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>444</x>
      <y>855</y>
      <w>821</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;8190.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1258</x>
      <y>885</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1256</x>
      <y>892</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>putname(tmp)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1262</x>
      <y>888</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1270</x>
      <y>885</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out_error
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>444</x>
      <y>855</y>
      <w>832</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;8300.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1270</x>
      <y>891</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_unused_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1274</x>
      <y>888</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1270</x>
      <y>897</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__put_unused_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1275</x>
      <y>894</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1268</x>
      <y>903</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>FD_CLR(fd, files-&gt;open_fds);
 //从这里看出，next_fd存储的
 //最小空闲的fd的偏移量
if (fd &lt; files-&gt;next_fd)
	files-&gt;next_fd = fd;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1275</x>
      <y>900</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>330</x>
      <y>891</y>
      <w>34</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //当flag的低两位是11时，flag没有++，所以还是11
if ((namei_flags+1) &amp; O_ACCMODE)
		namei_flags++;
 //空白打开，增加写权限
if (namei_flags &amp; O_TRUNC)
	namei_flags |= 2;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>340</x>
      <y>867</y>
      <w>112</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
open的权限转化成open_namei权限</panel_attributes>
    <additional_attributes>1100.0;10.0;10.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>390</x>
      <y>899</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>open_namei</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>394</x>
      <y>867</y>
      <w>58</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到文件的dentry</panel_attributes>
    <additional_attributes>560.0;10.0;10.0;320.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>343</x>
      <y>902</y>
      <w>53</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!(flag &amp; O_CREAT)
找不到文件不创建文件</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>335</x>
      <y>941</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>329</x>
      <y>944</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_flags</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>344</x>
      <y>944</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>359</x>
      <y>944</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>343</x>
      <y>941</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>343</x>
      <y>941</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>309</x>
      <y>950</y>
      <w>49</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.默认打开置上LOOKUP_FOLLOW (遇到link，继续向下找到真实文件)
2.O_NOFOLLOW 或者 O_CREAT|O_EXCL置上时，LOOKUP_FOLLOW取消
3.O_DIRECTORY时 LOOKUP_DIRECTORY（如果inode没有op则会报错）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>331</x>
      <y>947</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>394</x>
      <y>902</y>
      <w>21</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flag &amp; O_CREAT</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;370.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>373</x>
      <y>944</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>387</x>
      <y>944</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>378</x>
      <y>938</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
LOOKUP_PARENT表示只找到父节点
但是nd.last是指向最后一个节点的</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>392</x>
      <y>938</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>401</x>
      <y>944</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //不能是.或者..
nd-&gt;last_type != LAST_NORM 
 //字符串最后一个字符是'\0'
 //不能是'\'
|| nd-&gt;last.name[nd-&gt;last.len]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>409</x>
      <y>938</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为O_CREAT
所以最后一个节点不能是目录
目录要通过mkdir创建</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>431</x>
      <y>945</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>408</x>
      <y>938</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在dir中查找nd.last</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>361</x>
      <y>959</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode = base-&gt;d_inode;
err = permission(inode, MAY_EXEC)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>372</x>
      <y>948</y>
      <w>66</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>640.0;10.0;310.0;90.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>390</x>
      <y>961</y>
      <w>15</w>
      <h>3</h>
    </coordinates>
    <panel_attributes> base-&gt;d_op-&gt;d_hash
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>948</y>
      <w>42</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
base-&gt;d_op &amp;&amp; base-&gt;d_op-&gt;d_hash</panel_attributes>
    <additional_attributes>400.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>406</x>
      <y>960</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cached_lookup
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>411</x>
      <y>948</y>
      <w>27</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在dentry_hashtable中查找</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>434</x>
      <y>948</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!dentry
如果在hash中没找到dentry</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>420</x>
      <y>960</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_alloc
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>424</x>
      <y>953</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
先alloc
是因为alloc可能睡</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>434</x>
      <y>961</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op-&gt;lookup
（reference）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>434</x>
      <y>953</y>
      <w>9</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>434</x>
      <y>953</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2中!dentry
表示没返回错误</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>451</x>
      <y>958</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>if (!dentry)
	dentry = new;
else
	dput(new)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>462</x>
      <y>940</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!dentry-&gt;d_inode
如果磁盘上没有这个文件</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>462</x>
      <y>962</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>462</x>
      <y>943</y>
      <w>8</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>474</x>
      <y>950</y>
      <w>15</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //释放父目录
dput(nd-&gt;dentry);
 //更新为文件的dentry
nd-&gt;dentry = dentry;
acc_mode = 0;
flag &amp;= ~O_TRUNC;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>462</x>
      <y>943</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>489</x>
      <y>940</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
存在这个文件</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>943</y>
      <w>6</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>491</x>
      <y>960</y>
      <w>43</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.O_CREAT|O_EXCL 如果这两个标志置上，表示文件必须得不存在
	所以这里检查O_EXCL，如果有，则报错文件存在
2.检查是否要打开的文件是否挂载设备 d_mountpoint
	如果挂载了，但是O_NOFOLLOW置上，则报错，
	如果O_NOFOLLOW没置上，则一直__follow_down到最后的文件
3.如果!dentry-&gt;d_inode，表示文件指向的最终文件不存在，
	返回错误
4.如果当前文件时符号链接（i_op-&gt;follow_link存在），去do_link

 //中间将dentry替换成寻找的文件
dput(nd-&gt;dentry);
nd-&gt;dentry = dentry;

5.dentry-&gt;d_inode &amp;&amp; S_ISDIR open不能打开目录
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>943</y>
      <w>94</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;480.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>597</x>
      <y>991</y>
      <w>3</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>ok
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>943</y>
      <w>275</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2730.0;540.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>777</x>
      <y>997</y>
      <w>7</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>do_link
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>760</x>
      <y>999</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
O_NOFOLLOW</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>757</x>
      <y>1008</y>
      <w>7</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>-ELOOP
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>768</x>
      <y>1007</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>UPDATE_ATIME</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>774</x>
      <y>999</y>
      <w>8</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>785</x>
      <y>1008</y>
      <w>25</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>dentry-&gt;d_inode-&gt;i_op-&gt;follow_link
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>774</x>
      <y>999</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注意这里nd中的flag还是之前path_init的
LOOKUP_PARENT</panel_attributes>
    <additional_attributes>60.0;10.0;200.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>812</x>
      <y>1008</y>
      <w>9</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>dput(dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>780</x>
      <y>999</y>
      <w>36</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>780</x>
      <y>999</y>
      <w>50</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>823</x>
      <y>1008</y>
      <w>35</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1. LAST_BIND（Procfs相关）
	dentry = nd-&gt;dentry;
	goto ok;
2.LAST_NORM ||  nd-&gt;last.name[nd-&gt;last.len]
	-EISDIR
3.counter==32
	dentry = nd-&gt;dentry;
	putname(nd-&gt;last.name);
	goto ok;
  注意：follow_link中虽然有循环的计数，
  			但是那是针对要寻找节点的，但是现在
  			要寻找的节点是 目标节点的父节点
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>485</x>
      <y>937</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_last
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>409</x>
      <y>936</y>
      <w>82</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;30.0;800.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>860</x>
      <y>1008</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //保存父目录
dir = nd-&gt;dentry;
dentry = lookup_hash(&amp;nd-&gt;last, nd-&gt;dentry);
 //找到了目标节点，释放其名称
putname(nd-&gt;last.name);
goto do_last;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>780</x>
      <y>999</y>
      <w>90</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;880.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>529</x>
      <y>1001</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.!inode 不存在inode
	-ENOENT
2.S_ISLNK 如果是符号链接
	-ELOOP
3.S_ISDIR &amp;&amp; FMODE_WRITE
  -EISDIR

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>536</x>
      <y>993</y>
      <w>64</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter
这些条件在某些情况下并没有被检查
（例如!(flag &amp; O_CREAT)）</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>316</x>
      <y>944</y>
      <w>10</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>acc_mode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>320</x>
      <y>902</y>
      <w>76</w>
      <h>44</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
"\000\004\002\006"[(x)&amp;O_ACCMODE]
注：1.ASCII中\ddd表示一个八进制的数
    2.这里字符串是一个指针，[]中时索引
    所以这里是将open_namei的权限转换成
    permission的权限</panel_attributes>
    <additional_attributes>740.0;10.0;190.0;130.0;10.0;420.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>552</x>
      <y>1003</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>permission</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>556</x>
      <y>993</y>
      <w>44</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>420.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>565</x>
      <y>1001</y>
      <w>30</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.S_ISFIFO  S_ISSOCK  S_ISBLK  S_ISCHR
	flag &amp;= ~O_TRUNC
2.IS_RDONLY &amp;&amp; (flag &amp; 2)
	是readonly安装，但是要求写 报-EROFS
3.如果sb只能添加IS_APPEND
	3.1但是 FMODE_WRITE &amp;&amp; ！O_APPEND
		要写，但是不是添加
	3.2.O_TRUNC 空白打开
	报-EPERM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>577</x>
      <y>993</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>596</x>
      <y>1002</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_lease</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>598</x>
      <y>993</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
文件“租借”相关</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>598</x>
      <y>993</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>626</x>
      <y>1001</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flag &amp; O_TRUNC</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>608</x>
      <y>1005</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>579</x>
      <y>1018</y>
      <w>30</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.检查inode-&gt;i_writecount是否小于0
	注：文件有可能通过mmap映射到内存中，
		这个时候进程访问内存和进程直接访问文件就
		需要互斥。所以就有了get_write_access和
		deny_write_access。当访问内存文件时，通过
		deny_write_access，将i_writecount置为负数
		如果此时另一个进程需要访问inode文件，需要通过
		get_write_access检查i_writecount是否小于0，
		如果小于0，则返回-ETXTBSY
2.增加inode-&gt;i_writecount的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>604</x>
      <y>1009</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_write_access</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>593</x>
      <y>1012</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>635</x>
      <y>1008</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_verify_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>626</x>
      <y>1005</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>629</x>
      <y>1011</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查强制锁</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>622</x>
      <y>1015</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>MANDATORY_LOCK</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>610</x>
      <y>1023</y>
      <w>48</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.检查sb中的s_flags是否有MS_MANDLOCK
2.并且inode中i_mode的S_ISGID置上，但是S_IXGRP没置
	注：1.强制锁指的是操作系统在进程访问文件时，主动加锁（fcntl）
			协调锁是进程在调用的过程中自己主动加锁
			（进程通过一次系统调用实现读或写的时候，对于进程本身是“原子”的
			因为进程在内核中不会因为时间而发生进程的切换，但是在对一个文件做
			多次的读写操作时，这个过程就不可能是“原子的”）
		2.一般S_ISGID置上，就是为了以这个group的权限去执行文件，但是如果
			S_IXGRP没设置，这个对于这个实例是没有意义的，所以Unix就用这个标志
			来确定是否要给inode加强制锁
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>630</x>
      <y>1018</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>655</x>
      <y>1017</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_mandatory_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>645</x>
      <y>1011</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>659</x>
      <y>1024</y>
      <w>36</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>遍历inode-&gt;i_flock，如果fl-&gt;fl_flags
的FL_POSIX置上，但是fl_owner却不是
current-&gt;files，说明这个inode被其他进程锁上
所以返回-EAGAIN。遍历完，没有被自己以外的其
他进程锁上，就返回0.
注：1.每当进程对文件的一个区间加锁时，就会在
		链表中增加一个 file_lock结构，该结构中
		fl_start和fl_end确定这个区间
	2.FL_POSIX（ fcntl）支持对区间加锁，可以是强制锁，
		也可以是协调锁因为前面有MANDATORY_LOCK的检测，
	  所以这里是强制锁，
	  FL_FLOCK（ fcntl）是协调锁，只支持对整个文件加锁
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>665</x>
      <y>1020</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>672</x>
      <y>1010</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DQUOT_INIT</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>626</x>
      <y>1005</y>
      <w>53</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>669</x>
      <y>1015</y>
      <w>21</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_sb-&gt;dq_op-&gt;initialize
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>677</x>
      <y>1013</y>
      <w>4</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>709</x>
      <y>1011</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_truncate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>626</x>
      <y>1005</y>
      <w>90</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;880.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>706</x>
      <y>1024</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>attr-&gt;ia_ctime = now
attr-&gt;ia_atime
attr-&gt;ia_mtime
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>719</x>
      <y>1032</y>
      <w>16</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op-&gt;setattr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>737</x>
      <y>1031</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_change_ok</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>766</x>
      <y>1031</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_setattr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>715</x>
      <y>1020</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>725</x>
      <y>1020</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>727</x>
      <y>1022</y>
      <w>16</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode-&gt;i_op-&gt;setattr</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>739</x>
      <y>1022</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2没有setattr</panel_attributes>
    <additional_attributes>20.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>742</x>
      <y>1025</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>746</x>
      <y>1025</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>704</x>
      <y>1038</y>
      <w>37</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.ia_valid中ATTR_FORCE 置上，权限检查ok
2.ATTR_UID置上时
	fsuid要和inode-&gt;i_uid相等，并且如果attr-&gt;ia_uid和
	i_uid不相等，CAP_CHOWN就得置上
3.ATTR_GID置上时，以下三种情况要满足一个：
	1.attr-&gt;ia_gid在fsgid中，
	2.ia_gid等于i_gid
	3.CAP_CHOWN置上
4.ATTR_MODE置上时
	1.fsuid不等于inode-&gt;i_uid时，CAP_FOWNER得置上
	2.ia_gid（ATTR_GID）或者i_gid不在fsgid中时，
		CAP_FSETID得置上。
5.ATTR_MTIME_SET | ATTR_ATIME_SET有一个置上时：
	如果fsuid不等于i_uid，CAP_FOWNER得置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>724</x>
      <y>1034</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>744</x>
      <y>1039</y>
      <w>22</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.ATTR_UID时：
	inode-&gt;i_uid = attr-&gt;ia_uid
2.ATTR_GID时：
	inode-&gt;i_gid = attr-&gt;ia_gid
3.ATTR_SIZE时：
	vmtruncate(inode, attr-&gt;ia_size)
4.ATTR_ATIME时：
	inode-&gt;i_atime = attr-&gt;ia_atime
5.ATTR_MTIME时：
	inode-&gt;i_mtime = attr-&gt;ia_mtime
6.ATTR_CTIME时：
	inode-&gt;i_ctime = attr-&gt;ia_ctime
7.ATTR_MODE时：
	inode-&gt;i_mode = attr-&gt;ia_mode
	如果inode-&gt;i_gid不在fsgid中，但是CAP_FSETID没置上时：
		inode-&gt;i_mode &amp;= ~S_ISGID
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>753</x>
      <y>1034</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>682</x>
      <y>1019</y>
      <w>31</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>newattrs.ia_size = length;
newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>697</x>
      <y>1014</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>720</x>
      <y>1017</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>notify_change</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>713</x>
      <y>1014</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>772</x>
      <y>1034</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>782</x>
      <y>1037</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_inode_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>786</x>
      <y>1040</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
没I_DIRTY
I_DIRTY是指I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES
全置上</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>781</x>
      <y>1046</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__mark_inode_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>768</x>
      <y>1053</y>
      <w>16</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_state |= flags
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>774</x>
      <y>1049</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
此时flag传的是I_DIRTY</panel_attributes>
    <additional_attributes>130.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>780</x>
      <y>1049</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode在hash中时
从inode_in_use或者inode_unused中删除
添加到s_dirty中</panel_attributes>
    <additional_attributes>70.0;10.0;200.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>792</x>
      <y>1054</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_del(&amp;inode-&gt;i_list);
list_add(&amp;inode-&gt;i_list, &amp;sb-&gt;s_dirty);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>787</x>
      <y>1025</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setattr_mask</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>805</x>
      <y>1025</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_dir_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>725</x>
      <y>1020</y>
      <w>69</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>725</x>
      <y>1020</y>
      <w>89</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;870.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>628</x>
      <y>1001</y>
      <w>123</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flag中O_TRUNC没置上
但是FMODE_WRITE置上</panel_attributes>
    <additional_attributes>10.0;10.0;1210.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>743</x>
      <y>1005</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DQUOT_INIT</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>730</x>
      <y>1009</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_write_access</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>626</x>
      <y>1005</y>
      <w>112</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>449</x>
      <y>867</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请file与dentry关联</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>478</x>
      <y>874</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>450</x>
      <y>884</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_empty_filp</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>454</x>
      <y>877</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>430</x>
      <y>892</y>
      <w>41</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.如果files_stat.nr_free_files大于NR_RESERVED_FILES
	1.从free_list中申请一个file
		f = list_entry(free_list.next, struct file, f_list);
		list_del(&amp;f-&gt;f_list);
		files_stat.nr_free_files--;
	2.对file进行初始化
		memset(f, 0, sizeof(*f));
		atomic_set(&amp;f-&gt;f_count,1);
		f-&gt;f_version = ++event;
		f-&gt;f_uid = current-&gt;fsuid;
		f-&gt;f_gid = current-&gt;fsgid;
		//暂时加到anon_list链表中
		list_add(&amp;f-&gt;f_list, &amp;anon_list);
2.剩余file的数量小于要reserve的，并且之歌数量不为0，uid为0
	也做1.1和1.2
3.如果上述两个条件都不满足
	1.如果files_stat.nr_files &lt; files_stat.max_files
		就向filp_cachep申请file（kmem_cache_alloc），并
		增加计数（files_stat.nr_files++），然后通过1.2进行初始化
	2.否则返回NULL（静态变量old_max做到只提示一次）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>446</x>
      <y>887</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>473</x>
      <y>892</y>
      <w>26</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>f-&gt;f_flags = flags;
 //flags转换成file的read/write标志
f-&gt;f_mode = (flags+1) &amp; O_ACCMODE;
inode = dentry-&gt;d_inode;
if (f-&gt;f_mode &amp; FMODE_WRITE)
	get_write_access
f-&gt;f_dentry = dentry;
f-&gt;f_vfsmnt = mnt;
f-&gt;f_pos = 0;
f-&gt;f_reada = 0;
 //如果(fops) &amp;&amp; (fops)-&gt;owner存在
 //增加owner的计数，返回inode-&gt;i_fop
f-&gt;f_op = fops_get(inode-&gt;i_fop);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>483</x>
      <y>877</y>
      <w>4</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>483</x>
      <y>877</y>
      <w>30</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode-&gt;i_sb存在
将f_list添加到
inode-&gt;i_sb-&gt;s_files中</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>504</x>
      <y>892</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file_move</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>501</x>
      <y>899</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>list_del(&amp;file-&gt;f_list);
list_add(&amp;file-&gt;f_list, list);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>509</x>
      <y>895</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>483</x>
      <y>877</y>
      <w>51</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
f-&gt;f_op-&gt;open
附加操作</panel_attributes>
    <additional_attributes>10.0;10.0;490.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>526</x>
      <y>892</y>
      <w>11</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>f-&gt;f_op-&gt;open
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>519</x>
      <y>902</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_open_file</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>524</x>
      <y>894</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>500</x>
      <y>908</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>当f_flags中O_LARGEFILE没置上时
 inode-&gt;i_size不能大于2G
 (如果O_LARGEFILE置上，高32位在
	i_high_size中，其低32位为ext2_inode
	中的i_size，两者合起来为i_size是64位整数)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>513</x>
      <y>905</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>553</x>
      <y>886</y>
      <w>35</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>f-&gt;f_flags &amp;= 
~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>483</x>
      <y>877</y>
      <w>83</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将打开时用的flag给清掉</panel_attributes>
    <additional_attributes>10.0;10.0;810.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>407</x>
      <y>970</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //umask置1的位表示该进程对组没有响应的权限
mode &amp;= S_IALLUGO &amp; ~current-&gt;fs-&gt;umask;
mode |= S_IFREG;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>446</x>
      <y>971</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>may_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>426</x>
      <y>977</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.child-&gt;d_inode不能存在
2.i_flags中S_DEAD不能置上，
	S_DEAD表示inode被删除，但是count不为0
3.检查父节点的MAY_WRITE | MAY_EXEC权限
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>462</x>
      <y>971</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_op-&gt;create
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>389</x>
      <y>987</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>393</x>
      <y>974</y>
      <w>90</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_dir_inode_operations</panel_attributes>
    <additional_attributes>760.0;10.0;670.0;110.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>420</x>
      <y>965</y>
      <w>50</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>450</x>
      <y>965</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>467</x>
      <y>965</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>443</x>
      <y>974</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>288</x>
      <y>993</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_new_inode
1.内存中申请管理结构new_inode
2.在磁盘上寻找inode
	1.找到对应的group
	2.在group的位图中找到对应空闲inode号
	3.对group的硬盘信息更新
3.根据硬件和进程信息初始化内存inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>293</x>
      <y>990</y>
      <w>103</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1010.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>87</x>
      <y>1016</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>filter
1.!dir || !dir-&gt;i_nlink
	父节点不能为空，存在和这个inode相关的目录项
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>105</x>
      <y>996</y>
      <w>189</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1870.0;10.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>120</x>
      <y>1017</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>new_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>125</x>
      <y>996</y>
      <w>170</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sb</panel_attributes>
    <additional_attributes>1680.0;10.0;10.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>104</x>
      <y>1025</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_empty_inode
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>110</x>
      <y>1020</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>119</x>
      <y>1026</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_sb = sb;
inode-&gt;i_dev = sb-&gt;s_dev;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>124</x>
      <y>1020</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>156</x>
      <y>1012</y>
      <w>35</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISDIR</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>138</x>
      <y>1025</y>
      <w>58</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.每个组平均inode的数量
avefreei = le32_to_cpu(es-&gt;s_free_inodes_count) /
			sb-&gt;u.ext2_sb.s_groups_count;
2.inode属于哪个group
i = dir-&gt;u.ext2_i.i_block_group;
3.（被注释）从i开始遍历所有的group，找到bg_used_dirs_count(目录的数量)*256
	低于bg_free_inodes_count（空闲inode数量）的group
注：1.遍历方式，遍历的次数（bg_free_inodes_count）和遍历的起始点（i）分开
	2.ext2_get_group_desc
		sb-&gt;u.ext2_sb.s_group_desc[group_desc].b_data+desc
		bh存储s_group_desc[group_desc]这个管理结构
4.如果没有找到相应的group，再次遍历所有的group，找到空闲inode数量（s_groups_count）
	大于avefreei的inode数量（这个条件使遍历少了一些），找到最大的bg_free_blocks_count
	的group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>188</x>
      <y>1012</y>
      <w>17</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不是目录文件</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>188</x>
      <y>996</y>
      <w>107</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
文件最好和父目录放在同一个group
但是子目录可以不放在同一个group</panel_attributes>
    <additional_attributes>1050.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>197</x>
      <y>1028</y>
      <w>45</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.获取当前dir所在的group
2，如果当前group存在空闲inode（bg_free_inodes_count不为0）
	就选取当前的group
3.如果当前group不存在空闲inode，以j &lt;&lt;= 1的方式，遍历所有的group
	找到有空闲inode的group
4.如果还没找到就通过线性查找所有的group，找到空闲inode的group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>249</x>
      <y>1008</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>load_inode_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>252</x>
      <y>996</y>
      <w>46</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>243</x>
      <y>1016</y>
      <w>52</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.要load的group要小于s_groups_count
2.一般将最近使用的group放在0号位
	所以利用程序执行的局部性，如果0号位就
	检测到了要加载的group，直接返回
3.如果设备对应的group总数（s_groups_count）
	小于加载数组的大小（EXT2_MAX_GROUP_LOADED）
	那么每个group都存在数组对应的group号下面
	如果在block_group号下没找到，就通过read_inode_bitmap
	读取group的位图
4.如果group的总数大于数组的大小，将已经加载到数组中的
	位图（s_loaded_inode_bitmaps）向后移一位，将0号空闲出来
	（注：如果数组包含当前group，就移当前group之前的位，如果不包含
	就将所有的s_loaded_inode_bitmaps向后移一位）。再看是否包含要查找的group，
	如果不包含就通过read_inode_bitmap将位图读入数组（s_loaded_inode_bitmaps
	如果小于EXT2_MAX_GROUP_LOADED，在再次加载的时候，应该++）
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>255</x>
      <y>1011</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>255</x>
      <y>1043</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_inode_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>263</x>
      <y>1040</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>230</x>
      <y>1051</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_get_group_desc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>236</x>
      <y>1046</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>204</x>
      <y>1054</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>194</x>
      <y>1062</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_group&lt;s_groups_count
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>226</x>
      <y>1054</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
计算group对应的bh
和在bh中的偏移</panel_attributes>
    <additional_attributes>120.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>217</x>
      <y>1061</y>
      <w>39</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>group_desc = block_group / EXT2_DESC_PER_BLOCK(sb);
desc = block_group % EXT2_DESC_PER_BLOCK(sb);
s_group_desc[group_desc]不为空
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>258</x>
      <y>1061</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.bh存储管理结构s_group_desc[group_desc]
2.返回磁盘中的真实数据的内存偏移
	s_group_desc[group_desc]-&gt;b_data+desc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>237</x>
      <y>1054</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>265</x>
      <y>1052</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>264</x>
      <y>1046</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读取位图的inode
位图的inode号通过管理结构desc存储</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>279</x>
      <y>1052</y>
      <w>43</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>sb-&gt;u.ext2_sb.s_inode_bitmap_number[bitmap_nr] = block_group;
sb-&gt;u.ext2_sb.s_inode_bitmap[bitmap_nr] = bh;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>264</x>
      <y>1046</y>
      <w>40</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>281</x>
      <y>996</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_find_first_zero_bit
（find_first_zero_bit）
&lt;EXT2_INODES_PER_GROUP</panel_attributes>
    <additional_attributes>150.0;10.0;60.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>276</x>
      <y>1003</y>
      <w>13</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>272</x>
      <y>1011</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_set_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>287</x>
      <y>1011</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_buffer_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>286</x>
      <y>1003</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>286</x>
      <y>1003</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MS_SYNCHRONOUS
如果同步就写超级块</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>303</x>
      <y>1010</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>ll_rw_block (WRITE, 1, &amp;bh);
wait_on_buffer (bh);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>295</x>
      <y>996</y>
      <w>46</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
计算inode号</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>328</x>
      <y>1010</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //i是group号
 //j是在group中的偏移索引
 //所以+1
j += i * EXT2_INODES_PER_GROUP(sb) + 1
 EXT2_FIRST_INO&lt;j&lt;s_inodes_count
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>360</x>
      <y>1005</y>
      <w>50</w>
      <h>88</h>
    </coordinates>
    <panel_attributes> //更新group中空闲inode数量
gdp-&gt;bg_free_inodes_count =
	cpu_to_le16(le16_to_cpu(gdp-&gt;bg_free_inodes_count) - 1);
 //如果是目录，更新group中目录的数量
if (S_ISDIR(mode))
	gdp-&gt;bg_used_dirs_count =
		cpu_to_le16(le16_to_cpu(gdp-&gt;bg_used_dirs_count) + 1);
 //标记group的管理结构dirty
mark_buffer_dirty(bh2);
 //更新设备空闲inode数量
es-&gt;s_free_inodes_count =
	cpu_to_le32(le32_to_cpu(es-&gt;s_free_inodes_count) - 1);
mark_buffer_dirty(sb-&gt;u.ext2_sb.s_sbh);
sb-&gt;s_dirt = 1;
inode-&gt;i_mode = mode;
 //注意inode的mode是fsuid，所以如果进程通过执行isuid文件改变相应的uid
 //其创建出来的文件也是改变之后的uid
inode-&gt;i_uid = current-&gt;fsuid;
 //sb在安装时GRPID置上，或者dir的S_ISGID置上
 //该目录下的i_gid都是目录的gid
 //否则就是进程的fsgid
if (test_opt (sb, GRPID))
	inode-&gt;i_gid = dir-&gt;i_gid;
else if (dir-&gt;i_mode &amp; S_ISGID) {
	inode-&gt;i_gid = dir-&gt;i_gid;
	if (S_ISDIR(mode))
		mode |= S_ISGID;
} else
	inode-&gt;i_gid = current-&gt;fsgid;

inode-&gt;i_ino = j;
inode-&gt;i_blksize = PAGE_SIZE;	
inode-&gt;i_blocks = 0;
inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = CURRENT_TIME;
inode-&gt;u.ext2_i.i_new_inode = 1;
inode-&gt;u.ext2_i.i_flags = dir-&gt;u.ext2_i.i_flags;
if (S_ISLNK(mode))
	inode-&gt;u.ext2_i.i_flags &amp;= ~(EXT2_IMMUTABLE_FL | EXT2_APPEND_FL);
inode-&gt;u.ext2_i.i_faddr = 0;
inode-&gt;u.ext2_i.i_frag_no = 0;
inode-&gt;u.ext2_i.i_frag_size = 0;
inode-&gt;u.ext2_i.i_file_acl = 0;
inode-&gt;u.ext2_i.i_dir_acl = 0;
inode-&gt;u.ext2_i.i_dtime = 0;
inode-&gt;u.ext2_i.i_block_group = i;
if (inode-&gt;u.ext2_i.i_flags &amp; EXT2_SYNC_FL)
	inode-&gt;i_flags |= S_SYNC;
 //如果文件没有sb就存放在anon_hash_chain
 //如果有sb就存放在inode_hashtable + hash(inode-&gt;i_sb, inode-&gt;i_ino)中
 //注：list_add是头插
insert_inode_hash(inode);
inode-&gt;i_generation = event++;
mark_inode_dirty(inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>295</x>
      <y>996</y>
      <w>81</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;790.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>332</x>
      <y>992</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op = &amp;ext2_file_inode_operations;
inode-&gt;i_fop = &amp;ext2_file_operations;
inode-&gt;i_mapping-&gt;a_ops = &amp;ext2_aops;
inode-&gt;i_mode = mode;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>346</x>
      <y>990</y>
      <w>49</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>364</x>
      <y>993</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>mark_inode_dirty
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>370</x>
      <y>990</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>393</x>
      <y>993</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>ext2_add_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>390</x>
      <y>990</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在目录中添加目录项</panel_attributes>
    <additional_attributes>30.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>417</x>
      <y>993</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>d_instantiate
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>391</x>
      <y>990</y>
      <w>36</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将inode和dir的管理结构关联</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>185</x>
      <y>812</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file.f_op
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>212</x>
      <y>812</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_fop
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>197</x>
      <y>812</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dentry_open</panel_attributes>
    <additional_attributes>10.0;20.0;150.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>243</x>
      <y>812</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de-&gt;proc_fops
ext2_file_operations
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>223</x>
      <y>812</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_read_inode
proc_get_inode
ext2_create
文件系统中给inode的操作函数赋值</panel_attributes>
    <additional_attributes>20.0;20.0;200.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>255</x>
      <y>812</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_register
proc_register
proc_root</panel_attributes>
    <additional_attributes>10.0;20.0;220.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>277</x>
      <y>812</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_file_operations
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>211</x>
      <y>822</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>242</x>
      <y>823</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de-&gt;proc_iops
ext2_file_inode_operations
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>222</x>
      <y>822</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_read_inode
proc_get_inode
ext2_create
文件系统中给inode的操作函数赋值</panel_attributes>
    <additional_attributes>20.0;20.0;200.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>272</x>
      <y>823</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_dir_inode_operations
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>254</x>
      <y>823</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_register
proc_register
proc_root</panel_attributes>
    <additional_attributes>10.0;20.0;180.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>532</x>
      <y>894</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISCHR
def_chr_fops</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>543</x>
      <y>901</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>chrdev_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>535</x>
      <y>909</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_chrfops</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>540</x>
      <y>904</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filp-&gt;f_op</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>577</x>
      <y>906</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>548</x>
      <y>904</y>
      <w>37</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>531</x>
      <y>915</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fops_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>536</x>
      <y>912</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>500</x>
      <y>923</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.查看chrdevs[major].fops是否存在
2.如果存在，且对应的owner module存在
	增加module的计数，并返回fops，如果不存在
	owner，直接返回fops
3、如果不存在，直接返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>517</x>
      <y>918</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>535</x>
      <y>922</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果能找到major的fops，并且是终端设备
	（major是TTY_MAJOR或者TTYAUX_MAJOR）
2.如果需要need_serial，通过fops_put将找到的
	fops释放，之后利用内核提供的module
	need_serial(get_tty_driver)：
	遍历tty_drivers，看其中是否有一个driver，其
	和device相同的 major，并且minor要在dirver
	的minor_start~ minor_start + p-&gt;num之间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>535</x>
      <y>918</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>570</x>
      <y>923</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //请求char-major-x  module
sprintf(name, "char-major-%d", major);
request_module(name);
 //获取fops
ret = fops_get(chrdevs[major].fops);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>535</x>
      <y>918</y>
      <w>47</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果fops为NULL</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1057</x>
      <y>918</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>532</x>
      <y>894</y>
      <w>531</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_fops</panel_attributes>
    <additional_attributes>10.0;10.0;5290.0;240.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1040</x>
      <y>921</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据inode获得虚拟设备devfs_entrylt</panel_attributes>
    <additional_attributes>210.0;10.0;18.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1030</x>
      <y>926</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_devfs_entry_from_vfs_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1047</x>
      <y>931</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果是S_ISDIR，goto out
2.de-&gt;registered为false， -ENODEV
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1057</x>
      <y>921</y>
      <w>6</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1073</x>
      <y>931</y>
      <w>55</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.file-&gt;private_data = de-&gt;info
2.S_ISBLK：
	file-&gt;f_op = &amp;def_blk_fops
	//如果df-&gt;ops存在
	inode-&gt;i_bdev-&gt;bd_op = df-&gt;ops
	其他：
	file-&gt;f_op=df-&gt;ops
3.如果file-&gt;f_op存在，且桥接的fop要求open（file-&gt;f_op-&gt;open）
	(*file-&gt;f_op-&gt;open) (inode, file)
4.如果file-&gt;f_op不存在
	如果是S_ISCHR，通过chrdev_open从chrdevs获取fops，并且
	执行桥接的filp-&gt;f_op-&gt;open
	如果是其他设备，返回-ENODEV
5.如果df已经打开（df-&gt;open为true），返回
6.如果df没打开，df-&gt;open = TRUE
7，如果要求自动owner（df-&gt;auto_owner）
	de-&gt;inode.mode = (de-&gt;inode.mode &amp; ~S_IALLUGO) |(de-&gt;mode &amp; S_IRWXUGO);
	de-&gt;inode.uid = current-&gt;euid;
	de-&gt;inode.gid = current-&gt;egid;
	inode-&gt;i_mode = de-&gt;inode.mode;
	inode-&gt;i_uid = de-&gt;inode.uid;
	inode-&gt;i_gid = de-&gt;inode.gid;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1060</x>
      <y>921</y>
      <w>34</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1132</x>
      <y>930</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfsd_notify_one</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1060</x>
      <y>921</y>
      <w>80</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
df-&gt;aopen_notify</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;80.0;780.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>533</x>
      <y>894</y>
      <w>627</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISBLK
def_blk_fops</panel_attributes>
    <additional_attributes>10.0;10.0;6250.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1153</x>
      <y>918</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1126</x>
      <y>925</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdev = inode-&gt;i_bdev
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1131</x>
      <y>921</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1155</x>
      <y>921</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bdev-&gt;bd_op不存在</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1149</x>
      <y>926</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_blkfops</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1138</x>
      <y>934</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.major不能为0，并且要小于MAX_BLKDEV
2.如果blkdevs[major].bdops不存在，通过
	request_module安装module
3.返回blkdevs[major].bdops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1150</x>
      <y>929</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1157</x>
      <y>921</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1167</x>
      <y>928</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果没找到了bd_op，返回ENXIO
2.如果找到了，并且bdev-&gt;bd_op-&gt;open存在，
	通过这个函数对file的op进行桥接
3.如果正确返回，atomic_inc(&amp;bdev-&gt;bd_openers)
	如果没有，且没有bd_openers：
	bdev-&gt;bd_op = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1174</x>
      <y>942</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdev-&gt;bd_op-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>938</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1181</x>
      <y>945</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_fops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1176</x>
      <y>949</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1150</x>
      <y>954</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_info_ptr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>952</y>
      <w>29</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1132</x>
      <y>961</y>
      <w>28</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.通过major在ide_hwifs（接口）找到对应的类型
	hwif-&gt;present &amp;&amp; major == hwif-&gt;major
2.通过minor在hwif-&gt;drives中找到特定种类的
	设备（ide_drive_t）
3.如果drive-&gt;present置上，返回设备
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1147</x>
      <y>957</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>952</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;driver == NULL
如果设备中没有相应的操作</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1173</x>
      <y>954</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>80.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1168</x>
      <y>957</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_driver_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1161</x>
      <y>962</y>
      <w>28</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果之前有ide interface检测到
	直接将ide_modules链表中module-&gt;init
	然后在revalidate_drives
2.如果没有ide interface检测到
	通过ide_probe_module检测module
	然后在初始化ide_modules链表中的module
	并执行revalidate_drives
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>960</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1158</x>
      <y>976</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_probe_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1163</x>
      <y>973</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1150</x>
      <y>979</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!ide_probe
请求安装ide-probe-mod</panel_attributes>
    <additional_attributes>120.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1147</x>
      <y>983</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1160</x>
      <y>984</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_probe-&gt;init
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1160</x>
      <y>979</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_probe存在</panel_attributes>
    <additional_attributes>20.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1177</x>
      <y>983</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>revalidate_drives</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1161</x>
      <y>979</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1183</x>
      <y>973</y>
      <w>4</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1160</x>
      <y>986</y>
      <w>41</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历所有ide interface的设备（注意这里都是实体，没有指针）
查看drive-&gt;revalidate是否置上，如果置上并且没被初始化
（!initializing）</panel_attributes>
    <additional_attributes>230.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1170</x>
      <y>992</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_revalidate_disk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1191</x>
      <y>958</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>955</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果时具体的设备被拆除
根据drive-&gt;media安装</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1205</x>
      <y>958</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>while (drive-&gt;busy)
	sleep_on(&amp;drive-&gt;wqueue);
drive-&gt;usage++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>952</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1230</x>
      <y>959</y>
      <w>15</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>DRIVER(drive)-&gt;open
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>953</y>
      <w>57</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;driver != NULL</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1237</x>
      <y>961</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
idedisk_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1231</x>
      <y>966</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>idedisk_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1230</x>
      <y>973</y>
      <w>18</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>MOD_INC_USE_COUNT
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1237</x>
      <y>969</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>564</x>
      <y>911</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memory_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>568</x>
      <y>908</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
memory_fops</panel_attributes>
    <additional_attributes>160.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>557</x>
      <y>913</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MINOR=3</panel_attributes>
    <additional_attributes>150.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>551</x>
      <y>916</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op = &amp;null_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>571</x>
      <y>914</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果filp-&gt;f_op-&gt;open
不为空，继续桥接</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>581</x>
      <y>917</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>648</x>
      <y>914</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty_open
1.识别设备号
2.通过设备号，找到tty_driver，并通过driver找到tty
3.tty链路层ldisc.open
4.tty.driver.open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>584</x>
      <y>909</y>
      <w>70</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty_fops</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>599</x>
      <y>920</y>
      <w>47</w>
      <h>44</h>
    </coordinates>
    <panel_attributes>1.存储noctty(表示进程如果没有代开tty，第一次打开tty
	会将打开的tty作为进程的tty，但是如果这个标志置上，
	则不会成为进程的tty)
	noctty = filp-&gt;f_flags &amp; O_NOCTTY
2.如果是/dev/tty，需要检查current-&gt;tty，如果存在
	获取设备号
	device = current-&gt;tty-&gt;device
	 filp-&gt;f_flags |= O_NONBLOCK
3.如果是/dev/tty0，获取前台console（fg_console），因为
	fg_console是从0开始计数，tty*是从1开始计数，所以：
	device = MKDEV(TTY_MAJOR, fg_console + 1);
	noctty = 1;
4.如果是/dev/console，查找console_drivers链表中device
	存在的console，并获取设备号：
	device = c-&gt;device(c);
	filp-&gt;f_flags |= O_NONBLOCK; /* Don't let /dev/console block */
	noctty = 1
5.如果是/dev/ptmx,扫描伪终端主设备数组ptm_driver，根据driver组装
	device = MKDEV(driver-&gt;major, minor)
	然后试图init_dev，如果正确返回，ptmx_found
注：/dev/tty0，(4,0)系统当前虚拟终端，由键盘和显示器组成,
					可以通过CONFIG_VT开关
	/dev/tty,(5,0)当前进程使用的终端，可以是tty0，可以是URAT
					或者其他终端设备
	/dev/comsole，（5,1）系统当前使用的控制台，默认是tty0，也可以是URAT
	/dev/ptmx，是伪终端设备的总入口，在打开时临时分配设备号，参考P1190
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>618</x>
      <y>917</y>
      <w>39</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>654</x>
      <y>917</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>663</x>
      <y>920</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ptmx_found
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>647</x>
      <y>927</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>set_bit(TTY_PTY_LOCK, &amp;tty-&gt;flags)
 //算出伪终端设备在driver终端的偏移量
minor -= driver-&gt;minor_start
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>657</x>
      <y>923</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>675</x>
      <y>928</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devpts_pty_new</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>667</x>
      <y>923</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为slave创建inode</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>649</x>
      <y>937</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //获取devpts的sb
sb = devpts_mnt-&gt;mnt_sb
sbi = SBI(sb)
 //如果inode存在，则直接返回
if ( sbi-&gt;inodes[number] )
		return
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>657</x>
      <y>931</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>670</x>
      <y>936</y>
      <w>37</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>inode = new_inode(sb)
inode-&gt;i_ino = number+2;
inode-&gt;i_blocks = 0;
inode-&gt;i_blksize = 1024;
inode-&gt;i_uid = sbi-&gt;setuid ? sbi-&gt;uid : current-&gt;fsuid;
inode-&gt;i_gid = sbi-&gt;setgid ? sbi-&gt;gid : current-&gt;fsgid;
inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = CURRENT_TIME;
init_special_inode(inode, S_IFCHR|sbi-&gt;mode, kdev_t_to_nr(device))
 //因为new_inode可能睡，所以需要再次检查
if ( sbi-&gt;inodes[number] ) {
		iput(inode);
		return;
}
sbi-&gt;inodes[number] = inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>679</x>
      <y>931</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>705</x>
      <y>929</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty_register_devfs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>667</x>
      <y>923</y>
      <w>44</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为slave注册devfs</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>710</x>
      <y>932</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>708</x>
      <y>934</y>
      <w>22</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>tty.driver = *driver;
tty.device = MKDEV (driver-&gt;major, minor)

mode默认：mode = S_IFCHR | S_IRUSR | S_IWUSR
/dev/tty，/dev/ptmx加上：mode |= S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH

major=2（静态分配的伪终端主设备）flags |= DEVFS_FL_AUTO_OWNER
动态分配的伪终端主设备：flags |= DEVFS_FL_CURRENT_OWNER

devfs_register（name:tty-&gt;driver.name，idx + tty-&gt;driver.name_base嵌入到name中）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>743</x>
      <y>924</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>653</x>
      <y>917</y>
      <w>96</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;940.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>730</x>
      <y>930</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_tty_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>731</x>
      <y>937</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>遍历tty_drivers找到：
tty_driver.major = major
tty_driver.minor_start&lt;minor &lt; tty_driver.minor_start+tty_driver.num
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>735</x>
      <y>927</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>736</x>
      <y>933</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>748</x>
      <y>930</y>
      <w>38</w>
      <h>44</h>
    </coordinates>
    <panel_attributes>1.算出device在driver中偏移量
	idx = MINOR(device) - driver-&gt;minor_start
2.如果driver-&gt;table[idx]中的tty存在，就找到了，fast_track
3.如果没找到：
	1.通过alloc_tty_struct申请tty，然后通过initialize_tty_struct
		初始化，并初始化driver和device
		tty-&gt;device = device;
		tty-&gt;driver = *driver
	2.如果driver-&gt;termios[idx]不存在，通过kmalloc在cache中申请，
		并初始化为driver-&gt;init_termios
	3.如果driver-&gt;termios_locked[idx]不存在，通过kmalloc在cache中申请
		并初始化为0
	4.如果是伪终端设备（TTY_DRIVER_TYPE_PTY），通过alloc_tty_struct
		为另一设备申请tty，并通过initialize_tty_struct初始化，并设置device和driver
		o_tty-&gt;device = (kdev_t) MKDEV(driver-&gt;other-&gt;major,
					driver-&gt;other-&gt;minor_start + idx);
		o_tty-&gt;driver = *driver-&gt;other
		如果另一设备的termios不存在，通过kmalloc申请，并初始化为driver-&gt;other-&gt;init_termios
		如果另一设备的termios_locked不存在，通过kmalloc申请，并初始化为0
		driver-&gt;other-&gt;table[idx] = o_tty
		o_tty-&gt;termios = *o_tp_loc;
		o_tty-&gt;termios_locked = *o_ltp_loc
		(*driver-&gt;other-&gt;refcount)++
		如果是主设备（PTY_TYPE_MASTER），从设备：o_tty-&gt;count++
		建立起主从设备的联系：
		tty-&gt;link   = o_tty;
		o_tty-&gt;link = tty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>749</x>
      <y>927</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>751</x>
      <y>975</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_tty_struct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>737</x>
      <y>981</y>
      <w>40</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果PAGE_SIZE大于8k,则通过kmalloc在cache中申请
2.如果小于等于8k，通过get_zeroed_page从伙伴系统中申请
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>756</x>
      <y>978</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>775</x>
      <y>975</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>initialize_tty_struct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>782</x>
      <y>980</y>
      <w>28</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>memset(tty, 0, sizeof(struct tty_struct));
tty-&gt;magic = TTY_MAGIC;
 //分配链路层ldiscs
tty-&gt;ldisc = ldiscs[N_TTY];
tty-&gt;pgrp = -1; 
 //用于存储传递过来的目标码
tty-&gt;flip.char_buf_ptr = tty-&gt;flip.char_buf;
tty-&gt;flip.flag_buf_ptr = tty-&gt;flip.flag_buf;
tty-&gt;flip.tqueue.routine = flush_to_ldisc;
tty-&gt;flip.tqueue.data = tty;
init_MUTEX(&amp;tty-&gt;flip.pty_sem);
init_waitqueue_head(&amp;tty-&gt;write_wait);
init_waitqueue_head(&amp;tty-&gt;read_wait);
tty-&gt;tq_hangup.routine = do_tty_hangup;
tty-&gt;tq_hangup.data = tty;
sema_init(&amp;tty-&gt;atomic_read, 1);
sema_init(&amp;tty-&gt;atomic_write, 1);
spin_lock_init(&amp;tty-&gt;read_lock);
INIT_LIST_HEAD(&amp;tty-&gt;tty_files);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>784</x>
      <y>978</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>756</x>
      <y>973</y>
      <w>6</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>778</x>
      <y>973</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>788</x>
      <y>931</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>driver-&gt;table[idx] = tty
tty-&gt;termios = *tp_loc;
tty-&gt;termios_locked = *ltp_loc;
(*driver-&gt;refcount)++;
tty-&gt;count++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>749</x>
      <y>927</y>
      <w>51</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
处理新申请的tty，tp_loc，ltp_loc</panel_attributes>
    <additional_attributes>10.0;10.0;490.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>817</x>
      <y>931</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;ldisc.open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>749</x>
      <y>927</y>
      <w>76</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty_ldisc_N_TTY</panel_attributes>
    <additional_attributes>10.0;10.0;740.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>817</x>
      <y>938</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>n_tty_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>821</x>
      <y>934</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>801</x>
      <y>941</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!tty-&gt;read_buf
如果!tty-&gt;read_buf不存在</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>796</x>
      <y>945</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_buf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>790</x>
      <y>952</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1，如果在in_interrupt中，采用GFP_ATOMIC
	申请内存，否则使用GFP_KERNEL申请
	这个允许等待和同步
2.如果N_TTY_BUF_SIZE和PAGE_SIZE
	不相等，则通过kmalloc在cache中
	申请，并清0；否则通过get_zeroed_page
	在buddy中申请
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>800</x>
      <y>948</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>815</x>
      <y>947</y>
      <w>24</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>memset(tty-&gt;read_buf, 0, N_TTY_BUF_SIZE);
reset_buffer_flags(tty);
tty-&gt;column = 0;
n_tty_set_termios(tty, 0);
tty-&gt;minimum_to_wake = 1;
tty-&gt;closing = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>823</x>
      <y>941</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>815</x>
      <y>960</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reset_buffer_flags</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>819</x>
      <y>957</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>793</x>
      <y>967</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>tty-&gt;read_head = tty-&gt;read_tail = tty-&gt;read_cnt = 0
tty-&gt;canon_head = tty-&gt;canon_data = tty-&gt;erasing = 0
memset(&amp;tty-&gt;read_flags, 0, sizeof tty-&gt;read_flags)
 //tty.count不为0，tty-&gt;flags的TTY_THROTTLED置上时
 //执行tty-&gt;driver.unthrottle
check_unthrottle
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>808</x>
      <y>963</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>838</x>
      <y>961</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>n_tty_set_termios</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>828</x>
      <y>957</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置tty.process_char_map</panel_attributes>
    <additional_attributes>20.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>834</x>
      <y>931</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>o_tty-&gt;ldisc.open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>749</x>
      <y>927</y>
      <w>94</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果o_tty和o_tty-&gt;ldisc.open存在</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>855</x>
      <y>931</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fast_track
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>750</x>
      <y>927</y>
      <w>112</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在driver-&gt;table[idx]中有</panel_attributes>
    <additional_attributes>10.0;10.0;1100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>844</x>
      <y>939</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.测试tty-&gt;flags中TTY_CLOSING置上
	报错
2.如果是伪终端的主设备（如果此时tty.count
	存在，报错),将从设备tty-&gt;link-&gt;count++
3.更新tty
	tty-&gt;count++;
	tty-&gt;driver = *driver
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>853</x>
      <y>934</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>653</x>
      <y>917</y>
      <w>241</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2390.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>885</x>
      <y>926</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_dev_done
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>871</x>
      <y>934</y>
      <w>25</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>filp-&gt;private_data = tty
 //将file.list链接到tty-&gt;tty_files链表中
file_move
 //tty的count包括tty_files中的file的数量
 //+1（如果是伪终端从设备的或，加上主设备的）
check_tty_count
 //如果是伪终端主设备
noctty = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>875</x>
      <y>929</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>897</x>
      <y>934</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;driver.open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>889</x>
      <y>929</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>901</x>
      <y>937</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
con_init-&gt;console_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>870</x>
      <y>946</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
currcons是minor的偏移量</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>864</x>
      <y>954</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vc_allocate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>856</x>
      <y>957</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>852</x>
      <y>961</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>偏移量不能大于
虚拟终端的数量
否则返回-ENXIO
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>865</x>
      <y>957</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果vc_cons[currcons].d存在
返回0，如果不存在</panel_attributes>
    <additional_attributes>60.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>853</x>
      <y>962</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>834</x>
      <y>970</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.检查偏移量
2.检查进程的CAP_SYS_RESOURCE
	权限
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>862</x>
      <y>971</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>865</x>
      <y>962</y>
      <w>16</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请vc_data +vt_struct
的内存</panel_attributes>
    <additional_attributes>120.0;10.0;30.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>876</x>
      <y>969</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //指向vc_data
vc_cons[currcons].d
 //指向vt_struct
vt_cons[currcons]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>877</x>
      <y>962</y>
      <w>7</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>891</x>
      <y>969</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>visual_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>877</x>
      <y>962</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化 vc_cons[currcons].d
中的变量</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>880</x>
      <y>954</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>vt_cons[currcons]-&gt;vc_num = currcons;
tty-&gt;driver_data = vt_cons[currcons]
 //如果下面两项同时为0时
tty-&gt;winsize.ws_row = video_num_lines;
tty-&gt;winsize.ws_col = video_num_columns
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>897</x>
      <y>943</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>con_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>890</x>
      <y>946</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>913</x>
      <y>954</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vcs_make_devfs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>898</x>
      <y>946</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty-&gt;count == 1时
创建虚拟终端的buffer及属性的设备文件</panel_attributes>
    <additional_attributes>50.0;10.0;200.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>906</x>
      <y>964</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_unregister</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>925</x>
      <y>964</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_register
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>911</x>
      <y>960</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>918</x>
      <y>960</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>918</x>
      <y>957</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
（7，1~63）buffer
（7，129~191）attribute
devfs_handle是vcs_init中初始化为/dev/vcc</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>935</x>
      <y>935</y>
      <w>43</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.filp-&gt;f_flags = saved_flags
2.如果之前没错，测试现在如果不是特权用户
	访问TTY_EXCLUSIVE的tty，报EBUSY
3.如果之前有错，释放dev（release_dev）
	只有在是ERESTARTSYS错并且没有signal
	待处理时，会调度之后，然后再次通过filp-&gt;f_op = &amp;tty_fops
	重新open
	否则直接return
4.如果noctty没置上，并且时当前session的主进程（current-&gt;leader）
	且这个进程没有tty，tty.session不存在：
	current-&gt;tty = tty
	current-&gt;tty_old_pgrp = 0;
	tty-&gt;session = current-&gt;session;
	tty-&gt;pgrp = current-&gt;pgrp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>890</x>
      <y>929</y>
      <w>69</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>584</x>
      <y>909</y>
      <w>425</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_init-&gt;usb_major_init-&gt;usb_fops
如果在devfs中注册了，直接执行driver中的open</panel_attributes>
    <additional_attributes>10.0;10.0;4230.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1000</x>
      <y>920</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>991</x>
      <y>928</y>
      <w>32</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.获取usb_driver(usb_minors[minor/16]),并通过
	fops_get获取driver中的fops
2.如果fops存在，将其赋值：
	file-&gt;f_op = new_fops
	如果其中的open接口存在，执行
	file-&gt;f_op-&gt;open
3.如果执行出错，将fops还原：
	file-&gt;f_op = fops_get(old_fops)
4.释放旧的fops，注意这里不管出没出错，都应该释放掉
	这是释放之前的old_fops
	fops_put(old_fops)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1006</x>
      <y>923</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>997</x>
      <y>950</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1002</x>
      <y>946</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1002</x>
      <y>953</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_scanner_init-&gt;usb_register(scanner_driver)
-&gt;usb_scanner_fops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>997</x>
      <y>957</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>open_scanner</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>988</x>
      <y>964</y>
      <w>29</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.算出scanner在p_scn_table中的位置：
	scn_minor=MINOR((X)-&gt;i_rdev) - SCN_BASE_MNR
2.获取scn_usb_data(要存在，否则返回ENODEV)
	scn = p_scn_table[scn_minor]
	dev = scn-&gt;scn_dev
3.filter:
	1.dev要存在
	2.scanner要被初始化（scn-&gt;present）
	3.scanner没被打开（!scn-&gt;isopen）
4.init_waitqueue_head(&amp;scn-&gt;rd_wait_q)
	scn-&gt;isopen = 1
	file-&gt;private_data = scn
	MOD_INC_USE_COUNT
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1002</x>
      <y>960</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>533</x>
      <y>894</y>
      <w>714</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISFIFO
def_fifo_fops</panel_attributes>
    <additional_attributes>10.0;10.0;7120.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1239</x>
      <y>918</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fifo_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1202</x>
      <y>926</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过PIPE_SEM保护整个过程
2.如果没有申请inode-&gt;i_pipe，通过
	pipe_new申请fifo页面和pipe_inode_info
3.filp-&gt;f_version = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1211</x>
      <y>921</y>
      <w>36</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1228</x>
      <y>928</y>
      <w>36</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.桥接fops：
	filp-&gt;f_op = &amp;read_fifo_fops;
2.增加读端计数：
	//注：这里在pipe_new中被设置成1
	PIPE_RCOUNTER(*inode)++;
3.PIPE_READERS++，如果之前是0，通过
	wake_up_partner唤醒等待队列PIPE_WAIT
4.如果之前没有PIPE_WRITERS：
	1.如果要求O_NONBLOCK：
	filp-&gt;f_version = PIPE_WCOUNTER(*inode)
	并返回0
	2.如果要求block，通过wait_for_partner等待（pipe_wait）
		PIPE_RCOUNTER变化，如果醒来发现是信号唤醒，唤醒等待
		队列，并返回ERESTARTSYS
	注：如果此时reader和writer都没有，将整个pipe释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1245</x>
      <y>921</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filp-&gt;f_mode</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1238</x>
      <y>924</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1
只读</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1245</x>
      <y>924</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
２
只写</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1266</x>
      <y>928</y>
      <w>39</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果要求O_NONBLOCK，但是没有PIPE_READERS
	直接返回ENXIO
2.桥接fops：
	filp-&gt;f_op = &amp;write_fifo_fops
3.增加写端计数：
	PIPE_WCOUNTER(*inode)++
4.PIPE_WRITERS(*inode)++，如果之前没有writer
	通过唤醒PIPE_WAIT
5.如果没有reader，通过wait_for_partner等待PIPE_RCOUNTER
	计数不同。如果醒来之后，发现是信号唤醒，释放PIPE_WRITERS
	如果减至0，唤醒等待队列。
注：在５的时候肯定是要求ｂｌｏｃｋ的
	如果最后ｒｅａｄｅｒ和ｗｒｉｔｅｒ都没有，释放ｐｉｐｅ
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1245</x>
      <y>924</y>
      <w>68</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
３
可读可写</panel_attributes>
    <additional_attributes>10.0;10.0;660.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1306</x>
      <y>928</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>１.PIPE_READERS(*inode)++;
	PIPE_WRITERS(*inode)++;
	PIPE_RCOUNTER(*inode)++;
	PIPE_WCOUNTER(*inode)++;
２.如果之前没有ｒｅａｄｅｒ或者ｗｒｉｔｅｒ
	尝试通过wake_up_partner唤醒等待队列
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1410</x>
      <y>847</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_close</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1355</x>
      <y>858</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.fd不能大于max_fds
2，files-&gt;fd[fd]不能为空
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1363</x>
      <y>850</y>
      <w>55</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>530.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1380</x>
      <y>858</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>files-&gt;fd[fd] = NULL;
 //当进程通过execv时，close_on_exec
 //指示要关闭的文件
FD_CLR(fd, files-&gt;close_on_exec);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1390</x>
      <y>850</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1410</x>
      <y>859</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__put_unused_fd
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1415</x>
      <y>850</y>
      <w>5</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1432</x>
      <y>860</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp_close</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1415</x>
      <y>850</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1402</x>
      <y>863</y>
      <w>37</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1396</x>
      <y>870</y>
      <w>15</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.file.f_count不为0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1420</x>
      <y>863</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果文件系统想在文件关闭之前
将文件写入到设备中
（filp-&gt;f_op-&gt;flush存在）</panel_attributes>
    <additional_attributes>170.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1418</x>
      <y>870</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;flush
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1436</x>
      <y>870</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fcntl_dirnotify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1453</x>
      <y>870</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_remove_posix</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1437</x>
      <y>863</y>
      <w>9</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TODO:</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1437</x>
      <y>863</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1474</x>
      <y>870</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1437</x>
      <y>863</y>
      <w>44</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1459</x>
      <y>873</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历inode-&gt;i_flock链表
将该进程（owner）对该文件上的
所有POSIX锁都清掉
TODO:</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1454</x>
      <y>881</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_unlock_delete</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1471</x>
      <y>879</y>
      <w>33</w>
      <h>37</h>
    </coordinates>
    <panel_attributes> //递减file的引用计数
if (atomic_dec_and_test(&amp;file-&gt;f_count)) {
	//如果此时file引用减到0
	//移除协调锁 TODO:
	locks_remove_flock(file);
  //对应ext2_release_file ，将预分配的数据块释放
	if (file-&gt;f_op &amp;&amp; file-&gt;f_op-&gt;release)
		file-&gt;f_op-&gt;release(inode, file);
	//递减模块的动态安装计数
	fops_put(file-&gt;f_op);
	file-&gt;f_dentry = NULL;
	file-&gt;f_vfsmnt = NULL;
	//在dentry_open中get_write_access
	if (file-&gt;f_mode &amp; FMODE_WRITE)
		put_write_access(inode);
	dput(dentry);
	if (mnt)
		mntput(mnt)
	//从sb的s_files中移到free_list中
	list_del(&amp;file-&gt;f_list);
	list_add(&amp;file-&gt;f_list, &amp;free_list);
	files_stat.nr_free_files++;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1481</x>
      <y>873</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1496</x>
      <y>919</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;release
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1484</x>
      <y>915</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1475</x>
      <y>926</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_read_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1482</x>
      <y>922</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
read_pipe_fops
</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1496</x>
      <y>926</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_write_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1498</x>
      <y>922</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
write_pipe_fops
</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1487</x>
      <y>933</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1480</x>
      <y>929</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
第二个参数是读权限
第三个参数是写权限</panel_attributes>
    <additional_attributes>20.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1493</x>
      <y>929</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1481</x>
      <y>941</y>
      <w>34</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.通过信号量inode.sem对整个过程进行保护
2.递减PIPE_READERS和PIPE_WRITERS的计数
3.如果readers和writers都为0：
	//释放fifo缓存，释放i_pipe
	inode-&gt;i_pipe = NULL;
	free_page((unsigned long) info-&gt;base);
	kfree(info);
4.如果不是都为0，通过wake_up_interruptible唤醒
	i_pipe的等待队列
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1492</x>
      <y>936</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1507</x>
      <y>922</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
socket_file_ops
</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1535</x>
      <y>926</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_close</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1541</x>
      <y>929</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1529</x>
      <y>933</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.file的inode要存在
2.通过sock_fasync撤销（第三个参数为0）file在sock上的异步等待
3.通过sock_release将sock释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1527</x>
      <y>943</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_fasync</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1533</x>
      <y>939</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1516</x>
      <y>949</y>
      <w>34</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.如果是插入异步监听（on），通过kmalloc申请一个fasync_struct
2.通过socki_lookup找到sock（本file的sock）
3.遍历sock.fasync_list链表
	1.查看其中是否有和当前file相同的fasync_struct
	2.如果是插入异步监听（on）
		1.如果3.1中查到有和当前file相同的fasync_struct：
			fa-&gt;fa_fd=fd;
			kfree(fna)//释放1申请的fasync_struct
		2.如果没有相同的fasync_struct，将其赋值后，头插至sock-&gt;fasync_list
	3.如果是撤销异步监听
		1.如果找到了fasync_struct，将其从链表中删除：
			*prev=fa-&gt;fa_next;
			kfree(fa)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1532</x>
      <y>946</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1563</x>
      <y>944</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1545</x>
      <y>939</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1554</x>
      <y>950</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过sock-&gt;ops-&gt;release将sock释放
2.如果fasync_list不为空，打印报错信息
 （fasync_list在有链接时会在unix_release_sock中sk_wake_async遍历唤醒）
3.sockets_in_use.counter--
4.如果sock没有file，通过iput将sock对应的inode释放
5.sock-&gt;file=NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1569</x>
      <y>947</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1564</x>
      <y>968</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1564</x>
      <y>962</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;release
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1569</x>
      <y>959</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1569</x>
      <y>965</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops/unix_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1559</x>
      <y>975</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果sock没分配sk，直接返回0
2.如果有分配：
	sock-&gt;sk = NULL
3.通过unix_release_sock释放sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1569</x>
      <y>971</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1563</x>
      <y>986</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_release_sock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1569</x>
      <y>982</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1547</x>
      <y>993</y>
      <w>56</w>
      <h>62</h>
    </coordinates>
    <panel_attributes>1.通过unix_remove_socket将sk从hash表中删除
	//通过af_unix.lock保护整个过程
2.通过sock_orphan使sk关系断开：
	sk-&gt;dead = 1;
	sk-&gt;socket = NULL;
	sk-&gt;sleep = NULL;
注；整个过程被callback_lock保护，所以如果单独读dead，可以对callback_lock上读锁
	但是在读dead时，还有读shutdown等变量，所以大多数时用的是af_unix.loc
3.置shutdown，分别将sk的dentry，mnt，state取出来，然后将sk的这三个属性清除
	sk-&gt;shutdown = SHUTDOWN_MASK;
	dentry = sk-&gt;protinfo.af_unix.dentry;
	sk-&gt;protinfo.af_unix.dentry=NULL;
	mnt = sk-&gt;protinfo.af_unix.mnt;
	sk-&gt;protinfo.af_unix.mnt=NULL;
	state = sk-&gt;state;
	sk-&gt;state = TCP_CLOSE;
	//释放af_unix.lock锁
4.通过wake_up_interruptible_all唤醒peer_wait等待队列
注：1.peer_wait只有在无连接发送的时候receive_queue超出限制时，会使用这个队列
	2.sleep在有链接发送时，senbuf满了之后会用；或者在接收时（不管有链接还是无连接）
		receive_queue中没有skb会用
	3.最重要，在有链接connect时，会将sleep队列指向peer_wait
5.通过unix_peer获取与sk连接的skpair，如果skpair存在时：
	1.如果是有链接（SOCK_STREAM），
		skpair-&gt;shutdown=SHUTDOWN_MASK
		skpair-&gt;err = ECONNRESET //receive_queue不为空，或者调用者要求（参数是1）
		skpair-&gt;state_change(skpair)//通知skpair状态改变
		sk_wake_async(skpair,1,POLL_HUP)//唤醒skpair对应sock的异步队列
	2.不管是有链接还是无连接：
		sock_put(skpair)
		unix_peer(sk) = NULL
6.通过skb_dequeue从sk.receive_queue
	1.如果现在释放的sk处于TCP_LISTEN状态（3中存储的）所以skb存储的是client端connect报文，
		递归调用unix_release_sock释放skb中对应的子serve_sock，注意调用参数是1，会强行将sk.err置上
	2.通过kfree_skb释放skb(不仅包含skb空间，包含sendbuf，发送方sk计数，发送方sk.cb中的fp数组，以及数组中的file)
7.释放dentry，mnt以及自己的sk（sock_put(sk)）
8.如果有还没被接收的file（unix_tot_inflight），通过unix_gc查看sk的hash表中是否有没被用户引用，但是被内核引用（inflight）
	的file（比如a将自己的sock_file授权给b，b也将自己的sock_file授权给a，但是a和b都没接收就close，因为在授权时，内核skb会递增
	对file的引用，导致两个进程都释放了file，但是file因为被skb引用没办法释放，而进程却没办法自己主动释放，所以只能由内核释放）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1569</x>
      <y>989</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1548</x>
      <y>1065</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_def_wakeup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1548</x>
      <y>1058</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skpair-&gt;state_change
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1555</x>
      <y>1054</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1553</x>
      <y>1061</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1540</x>
      <y>1072</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果sk-&gt;sleep不为空，通过wake_up_interruptible_all
	唤醒这个等待队列
注；callback_lock保护
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1553</x>
      <y>1068</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1578</x>
      <y>1057</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_gc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1579</x>
      <y>1054</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1567</x>
      <y>1064</y>
      <w>49</w>
      <h>47</h>
    </coordinates>
    <panel_attributes>1.申请静态信号量unix_gc_sem，down_trylock保证只能有
	一个进程处理
 //unix_table_lock保护hash表操作
2.遍历unix_socket_table表中所有bind的sk
	af_unix.gc_tree=GC_ORPHAN //之后用于栈的链表
3.再次遍历unix_socket_table表中所有bind的sk，查找其中sock_file的计数超过sk的inflight计数
	的sk（因为只有大于才是有用户引用而不全是内核引用），通过maybe_unmark_and_push将其压栈（注意
	栈中的sk是不应该被处理的sk）
4.通过empty_stack检查栈gc_current是否为空
	1.通过pop_stack将sk弹出
	//receive_queue.lock保护skb移出队列
	2.通过skb_peek查看队列中第一个skb
	3.如果队列中有skb，遍历链表中的所有skb（注意这里的skb被没有从链表中移除）
		1.如果skb.cb中有fp，遍历其fp数组。通过unix_get_socket查看这个file是否对应sk，如果对应
			那么这个sk也被用户引用（因为这个skb一旦被接收，就会被用户引用，到时候用户自己释放），所以通过
			maybe_unmark_and_push将这个file对应的sk压栈
		2.如果sk的状态是TCP_LISTEN，说明这个skb是client的控制报文，skb.sk指向的子serve_sk（这个也会被父serve_sk接收）
			所以也会通过maybe_unmark_and_push将这个sk压栈
	4.通过sock_put将sk释放（因为maybe_unmark_and_push中增加了对sk的计数，但是pop_stack中却没有减少）
注：1.在这期间系统过maybe_unmark_and_push加入栈中的sk也会随着!empty_stack被遍历到，所以所以不是GC_ORPHAN
	的sk都会经历pop_stack，sock_put，最终栈的状态也会是empty_stack
	2.在栈中的sk不会重复压栈，因为maybe_unmark_and_push在开始就检查了GC_ORPHAN
5.通过skb_queue_head_init初始化链表hitlist
6.遍历unix_socket_table表中所有bind的sk，
	1.如果是GC_ORPHAN，并且其skb.cb.fp存在，将receive_queue中的所有skb放到hitlist
		__skb_unlink(skb, skb-&gt;list);
		__skb_queue_tail(&amp;hitlist,skb);
	2.最后将所有sk的状态都置为GC_ORPHAN
7.通过__skb_dequeue将hitlist中所有的skb移出队列，并通过kfree_skb将其释放
	（不仅包含skb空间，包含sendbuf，发送方sk计数，发送方sk.cb中的fp数组，以及数组中的file)）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1584</x>
      <y>1060</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1567</x>
      <y>1115</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>maybe_unmark_and_push</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1576</x>
      <y>1110</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1558</x>
      <y>1121</y>
      <w>32</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果不是GC_ORPHAN，直接退出（因为已经在栈中了）
2.通过sock_hold递增sk的计数
3.sk压栈
	x-&gt;protinfo.af_unix.gc_tree = gc_current
	gc_current = x
注：这里要注意栈的链表指针和标志GC_ORPHAN的指针是同一个
	所以只要sk在栈中，就不是GC_ORPHAN
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1574</x>
      <y>1118</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1600</x>
      <y>1115</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pop_stack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1598</x>
      <y>1110</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1594</x>
      <y>1122</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>p=gc_current;
gc_current = p-&gt;protinfo.af_unix.gc_tree;
return p;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1605</x>
      <y>1118</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>221</x>
      <y>1330</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>56</x>
      <y>1359</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>63</x>
      <y>1333</y>
      <w>165</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1630.0;10.0;10.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>36</x>
      <y>1366</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fcheck</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>41</x>
      <y>1362</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>40</x>
      <y>1369</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fd &lt; files-&gt;max_fds</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>34</x>
      <y>1374</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file = files-&gt;fd[fd]
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>60</x>
      <y>1362</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>62</x>
      <y>1367</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_file</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>62</x>
      <y>1374</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file.count++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>68</x>
      <y>1370</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>175</x>
      <y>1333</y>
      <w>53</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file不为空
FMODE_WRITE</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>151</x>
      <y>1344</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里只是验证访问的区域是否被锁上
并没有上锁，locks_mandatory_area
中只是临时上锁检验一下</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>145</x>
      <y>1353</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_verify_area</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>139</x>
      <y>1356</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 //上了锁
inode-&gt;i_flock &amp;&amp; 
 //该inode上强制锁
MANDATORY_LOCK(inode)</panel_attributes>
    <additional_attributes>120.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>139</x>
      <y>1363</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_mandatory_area</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>69</x>
      <y>1380</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_alloc_lock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>74</x>
      <y>1366</y>
      <w>75</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
account指示是否检查current-&gt;locks超过限制</panel_attributes>
    <additional_attributes>730.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>54</x>
      <y>1387</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>63</x>
      <y>1383</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>75</x>
      <y>1388</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;locks++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>72</x>
      <y>1383</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>90</x>
      <y>1381</y>
      <w>44</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>new_fl-&gt;fl_owner = current-&gt;files;
new_fl-&gt;fl_pid = current-&gt;pid;
new_fl-&gt;fl_file = filp;
new_fl-&gt;fl_flags = FL_POSIX | FL_ACCESS;
new_fl-&gt;fl_type = 
(read_write == FLOCK_VERIFY_WRITE) ? F_WRLCK : F_RDLCK;
new_fl-&gt;fl_start = offset; //file-&gt;f_pos
new_fl-&gt;fl_end = offset + count - 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>101</x>
      <y>1366</y>
      <w>48</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>146</x>
      <y>1366</y>
      <w>39</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历inode-&gt;i_flock链表
如果FL_POSIX置上
遍历的posix锁的start小于申请锁的end
（如果大于，直接返回正确，说明锁进行了排序）</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>147</x>
      <y>1377</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>140</x>
      <y>1384</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>posix_locks_conflict</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>147</x>
      <y>1387</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>135</x>
      <y>1391</y>
      <w>35</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.申请的锁没打开posix锁的，直接返回正确（0）
2，是同一个进程加的锁，直接返回正确（0）
	//是同一个files
	fl1-&gt;fl_owner == fl2-&gt;fl_owner
	//是同一个pid
	&amp;&amp; fl1-&gt;fl_pid   == fl2-&gt;fl_pid
3.检查申请的lock（sys_fl），和存在的lock（caller_fl）
	是否有重叠
	(fl1-&gt;fl_end &gt;= fl2-&gt;fl_start) &amp;&amp;
	(fl2-&gt;fl_end &gt;= fl1-&gt;fl_start)
4.如果有重叠，如果存在的lock是读锁（F_RDLCK），
	申请的lock是写锁，则错误（1）
	如果申请的是写锁，则错误（1）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>155</x>
      <y>1377</y>
      <w>34</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果存在冲突</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>173</x>
      <y>1388</y>
      <w>64</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果file是O_NONBLOCK（不能阻断的），返回-EAGAIN
2.查看如果加上申请的锁，是否会形成死锁，如果死锁，返回-EDEADLK
	posix_locks_deadlock
		1.查看申请的锁和阻塞锁是否属于同一个进程（AA）,如果是的话，就是死锁
		2.等待锁序列blocked_list中是否有和阻塞锁是同一个进程的，如果有，说明
		阻塞锁所在的进程被pending（注释说等待序列blocked_list中同一个进程，正在等待
		的锁只有一个，是因为进程只要有一个锁在等待序列中，进程就pending）
		3.在等待序列中的锁的fl_next字段，指向的是这个所等待的锁（见locks_block_on）（
		不在这个等待序列中的fl_next字段是连在inode-&gt;i_flock链表中的），
		4.如果找到等待序列中的锁和block的锁属于同一进程，说明该进程被另一个进程的锁block，具体对应
		的锁是fl-&gt;fl_next，如果这个锁和要申请的锁属于同一个进程，那么就发生死锁（AB BA）。
		5.如果不是同一个进程，重复2，3，4，查看是否有没有AB BA的死锁
3.	如果不会死锁，通过locks_block_on对进程加锁
4.如果醒来之后，发现强制锁被清了之后，直接退出，否者重新查看该锁是否存在冲突
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>194</x>
      <y>1415</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_block_on</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>201</x>
      <y>1411</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>153</x>
      <y>1422</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_insert_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>190</x>
      <y>1423</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>interruptible_sleep_on_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>265</x>
      <y>1422</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_delete_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>161</x>
      <y>1418</y>
      <w>41</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>200</x>
      <y>1418</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>200</x>
      <y>1418</y>
      <w>74</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>126</x>
      <y>1430</y>
      <w>34</w>
      <h>13</h>
    </coordinates>
    <panel_attributes> //加在blocker的链表中，链表中的实体被blocker阻塞
list_add_tail(&amp;waiter-&gt;fl_block,
			&amp;blocker-&gt;fl_block);
 //注意这里fl_next指向的是阻塞自己的实体
waiter-&gt;fl_next = blocker;
 //加载在等待序列中
list_add(&amp;waiter-&gt;fl_link, &amp;blocked_list);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>137</x>
      <y>1425</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>162</x>
      <y>1435</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>current-&gt;state = TASK_INTERRUPTIBLE;
 //加到等待锁的唤醒队列中
add_wait_queue(fl_wait, &amp;wait);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>173</x>
      <y>1426</y>
      <w>30</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>201</x>
      <y>1426</y>
      <w>6</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>198</x>
      <y>1432</y>
      <w>9</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
timeout=0</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>201</x>
      <y>1432</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
时间到了之后自己被timer唤醒</panel_attributes>
    <additional_attributes>40.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>192</x>
      <y>1438</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>209</x>
      <y>1437</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>schedule_timeout</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>201</x>
      <y>1426</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
有不是block的信号将其唤醒时
报错ERESTARTSYS</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>227</x>
      <y>1436</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>signal_pending</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>244</x>
      <y>1436</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_wait_queue(fl_wait, &amp;wait);
current-&gt;state = TASK_RUNNING;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>201</x>
      <y>1426</y>
      <w>55</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;530.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>272</x>
      <y>1431</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>list_del(&amp;waiter-&gt;fl_block);
INIT_LIST_HEAD(&amp;waiter-&gt;fl_block);
list_del(&amp;waiter-&gt;fl_link);
INIT_LIST_HEAD(&amp;waiter-&gt;fl_link);
waiter-&gt;fl_next = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>272</x>
      <y>1425</y>
      <w>9</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>346</x>
      <y>1347</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;write
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>175</x>
      <y>1344</y>
      <w>179</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1770.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>359</x>
      <y>1354</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_file_write
1.计算pos，算出在inode的逻辑block
2.根据逻辑block和adress_space看是否存在内存（page）（__grab_cache_page）
3.如果没有内存就要分配page和bh（create_empty_buffers）
4.如果是分配的bh，需要由逻辑block推导出实际block（ext2_get_block）
5.如果实际block不存在，需要create（ext2_find_goal 找到实际block
	ext2_alloc_branch 使索引chain完整
	）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>352</x>
      <y>1350</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_file_operations</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>243</x>
      <y>1357</y>
      <w>125</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file-&gt;f_error
如果之前有错，直接返回</panel_attributes>
    <additional_attributes>1230.0;10.0;10.0;290.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>238</x>
      <y>1386</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_error=0
goto out
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>258</x>
      <y>1357</y>
      <w>110</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
O_APPEND</panel_attributes>
    <additional_attributes>1080.0;10.0;10.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>251</x>
      <y>1387</y>
      <w>15</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>pos = inode-&gt;i_size
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>269</x>
      <y>1357</y>
      <w>100</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;rlim[RLIMIT_FSIZE].rlim_cur
 != RLIM_INFINITY</panel_attributes>
    <additional_attributes>980.0;10.0;10.0;280.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>267</x>
      <y>1385</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果现在文件的位置pos已经超过了limit
	send_sig(SIGXFSZ, current, 0);
	goto out;
2.如果要添加的内容超过了limit
	send_sig(SIGXFSZ, current, 0);
 //pos如果不是append，就是file-&gt;f_pos
	count = limit - pos;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>313</x>
      <y>1357</y>
      <w>56</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
count
如果此次写操作有效</panel_attributes>
    <additional_attributes>540.0;10.0;10.0;270.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>303</x>
      <y>1383</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>298</x>
      <y>1390</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_suid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>258</x>
      <y>1400</y>
      <w>45</w>
      <h>7</h>
    </coordinates>
    <panel_attributes> //如果S_IXGRP置上，就将S_ISGID置上，S_ISUID一直置
mode = (inode-&gt;i_mode &amp; S_IXGRP)*(S_ISGID/S_IXGRP) | S_ISUID;
	//这里是查看inode中的S_ISGID和S_ISUID权限
mode &amp;= inode-&gt;i_mode;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>286</x>
      <y>1393</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>295</x>
      <y>1393</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果inode有S_ISGID和S_ISUID权限，
但是进程却不具备setuid的特权
mode &amp;&amp; !capable(CAP_FSETID)</panel_attributes>
    <additional_attributes>80.0;10.0;170.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>308</x>
      <y>1401</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //清除inode的setuid特权
inode-&gt;i_mode &amp;= ~mode;
mark_inode_dirty(inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>313</x>
      <y>1383</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>311</x>
      <y>1390</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_ctime = inode-&gt;i_mtime = CURRENT_TIME;
mark_inode_dirty_sync(inode)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>366</x>
      <y>1357</y>
      <w>21</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环写入数据字节数count</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>354</x>
      <y>1372</y>
      <w>19</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>349</x>
      <y>1391</y>
      <w>27</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>offset = (pos &amp; (PAGE_CACHE_SIZE -1));
index = pos &gt;&gt; PAGE_CACHE_SHIFT;
 //现在一页内写入数据
bytes = PAGE_CACHE_SIZE - offset;
 //写入的长度最大不能超过count
if (bytes &gt; count) {
	bytes = count;
	deactivate = 0;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>385</x>
      <y>1392</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__grab_cache_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>370</x>
      <y>1372</y>
      <w>23</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>377</x>
      <y>1401</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>381</x>
      <y>1395</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>353</x>
      <y>1409</y>
      <w>32</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_hash_table+_page_hashfn(mapping,index)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>371</x>
      <y>1404</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>398</x>
      <y>1400</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__find_lock_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>393</x>
      <y>1395</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>386</x>
      <y>1408</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__find_page_nolock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>392</x>
      <y>1403</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>365</x>
      <y>1415</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.遍历hash，过滤出mapping相同，index相同的page
2.增加引用page的寿命，如果page短缺，将激活kswapd进程
age_page_up(page);
if (inactive_shortage() &gt; inactive_target / 2 &amp;&amp; free_shortage())
		wakeup_kswapd(0);
注：page-&gt;index被抽象为在硬盘的偏移，普通的page被抽象为在
	交换设备中的偏移inode的buffer被抽象为在inode中的偏移
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>380</x>
      <y>1411</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>400</x>
      <y>1410</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>400</x>
      <y>1403</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在hash中找到page</panel_attributes>
    <additional_attributes>60.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>401</x>
      <y>1405</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加page.count的计数</panel_attributes>
    <additional_attributes>90.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>415</x>
      <y>1410</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lock_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>409</x>
      <y>1405</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>407</x>
      <y>1417</y>
      <w>40</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.TryLockPage，这里调用test_and_set_bit，
	会将page锁上，并通过sbbl检查之前的位，如果是0
	则返回0，否则返回-1
2.如果不为0，__lock_page
	1.增加局部变量wait（current），并将其加入到page-&gt;wait
	2.利用page提供的硬盘的page-&gt;mapping，将page同步到硬盘
	3.将task设置为TASK_UNINTERRUPTIBLE
	4.如果此时page还是锁着的，将tq_disk链表中存储的routine
		执行一遍（run_task_queue），然后调度schedule
	5.醒来之后继续TryLockPage
	6.如果锁上之后：
		tsk-&gt;state = TASK_RUNNING;
		remove_wait_queue(&amp;page-&gt;wait, &amp;wait)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>420</x>
      <y>1413</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>433</x>
      <y>1411</y>
      <w>10</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>return page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>409</x>
      <y>1405</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page-&gt;mapping
如果醒来之后还在hash</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>449</x>
      <y>1411</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>UnlockPage(page);
page_cache_release(page);
goto repeat;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>408</x>
      <y>1405</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不在hash中，则释放这个page，重新查找</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>394</x>
      <y>1393</y>
      <w>87</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在hash中没找到page</panel_attributes>
    <additional_attributes>10.0;10.0;850.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>473</x>
      <y>1410</y>
      <w>39</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.如果caller提供了cached_page,就使用caller提供的（或者
	在下面add_to_page_cache_unique为1时，cache中的页面）
	否者通过page_cache_alloc申请一个页面
2.调用add_to_page_cache_unique
	1.__find_page_nolock查找是否在page
	2.如果在hash中没找到，利用__add_to_page_cache加入
		到hash和inode的链表中
	__add_to_page_cache
		//清掉flag
		flags = page-&gt;flags &amp; ~((1 &lt;&lt; PG_uptodate) | (1 &lt;&lt; PG_error) | (1 &lt;&lt; PG_dirty) | (1 &lt;&lt; PG_referenced) | (1 &lt;&lt; PG_arch_1));
		//置上lock
		page-&gt;flags = flags | (1 &lt;&lt; PG_locked);
		//增加计数和在inode中的偏移
		page_cache_get(page);
		page-&gt;index = offset;
		//将page加在inode的clean page中，并将page的mapping映射到inode上
		add_page_to_inode_queue
			*head = &amp;mapping-&gt;clean_pages;
			mapping-&gt;nrpages++;
			list_add(&amp;page-&gt;list, head);
			page-&gt;mapping = mapping;
		//将page添加到hash中
		add_page_to_hash_queue
		//添加到active_list中
		lru_cache_add（加入到active_list）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>370</x>
      <y>1372</y>
      <w>71</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;690.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>433</x>
      <y>1391</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page要locked
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>484</x>
      <y>1391</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;prepare_write
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>371</x>
      <y>1372</y>
      <w>126</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1240.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>509</x>
      <y>1400</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_prepare_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>495</x>
      <y>1394</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_aops</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>539</x>
      <y>1409</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_prepare_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>516</x>
      <y>1403</y>
      <w>32</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_get_block</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>514</x>
      <y>1418</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode = 
page-&gt;mapping-&gt;host
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>519</x>
      <y>1412</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page对应的inode</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>545</x>
      <y>1418</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__block_prepare_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>546</x>
      <y>1412</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>515</x>
      <y>1426</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blocksize = 
inode-&gt;i_sb-&gt;s_blocksize
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>522</x>
      <y>1421</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>538</x>
      <y>1427</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_empty_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>542</x>
      <y>1421</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果这个页面没有分配bh
!page-&gt;buffers</panel_attributes>
    <additional_attributes>120.0;10.0;40.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>518</x>
      <y>1434</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>522</x>
      <y>1430</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>523</x>
      <y>1437</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从PAGE_SIZE开始，每个
bh管理blocksize的长度
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>1442</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>494</x>
      <y>1449</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_unused_buffer_head</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>468</x>
      <y>1452</y>
      <w>36</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果unused_list有足够的bh
nr_unused_buffer_heads &gt; NR_RESERVED</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>453</x>
      <y>1461</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>bh = unused_list;
unused_list = bh-&gt;b_next_free;
nr_unused_buffer_heads--;
return bh
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>497</x>
      <y>1452</y>
      <w>16</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没有足够的bh</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>478</x>
      <y>1462</y>
      <w>38</w>
      <h>14</h>
    </coordinates>
    <panel_attributes> //注释说SLAB_BUFFER不会因为申请不到内存将
 //page换出，产生更多的bh，但是从2.4.0中我暂时
 //没看到相关的代码，但是在3.4.2中__zone_watermark_ok
 //中的ALLOC_HIGH可能让page更容易从reserve的page中
 //申请到
kmem_cache_alloc(bh_cachep, SLAB_BUFFER)
memset(bh, 0, sizeof(*bh));
init_waitqueue_head(&amp;bh-&gt;b_wait)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>502</x>
      <y>1452</y>
      <w>22</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果想内存没有申请到page
并且async置上，就像reserve的
unused_list中继续申请</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>518</x>
      <y>1464</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>bh = unused_list;
unused_list = bh-&gt;b_next_free;
nr_unused_buffer_heads--;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>523</x>
      <y>1442</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果申请到bh</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>539</x>
      <y>1450</y>
      <w>29</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>bh-&gt;b_dev = B_FREE;
 //将申请的bh加到head链表中
bh-&gt;b_this_page = head;
head = bh;

bh-&gt;b_state = 0;
bh-&gt;b_next_free = NULL;
bh-&gt;b_pprev = NULL;
atomic_set(&amp;bh-&gt;b_count, 0);
bh-&gt;b_size = size;

set_bh_page(bh, page, offset);
	bh-&gt;b_page = page
	if PageHighMem
		bh-&gt;b_data = (char *)(0 + offset);
	else
		bh-&gt;b_data = page_address(page) + offset;

bh-&gt;b_list = BUF_CLEAN;
bh-&gt;b_end_io = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>523</x>
      <y>1437</y>
      <w>59</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果中间没有申请到bh</panel_attributes>
    <additional_attributes>10.0;10.0;570.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>574</x>
      <y>1447</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>no_grow
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>571</x>
      <y>1456</y>
      <w>31</w>
      <h>23</h>
    </coordinates>
    <panel_attributes> //释放申请的bh
bh = head;
head = head-&gt;b_this_page;
__put_unused_buffer_head(bh);
wake_up(&amp;buffer_wait)

if (!async)
	return NULL;

run_task_queue(&amp;tq_disk);
 //这里是通过宏建wait的queue，然后schedule，
 //等待唤醒后，检查condition
wait_event(buffer_wait,
			nr_unused_buffer_heads &gt;= MAX_BUF_PER_PAGE)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>579</x>
      <y>1450</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>545</x>
      <y>1430</y>
      <w>65</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;630.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>604</x>
      <y>1437</y>
      <w>20</w>
      <h>25</h>
    </coordinates>
    <panel_attributes> //遍历返回的head链表，
 //将bh进行填充
do {
	bh-&gt;b_dev = dev;
	bh-&gt;b_blocknr = 0;
	bh-&gt;b_end_io = NULL;
	tail = bh;
	bh = bh-&gt;b_this_page;
} while (bh);

 //page对应的bh形成循环链表
tail-&gt;b_this_page = head;
 //page指向bh的链表
page-&gt;buffers = head;
page_cache_get(page);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>564</x>
      <y>1425</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>bbits = inode-&gt;i_sb-&gt;s_blocksize_bits;
 //要写区域的逻辑block偏移
block = page-&gt;index &lt;&lt; (PAGE_CACHE_SHIFT 
					- bbits)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>553</x>
      <y>1421</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>553</x>
      <y>1421</y>
      <w>88</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历page-&gt;buffers链表</panel_attributes>
    <additional_attributes>10.0;10.0;860.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>625</x>
      <y>1434</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.block_end = block_start+blocksize;
2.filter：from~to要和bh所在的区间有重合
	//bh还没到要操作的区间（继续下一个bh）
	block_end &lt;= from
	//bh已经超过了要操作的区间（退出循环）
	block_start &gt;= to
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>634</x>
      <y>1425</y>
      <w>7</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>637</x>
      <y>1425</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!buffer_mapped
bh.b_state的Mapped没置上
BH_Mapped:表示bh和实际block映射起来了</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>670</x>
      <y>1437</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_block
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>665</x>
      <y>1430</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>676</x>
      <y>1440</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;35.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>690</x>
      <y>1443</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_get_block
注：ext2_get_block包括寻找chain，补全chain，而获取实际的block号给bh
getblk是根据dev和实际block号找到bh（包括创建bh及其内存）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>637</x>
      <y>1425</y>
      <w>154</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果page的PG_uptodate置上
bh的BH_Uptodate肯定会置上
Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;1520.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>783</x>
      <y>1429</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_bit(BH_Uptodate, &amp;bh-&gt;b_state);
continue;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>638</x>
      <y>1424</y>
      <w>184</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 //磁盘上的内容没有更新到内存
!buffer_uptodate(bh) &amp;&amp;
 //bh中有一段内存不在操作的区域
 //注：前面有filter，所以bh必定是有一部分
 //是要操作的区域，所以这里只是一部分没落在
 //要操作的区域
(block_start &lt; from || block_end &gt; to)</panel_attributes>
    <additional_attributes>10.0;20.0;1820.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>810</x>
      <y>1427</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>ll_rw_block(READ, 1, &amp;bh);
 //wait_bh指向wait，wait是
 //包含两个（包含两个的原因是：
 //不全在操作范围的bh最多只有
 //两个，前面一个，后面一个）
 //函数指针的数组，
*wait_bh++=bh;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>553</x>
      <y>1421</y>
      <w>292</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2900.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>840</x>
      <y>1426</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //等待要读的bh全部读完
while(wait_bh &gt; wait) {
	wait_on_buffer(*--wait_bh);
	if (!buffer_uptodate(*wait_bh))
		goto out;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>626</x>
      <y>1455</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_block_to_path</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>633</x>
      <y>1446</y>
      <w>64</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>604</x>
      <y>1464</y>
      <w>59</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果小于EXT2_NDIR_BLOCKS（12），属于直接索引（逻辑block就是索引号）
2.如果上述条件不满足，但是小于EXT2_ADDR_PER_BLOCK（一个block可以存放
	多少个block号），属于间接索引， 	首层索引为EXT2_IND_BLOCK（12），第二层
	索引为i_block -= direct_blocks
3.如果小于double_blocks（ptrs_bits * 2个bit），属于二层索引，首层索引号为
	EXT2_DIND_BLOCK（13），第二层索引号为i_block &gt;&gt; ptrs_bits，第三层索引号
	为i_block &amp; (ptrs - 1)
4.如果小于ptrs_bits * 3（因为ptrs有一个ptrs_bits），首层索引为EXT2_TIND_BLOCK（14）
	第二程索引为i_block &gt;&gt; (ptrs_bits * 2)，第三层索引为(i_block &gt;&gt; ptrs_bits) &amp; (ptrs - 1)
	第四层索引为i_block &amp; (ptrs - 1)
注：在这里if..elseif..中是先执行i_block -= ，然后在进行判断，所以这里已经将前面判断的值给减掉了
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>628</x>
      <y>1458</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>679</x>
      <y>1455</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_get_branch</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>680</x>
      <y>1446</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果正常找到block，返回NULL
有其他异常，则返回当前的chain</panel_attributes>
    <additional_attributes>160.0;10.0;50.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>665</x>
      <y>1464</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_chain</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>664</x>
      <y>1472</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.p指向bh+offset
2.k记录下一个的实际block号
3.bh指向实际block号所在的buffer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>670</x>
      <y>1458</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>671</x>
      <y>1467</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>682</x>
      <y>1458</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历depth（索引层次）次，
寻找逻辑block对应的实际block号</panel_attributes>
    <additional_attributes>40.0;10.0;180.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>686</x>
      <y>1468</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>689</x>
      <y>1464</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>697</x>
      <y>1468</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>verify_chain</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>699</x>
      <y>1464</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>689</x>
      <y>1475</y>
      <w>41</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.遍历暂存的chain数组，验证读进来的block号有没有被修改
	from-&gt;key == *from-&gt;p
注：注意p是指针，指向的是bh中的一个block号，k是之前从这个
	这个地址中拿来放在chain数组中，在bread时，有可能休眠，
	其他进程有可能将这段给删了，导致之前存的key和现在去的*p
	不一致，所以在这里为了功能安全，需要加以验证
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>701</x>
      <y>1471</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>710</x>
      <y>1468</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_chain</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>699</x>
      <y>1464</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将读入的数据存储在chain中</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>696</x>
      <y>1446</y>
      <w>25</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果找到了实际的block
!partial</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>724</x>
      <y>1460</y>
      <w>36</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>bh_result-&gt;b_dev = inode-&gt;i_dev;
 //物理block号
bh_result-&gt;b_blocknr = le32_to_cpu(chain[depth-1].key);
bh_result-&gt;b_state |= (1UL &lt;&lt; BH_Mapped);
 //这里将partial赋值为最后一个chain
partial = chain+depth-1
goto cleanup
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>712</x>
      <y>1453</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>got_it
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>719</x>
      <y>1456</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>761</x>
      <y>1453</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cleanup
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>696</x>
      <y>1446</y>
      <w>73</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将暂存在chain中的bh释放

如果没找到实际block号，但是
没有要求创建，或者要求创建，但是
出现了EIO,即没有将磁盘中的内容通过
bread读到buffer中，会执行clean_up，并返回err</panel_attributes>
    <additional_attributes>10.0;10.0;710.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>762</x>
      <y>1461</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>while (partial &gt; chain) {
	brelse(partial-&gt;bh);
	partial--;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>767</x>
      <y>1456</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>696</x>
      <y>1446</y>
      <w>118</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
没有找到相应的block
err ！= -EAGAIN
err ！= -EIO
partial！=NULL
create!=0</panel_attributes>
    <additional_attributes>10.0;10.0;1160.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>788</x>
      <y>1452</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里是找到一个物理block
用于与这个逻辑block映射
原则：尽量文件的物理block全部放在一起
	并且连续</panel_attributes>
    <additional_attributes>240.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>784</x>
      <y>1460</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_find_goal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>750</x>
      <y>1473</y>
      <w>53</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>1.如果要分配的逻辑block只比预期要分配的逻辑block大1，
	将预期分配的逻辑block和物理block都加1.（这样使预期分配的
	逻辑block和要分配的逻辑block相等，直接使用i_next_alloc_goal
	而不通过ext2_find_near去寻找实际要分配的block）
	inode-&gt;u.ext2_i.i_next_alloc_block++;
	inode-&gt;u.ext2_i.i_next_alloc_goal++;
2.通过verify_chain验证要分配block的路径的有效性（没有其他进程对这条
	映射链有更改）
3.如果要分配的逻辑block和预期分配的逻辑block（i_next_alloc_block）
	相等，要分配的实际block就为预期分配的实际block（i_next_alloc_goal）
4.如果不相等（或者之前这个inode没有进入过ext2_find_goal，此时
	i_next_alloc_goal为0）就通过ext2_find_near寻找实际block供分配
	
	ext2_find_near
		1.寻找到当前key为0所在的block
		2.在这个block中遍历key为0之前的内存，如果发现内存中的实际block不为0，
			那之后就从这个设备block向前找到这个空闲的block
		3.在这个block中遍历key为0之前的内存，发现key都为0，那么这个间接映射可能是
			inode申请的最后一个block，所以以这个间接映射所在的block为起始点开始寻找
			（ind-&gt;bh-&gt;b_blocknr）
		4.如果不是间接映射的block，就以inode所在的第一个group所在的第一个data_blcok
			开始寻找实际的block（s_first_data_block）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>777</x>
      <y>1463</y>
      <w>14</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>798</x>
      <y>1463</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>left = (chain + depth) - partial
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>810</x>
      <y>1452</y>
      <w>22</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
剩下的没有被映射的间接索引</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>841</x>
      <y>1463</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_alloc_branch</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>811</x>
      <y>1452</y>
      <w>38</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到相应的block
填充好chain
</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>828</x>
      <y>1473</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_alloc_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>830</x>
      <y>1466</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更具goal找到实际的设备block
</panel_attributes>
    <additional_attributes>170.0;10.0;30.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1042</x>
      <y>1474</y>
      <w>47</w>
      <h>43</h>
    </coordinates>
    <panel_attributes>1.将找到的block（parent）放在断裂的chain中（branch）
	branch[0].key = cpu_to_le32(parent)
2.如果找到了block，将所有的没有映射的chain进行填充
	1.找到下一个映射的block（ext2_alloc_block）
	2.填充chain
		1.branch[n].key = cpu_to_le32(nr)
		2.获取parent的bh，并memset（没有获取最后一个bh，因为最后一个bh是作为参数传给
			ext2_get_block）
			bh = getblk(inode-&gt;i_dev, parent, blocksize);
			if (!buffer_uptodate(bh))
				wait_on_buffer(bh);
			memset(bh-&gt;b_data, 0, blocksize);
			branch[n].bh = bh
		3.branch[n].p = (u32*) bh-&gt;b_data + offsets[n];
		4.将key写到内存（注branch[0]的p出没写，也就是和chain还没连起来）
			*branch[n].p = branch[n].key;
			mark_buffer_uptodate(bh, 1);
			mark_buffer_dirty_inode(bh, inode);
		5.如果需要同步写入，就请求写
			if (IS_SYNC(inode) || inode-&gt;u.ext2_i.i_osync) {
				ll_rw_block (WRITE, 1, &amp;bh);
				wait_on_buffer (bh);
			}
3.如果ext2_alloc_block每次都能找到设备block，最后都是n==num,返回0
4.如果ext2_alloc_block出错，就释放bh（bforget(branch[i].bh)）和
	block（ext2_free_blocks），并返回error
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>846</x>
      <y>1466</y>
      <w>204</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2020.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>812</x>
      <y>1476</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果inode的i_prealloc_count不为0
并且goal最多比i_prealloc_block大1</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>804</x>
      <y>1486</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>result = inode-&gt;u.ext2_i.i_prealloc_block++;
inode-&gt;u.ext2_i.i_prealloc_count--;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>832</x>
      <y>1476</y>
      <w>16</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不满足左边的条件</panel_attributes>
    <additional_attributes>20.0;10.0;130.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>833</x>
      <y>1487</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_discard_prealloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>839</x>
      <y>1483</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>806</x>
      <y>1495</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode-&gt;u.ext2_i.i_prealloc_count = 0;
inode-&gt;u.ext2_i.i_prealloc_block = 0;
ext2_free_blocks
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>823</x>
      <y>1490</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>871</x>
      <y>1488</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_new_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>844</x>
      <y>1483</y>
      <w>38</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是S_ISREG，需要填充i_prealloc_count
和i_prealloc_block。否则不用填充</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>810</x>
      <y>1502</y>
      <w>36</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果超级块的空闲block数量小于reserve的数量
	即需要sb的s_resuid在fsuid中，或者sb的s_resgid
	所在的组为超级用户，或者在fsgid所在的组，或者进程有
	CAP_SYS_RESOURCE权限
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>825</x>
      <y>1491</y>
      <w>53</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>847</x>
      <y>1504</y>
      <w>29</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>goal = le32_to_cpu(es-&gt;s_first_data_block)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>853</x>
      <y>1491</y>
      <w>29</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果超出了sb规定的block范围
goal &lt; le32_to_cpu(es-&gt;s_first_data_block) ||
goal &gt;= le32_to_cpu(es-&gt;s_blocks_count)</panel_attributes>
    <additional_attributes>230.0;10.0;50.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>878</x>
      <y>1504</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_get_group_desc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>875</x>
      <y>1491</y>
      <w>14</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取desc</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>894</x>
      <y>1504</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>load_block_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>875</x>
      <y>1491</y>
      <w>29</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
i为所在的block_group
j为在group中的序号

返回在s_block_bitmap_number或者
s_block_bitmap的位置</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>864</x>
      <y>1512</y>
      <w>48</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.代码运行的局部性：
	如果加载过block_bitmap（s_loaded_block_bitmaps &gt; 0）
	首先查看0处是否为要查找的block_group
2.如果磁盘的所有group都不超过最大的缓存数
	（s_groups_count &lt;=EXT2_MAX_GROUP_LOADED）
	此时block_group为其数组的索引，所以查看
	sb-&gt;u.ext2_sb.s_block_bitmap_number[block_group] == block_group &amp;&amp;
 	sb-&gt;u.ext2_sb.s_block_bitmap[block_group]
3.通过__load_block_bitmap将新加的block_group加载进来
	1.要加载的block_group不能大于s_groups_count
	2.当磁盘的group总量小于加载的内存数量（s_groups_count
											&lt;= EXT2_MAX_GROUP_LOADED）
		read_block_bitmap
	3.遍历s_loaded_block_bitmaps，看是block_group的位图是否存在于内存中
		如果存在将block_group在s_block_bitmap_number和s_block_bitmap
		中的位置移到第0位；
		如果不在，腾出一个内存单元（s_loaded_block_bitmaps++或者brelse）
		并通过read_block_bitmap读到第0位
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>889</x>
      <y>1507</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>877</x>
      <y>1546</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_block_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>884</x>
      <y>1542</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>859</x>
      <y>1553</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>862</x>
      <y>1549</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>874</x>
      <y>1553</y>
      <w>42</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;u.ext2_sb.s_block_bitmap_number[bitmap_nr] = block_group;
sb-&gt;u.ext2_sb.s_block_bitmap[bitmap_nr] = bh;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>884</x>
      <y>1549</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>908</x>
      <y>1500</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_test_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>875</x>
      <y>1491</y>
      <w>43</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
测试第i组的第j个block
是否被占用</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>910</x>
      <y>1507</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>got_block
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>914</x>
      <y>1503</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果为0表示没有被占用</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>876</x>
      <y>1491</y>
      <w>76</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果ext2_test_bit不为0</panel_attributes>
    <additional_attributes>10.0;10.0;740.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>930</x>
      <y>1501</y>
      <w>53</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.如果j不为0，通过ext2_find_next_zero_bit寻找位图中为0的索引
	end_goal为其搜索的结束地址（64位对齐）
2.如果还没找到，从end_goal继续查找，直到查找到EXT2_BLOCKS_PER_GROUP
	memscan
	__asm__("repnz; scasb //edi++,ecx--，如果edi！=eax或者ecx&gt;0则继续
		jnz 1f
		dec %%edi //将addr恢复到原来相等的地址
	1:		"
		: "=D" (addr), "=c" (size)
		: "0" (addr), "1" (size), "a" (c));
	如果发现连续8位都为0，search_back去向之前查找!ext2_test_bit (j - 1, bh-&gt;b_data)
	将j更新为最小的空闲block，然后got_block
3.如果在本group没有找到，遍历之后的group，只要其中的bg_free_blocks_count&gt;0，
	就加载其block_bitmap
	先连续查看是否有连续8bit的空闲block（memscan(bh-&gt;b_data, 
				0, EXT2_BLOCKS_PER_GROUP(sb) &gt;&gt; 3)）
	如果没有，通过ext2_find_first_zero_bit查找空闲的block
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>875</x>
      <y>1491</y>
      <w>130</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1280.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>999</x>
      <y>1499</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>got_block
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>986</x>
      <y>1507</y>
      <w>48</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.计算获得的实际block号（group号，s_first_data_block都加进去）
2.获得的block号，不能是本group的block位图区（s_first_data_block）
	也不能是inode位图区（bg_inode_bitmap），也不能在inode所在的block
	区（e32_to_cpu(gdp-&gt;bg_inode_table),
		      sb-&gt;u.ext2_sb.s_itb_per_group）
3.将group中相应的block位图置上（ext2_set_bit），mark_buffer_dirty
4.获取的block号不能大于磁盘最大的block号（s_blocks_count）
5.gdp-&gt;bg_free_blocks_count--，并将其标记为dirty（mark_buffer_dirty）
6.s_free_blocks_count--，将超级块标记为dirty
	mark_buffer_dirty(sb-&gt;u.ext2_sb.s_sbh);
	sb-&gt;s_dirt = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1004</x>
      <y>1502</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1061</x>
      <y>1520</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getblk
1.lru_list,如果正在被使用会被加入到iru_list和hash中
	此时b_count不为0，且b_blocknr存在
2.free_list，如果进程释放掉这个bh，b_count为0，不在
	hash表中，但是b_blocknr存在（page能再次利用）
3.unused_list，这个是bh所指向的page被释放，此时b_count为0，
	不在hash表中，且b_blocknr=-1（要申请page才能利用）
注：1.从这里暂时没看出unused_list和free_list的不同，但是在try_to_free_buffer
中有当b_dev不存在时，将bh从free_list移除，然后放到unused_list中释放
2.这里的touch_buffer是增加page寿命，使其不会被老化换出
3.这里block的传参，是设备上的block号，并不是文件的逻辑block号</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1066</x>
      <y>1516</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1013</x>
      <y>1531</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_hash_table</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1020</x>
      <y>1523</y>
      <w>49</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1004</x>
      <y>1537</y>
      <w>28</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.遍历hash_table（dev和block作为杂凑值）
	中的b_next
2.查看下面字段
bh-&gt;b_blocknr == block	&amp;&amp;
bh-&gt;b_size    == size	&amp;&amp;
bh-&gt;b_dev     == dev
3.增加bh-&gt;b_count计数
4.goto out
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1019</x>
      <y>1534</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1064</x>
      <y>1523</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从free_list对应的size中查找
如果有空闲的bh</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1040</x>
      <y>1532</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__remove_from_free_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1048</x>
      <y>1528</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1035</x>
      <y>1539</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果free_list中只有bh一个（b_next_free指向自己）
	 free_list[index].list = NULL;
2.如果不止一个，将bh从free链表中删除，如果free_list
	指向的是bh，就将free_list指向bh-&gt;b_next_free
3.将bh链表置空
	bh-&gt;b_next_free = bh-&gt;b_prev_free = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1047</x>
      <y>1535</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1064</x>
      <y>1528</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1075</x>
      <y>1532</y>
      <w>31</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>atomic_set(&amp;bh-&gt;b_count, 1)
init_buffer
	bh-&gt;b_list = BUF_CLEAN;
	bh-&gt;b_end_io = handler;（这里是NULL）
	bh-&gt;b_private = private;（这里是NULL）
bh-&gt;b_dev = dev;
bh-&gt;b_blocknr = block;
bh-&gt;b_state = 1 &lt;&lt; BH_Mapped;
__insert_into_queues
out:
touch_buffer  (SetPageReferenced(bh-&gt;b_page))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1058</x>
      <y>1553</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__insert_into_queues</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1065</x>
      <y>1550</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1043</x>
      <y>1561</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__hash_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1060</x>
      <y>1560</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__insert_into_lru_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1048</x>
      <y>1556</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将bh头插至hash中
并将hash指向bh
注：b_pprev指向箭头</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1066</x>
      <y>1556</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1049</x>
      <y>1572</y>
      <w>38</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果lru_list为空，首先将其初始化，使后面的接口操作统一
	*bhp = bh;
	bh-&gt;b_prev_free = bh;
2.将bh尾插至lru链表的最后
	bh-&gt;b_next_free = *bhp;
	bh-&gt;b_prev_free = (*bhp)-&gt;b_prev_free;
	(*bhp)-&gt;b_prev_free-&gt;b_next_free = bh;
	(*bhp)-&gt;b_prev_free = bh;
	nr_buffers_type[blist]++;
	size_buffers_type[blist] += bh-&gt;b_size;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1062</x>
      <y>1563</y>
      <w>15</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里是循环链表
没有pprev</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1149</x>
      <y>1532</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>refill_freelist</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1066</x>
      <y>1523</y>
      <w>92</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果从hash或者free_list中都没找到
</panel_attributes>
    <additional_attributes>10.0;10.0;900.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1119</x>
      <y>1538</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>balance_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1124</x>
      <y>1535</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1113</x>
      <y>1546</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>balance_dirty_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1117</x>
      <y>1541</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1075</x>
      <y>1561</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.计算所有空闲页的数量（free_pages inactive_clean_pages
	inactive_dirty_pages）
2.最小为freepages.high + inactive_target（考虑到kswapd会将
	空闲页恢复到这个数量）
3.然后还要算上nr_active_pages &gt;&gt; 4（应该是考虑到页的换出）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1105</x>
      <y>1549</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1097</x>
      <y>1554</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nr_free_buffer_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1079</x>
      <y>1557</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1117</x>
      <y>1561</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果BUF_DIRTY的数量大于hard_dirty_limit的数量，需要同步
	的将页面进行同步到硬盘
2.如果BUF_DIRTY的数量大于soft_dirty_limit的数量，或者nr_inactive_dirty_pages
	的页面过多，会异步将页面写入硬盘
3.否则不进行flush操作
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1119</x>
      <y>1549</y>
      <w>13</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1142</x>
      <y>1546</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wakeup_bdflush</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1125</x>
      <y>1541</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果需要flush</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1131</x>
      <y>1551</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1136</x>
      <y>1548</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>100.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1160</x>
      <y>1552</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_dirty_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1147</x>
      <y>1549</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果需要同步的flush</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1159</x>
      <y>1560</y>
      <w>49</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.遍历lru_list[BUF_DIRTY]，这里用的是nr_buffers_type，是因为
	__refile_buffer可能使这个链表没有遍历完全，或者成为死循环
2.!buffer_dirty，如果dirty没置上，就将其移到相应的lru链表中
3.buffer_locked，bh正在想硬盘写，不用管，继续下一个
4.check_flushtime置上时，check有没有超时（bh-&gt;b_flushtime）
	没置上时，检查写入到硬盘的dirty_page是否超过bdf_prm.b_un.ndirty
	（最大写入硬盘的dirty_page数）
5.如果上述filter成立，ll_rw_block(WRITE, 1, &amp;bh)
6.如果在wake_up_process中need_resched置上，直接让当前进程进行调度
	schedule
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1167</x>
      <y>1555</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1149</x>
      <y>1535</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果页面短缺
free_shortage</panel_attributes>
    <additional_attributes>60.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1147</x>
      <y>1539</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_launder</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1194</x>
      <y>1539</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>grow_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>1535</y>
      <w>49</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1174</x>
      <y>1548</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.以block为单位（512）
2.不能大于PAGE_SIZE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>1542</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1196</x>
      <y>1548</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1199</x>
      <y>1542</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1212</x>
      <y>1548</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1199</x>
      <y>1542</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1230</x>
      <y>1548</y>
      <w>30</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>tmp-&gt;b_this_page = bh;
free_list[isize].list = bh;
page-&gt;buffers = bh;
page-&gt;flags &amp;= ~(1 &lt;&lt; PG_referenced);
 //加到lru链表中，因为是新申请的page
 //age为0，所以可能加入到inactive_dirty_list中
lru_cache_add(page);
atomic_inc(&amp;buffermem_pages)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1200</x>
      <y>1542</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将bh链表依次插入到free_list中
其next_free的顺序是之前bh链表的顺序
</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1123</x>
      <y>1460</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_splice_branch</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>811</x>
      <y>1452</y>
      <w>320</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;3180.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1090</x>
      <y>1469</y>
      <w>31</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.验证之前没有断裂的索引链表（chain~where-1）
2.验证索引链表在where出断裂（*where-&gt;p）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1103</x>
      <y>1463</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1100</x>
      <y>1478</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>change
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1090</x>
      <y>1486</y>
      <w>36</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.bforget(where[i].bh)
2.ext2_free_blocks(inode, le32_to_cpu(where[i].key), 1)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1106</x>
      <y>1473</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果情况出现了变化</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1107</x>
      <y>1481</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1124</x>
      <y>1470</y>
      <w>44</w>
      <h>15</h>
    </coordinates>
    <panel_attributes> //将所有链表断裂处连接起来
*where-&gt;p = where-&gt;key;
 //下一个待分配的逻辑block
inode-&gt;u.ext2_i.i_next_alloc_block = block;
 //下一个待分配的实际block
inode-&gt;u.ext2_i.i_next_alloc_goal = le32_to_cpu(where[num-1].key);
 //更新inode的block的数量
inode-&gt;i_blocks += num * inode-&gt;i_sb-&gt;s_blocksize/512;
inode-&gt;i_ctime = CURRENT_TIME
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1129</x>
      <y>1463</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1128</x>
      <y>1463</y>
      <w>57</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
where-&gt;bh存在
如果需要同步，则向发送写请求，并等待
if (IS_SYNC(inode) || inode-&gt;u.ext2_i.i_osync) {
	ll_rw_block (WRITE, 1, &amp;where-&gt;bh);
	wait_on_buffer(where-&gt;bh);
}</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1174</x>
      <y>1471</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_buffer_dirty_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1169</x>
      <y>1479</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_buffer_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1188</x>
      <y>1479</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>buffer_insert_inode_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1183</x>
      <y>1474</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1198</x>
      <y>1482</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1194</x>
      <y>1488</y>
      <w>52</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果bh.b_inode指向对应的inode，将bh.b_inode_buffers从inode的链表中删除
2.bh-&gt;b_inode = inode
3.list_add(&amp;bh-&gt;b_inode_buffers, &amp;inode-&gt;i_dirty_buffers)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1172</x>
      <y>1474</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1173</x>
      <y>1482</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
atomic_set_buffer_dirty
set bh dirty
如果之前不是dirty</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>1487</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1162</x>
      <y>1491</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__mark_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1133</x>
      <y>1499</y>
      <w>36</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.bh-&gt;b_flushtime = jiffies + bdf_prm.b_un.age_buffer
2.refile_buffer （__refile_buffer）
	1.查看bh.b_state处于一个什么状态，从而判断其应该处于一个lru链表中
	2，比较其应该在的链表和其现在所在的链表（bh-&gt;b_list），如果不相同，
		将其从现在的lru链表中删除，加在应该处的lru链表中
		__remove_from_lru_list(bh, bh-&gt;b_list);
		bh-&gt;b_list = dispose;
		__insert_into_lru_list(bh, dispose)
	3.如果应该处于BUF_CLEAN中，就将其从inode中删除
		bh-&gt;b_inode = NULL;
		list_del(&amp;bh-&gt;b_inode_buffers)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1152</x>
      <y>1494</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1177</x>
      <y>1491</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>balance_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1172</x>
      <y>1487</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
看是否将dirty_buffer向
硬盘中写</panel_attributes>
    <additional_attributes>30.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1128</x>
      <y>1463</y>
      <w>118</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1160.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1225</x>
      <y>1469</y>
      <w>28</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果需要同步
IS_SYNC(inode) || inode-&gt;u.ext2_i.i_osync</panel_attributes>
    <additional_attributes>190.0;10.0;80.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1225</x>
      <y>1476</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_sync_inode
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1250</x>
      <y>1476</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_inode_dirty
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1243</x>
      <y>1469</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不需要同步</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1180</x>
      <y>1458</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bh_result-&gt;b_state |= (1UL &lt;&lt; BH_New)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>811</x>
      <y>1452</y>
      <w>384</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;3820.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>665</x>
      <y>1430</y>
      <w>36</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
buffer_new
BH_New:表示这个实际block是被创建的</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>694</x>
      <y>1432</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查hash表中有没有和其指向同一个dev和block
的bh，如果有，将这个bh写入磁盘并释放</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>684</x>
      <y>1437</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unmap_underlying_metadata</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>704</x>
      <y>1439</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>set_bit(BH_Uptodate, &amp;bh-&gt;b_state);
continue;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>698</x>
      <y>1432</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>732</x>
      <y>1437</y>
      <w>25</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>if (block_end &gt; to)
	memset(kaddr+to, 0, block_end-to);
if (block_start &lt; from)
	memset(kaddr+block_start, 0, from-block_start);
continue
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>697</x>
      <y>1432</y>
      <w>47</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为是新创建的，把不写的区域清0</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>517</x>
      <y>1390</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>kaddr = page_address(page);
status = copy_from_user(kaddr+offset, buf, bytes);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>370</x>
      <y>1372</y>
      <w>167</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制内容到缓存</panel_attributes>
    <additional_attributes>10.0;10.0;1650.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>569</x>
      <y>1376</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;commit_write
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>370</x>
      <y>1372</y>
      <w>209</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2070.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>578</x>
      <y>1379</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_aops</panel_attributes>
    <additional_attributes>20.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>576</x>
      <y>1382</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_commit_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>558</x>
      <y>1389</y>
      <w>34</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //address_space是inode和page的关联
inode = 
page-&gt;mapping-&gt;host
 //写完最后的位置
pos = ((loff_t)page-&gt;index &lt;&lt; PAGE_CACHE_SHIFT) 
		+ to
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>564</x>
      <y>1385</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>599</x>
      <y>1387</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__block_commit_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>585</x>
      <y>1385</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>607</x>
      <y>1390</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历page-&gt;buffers链表</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>566</x>
      <y>1394</y>
      <w>45</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果这个bh不在要写的范围
block_end &lt;= from || block_start &gt;= to
并且不和硬盘一致
!buffer_uptodate</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>561</x>
      <y>1406</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>partial = 1;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>598</x>
      <y>1394</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果bh在这次写的范围内
（即使部分也是的，因为__block_prepare_write
已经将那部分读了上来）</panel_attributes>
    <additional_attributes>110.0;10.0;190.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>613</x>
      <y>1402</y>
      <w>25</w>
      <h>19</h>
    </coordinates>
    <panel_attributes> //设置bh和硬盘一致
set_bit(BH_Uptodate, &amp;bh-&gt;b_state);
 //bh置dirty
if (!atomic_set_buffer_dirty(bh)) {
 //如果之前没置dirty
 //更新bh的lru链表
	__mark_dirty(bh);
	//将bh加入到inode链表中
	buffer_insert_inode_queue(bh, inode);
	need_balance_dirty = 1;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>607</x>
      <y>1390</y>
      <w>42</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
need_balance_dirty置上
根据空闲page的数量，决定是否唤醒bdflush</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>642</x>
      <y>1400</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>balance_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>608</x>
      <y>1390</y>
      <w>63</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
partial没置上
这个page中所有缓存都和硬盘一致</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>663</x>
      <y>1399</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>SetPageUptodate(page)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>669</x>
      <y>1379</y>
      <w>17</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>written ? written : status
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>638</x>
      <y>1377</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>651</x>
      <y>1378</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_osync_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>603</x>
      <y>1377</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>written += status;
count -= status;
pos += status;
buf += status;
if (deactivate)
	deactivate_page(page);
page_cache_release(page);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>369</x>
      <y>1372</y>
      <w>242</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1510.0;10.0;2400.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>368</x>
      <y>1357</y>
      <w>278</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在__grab_cache_page中
有cached_page，将其释放</panel_attributes>
    <additional_attributes>10.0;10.0;2070.0;130.0;2760.0;200.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>368</x>
      <y>1357</y>
      <w>291</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
没有错误，并要求同步，将其同步到硬盘
(status &gt;= 0) &amp;&amp; (file-&gt;f_flags &amp; O_SYNC)</panel_attributes>
    <additional_attributes>10.0;10.0;1290.0;60.0;2890.0;210.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>369</x>
      <y>1357</y>
      <w>310</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果写过，就返回写的字节数
如果没写过，就返回错误码</panel_attributes>
    <additional_attributes>10.0;10.0;2180.0;50.0;3080.0;220.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>624</x>
      <y>1378</y>
      <w>9</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>*ppos = pos;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>367</x>
      <y>1357</y>
      <w>263</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里更改了file-&gt;f_pos</panel_attributes>
    <additional_attributes>10.0;10.0;1670.0;140.0;2610.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>407</x>
      <y>1344</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_dir_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>224</x>
      <y>1333</y>
      <w>192</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有写buffer</panel_attributes>
    <additional_attributes>10.0;10.0;1900.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1133</x>
      <y>1349</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>225</x>
      <y>1333</y>
      <w>915</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放file</panel_attributes>
    <additional_attributes>10.0;10.0;9130.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1124</x>
      <y>1355</y>
      <w>33</w>
      <h>38</h>
    </coordinates>
    <panel_attributes> //递减file的count
if (atomic_dec_and_test(&amp;file-&gt;f_count)) {
 //如果f_count减到0
 //遍历inode-&gt;i_flock，删除这个file对应的FL_FLOCK|FL_LEASE锁
	locks_remove_flock(file);
	if (file-&gt;f_op &amp;&amp; file-&gt;f_op-&gt;release)
		file-&gt;f_op-&gt;release(inode, file);
	//释放module
	fops_put(file-&gt;f_op);
	file-&gt;f_dentry = NULL;
	file-&gt;f_vfsmnt = NULL;
	//释放write_access
	if (file-&gt;f_mode &amp; FMODE_WRITE)
		put_write_access(inode);
	//释放dentry mnt
	dput(dentry);
	if (mnt)
		mntput(mnt);
	//将file从anon_list加到free_list
	list_del(&amp;file-&gt;f_list);
	list_add(&amp;file-&gt;f_list, &amp;free_list);
	files_stat.nr_free_files++;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1138</x>
      <y>1352</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>15.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>376</x>
      <y>1270</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;write
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>377</x>
      <y>1278</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>381</x>
      <y>1273</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
def_blk_fops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>348</x>
      <y>1291</y>
      <w>37</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.dev不能是只读，is_read_only通过检查ro_bits相应的位
2.设置blocksize，blocksize_bits，block，offset，size
（参考block_read）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>361</x>
      <y>1281</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>397</x>
      <y>1287</y>
      <w>53</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.当起始block大于size时，返回ENOSPC
2.确定此次要写的大小chars（初始化为blocksize - offset，但是不能大于count）
3.通过getblk获取设备的bh，如果bh没更新（!buffer_uptodate）：
	1.如果是整块写（chars == blocksize），不需要将bh读进内存，只要wait_on_buffer
	2.如果不是整块写，需要将block读进来。如果f_reada 和read_ahead都为0，就不考虑预读
	否则预读规定块大小的一半，并根据size和bhlist的大小，重新更新blocks。
	将要读的bh通过getblk填充到bhlist中，然后通过ll_rw_block读取
	之后将预读的block释放（ brelse(bhlist[i])，此时因为lock，不会真正的释放），然后等待
	bh更新（ wait_on_buffer(bh)）
4.更新起始block（block++），更新ppos，更新写进的字节数written，更新要写的字节数count
	然后通过copy_from_user将用户空间的数据写入到bh中，更新用户空间的指针buf
5.mark_buffer_uptodate(bh, 1);
	mark_buffer_dirty(bh);
6.如果要求将数据同步写入磁盘（O_SYNC），将bh放到bufferlist中；当bufferlist满了，或者整个
	写操作完成之后，通过ll_rw_block将数据写入到磁盘
7.每写一个block的数据，通过balance_dirty在必要时将bh做同步
8.写操作完成之后，将filp-&gt;f_reada = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>382</x>
      <y>1281</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环在dev中读取count</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>354</x>
      <y>1350</y>
      <w>372</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
write_pipe_fops</panel_attributes>
    <additional_attributes>10.0;10.0;3700.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>718</x>
      <y>1364</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>687</x>
      <y>1372</y>
      <w>27</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.不能lseek，所以ppos = &amp;filp-&gt;f_pos
	否则返回ESPIPE
2.如果进程要写的数据字节count=0，
	直接返回0
3.通过down_interruptible申请信号量inode.i_sem
	对整个过程进行保护
4.要有PIPE_READERS，否则跳到sigpipe
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>701</x>
      <y>1367</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>821</x>
      <y>1371</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sigpipe
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>812</x>
      <y>1377</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果有写数据到fifo（written），释放信号量，
	然后返回写的字节数
2.如果没写数据（!written），向当前的进程发送
	信号SIGPIPE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>826</x>
      <y>1374</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>724</x>
      <y>1367</y>
      <w>104</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1020.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>716</x>
      <y>1372</y>
      <w>33</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.如果要写的count小于PIPE_BUF：
	1.如果是异步（O_NONBLOCK），在没有
		足够空间放下count字节数据，直接返回EAGAIN
	2.如果是同步，在没有足够空间放下couont数据
		时，睡眠直到有足够的空间能存放下count字节
		//睡着前先递增waiting_writers计数
		PIPE_WAITING_WRITERS(*inode)++;
		pipe_wait(inode);
		PIPE_WAITING_WRITERS(*inode)--;
		//如果有信号唤醒，或者没有reader，返回ERESTARTSYS
		ret = -ERESTARTSYS;
		if (signal_pending(current))
			goto out;

		if (!PIPE_READERS(*inode))
			goto sigpipe;
	3.如果有足够空间放下count字节数据，直接循环写
2.如果要写的count大于PIPE_BUF：
	1.只要有一个字节的空闲fifo，就可以写数据
	2.如果没有任何空闲空间能写，异步时返回EAGAIN，
		同步时等待睡眠，直到有空闲fifo
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>724</x>
      <y>1367</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>750</x>
      <y>1372</y>
      <w>29</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.如果有空闲的fifo（space = PIPE_FREE(*inode)!=0）
	1.本段要写的数据是 进程要写的数据count,fifo中空闲
		空间space，以及写指针到fifo尾端的空间chars的最小值
	2.通过copy_from_user将用户空间要写的数据复制到fifo中
	3.更新变量：
	 //已经写的字节数
		written += chars;
		PIPE_LEN(*inode) += chars;
		count -= chars;
		buf += chars;
		//这个宏是计算fifo空闲空间
		//因为pipe_len被计算，所以这个宏会被重新计算
		space = PIPE_FREE(*inode);
	4.通过continue，继续复制count数据
2.如果没有空闲的空间：
	1.如果是异步（O_NONBLOCK），break退出当前循环
	2.如果是同步，同样睡眠等待，醒来检查signal，pipe_readers
	注意这里do...while条件是!PIPE_FREE，和前面的PIPE_FREE(*inode) &lt; free
	不同，所以没采用pipe_read的结构

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>723</x>
      <y>1367</y>
      <w>44</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环写count字节数据</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>780</x>
      <y>1372</y>
      <w>30</w>
      <h>20</h>
    </coordinates>
    <panel_attributes> //唤醒等待队列
wake_up_interruptible(PIPE_WAIT(*inode))新
 //更新inode
inode-&gt;i_ctime = inode-&gt;i_mtime = CURRENT_TIME;
mark_inode_dirty(inode);
 //进程没写完，没有前面的步骤
 //释放信号量
up(PIPE_SEM(*inode));
 //返回写的字节数
if (written)
	ret = written;
return ret;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>724</x>
      <y>1367</y>
      <w>71</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果进程要写的数据被写完</panel_attributes>
    <additional_attributes>10.0;10.0;690.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>283</x>
      <y>1683</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>244</x>
      <y>1696</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>249</x>
      <y>1686</y>
      <w>43</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>264</x>
      <y>1696</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_verify_area
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>289</x>
      <y>1686</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file存在
f_mode &amp; FMODE_READ</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>269</x>
      <y>1691</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FLOCK_VERIFY_READ
验证这块区域是否加锁使其不可读</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>288</x>
      <y>1698</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;read
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>290</x>
      <y>1691</y>
      <w>6</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>312</x>
      <y>1698</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_dir_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>337</x>
      <y>1698</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fput
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>290</x>
      <y>1691</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>291</x>
      <y>1691</y>
      <w>53</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>179</x>
      <y>1701</y>
      <w>118</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_file_operations</panel_attributes>
    <additional_attributes>1160.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>174</x>
      <y>1713</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_file_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>151</x>
      <y>1720</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>access_ok</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>156</x>
      <y>1716</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
VERIFY_WRITE</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>139</x>
      <y>1727</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__range_ok</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>145</x>
      <y>1723</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>117</x>
      <y>1734</y>
      <w>35</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>"addl %3,%1 ;
 //flag=flag-cf，cf为1表示最高位产生了进位或者借位
sbbl %0,%0; 
 //current-&gt;addr_limit.seg-addr，然后检查cf
cmpl %1,%4; sbbl $0,%0" \
:"=&amp;r" (flag), "=r" (sum) \
:"1" (addr),"g" ((int)(size)),"g" (current-&gt;addr_limit.seg)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>132</x>
      <y>1730</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>160</x>
      <y>1727</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>desc.written = 0;
desc.count = count;
desc.buf = buf;
desc.error = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>166</x>
      <y>1716</y>
      <w>16</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>181</x>
      <y>1730</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_generic_file_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>179</x>
      <y>1716</y>
      <w>12</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>179</x>
      <y>1716</y>
      <w>38</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
desc.written
检查是否想用户空间写了
读上来的数据，否则返回错误</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>208</x>
      <y>1728</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>desc.error
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>154</x>
      <y>1743</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_max_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>162</x>
      <y>1733</y>
      <w>29</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>123</x>
      <y>1750</y>
      <w>40</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果没有设备号，或者此类设备没有规定预读的长度
	（(!inode-&gt;i_dev || !max_readahead[MAJOR(inode-&gt;i_dev)）
	则为MAX_READAHEAD
2.否则，就取规定的
max_readahead[MAJOR(inode-&gt;i_dev)][MINOR(inode-&gt;i_dev)]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>143</x>
      <y>1746</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>177</x>
      <y>1733</y>
      <w>14</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>159</x>
      <y>1744</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果超出了预读窗口
 //f_raend为预读的最后一页，f_rawin为窗口的长度
 //窗口为f_raend-f_rawin ~ f_raend
index &gt; filp-&gt;f_raend || 
index + filp-&gt;f_rawin &lt; filp-&gt;f_raend</panel_attributes>
    <additional_attributes>190.0;10.0;130.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>164</x>
      <y>1751</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>reada_ok = 0;
filp-&gt;f_raend = 0;
filp-&gt;f_ralen = 0;
filp-&gt;f_ramax = 0;
filp-&gt;f_rawin = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>177</x>
      <y>1744</y>
      <w>19</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果现在读取的内容在
之前预读的范围内</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>177</x>
      <y>1754</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>reada_ok = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>188</x>
      <y>1733</y>
      <w>15</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>188</x>
      <y>1744</y>
      <w>41</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果读取file最前半页的内容
不进行预读
 //第0页
!index &amp;&amp; 
 //第0页的前半页
offset + desc-&gt;count &lt;= (PAGE_CACHE_SIZE &gt;&gt; 1)</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>184</x>
      <y>1758</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_ramax = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>200</x>
      <y>1744</y>
      <w>8</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>201</x>
      <y>1756</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.随机读（reada_ok=0），f_ramax为正在读取的长度+1
	((offset + desc-&gt;count) &gt;&gt; PAGE_CACHE_SHIFT) + 1
2.如果是顺序读（reada_ok=1），f_ramax最小为max（need，MIN_READAHEAD）
3.不管何种情况，f_ramax最大为get_max_readahead
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>188</x>
      <y>1733</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环读取内容</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>211</x>
      <y>1741</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>206</x>
      <y>1745</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果读取的长度超出了i_size，退出循环
2.如果是inode的最后一个页面，但是超出了
	i_size &amp; ~PAGE_CACHE_MASK，也超过了inode
	的长度，退出循环
3.更新读取的长度 nr = nr - offset，
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>216</x>
      <y>1741</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从hash表中通过index找page</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>239</x>
      <y>1747</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>page_hash(mapping, index)
__find_page_nolock
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>216</x>
      <y>1741</y>
      <w>56</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;540.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>261</x>
      <y>1745</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在hash表中
找到来了page</panel_attributes>
    <additional_attributes>90.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>259</x>
      <y>1750</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>found_page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>336</x>
      <y>1751</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>no_cached_page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>269</x>
      <y>1745</y>
      <w>73</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在hash表中
没有找到page</panel_attributes>
    <additional_attributes>10.0;10.0;710.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>248</x>
      <y>1753</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加page计数</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>242</x>
      <y>1758</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_get
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>251</x>
      <y>1757</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果page和硬盘一致
</panel_attributes>
    <additional_attributes>90.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>149</x>
      <y>1771</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_file_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>259</x>
      <y>1753</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
Page_Uptodate
注：在do_generic_file_read只检查了
	page的uptodate，所以说如果不在读的范围内
	只要在相同的page中，也要将buffer读上来</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>259</x>
      <y>1757</y>
      <w>56</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不一致</panel_attributes>
    <additional_attributes>10.0;10.0;540.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>308</x>
      <y>1760</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_not_up_to_date
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>260</x>
      <y>1766</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_ok
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>156</x>
      <y>1761</y>
      <w>102</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1000.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>255</x>
      <y>1761</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>252</x>
      <y>1769</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>245</x>
      <y>1772</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file_read_actor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>227</x>
      <y>1779</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__copy_to_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>234</x>
      <y>1775</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将读到的数据复制到用户空间</panel_attributes>
    <additional_attributes>160.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>248</x>
      <y>1779</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>desc-&gt;count = count - size;
desc-&gt;written += size;
desc-&gt;buf += size;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>250</x>
      <y>1775</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新参数
size：nr</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>267</x>
      <y>1773</y>
      <w>27</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>offset += nr;
 //递增页index
index += offset &gt;&gt; PAGE_CACHE_SHIFT;
 //算出页内偏移，开始是offset，后期是0
offset &amp;= ~PAGE_CACHE_MASK;
 //释放页
page_cache_release(page);
 //count，如果还要读，继续循环
if (nr &amp;&amp; desc-&gt;count)
	continue;
 //否则退出
break;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>263</x>
      <y>1769</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>292</x>
      <y>1768</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_file_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>299</x>
      <y>1763</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>316</x>
      <y>1763</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>301</x>
      <y>1766</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
有可能是写一个新的
页，导致其没置上，
如果进过之前一些时间导致
page和磁盘一致</panel_attributes>
    <additional_attributes>160.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>299</x>
      <y>1773</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_ok
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>316</x>
      <y>1766</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果还不一致</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>307</x>
      <y>1776</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lock_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>311</x>
      <y>1771</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>315</x>
      <y>1771</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!page-&gt;mapping
如果醒来发现从hash表中
取消</panel_attributes>
    <additional_attributes>110.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>319</x>
      <y>1777</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>UnlockPage(page);
page_cache_release(page);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>325</x>
      <y>1771</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为lock_page可能导致进程睡眠
（generic_file_write将页locked）
所以醒来要检查是否和磁盘一致
Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>351</x>
      <y>1777</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>UnlockPage(page);
goto page_ok;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>324</x>
      <y>1771</y>
      <w>55</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果还不一致，只能锁住page从硬盘中读取</panel_attributes>
    <additional_attributes>10.0;10.0;530.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>371</x>
      <y>1775</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>readpage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>335</x>
      <y>1785</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;readpage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>343</x>
      <y>1778</y>
      <w>34</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>374</x>
      <y>1778</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>356</x>
      <y>1786</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_ok
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>359</x>
      <y>1782</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果和磁盘一致了</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>369</x>
      <y>1782</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不一致
（因为异步读取，还没传上来）</panel_attributes>
    <additional_attributes>70.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>370</x>
      <y>1785</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>362</x>
      <y>1790</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_file_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>381</x>
      <y>1790</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait_on_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>382</x>
      <y>1785</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
等待</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>395</x>
      <y>1790</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_ok
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>382</x>
      <y>1785</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>397</x>
      <y>1787</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
一致</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>406</x>
      <y>1790</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>error = -EIO
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>401</x>
      <y>1787</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>341</x>
      <y>1754</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
和__find_lock_page找不到时类似
如果找到page了</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>337</x>
      <y>1759</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>readpage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>188</x>
      <y>1733</y>
      <w>136</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1340.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>307</x>
      <y>1736</y>
      <w>32</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //更新f_pos
*ppos =  index &lt;&lt; PAGE_CACHE_SHIFT) + offset;
filp-&gt;f_reada = 1;
 //释放掉cached_page
if (cached_page)
	page_cache_free(cached_page);
UPDATE_ATIME(inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>336</x>
      <y>1793</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_readpage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>344</x>
      <y>1788</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_aops</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>335</x>
      <y>1801</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_read_full_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>342</x>
      <y>1796</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_get_block</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>277</x>
      <y>1811</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page要lock
（PageLocked）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>280</x>
      <y>1804</y>
      <w>65</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>630.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>298</x>
      <y>1804</y>
      <w>47</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!page-&gt;buffers</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>291</x>
      <y>1811</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_empty_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>320</x>
      <y>1804</y>
      <w>25</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历page-&gt;buffers链表</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>316</x>
      <y>1811</y>
      <w>40</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果buffer_uptodate，不用考虑
2.如果没有映射设备的block，并且没有超出inode.i_size，
	通过get_block（ext2_get_block）去获取设备block
	注意这里的create为0
3.如果超出了inode.i_size,
	将bh对应的内存设置为0
4.因为get_block可能使buffer_uptodate，所以再次检查
	注：ext2可能没有在get_block读，可能其他文件系统有读
5.如果get_block正确返回，或者！buffer_uptodate，记录没有
	uptodate的bh到arr,数目为nr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>343</x>
      <y>1804</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!nr
page中所有的bh都uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>361</x>
      <y>1812</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>SetPageUptodate(page);
UnlockPage(page);
return 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>343</x>
      <y>1804</y>
      <w>57</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果nr存在
遍历arr</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>388</x>
      <y>1811</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lock_buffer(bh);
bh-&gt;b_end_io = end_buffer_io_async;
atomic_inc(&amp;bh-&gt;b_count);
submit_bh(READ, arr[i])
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>0</x>
      <y>1786</y>
      <w>82</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.页面locked（PageLocked），此时页面正在和磁盘交互，不管是读还是写，当这个locked清除的时候，页面必然uptodate
	如果之前有预读（f_ralen存在），且当前页面在预读窗口内（raend-f_rawin ~ raend），此时因为磁盘繁忙，并且有预读窗口
	所以暂时不用预读
	如果之前没有预读（!f_ralen）,或者当前页面超出了预读窗口，将本次要读的长度预读到内存中
2.页面没锁
	如果首页在窗口中（reada_ok不为0），不是随机读的条件1（f_ramax不为0），并且在ahead窗口中，此时需要预读；预读的长度
	为f_ramax + 1，并且将之前的ahead窗口改变为现在的current窗口（filp-&gt;f_rawin = filp-&gt;f_ralen），ahead窗口
	将会在之后被设置

注：
1.预读窗口分为current（raend-f_rawin ~ raend-f_ralen）窗口和ahead（raend-f_ralen ~ raend）窗口，其中f_ralen
	指上次预读的长度，f_rawin指的是上次和上上次一起读的长度
2.随机读的条件：
	条件1.读的是最前半页
	条件2：此次读的首页不在整个预读窗口中
	条件1不成立的时候，绝对不会预读；但是条件2不成立的时候，会预读本次要读的数据到内存中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>57</x>
      <y>1774</y>
      <w>100</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>980.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>128</x>
      <y>1774</y>
      <w>40</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
执行需要预读的页面，
超过预读的量，或者超过inode.i_size,或者预读出错，就退出</panel_attributes>
    <additional_attributes>270.0;10.0;120.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>132</x>
      <y>1785</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>154</x>
      <y>1774</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有预读页面（ahead不为0）</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>163</x>
      <y>1780</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果进行了窗口的切换
reada_ok==2</panel_attributes>
    <additional_attributes>130.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>157</x>
      <y>1786</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>run_task_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>175</x>
      <y>1780</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>173</x>
      <y>1785</y>
      <w>25</w>
      <h>18</h>
    </coordinates>
    <panel_attributes> //更新ahead窗口
filp-&gt;f_ralen += ahead;
	//更新整个预读窗口
filp-&gt;f_rawin += filp-&gt;f_ralen;
filp-&gt;f_raend = raend + ahead + 1;
 //预读页面*2
filp-&gt;f_ramax += filp-&gt;f_ramax;

if (filp-&gt;f_ramax &gt; max_readahead)
	filp-&gt;f_ramax = max_readahead;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>199</x>
      <y>1782</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drop_behind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>154</x>
      <y>1774</y>
      <w>54</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放窗口之前的page</panel_attributes>
    <additional_attributes>10.0;10.0;520.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>216</x>
      <y>1782</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>profile_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>154</x>
      <y>1774</y>
      <w>69</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>201</x>
      <y>1789</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果首页到index的长度大于窗口的长度（f_rawin），
	只释放f_rawin的页面，否则一直释放到首页
2.在hash表中找到page，并释放deactivate_page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>206</x>
      <y>1785</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>88</x>
      <y>1798</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>page_hash
__find_page_nolock
return 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>93</x>
      <y>1788</y>
      <w>49</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从hash中查找page</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>140</x>
      <y>1788</y>
      <w>16</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在hash中没找到</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>105</x>
      <y>1802</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>110</x>
      <y>1797</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>123</x>
      <y>1803</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>163</x>
      <y>1804</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>139</x>
      <y>1804</y>
      <w>20</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;readpage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>129</x>
      <y>1797</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>140</x>
      <y>1797</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>140</x>
      <y>1797</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>294</x>
      <y>1701</y>
      <w>94</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_file_operations</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>381</x>
      <y>1714</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_file_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>328</x>
      <y>1729</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dp=inode-&gt;u.generic_ip
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>334</x>
      <y>1717</y>
      <w>54</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取inode对应的硬盘文件（被抽象）</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>362</x>
      <y>1729</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_free_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>367</x>
      <y>1717</y>
      <w>22</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
分配内存</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>386</x>
      <y>1717</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>376</x>
      <y>1726</y>
      <w>37</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读取大小</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>360</x>
      <y>1735</y>
      <w>29</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>count = MIN(PROC_BLOCK_SIZE, nbytes)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>390</x>
      <y>1737</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes> dp-&gt;get_info
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>409</x>
      <y>1726</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
eof指示是否结束</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>395</x>
      <y>1731</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
之前的版本</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>409</x>
      <y>1738</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dp-&gt;read_proc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>409</x>
      <y>1731</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
新版本
返回此次读的长度</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>393</x>
      <y>1748</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>loadavg_read_proc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>414</x>
      <y>1741</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在proc_misc_init中初始化create_proc_read_entry</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>359</x>
      <y>1759</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sprintf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>366</x>
      <y>1751</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
avenrun记录这cup的负荷
nr_running, nr_threads, last_pid
分别是处于运行态的进程数量
线程的数量
最大的pid号</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>393</x>
      <y>1758</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_calc_metrics</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>399</x>
      <y>1751</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
len表示文件现在存在的数据长度</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>386</x>
      <y>1767</y>
      <w>23</w>
      <h>16</h>
    </coordinates>
    <panel_attributes> //这个条件到了文件末尾
if (len &lt;= off+count) *eof = 1;
 //offset的地址
*start = page + off;
 //此次应该读的长度，如果大于了
 //count或者小于0就更新
len -= off;
if (len&gt;count) len = count;
if (len&lt;0) len = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>395</x>
      <y>1761</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>444</x>
      <y>1735</y>
      <w>25</w>
      <h>14</h>
    </coordinates>
    <panel_attributes> //文件偏移量更新
*ppos += start &lt; page ? (long)start : n
 //剩下需要读的字节数
nbytes -= n;
 //用户空间的指针更新
buf += n;
 //完成的字节数更新
retval += n;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>429</x>
      <y>1738</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_to_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>410</x>
      <y>1726</y>
      <w>26</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>410</x>
      <y>1726</y>
      <w>44</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>441</x>
      <y>1750</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>meminfo_read_proc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>400</x>
      <y>1745</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>414</x>
      <y>1745</y>
      <w>35</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>424</x>
      <y>1758</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>si_meminfo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>442</x>
      <y>1759</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>si_swapinfo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>429</x>
      <y>1753</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>445</x>
      <y>1753</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>412</x>
      <y>1767</y>
      <w>33</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>val-&gt;totalram = totalram_pages;
val-&gt;sharedram = 0;
val-&gt;freeram = nr_free_pages();
val-&gt;bufferram = atomic_read(&amp;buffermem_pages);
val-&gt;totalhigh = totalhigh_pages;
val-&gt;freehigh = nr_free_highpages();
val-&gt;mem_unit = PAGE_SIZE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>427</x>
      <y>1761</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>446</x>
      <y>1767</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>val-&gt;freeswap = freeswap;
val-&gt;totalswap = totalswap;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>436</x>
      <y>1762</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
记录交换设备上空闲的page（swap_map如果为0）
注意switch没有break</panel_attributes>
    <additional_attributes>120.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>458</x>
      <y>1760</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sprintf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>445</x>
      <y>1753</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>478</x>
      <y>1761</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_calc_metrics</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>445</x>
      <y>1753</y>
      <w>42</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>499</x>
      <y>1724</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pid_maps_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>294</x>
      <y>1701</y>
      <w>218</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果读/proc/self/maps
proc_maps_operations</panel_attributes>
    <additional_attributes>10.0;10.0;2160.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>478</x>
      <y>1735</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>inode = file-&gt;f_dentry-&gt;d_inode
task = inode-&gt;u.proc_i.task
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>488</x>
      <y>1727</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>494</x>
      <y>1744</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.一个vma，用MAPS_LINE_SHIFT个字符表示
2.lineno表示偏移的vma
	column表示在vma中的偏移
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>506</x>
      <y>1739</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
解释</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>528</x>
      <y>1744</y>
      <w>45</w>
      <h>43</h>
    </coordinates>
    <panel_attributes>1.首先遍历mm-&gt;mmap，lineno个vma，找到偏移的vma
2.map-&gt;vm_start, map-&gt;vm_end之后的5个字符
	查看第4条（cp初始地址和str相同）
	*cp++ = flags &amp; VM_READ ? 'r' : '-';
	*cp++ = flags &amp; VM_WRITE ? 'w' : '-';
	*cp++ = flags &amp; VM_EXEC ? 'x' : '-';
	*cp++ = flags &amp; VM_MAYSHARE ? 's' : 'p';
	*cp++ = 0;
3.如果该vma映射了file，那么通过d_path将file的绝对地址存在
	buffer中（这个file向前索引最大到当前进程的root，如果删除
	路径后面会接上/(deleted)）
4.通过sprintf复制 map-&gt;vm_start, map-&gt;vm_end, str, map-&gt;vm_pgoff
	等信息到buffer中（maxlen没用完的，用空格填充）
5.如果vma中的偏移column已经大过了此次vma中的总长度len
6.copy_to_user复制len-column到用户空间
7.更新读的指针，
	destptr += i;
	count   -= i;
	column  += i;
	//更新到下一个vma
	if (column &gt;= len) {
		column = 0; /* next time: next line at column 0 */
		lineno++;
	}
8.循环结束后，更新偏移量
	*ppos = (lineno &lt;&lt; MAPS_LINE_SHIFT) + column
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>500</x>
      <y>1736</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_pid_read_maps</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>1727</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
返回复制的长度</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>472</x>
      <y>1747</y>
      <w>18</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>buffer = __get_free_page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>480</x>
      <y>1739</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>1739</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>293</x>
      <y>1701</y>
      <w>333</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
def_blk_fops</panel_attributes>
    <additional_attributes>10.0;10.0;3310.0;280.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>618</x>
      <y>1729</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>576</x>
      <y>1739</y>
      <w>52</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>blocksize：设备上的块大小（默认是BLOCK_SIZE，查询blksize_size）
blocksize_bits：blocksize所占的位
size：设备的大小（默认INT_MAX 查询blk_size，为单位）
offset：文件内的偏移
left：要读的字节数（1.offset不能大于size;2.不能超过INT_MAX；3.不能超过进程要读的字节数count）
block:起始块的索引（offset &gt;&gt; blocksize_bits）
 //属性发生变化
offset:在块内的偏移
size：设备结束块的索引
blocks：要读的block数，
（初始值：(left + offset + blocksize - 1) &gt;&gt; blocksize_bits
预读调整：read_ahead[MAJOR(dev)] / (blocksize &gt;&gt; 9)，如果小于这个值，blocks就调整为这个值
			由此可知read_ahead存储预读的块的数量（块的大小是512字节）
size调整：不能大于size - block这个剩余的大小
）
bhb：指向这个循环最后一个从设备读到内核的bh
bhe：指向这个循环最后一个从内核写到用户的bh
buflist：相当于一个FIFO,bhb是写指针（将设备的数据写到内核）bhe是读指针（将内核的数据读到用户）
	这两个指针初始化为buflist
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>596</x>
      <y>1732</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>629</x>
      <y>1739</y>
      <w>58</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.首先将要读取的block添加到队列buflist中，这里file的逻辑block和设备的block相同
	*bhb = getblk(dev, block++, blocksize)
	如果!buffer_uptodate，将bh添加到数组bhreq中
	在以下三种情况退出wile循环：
	1.第一个读进来的bh已经uptodate（uptodate！=0）
	2.队列buflist已经被装满（bhb == bhe）
	3.要读的blocks读完了（blocks==0）
2.如果数组中装有未更新的bh（bhrequest!=0）,通过ll_rw_block读取数组bhreq
	中bhrequest个bh
3.进入第二层do..while
	1.通过wait_on_buffer等待bh更新，当醒来时bh应该已经更新，如果没更新，将left赋值为0
		退出整个read过程
	2.更新读进来的字节数chars，如果left没讲block占满，则为chars = left；否者就是
		chars = blocksize - offset
		并进一步更新偏移量ppos，剩余读取量left，读取两read
	3.利用copy_to_user将数据从内核copy到用户空间，并更新buf += chars
	4.offset = 0；++bhe（到最后就回到最开始）
	5.当剩余读取量left&lt;=0，或者队列buflist读完（bhe == bhb），或者要操作的bh还没更新（buffer_locked(*bhe)）
		退出第二层do...while。
		注：当第一个条件满足时退出读操作；当第二个条件满足，并且blocks读完了，退出读操作，但是blocks没读完时，继续
		通过第一层do..while填充队列buflist；当第三个条件满足时，在第一层do..while中填充队列buflist
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>623</x>
      <y>1732</y>
      <w>26</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
第一层do..while</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>293</x>
      <y>1701</y>
      <w>467</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty_fops</panel_attributes>
    <additional_attributes>10.0;10.0;4650.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>753</x>
      <y>1714</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>704</x>
      <y>1717</y>
      <w>58</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>560.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>680</x>
      <y>1727</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.只能顺序读，所以ppos = &amp;file-&gt;f_pos
2.通过file-&gt;private_data获取tty
3.通过tty_paranoia_check检查tty是否为NULL
·magic是否为TTY_MAGIC
4.检查tty是否为空，或者tty-&gt;flags是否有TTY_IO_ERROR
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>733</x>
      <y>1730</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;ldisc.read
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>737</x>
      <y>1717</y>
      <w>26</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty-&gt;ldisc.read存在</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>776</x>
      <y>1730</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_atime = CURRENT_TIME
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>759</x>
      <y>1717</y>
      <w>28</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>738</x>
      <y>1733</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty_ldisc_N_TTY</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>732</x>
      <y>1738</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_chan</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>695</x>
      <y>1741</y>
      <w>45</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>691</x>
      <y>1746</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.tty-&gt;read_buf要存在
2.如果不是当前虚拟终端或者控制台，只是进程的tty
（TODO:暂时不是很清楚）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>736</x>
      <y>1741</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
！tty-&gt;icanon
原始模式
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>726</x>
      <y>1746</y>
      <w>38</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>从termios-&gt;c_cc中获取控制信息
time = (HZ / 10) * TIME_CHAR(tty);
minimum = MIN_CHAR(tty)
1.如果time和minimum都存在，minimum_to_wake=1，因为每次收到需要重置时间
2.如果minum存在，但是time没有，minimum_to_wake取较小的那个（等待队列为空
	就是minimum、如果等待队列不为空，就取小的那个）
3.如果没有mininum，则tty-&gt;minimum_to_wake = minimum = 1
	如果有time，将timeout的时间设置成time，否则默认为0
注：minimum_to_wake：当键入多少字符时应该唤醒tty-&gt;read_wait
	minimum：如果buffer中有minimum的字符在，即使没到nr也不会阻塞	
	timeout：进程如果没有字符，进入休眠。如果此时，进程收到了minimum_to_wake
		会醒来；或者timeout时间到了之后，醒来，如果字符有字符会继续读到buffer
		然后继续睡
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>765</x>
      <y>1747</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果是不阻塞file-&gt;f_flags &amp; O_NONBLOCK
	使用down_trylock，如果没锁住就退出
2.如果不是，就采用down_interruptible
	如果没锁住就睡眠
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>737</x>
      <y>1741</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty-&gt;atomic_read
</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>787</x>
      <y>1747</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.首先通过add_wait_queue将
	其加入等待队列tty-&gt;read_wait
2.set_bit(TTY_DONT_FLIP, &amp;tty-&gt;flags)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>738</x>
      <y>1741</y>
      <w>58</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;560.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>737</x>
      <y>1741</y>
      <w>88</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读数据
</panel_attributes>
    <additional_attributes>10.0;10.0;860.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>807</x>
      <y>1745</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty-&gt;packet（信包模式）
&amp;&amp;tty-&gt;link-&gt;ctrl_status（有数据）</panel_attributes>
    <additional_attributes>160.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>807</x>
      <y>1750</y>
      <w>17</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果之前读有其他数据（b != buf），退出整个读
2.否则将ctrl_status的数据放入到buffer，并退出
	cs = tty-&gt;link-&gt;ctrl_status;
	tty-&gt;link-&gt;ctrl_status = 0;
	put_user(cs, b++);
	nr--;
	break;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>819</x>
      <y>1745</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TASK_INTERRUPTIBLE</panel_attributes>
    <additional_attributes>40.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>826</x>
      <y>1749</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_current_state
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>843</x>
      <y>1749</y>
      <w>17</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果之前读有其他数据（b != buf），退出整个读
2.否则将ctrl_status的数据放入到buffer，并退出
	cs = tty-&gt;link-&gt;ctrl_status;
	tty-&gt;link-&gt;ctrl_status = 0;
	put_user(cs, b++);
	nr--;
	break;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>822</x>
      <y>1745</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>862</x>
      <y>1749</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;minimum_to_wake
	= (minimum - (b - buf))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>822</x>
      <y>1745</y>
      <w>48</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据已经写到buffer的数据
更新minimum_to_wake</panel_attributes>
    <additional_attributes>10.0;10.0;460.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>822</x>
      <y>1745</y>
      <w>63</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>880</x>
      <y>1748</y>
      <w>29</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.通过input_available_p检查buffer是否有
	数据（有数据返回1，没有返回0）
2.如果没有数据：
	1.tty-&gt;flags的TTY_OTHER_CLOSED，退出
	报错EIO
	2.tty_hung_up_p检查file的fops是否为hung_up_tty_fops
		（可以等等），直接退出
	3.如果timeout时间为0，直接退出
	4.如果file-&gt;f_flags &amp; O_NONBLOCK，报
		EAGAIN，退出
	5.如果当前进程signal_pending，报ERESTARTSYS
		退出
	6.否则清除TTY_DONT_FLIP，然后以timeout时间
	为限schedule_timeout，醒来之后将TTY_DONT_FLIP
	置上，然后重新循环
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>886</x>
      <y>1777</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>input_available_p</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>890</x>
      <y>1773</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>880</x>
      <y>1784</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果是加工模式（tty-&gt;icanon），并且
	缓冲行有数据（canon_data），返回1
2.如果处于原始模式，read_cnt超过规定
	数量，返回1
3.否者返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>891</x>
      <y>1780</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>910</x>
      <y>1748</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>put_user(TIOCPKT_DATA, b++);
nr--;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>822</x>
      <y>1745</y>
      <w>95</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果packet mode
并且之前没读过(b == buf)</panel_attributes>
    <additional_attributes>10.0;10.0;930.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>933</x>
      <y>1748</y>
      <w>41</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.如果是加工模式（tty-&gt;icanon），就循环读取，直到
	读完nr或者将整个缓冲行读完（tty-&gt;read_cnt）
	1.1.read_flags中记载着该位置上的字符是不是缓冲行终结字符（\n）
	1.2.将buffer队列中的数据取出tty-&gt;read_buf[tty-&gt;read_tail]
	1.3.更新读端tty-&gt;read_tail，更新tty-&gt;read_cnt--
	1.4.如果是缓冲行最后一个字符是'\0'，就不用复制到用户空间
		否者：
		put_user(c, b++);
		nr--;
	1.5.如果缓冲行结束（eol），就退出此次复制
2.通过copy_from_read_buf将缓冲队列中的数据复制到用户空间
	（这里buffer是一个回环队列，而copy_from_read_buf
	中copy_to_user地址只能朝一个方向生长，所以这里复制了两次）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>821</x>
      <y>1745</y>
      <w>124</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1220.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>948</x>
      <y>1774</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_from_read_buf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>954</x>
      <y>1770</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>937</x>
      <y>1781</y>
      <w>34</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.从要读的数据nr，buffer中存在的数据量tty-&gt;read_cnt
	以及tail到buffer尾端的长度（N_TTY_BUF_SIZE - tty-&gt;read_tail，
	这里是让tail之前的数据，在另一个copy_from_read_buf
	中执行）选取一个最小值
2.通过copy_to_user将缓冲队列中的数据（tty-&gt;read_buf）
	复制到用户空间
3.更新缓冲队列，用户空间buffer和nr
	tty-&gt;read_tail = (tty-&gt;read_tail + n) &amp; (N_TTY_BUF_SIZE-1);
	tty-&gt;read_cnt -= n
	*b += n;
	*nr -= n;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>954</x>
      <y>1777</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>978</x>
      <y>1748</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过n_tty_chars_in_buffer检查缓冲队列中的数据
	是否低于TTY_THRESHOLD_UNTHROTTLE。如果低于
	通过check_unthrottle将阀门打开
注;当键盘输入过快时，应用程序来不及将数据读入缓冲区
	驱动（中断)会将阀门关闭，现在低于门限，需要将其
	打开
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>979</x>
      <y>1762</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>n_tty_chars_in_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>984</x>
      <y>1758</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>975</x>
      <y>1769</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果处于原始模式(!tty-&gt;icanon)，
	缓冲队列中的字符数是tty-&gt;read_cnt
2.如果处于加工模式，并且缓冲行
	有数据（tty-&gt;canon_data），字符
	数是tail~head的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>985</x>
      <y>1765</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1000</x>
      <y>1762</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>check_unthrottle</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>999</x>
      <y>1758</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1001</x>
      <y>1769</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>检查TTY_THROTTLED是否置上，
如果置上，使用tty-&gt;driver.unthrottle
将阀门打开
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1006</x>
      <y>1765</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>821</x>
      <y>1745</y>
      <w>171</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1690.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1010</x>
      <y>1748</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果读入字符数量超过了minimum，则退出
2.如果继续读的话，更新timeout为time
注;nr决定了此次读的上限，minimum是下限，
	加工模式具体读多少取决于缓冲行
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>822</x>
      <y>1745</y>
      <w>197</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1950.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1044</x>
      <y>1745</y>
      <w>25</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>clear_bit(TTY_DONT_FLIP
remove_wait_queue(&amp;tty-&gt;read_wait
 //如果等待队列tty-&gt;read_wait中没有
 //等待的进程，更新minimum_to_wake
tty-&gt;minimum_to_wake = minimum

current-&gt;state = TASK_RUNNING
 //如果读到数据（b - buf），返回b - buf
 //如果nr存在（表示进程已经来读过）
 clear_bit(TTY_PUSH
 //如果没读到数据，且TTY_PUSH，就
 //返回重新读
注：TTY_PUSH是底层驱动读到EOF将
	其置成1，表示进程需尽快读走
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>738</x>
      <y>1741</y>
      <w>313</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>296</x>
      <y>1701</y>
      <w>804</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_scanner_fops</panel_attributes>
    <additional_attributes>10.0;10.0;8020.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1093</x>
      <y>1724</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_scanner</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1095</x>
      <y>1727</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1079</x>
      <y>1731</y>
      <w>39</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.更新时间：
	file-&gt;f_dentry-&gt;d_inode-&gt;i_atime = CURRENT_TIME
2.循环从usb设备中读取count个数据
	1.检查进程如果有signal_pending，返回EINTR
	2.依次读的量不能大于IBUF_SIZE，并通过usb_bulk_msg去usb设备中读
	3.如果结果是timeout，并且没有任何数据读进来。这样的情形最多有RD_EXPIRE
	次，每次通过interruptible_sleep_on_timeout让进程睡眠RD_NAK_TIMEOUT
	时间；
	如果是其他错误（除了USB_ST_DATAUNDERRUN），返回EIO
	4.如果读到了数据（partial），最多将其前24字节打印出来
	5.如果读到了数据（partial），通过copy_to_user将数据copy到用户空间,并更新：
	//预期读this_read,实际读partial
	count -= this_read; /* Compensate for short reads */
	bytes_read += partial; /* Keep tally of what actually was read */
	buffer += partial;
	如果没读到数据，直接返回bytes_read
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1095</x>
      <y>1763</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_bulk_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1097</x>
      <y>1757</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_rcvbulkpipe
endpoint是bulk_in_ep</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1074</x>
      <y>1770</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_alloc_urb
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1078</x>
      <y>1766</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1089</x>
      <y>1770</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>urb-&gt;dev=usb_dev;\
urb-&gt;pipe=pipe;\
urb-&gt;transfer_buffer=data;\
urb-&gt;transfer_buffer_length=len;\
urb-&gt;complete=usb_api_blocking_completion;\
urb-&gt;context=0;\
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1099</x>
      <y>1766</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FILL_BULK_URB</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1115</x>
      <y>1770</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_start_wait_urb
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1101</x>
      <y>1766</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1144</x>
      <y>1718</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>298</x>
      <y>1701</y>
      <w>853</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
read_fifo_fops</panel_attributes>
    <additional_attributes>10.0;10.0;8510.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1121</x>
      <y>1725</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.因为pipe不能lseek，所以ppos
	指针必须是&amp;filp-&gt;f_pos
	如果不是，返回ESPIPE
2.如果要读的数据是count，返回0
3.通过inode.sem对整个过程保护
	（down_interruptible）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1129</x>
      <y>1721</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1148</x>
      <y>1721</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果fifo中没有数据
PIPE_EMPTY（inode.i_size=0）</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1142</x>
      <y>1725</y>
      <w>28</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果没有PIPE_WRITERS，直接返回0
2.如果f_flags &amp; O_NONBLOCK，返回EAGAIN
3.循环：
	增加WAITING_READERS的计数，然后通过pipe_wait
	睡眠。
	如果醒来之后，减少WAITING_READERS的计数
	1.如果是因为信号被唤醒（signal_pending），返回ERESTARTSYS
	2.如果是因为有数据被唤醒（!PIPE_EMPTY），退出循环
	3.如果是因为没PIPE_WRITERS被唤醒，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1149</x>
      <y>1744</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_wait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>1740</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>1747</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1151</x>
      <y>1721</y>
      <w>42</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
到这是因为有数据可读</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1177</x>
      <y>1725</y>
      <w>27</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.循环读取数据，直到进程要求读取的数据读取完（count&lt;=0）
	或者fifo中的数据读取完（PIPE_LEN=0）
2.一次读取的数据是count，PIPE_LEN以及PIPE_MAX_RCHUNK（
	start到fifo尾端的长度）的最小值
3.通过copy_to_user将fifo中的数据复制到用户空间
4.更新数据：
	//read是已读的所有数据长度
	read += chars;
	//start是读端的起始位置
	PIPE_START(*inode) += chars;
	PIPE_START(*inode) &amp;= (PIPE_SIZE - 1);
	PIPE_LEN(*inode) -= chars;
	count -= chars;
	buf += chars;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1152</x>
      <y>1721</y>
      <w>63</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_LEN=0
fifo中的数据全部读完
减少下次分两段读的可能性</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1207</x>
      <y>1724</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>PIPE_START(*inode) = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1152</x>
      <y>1721</y>
      <w>85</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;830.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1230</x>
      <y>1724</y>
      <w>30</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果进程要读的数据并没有被读完（count！=0）
	并且pipe中有等待的写端（WAITING_WRITERS）
	并且file被设置成block（!(f_flags &amp; O_NONBLOCK)）
	将等待队列中的唤醒，并跳到do_more_read去等待：
	wake_up_interruptible_sync(PIPE_WAIT(*inode));
	goto do_more_read;
2.如果上述条件并不满足，直接通过wake_up_interruptible唤醒
	等待队列，并返回已读的数据字节数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1139</x>
      <y>1750</y>
      <w>31</w>
      <h>19</h>
    </coordinates>
    <panel_attributes> //申明wait，并将其挂入等待队列
DECLARE_WAITQUEUE(wait, current);
current-&gt;state = TASK_INTERRUPTIBLE;
add_wait_queue(PIPE_WAIT(*inode), &amp;wait);
 //释放信号量，并调度
up(PIPE_SEM(*inode));
schedule();
 //移除wait，并申请信号量
remove_wait_queue(PIPE_WAIT(*inode), &amp;wait);
current-&gt;state = TASK_RUNNING;
down(PIPE_SEM(*inode));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>629</x>
      <y>1796</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.check bh.size和正确的block size是否一致
2.如果要求写，通过is_read_only查看dev是否
	只读

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>661</x>
      <y>1793</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>658</x>
      <y>1798</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过test_and_set_bit
	检查并设置BH_Lock
2.bh-&gt;b_end_io = 
			end_buffer_io_sync
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>667</x>
      <y>1793</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
rw</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>676</x>
      <y>1797</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
WRITE</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>674</x>
      <y>1801</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过atomic_set_buffer_clean
	检查并清除BH_Dirty
	如果没有置上，通过b_end_io
	结束这个bh请求
2.如果dirty置上了，通过__mark_buffer_clean
	改变bh在lru数组中的位置
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>679</x>
      <y>1797</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
READA
READ</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>695</x>
      <y>1802</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.检查bh是否uptodate，如果
	更新了，通过b_end_io结束
	bh请求
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>667</x>
      <y>1793</y>
      <w>70</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果bh请求没被end_io</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>728</x>
      <y>1802</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>submit_bh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>677</x>
      <y>1812</y>
      <w>32</w>
      <h>13</h>
    </coordinates>
    <panel_attributes> //lock要置上
test_bit(BH_Lock

set_bit(BH_Req
bh-&gt;b_rdev = bh-&gt;b_dev;
 //扇区的大小是512字节
bh-&gt;b_rsector = bh-&gt;b_blocknr * (bh-&gt;b_size&gt;&gt;9);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>687</x>
      <y>1805</y>
      <w>49</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>735</x>
      <y>1810</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_make_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>734</x>
      <y>1805</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>735</x>
      <y>1805</y>
      <w>42</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>770</x>
      <y>1810</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>WRITE:
kstat.pgpgout++
default:
kstat.pgpgin++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>713</x>
      <y>1813</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>710</x>
      <y>1816</y>
      <w>29</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.b_end_io要存在
2.通过blk_size计算出dev的扇区数maxsector
	通过bh-&gt;b_size计算出一个bh包含多少个扇区
	如果要写的扇区数count&gt;maxsector
	或者从sector写count个扇区后超过maxsector
	bh-&gt;b_state &amp;= (1 &lt;&lt; BH_Lock) | (1 &lt;&lt; BH_Mapped)
	bh-&gt;b_end_io(bh, 0)
halign=left
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>723</x>
      <y>1813</y>
      <w>51</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过do..while循环向终极设备发送请求
例如对RAID设备，因为RAID设备是对底层硬盘的抽象
所以通过make_request_fn向RAID设备发送请求时，
RAID设备会向第一块硬盘写，然后返回1，通过do..while
再次发送请求，RAID会向第二块硬盘发送写请求，并返回0，终止make_request
注：RAID参考南京大学蒋炎岩老师的视频</panel_attributes>
    <additional_attributes>220.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>746</x>
      <y>1816</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>740</x>
      <y>1819</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blk_get_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>740</x>
      <y>1825</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__blk_get_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>745</x>
      <y>1822</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>736</x>
      <y>1828</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>720</x>
      <y>1832</y>
      <w>37</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果blk_dev[MAJOR(dev)].queue存在，返回queue
2.否者返回blk_dev[MAJOR(dev)].request_queue
注：首次通过queue找到dev的队列，之后就可以直接通过
	request_queue找到
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>750</x>
      <y>1816</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>727</x>
      <y>1843</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_get_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>759</x>
      <y>1820</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;make_request_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>733</x>
      <y>1838</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hwif_init：
blk_dev[hwif-&gt;major].data = hwif;
blk_dev[hwif-&gt;major].queue = ide_get_queue;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>718</x>
      <y>1849</y>
      <w>28</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>hwif-&gt;drives[DEVICE_NR(dev) &amp; 1].queue
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>732</x>
      <y>1846</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>757</x>
      <y>1822</y>
      <w>44</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hwif_init-&gt;init_irq-&gt;ide_init_queue-&gt;blk_init_queue-&gt;__make_request</panel_attributes>
    <additional_attributes>100.0;20.0;330.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>783</x>
      <y>1825</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__make_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>758</x>
      <y>1833</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果是预读（READA）：
	rw_ahead = 1;
	rw = READ
2.通过buffer_mapped检测bh是否
	映射到磁盘

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>760</x>
      <y>1828</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>782</x>
      <y>1835</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_bounce</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>787</x>
      <y>1828</y>
      <w>5</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>788</x>
      <y>1838</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
DMA寻址范围是32位，不能寻址超过4G
需要将低内存区域对其做一个镜像
注：__GFP_HIGH和__GFP_HIGHMEM不一样</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>766</x>
      <y>1841</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>755</x>
      <y>1845</y>
      <w>21</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>!PageHighMem，不做任何处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>780</x>
      <y>1841</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bh_cachep中申请bh</panel_attributes>
    <additional_attributes>90.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>778</x>
      <y>1845</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>793</x>
      <y>1845</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>787</x>
      <y>1841</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在低于4G申请内存</panel_attributes>
    <additional_attributes>20.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>803</x>
      <y>1849</y>
      <w>30</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>set_bh_page(bh, page, 0);

bh-&gt;b_next = NULL;
bh-&gt;b_blocknr = bh_orig-&gt;b_blocknr;
bh-&gt;b_size = bh_orig-&gt;b_size;
bh-&gt;b_list = -1;
bh-&gt;b_dev = bh_orig-&gt;b_dev;
bh-&gt;b_count = bh_orig-&gt;b_count;
bh-&gt;b_rdev = bh_orig-&gt;b_rdev;
bh-&gt;b_state = bh_orig-&gt;b_state;
bh-&gt;b_flushtime = jiffies;
bh-&gt;b_next_free = NULL;
bh-&gt;b_prev_free = NULL;
bh-&gt;b_reqnext = NULL;
bh-&gt;b_pprev = NULL;

w:
bh-&gt;b_end_io = bounce_end_io_write;
copy_from_high_bh(bh, bh_orig);
r:
bh-&gt;b_end_io = bounce_end_io_read

bh-&gt;b_private = (void *)bh_orig;
bh-&gt;b_rsector = bh_orig-&gt;b_rsector;
memset(&amp;bh-&gt;b_wait, -1, sizeof(bh-&gt;b_wait));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>788</x>
      <y>1841</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>820</x>
      <y>1831</y>
      <w>39</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.从max_sectors中获取dev的扇区数（默认是MAX_SECTORS）
2.获取latency(r:read_latency;w:write_latency)，用于后期电梯
	算法的优化
3.如果req已经开始执行，但是没从队列里删除，会在执行完
	之后删除（q-&gt;head_active）
	并且不在bottom_half的任务队列tq_disk中（!q-&gt;plugged）
	head指向q-&gt;queue_head-&gt;next
4.如果队列为空：list_empty(head)，执行q-&gt;plug_device_fn
	因为队列为空，所以不用电梯算法优化，直接get_rq（申请req，
	加入到电梯队列中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>789</x>
      <y>1828</y>
      <w>44</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>840</x>
      <y>1850</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;plug_device_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>847</x>
      <y>1847</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>845</x>
      <y>1853</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
blk_init_queue</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>840</x>
      <y>1856</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_plug_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>834</x>
      <y>1863</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果请求队列为空或者
	队列中有req在tq_disk中
	这个req的IO由进程自己启动
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>841</x>
      <y>1859</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>847</x>
      <y>1859</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不由进程启动IO</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>860</x>
      <y>1862</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>855</x>
      <y>1866</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;plugged = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>863</x>
      <y>1862</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将队列挂在tq_disk中</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>871</x>
      <y>1866</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>queue_task</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>861</x>
      <y>1872</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>test_and_set_bit
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>877</x>
      <y>1872</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_add_tail
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>862</x>
      <y>1869</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
队列的plug_tq.sync检查是否为0
并置1</panel_attributes>
    <additional_attributes>130.0;10.0;70.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>875</x>
      <y>1869</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>866</x>
      <y>1831</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>elevator-&gt;elevator_merge_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>788</x>
      <y>1828</y>
      <w>86</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
blk_init_queue
ELEVATOR_LINUS</panel_attributes>
    <additional_attributes>10.0;10.0;840.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>867</x>
      <y>1838</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>elevator_linus_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>874</x>
      <y>1834</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>860</x>
      <y>1845</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果q-&gt;queue_head只是因为没执行完
	而没在队列中删除（head_active），
	而不是其他原因（q-&gt;plugged），就将
	head指向队列中的下一个
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>869</x>
      <y>1841</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>889</x>
      <y>1845</y>
      <w>37</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.向前遍历request_queue链表，滤除以下req：
	1.队列中req信号量sem存在
	2.队列中req的cmd的读写操作和rw不同
	3.队列中的req写的nr_sectors和现在req要写扇区数
	（count）超过了最大扇区数max_sectors
	4.队列中的req的设备号rq_dev和要写的req
		的b_rdev不同
2.如果要写的req在队列中req的后面
	if (__rq-&gt;sector + __rq-&gt;nr_sectors == bh-&gt;b_rsector) {
			ret = ELEVATOR_BACK_MERGE;
3.如果要写的req在队列中req的前面
	if (__rq-&gt;sector - count == bh-&gt;b_rsector) {
		//elevator_sequence来自latency，在这个检测之前，会看其是否为0
		//这个在电梯算法中为了防止order值过大的req饥饿，所以只要在req的前面
		//有插一个新req，req和之后的req的elevator_sequence都会--
			__rq-&gt;elevator_sequence--;
			ret = ELEVATOR_FRONT_MERGE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>876</x>
      <y>1841</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>927</x>
      <y>1845</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>如果新的req需要merge，并且被merge
的req之后链表还有req
因为之后的req前面有添加req，
所以需要把他们的tmp-&gt;elevator_sequence--
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>876</x>
      <y>1841</y>
      <w>62</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;600.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>789</x>
      <y>1828</y>
      <w>193</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1910.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>967</x>
      <y>1832</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ELEVATOR_BACK_MERGE</panel_attributes>
    <additional_attributes>130.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>964</x>
      <y>1836</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>960</x>
      <y>1848</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ll_back_merge_fn</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>960</x>
      <y>1841</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;back_merge_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>966</x>
      <y>1844</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
blk_init_queue</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>937</x>
      <y>1855</y>
      <w>42</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果req中最后一个bh能和插入的bh在物理内存
	上合并成在一起：
	req-&gt;bhtail-&gt;b_data + req-&gt;bhtail-&gt;b_size == bh-&gt;b_data
	直接返回，不对nr_segments操作
2.如果不能，通过ll_new_segment对nr_segments进行操作
	req-&gt;nr_segments++;
	q-&gt;elevator.nr_segments++
	如果req-&gt;nr_segments超过了限制，返回0，从而不对req进行合并
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>960</x>
      <y>1851</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>972</x>
      <y>1836</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果可以进行合并</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>976</x>
      <y>1841</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //bhtail指向req-&gt;bh链表中最后一个bh
req-&gt;bhtail-&gt;b_reqnext = bh;
req-&gt;bhtail = bh;
req-&gt;nr_sectors = req-&gt;hard_nr_sectors += count;
req-&gt;e = elevator;
 //硬盘信息统计
drive_stat_acct
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>971</x>
      <y>1836</y>
      <w>47</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1010</x>
      <y>1841</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>attempt_back_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1010</x>
      <y>1848</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果当前req是队列中的最后一个，没
	办法merge，直接return
2.不是最后一个，通过attempt_merge
	看能否将req和req.next merge
注：因为新插入的req可能将前后两个req
	连接起来
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1015</x>
      <y>1860</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>attempt_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1019</x>
      <y>1844</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1022</x>
      <y>1857</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1009</x>
      <y>1867</y>
      <w>34</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.查看两个相邻的req在扇区上是否能合并
	req-&gt;sector + req-&gt;nr_sectors = next-&gt;sector
2.查看两个req的属性是否相同，参考elevator_linus_merge
	req-&gt;cmd = next-&gt;cmd
	&amp;&amp; req-&gt;rq_dev = next-&gt;rq_dev
	&amp;&amp; req-&gt;nr_sectors + next-&gt;nr_sectors &lt; max_sectors
	&amp;&amp; !next-&gt;sem
3.通过q-&gt;merge_requests_fn查看bh指向的物理内存
	是否可以合并（nr_segments不能超过限制）
4.如果可以合并：
	//将next的bh链表加入到req的bh链表中，bhtail指向next的bh最后一个
	req-&gt;bhtail-&gt;b_reqnext = next-&gt;bh;
	req-&gt;bhtail = next-&gt;bhtail;
	req-&gt;nr_sectors = req-&gt;hard_nr_sectors += next-&gt;hard_nr_sectors;
	//将next从队列中删除
	list_del(&amp;next-&gt;queue);
	blkdev_release_request
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1022</x>
      <y>1863</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1017</x>
      <y>1899</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_release_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1025</x>
      <y>1895</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1011</x>
      <y>1902</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>996</x>
      <y>1906</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>req-&gt;rq_status = RQ_INACTIVE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1014</x>
      <y>1902</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
req-&gt;free_list不为空
free_list记录req是来自read_req还是write_req链表</panel_attributes>
    <additional_attributes>130.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1023</x>
      <y>1905</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
req释放给free_list</panel_attributes>
    <additional_attributes>90.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1020</x>
      <y>1910</y>
      <w>9</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>list_add
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1031</x>
      <y>1909</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>req-&gt;free_list = NULL;
 //唤醒队列的req等待序列
wake_up(&amp;req-&gt;q-&gt;wait_for_request)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1032</x>
      <y>1905</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>979</x>
      <y>1832</y>
      <w>82</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ELEVATOR_FRONT_MERGE</panel_attributes>
    <additional_attributes>10.0;10.0;800.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1045</x>
      <y>1836</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1039</x>
      <y>1841</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;front_merge_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1039</x>
      <y>1848</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ll_front_merge_fn</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1044</x>
      <y>1844</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1044</x>
      <y>1858</y>
      <w>42</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果bh能和req的最前面的bh在物理内存上合并成在一起：
	bh-&gt;b_data + bh-&gt;b_size == req-&gt;bh-&gt;b_data
	直接返回，不对nr_segments操作
2.如果不能，通过ll_new_segment对nr_segments进行操作
	req-&gt;nr_segments++;
	q-&gt;elevator.nr_segments++
	如果req-&gt;nr_segments超过了限制，返回0，从而不对req进行合并
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1044</x>
      <y>1851</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1058</x>
      <y>1836</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果可以进行合并</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1065</x>
      <y>1839</y>
      <w>33</w>
      <h>18</h>
    </coordinates>
    <panel_attributes> //将bh插入到req的头部
bh-&gt;b_reqnext = req-&gt;bh;
req-&gt;bh = bh;
 //buffer指向第一个bh的数据内存地址
req-&gt;buffer = bh-&gt;b_data;
 //第一个bh有多少个扇区
req-&gt;current_nr_sectors = count;
req-&gt;sector = req-&gt;hard_sector = sector;
req-&gt;nr_sectors = req-&gt;hard_nr_sectors += count;
req-&gt;e = elevator;
drive_stat_acct
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1101</x>
      <y>1839</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>attempt_front_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1057</x>
      <y>1836</y>
      <w>53</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1100</x>
      <y>1846</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果当前req是队列中的第一个，没
	办法merge，直接return
2.不是第一个，通过attempt_merge
	看能否将req.prev和req merge
注：因为新插入的req可能将前后两个req
	连接起来
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1109</x>
      <y>1842</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>980</x>
      <y>1832</y>
      <w>173</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ELEVATOR_NO_MERGE</panel_attributes>
    <additional_attributes>10.0;10.0;1710.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1146</x>
      <y>1837</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_rq
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>971</x>
      <y>1836</y>
      <w>64</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1029</x>
      <y>1840</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1121</x>
      <y>1839</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1057</x>
      <y>1836</y>
      <w>70</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1126</x>
      <y>1846</y>
      <w>34</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果之前申请过freereq
	req = freereq;
	freereq = NULL
2.如果没申请过req，通过get_request申请，
	因为req在blk_init_free_list规定是有限的
	所以有可能申请不到
3.当申请不到时，如果时预读（rw_ahead），直接结束
	本次读取；如果不是通过__get_request_wait等待
	获取，因为醒来时电梯中的req可能发生改变，所以再次
	遍历dev的request_queue
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1138</x>
      <y>1840</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1127</x>
      <y>1866</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1131</x>
      <y>1862</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1114</x>
      <y>1872</y>
      <w>31</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.首先获取空闲req的read/write链表
	q-&gt;request_freelist[rw]
2.如果空闲req链表不为空，通过blkdev_free_rq
	从空闲链表中获取req
3.如果空闲req为空，尝试从write req空闲链表中
	通过blkdev_free_rq获取req
4.如果获取到req，将req脱链，并进行初始化
	list_del(&amp;rq-&gt;table);
	//释放时，释放给对应的free_list
	rq-&gt;free_list = list;
	rq-&gt;rq_status = RQ_ACTIVE;
	rq-&gt;special = NULL;
	//指向req队列
	rq-&gt;q = q;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1127</x>
      <y>1869</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1147</x>
      <y>1867</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_request_wait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1146</x>
      <y>1862</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1149</x>
      <y>1875</y>
      <w>35</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.申明一个wait，加入到队列的wait_for_request链表中
2.将进程的状态设置为TASK_UNINTERRUPTIBLE，并
	试图通过get_request获取req，如果得到了，则退出
	将进程的状态还原，并将wait从wait_for_request从
	链表中移除
3.如果还是无法获取req，通过generic_unplug_device
	执行req队列从而释放req，并schedule
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>1870</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1160</x>
      <y>1891</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_unplug_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>1887</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1161</x>
      <y>1898</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__generic_unplug_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>1894</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>1901</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
q-&gt;plugged
如果有req在tq_disk中</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1163</x>
      <y>1904</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1156</x>
      <y>1907</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;plugged = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1167</x>
      <y>1904</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
q-&gt;queue_head</panel_attributes>
    <additional_attributes>20.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1171</x>
      <y>1907</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;request_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1177</x>
      <y>1910</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_init_queue-&gt;blk_init_queue</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1172</x>
      <y>1914</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_ide_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1150</x>
      <y>1840</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果获取到了req</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1166</x>
      <y>1843</y>
      <w>37</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>req-&gt;cmd = rw;
req-&gt;errors = 0;
req-&gt;hard_sector = req-&gt;sector = sector;
req-&gt;hard_nr_sectors = req-&gt;nr_sectors = count;
 //第一个bh包含的扇区数
req-&gt;current_nr_sectors = count;
 //最初的bh只有一个内存区间
req-&gt;nr_segments = 1; 
req-&gt;nr_hw_segments = 1;
 //buffer是之后硬盘要返回数据的指针，指向缓冲区
req-&gt;buffer = bh-&gt;b_data;
req-&gt;sem = NULL;
 //bh指向链表，bhtail指向最后一个链表
req-&gt;bh = bh;
req-&gt;bhtail = bh;
req-&gt;rq_dev = bh-&gt;b_rdev;
req-&gt;e = elevator;
 //将req加入到电梯队列中
add_request(q, req, head, latency)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1194</x>
      <y>1877</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1192</x>
      <y>1873</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1189</x>
      <y>1880</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
硬盘信息统计</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1185</x>
      <y>1883</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drive_stat_acct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1199</x>
      <y>1883</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;elevator.elevator_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1196</x>
      <y>1880</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
blk_init_queue
ELEVATOR_LINUS</panel_attributes>
    <additional_attributes>40.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1203</x>
      <y>1890</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>elevator_linus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1207</x>
      <y>1886</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1185</x>
      <y>1897</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>req-&gt;elevator_sequence 
				= orig_latency
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1191</x>
      <y>1893</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1207</x>
      <y>1893</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1204</x>
      <y>1897</y>
      <w>32</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.从后向前扫描req链表
2.通过blkdev_entry_to_request获取temp
3.通过IN_ORDER来看要插入的req是否在权重
	上大于temp，如果大于，req就要插到temp的
	后面
	list_add(&amp;req-&gt;queue, entry)
4.如果小于temp，需要插到temp前面，通过
	检查elevator_sequence查看temp前面是否能
	插入req；如果不能，只能插到temp后面；如果可以
	elevator_sequence--
注：1. linux2.4.0为了防止电梯队列中队列最后的
		req饥饿，通过以下方法：
		1.从前向后遍历req链表
		2.elevator_sequence设置req能允许多少个req
			插入其前面
	2.相比于linux0.11，order的权重少了rw的比较
		另外，linux0.11依靠!IN_ORDER(tmp,tmp-&gt;next)
		来防止后面的req饥饿
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1214</x>
      <y>1838</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>790</x>
      <y>1828</y>
      <w>429</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;4270.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>789</x>
      <y>1828</y>
      <w>451</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;4490.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1207</x>
      <y>1841</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!q-&gt;plugged
如果不在tq_disk中</panel_attributes>
    <additional_attributes>110.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1204</x>
      <y>1846</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;request_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1217</x>
      <y>1846</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_release_request
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1216</x>
      <y>1841</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果freereq没用
将其释放</panel_attributes>
    <additional_attributes>20.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1235</x>
      <y>1838</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>end_io
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1234</x>
      <y>1846</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bh-&gt;b_end_io
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1238</x>
      <y>1841</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1199</x>
      <y>1880</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1220</x>
      <y>1883</y>
      <w>26</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>当major满足：
COMPAQ_SMART2_MAJOR~COMPAQ_SMART2_MAJOR+7
COMPAQ_CISS_MAJOR~COMPAQ_CISS_MAJOR+7
DAC960_MAJOR~ DAC960_MAJOR+7
时：
q-&gt;request_fn
注：这里执行request_fn，是即使req加入到
	tq_disk，也要进程自己将其IO启动
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1172</x>
      <y>1921</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_do_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1176</x>
      <y>1917</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1089</x>
      <y>1924</y>
      <w>89</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
关闭中断</panel_attributes>
    <additional_attributes>870.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1087</x>
      <y>1928</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__cli
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1176</x>
      <y>1924</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!hwgroup-&gt;busy</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1096</x>
      <y>1931</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hwgroup-&gt;busy = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1102</x>
      <y>1927</y>
      <w>77</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>750.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1112</x>
      <y>1932</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>choose_drive</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1115</x>
      <y>1927</y>
      <w>64</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1066</x>
      <y>1939</y>
      <w>61</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.遍历hwgroup-&gt;drive（以next连接），如果dev所在
	的req队列不为空，并且设备没有睡眠（!drive-&gt;sleep）
	或者设备已经从睡眠中苏醒（0 &lt;= (signed long)(jiffies - drive-&gt;sleep)）
	时，在下列三种情况下，dev可以参选best：
	1.best还没有
	2.dev有睡过（drive-&gt;sleep，因为前面有条件，所以这里一定是睡着之后醒过来的）
		并且best没睡或者best.sleep比dev大（说明best的req请求是在dev之后，不然best在
		之前就执行完了，不会等到现在才执行）
	3.如果best和dev都不需要睡，就比较执行完操作醒来的时间WAKEUP(best) - WAKEUP(drive)
	（这里有两个假设，1，上次执行的时间service_time和此次执行的时间相同；2，上次执行完的时间点
		和现在执行这个函数的时间点一样，都是drive-&gt;service_start+drive-&gt;service_time
		所以(drive)-&gt;service_start + 2 * (drive)-&gt;service_time是预估dev执行完这个req
		所需的时间）
	如果上述3个条件满足其中一个，并且不在tq_disk中（!drive-&gt;queue.plugged ）
	best = drive
2.如果best存在，且其nice1存在，不曾睡眠（!best-&gt;sleep），best没有和group中的其他dev比较完
	（best != hwgroup-&gt;drive），上一次best的操作时间service_time &gt; WAIT_MIN_SLEEP
	如果上述条件满足，并且此次预估的操作时间WAKEUP(best) - jiffies&gt;WAIT_MIN_SLEEP
	然后再次从best遍历链表，如果在链表中发现有一个dev的sleep为0（只要激活立刻能请求），并且
	dev预估醒来的时间WAKEUP(drive)要大于best上次请求的时间（jiffies - best-&gt;service_time）（这里应该是为了确定dev没有长时间的在tq_disk中，如果长时间在tq_disk中，best留时间给dev也没用）
	并且dev预估醒来的时间比best要块时：
	通过ide_stall_queue让best sleep
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1090</x>
      <y>1978</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_stall_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1084</x>
      <y>1985</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drive-&gt;sleep = timeout + jiffies
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1099</x>
      <y>1935</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1094</x>
      <y>1974</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1092</x>
      <y>1981</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1131</x>
      <y>1927</y>
      <w>48</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive == NULL
如果没找到要执行req的设备</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1128</x>
      <y>1934</y>
      <w>37</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.遍历group的设备链表，找到其中能最早醒来的设备
2.如果sleep=0,表示没有设备睡着，是没有正在请求的req
3.如果sleep存在，设置相应的标志位
	hwgroup-&gt;sleeping = 1
	并且设置定时器hwgroup-&gt;timer，当时间到达之后通知执
	行req的超时（timer的function在init_irq中被设置为ide_timer_expiry）
4.之后直接return
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1140</x>
      <y>1949</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mod_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1144</x>
      <y>1945</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1128</x>
      <y>1957</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>timer-&gt;expires = expires;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1132</x>
      <y>1952</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1146</x>
      <y>1957</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>detach_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1144</x>
      <y>1952</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1158</x>
      <y>1957</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>internal_add_timer
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1144</x>
      <y>1952</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1137</x>
      <y>1964</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.通过timer_pending查看timer是否在链表中
2.如果在，通过list_del将time从链表中删除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1151</x>
      <y>1960</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1167</x>
      <y>1927</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取设备所在的接口</panel_attributes>
    <additional_attributes>100.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1165</x>
      <y>1934</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hwif = HWIF(drive)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1179</x>
      <y>1934</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>SELECT_INTERRUPT
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1176</x>
      <y>1927</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要操作的接口
不是原来的接口</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1168</x>
      <y>1939</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>OUT_BYTE((drive)-&gt;ctl|2, 
hwif-&gt;io_ports[IDE_CONTROL_OFFSET])
注：ctl bit1置1表示中断屏蔽
	第二个参数是是寄存器的IO地址
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>1937</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1197</x>
      <y>1934</y>
      <w>31</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>hwgroup-&gt;hwif = hwif;
hwgroup-&gt;drive = drive;
drive-&gt;sleep = 0;
drive-&gt;service_start = jiffies
 //指向当前的req，make_request中某种情况head指向next是因为next不被遍历
 //这里是处理完了之后才脱链
hwgroup-&gt;rq = blkdev_entry_next_request(&amp;drive-&gt;queue.queue_head)
 //因为要打开中断，防止其他irq被阻塞
 //所以这里将接口的irq屏蔽，打开其他中断
 //但是因为有hwgroup-&gt;busy挡住其他接口的请求
 //所以mask_irq设置位0
disable_irq_nosync
ide__sti
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1176</x>
      <y>1927</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1254</x>
      <y>1932</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1176</x>
      <y>1927</y>
      <w>86</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;840.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1235</x>
      <y>1935</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1229</x>
      <y>1939</y>
      <w>34</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.unit不能大于MAX_DRIVES
2.在ide_disk和ide_floppy进行读写时，
	要写的block号不能大于drive-&gt;part[minor&amp;PARTN_MASK].nr_sects
3.因为block号可能时设备分区的block号，所以通过start_sect+sect0转化
	为设备实际的block号
	block += drive-&gt;part[minor&amp;PARTN_MASK].start_sect + drive-&gt;sect0
4.如果设备的remap_0_to_1置上，那么如果block为0时将其映射到1号block（引导扇区的重新映射）
5.如果设备两次操作之间需要时间间隔，所以需要通过while等待间隔时间
	while ((read_timer() - hwif-&gt;last_time) &lt; DISK_RECOVERY_TIME);
注：unit是实际设备号
minor后面PARTN_BITS指的是设备的逻辑分区
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1273</x>
      <y>1939</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>SELECT_DRIVE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1260</x>
      <y>1935</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1264</x>
      <y>1945</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hwif-&gt;selectproc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1267</x>
      <y>1942</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1278</x>
      <y>1945</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>OUT_BYTE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1271</x>
      <y>1942</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
写寄存器IDE_SELECT_OFFSET
选择磁盘操作的模式，参考P1144</panel_attributes>
    <additional_attributes>90.0;10.0;120.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1292</x>
      <y>1939</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_special</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1260</x>
      <y>1935</y>
      <w>38</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;special.all
如果有什么特殊处理，例如每次操作之后需要回到0号柱面</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1260</x>
      <y>1935</y>
      <w>55</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没什么特殊操作</panel_attributes>
    <additional_attributes>10.0;10.0;530.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1303</x>
      <y>1937</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
IDE_DRIVE_CMD ||
IDE_DRIVE_TASK</panel_attributes>
    <additional_attributes>100.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1302</x>
      <y>1940</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>execute_drive_cmd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1319</x>
      <y>1940</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>driver-&gt;do_request
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1312</x>
      <y>1937</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1324</x>
      <y>1943</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
idedisk_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1320</x>
      <y>1948</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_rw_disk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1276</x>
      <y>1951</y>
      <w>51</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1263</x>
      <y>1954</y>
      <w>35</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.向IDE_CONTROL_REG写drive-&gt;ctl，将中断屏蔽打开
2.向IDE_NSECTOR_REG写要读写的扇区数rq-&gt;nr_sectors
3.如果是lba或者是PDC4030，将block号写入28位寄存器
	低8位写入IDE_SECTOR_REG
	中间16位写入CYL_REG
	最高4位写入IDE_SELECT_REG低4位
4.如果是chs，将block写入到指定寄存器
	扇区模（sect  = block % drive-&gt;sect + 1）写进IDE_SECTOR_REG
	磁头号（track % drive-&gt;head）写进IDE_SELECT_REG低4位
	柱面号（track / drive-&gt;head）写进CYL_REG
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1310</x>
      <y>1951</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
READ</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1301</x>
      <y>1954</y>
      <w>14</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;using_dma
ide_dma_read</panel_attributes>
    <additional_attributes>100.0;10.0;30.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1299</x>
      <y>1962</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>HWIF(drive)-&gt;dmaproc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1310</x>
      <y>1954</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不用DMA</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1320</x>
      <y>1956</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
read_intr</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1314</x>
      <y>1961</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_set_handler</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1308</x>
      <y>1967</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>hwgroup-&gt;handler	= handler;
 //超时之后的函数指针
hwgroup-&gt;expiry		= expiry;
hwgroup-&gt;timer.expires	= jiffies + timeout;
add_timer(&amp;hwgroup-&gt;timer);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1319</x>
      <y>1964</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1326</x>
      <y>1961</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>OUT_BYTE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1313</x>
      <y>1956</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
向IDE_COMMAND_REG寄存器
发送MULTREAD或者READ命令
MULTREAD取决于要读的扇区号和磁盘缓冲区大小</panel_attributes>
    <additional_attributes>120.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1325</x>
      <y>1951</y>
      <w>46</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
WRITE</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1324</x>
      <y>1956</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1343</x>
      <y>1961</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return ide_started
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1357</x>
      <y>1953</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;using_dma
ide_dma_write</panel_attributes>
    <additional_attributes>120.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1348</x>
      <y>1956</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>HWIF(drive)-&gt;dmaproc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1368</x>
      <y>1954</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不用DMA</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1382</x>
      <y>1956</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1377</x>
      <y>1959</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_wait_stat</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1360</x>
      <y>1966</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果硬盘状态为BUSY_STAT，设置timeout
	时间，然后通过while等待，如果在timeout时间
	之内busy标志清除，执行2，否者返回1
2.如果busy标志清除，检查硬盘状态是good而不是
	bad（循环查询10次），正确返回0，否则返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1374</x>
      <y>1962</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1380</x>
      <y>1956</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要求屏蔽其他中断
!drive-&gt;unmask
暂时没看见在什么时候打开</panel_attributes>
    <additional_attributes>30.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1392</x>
      <y>1962</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cli
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1359</x>
      <y>1956</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查看mult_count，
然后写相应的命令至IDE_COMMAND_REG</panel_attributes>
    <additional_attributes>230.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1361</x>
      <y>1961</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>OUT_BYTE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1382</x>
      <y>1956</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1411</x>
      <y>1959</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mult_count</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1411</x>
      <y>1959</y>
      <w>44</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1447</x>
      <y>1962</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
write_intr</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1444</x>
      <y>1965</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_set_handler</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1457</x>
      <y>1965</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>idedisk_output_data</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1453</x>
      <y>1962</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1458</x>
      <y>1973</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_output_data</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1464</x>
      <y>1968</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bswap表示将数据的高8位和低8位换位置</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1444</x>
      <y>1976</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;io_32bit
如果是32位</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1465</x>
      <y>1976</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是16位</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1459</x>
      <y>1980</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;slow
out在io.h中定义
这里_p是有延时
向IDE_DATA_REG写2个short</panel_attributes>
    <additional_attributes>160.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1459</x>
      <y>1985</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>outw_p
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1473</x>
      <y>1980</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
OUTS
靠rep循环写入16字节
所以wcount左移1位</panel_attributes>
    <additional_attributes>20.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1481</x>
      <y>1986</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>outsw
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1442</x>
      <y>1980</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
rep循环写入32字节</panel_attributes>
    <additional_attributes>30.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1446</x>
      <y>1985</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>outsl
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1472</x>
      <y>1962</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return ide_started
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1368</x>
      <y>1954</y>
      <w>111</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1090.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1438</x>
      <y>1980</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1431</x>
      <y>1983</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过do_vlb_sync读
	3次寄存器IDE_NSECTOR_REG
2.在通过outl写数据
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1411</x>
      <y>1963</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
multwrite_intr</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1407</x>
      <y>1967</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_set_handler</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1393</x>
      <y>1967</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hwgroup-&gt;wrq = *rq
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1399</x>
      <y>1963</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
赋值request</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1421</x>
      <y>1967</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_multwrite</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1412</x>
      <y>1963</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1418</x>
      <y>1970</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1392</x>
      <y>1973</y>
      <w>38</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.确定此次写入的扇区大小，以current_nr_sectors
	为基础，如果超过了mcount，就只写mcount
2.更新mcount
3.通过idedisk_output_data向磁盘写buffer
	将扇区数左移7位换算成32位
4.检查nr_sectors是否读完，如果读完，break
	返回0，之后在上层函数中返回ide_started
5.如果没读完，查看当前bh的扇区是否读完，如果没有读完
	只有可能是mcount比bh扇区数小，所以将buffer指针更新
	返回0，之后在上层函数中返回ide_started
6.如果bh的扇区读完，就读下一个bh，并更新req
	rq-&gt;current_nr_sectors = rq-&gt;bh-&gt;b_size&gt;&gt;9;
	rq-&gt;buffer             = rq-&gt;bh-&gt;b_data;
	执行下一个do...while
7.如果整个req的写完了，通过ide_end_request结束request
	注意uptodate为0，表示数据还没更新
注:磁盘的缓冲区大小是mcount
	如果mcount写完，只能等到中断到来之后，再次通过中断向
	硬盘进行写入
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1300</x>
      <y>1965</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_setup_dma</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1294</x>
      <y>1973</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_dmaproc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1206</x>
      <y>1976</y>
      <w>95</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_dma_read</panel_attributes>
    <additional_attributes>930.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1200</x>
      <y>1986</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reading = 1 &lt;&lt; 3
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1244</x>
      <y>1976</y>
      <w>57</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_dma_read/ide_dma_write</panel_attributes>
    <additional_attributes>550.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1219</x>
      <y>1985</y>
      <w>29</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
&lt;&lt;includes&gt;&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1214</x>
      <y>1988</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>SELECT_READ_WRITE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1234</x>
      <y>1989</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_build_dmatable</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1231</x>
      <y>1985</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果出错返回0，ide_dmaproc返回1
do_rw_disk放弃dma继续执行io指令</panel_attributes>
    <additional_attributes>150.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1185</x>
      <y>1996</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_build_sglist</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1190</x>
      <y>1992</y>
      <w>52</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sg_table</panel_attributes>
    <additional_attributes>500.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1154</x>
      <y>2004</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>Read:
hwif-&gt;sg_dma_direction = PCI_DMA_FROMDEVICE
other:
hwif-&gt;sg_dma_direction = PCI_DMA_TODEVICE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1169</x>
      <y>1999</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1192</x>
      <y>2004</y>
      <w>39</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.遍历req的bh，看两个连着的bh是否在缓冲区上能合并
	virt_addr + size=bh-&gt;b_data
2.如果可以合并，将size增加，并遍历下一个bh
3.如果不能合并，直接退出当前遍历，然后申请一个scatterlist
	sg[nents].address = virt_addr;
	sg[nents].length = size;
	nents++;
4.然后在继续遍历向下遍历那个不能合并的bh
5.bh遍历完成之后，通过pci_map_sg检查，并返回nents
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1191</x>
      <y>1999</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1232</x>
      <y>1998</y>
      <w>44</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.遍历sg_table中的所有scatterlist
2.合并缓冲区的长度在每个DMA处理中都不能超过64K(0x10000)
	的边界，dmatable_cpu中第一项填起始地址，第二项填长度
	（最长不能超过64K,第一个entry可能没超过64K,即使其长度超过
	了64K,因为其内存单位是64K对齐）（两者合起来叫一个entry），
	如果一个DMA entry放不下这个scatterlist，就在下一个DMA entry
	中填写（这个entry不能超过PRD_ENTRIES（256），总共2k，有两个
	ide接口，总共4k）
注：dmatable_cpu指向的虚拟地址，dmatable_dma指向的是物理地址
	因为此时是cpu在操作，所以用的是dmatable_cpu
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1239</x>
      <y>1992</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1245</x>
      <y>1985</y>
      <w>44</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1278</x>
      <y>1993</y>
      <w>45</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.写寄存器
	向dma_base + 4写DMA表的32位指针dmatable_dma（实际物理地址）
	向dma_base（前8位ide0，后8位ide1）8位寄存器写读写命令（reading）
	向dma_base+2中的8位寄存器的第2，3位写1，清intr，error
2.	
	drive-&gt;waiting_for_dma = 1
	ide_set_handler（ide_dma_intr）
3.开启dma
	向IDE_COMMAND_REG写WIN_READDMA/WIN_WRITEDMA
	向dma_base8位寄存器的第1字节写1，开启DMA
注：之后DMA会根据dmatable_dma中的DMA表，向缓冲区读写数据，直到
	表写完之后向cpu发出中断
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1298</x>
      <y>1976</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_dma_end</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1326</x>
      <y>1984</y>
      <w>30</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>drive-&gt;waiting_for_dma = 0
 //向dma_base最低位写0，关闭dma
outb(inb(dma_base)&amp;~1, dma_base)
 //读出状态
dma_stat = inb(dma_base+2)
 //清intr error
outb(dma_stat|6, dma_base+2)
 //没有清除dma表，之后写的时候直接覆盖
ide_destroy_dmatable
最后检查dma_stat第3位（应该是error），正确的话是置上的
（此时返回0，正是ide_dma_intr需要的）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>656</x>
      <y>1785</y>
      <w>14</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历bh数组</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>637</x>
      <y>1785</y>
      <w>22</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>652</x>
      <y>1782</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ll_rw_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>657</x>
      <y>1774</y>
      <w>3</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>86</x>
      <y>2088</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_lseek</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>71</x>
      <y>2097</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>77</x>
      <y>2091</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>98</x>
      <y>2098</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>llseek</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>91</x>
      <y>2091</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
origin &lt;= 2</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>93</x>
      <y>2101</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file-&gt;f_op-&gt;llseek存在</panel_attributes>
    <additional_attributes>100.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>102</x>
      <y>2101</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>107</x>
      <y>2107</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>default_llseek</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>91</x>
      <y>2108</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;llseek
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>92</x>
      <y>2116</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_file_lseek</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>96</x>
      <y>2111</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_file_operations</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>69</x>
      <y>2119</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>56</x>
      <y>2124</y>
      <w>35</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.origin为2时，偏移从文件最后开始算（i_size+offset）
2.origin为1时，偏移从当前位置开始算(f_pos+offset)
3.origin为0时，偏移从文件首开始算(offset)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>97</x>
      <y>2119</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
offset &gt;&gt; 32 != 0
如果超过了32位</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>95</x>
      <y>2126</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>offset不能超过ext2_max_sizes
ext2_max_sizes规定的是逻辑block数组
最大是15经历了3层映射，所以最大长度是有限制的
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>97</x>
      <y>2119</y>
      <w>37</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
offset != file-&gt;f_pos</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>122</x>
      <y>2125</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>file-&gt;f_pos = offset;
file-&gt;f_reada = 0;
file-&gt;f_version = ++event;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>127</x>
      <y>2098</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>res是64位，retval是32位
当res != (loff_t)retval时，
说明sys_lseek超过了32位，报错-EOVERFLOW
如果超过32位，使用sys_llseek
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>91</x>
      <y>2091</y>
      <w>43</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;


</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>204</x>
      <y>2105</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_dup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>179</x>
      <y>2115</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>226</x>
      <y>2115</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dupfd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>184</x>
      <y>2108</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>210</x>
      <y>2108</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果file存在</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>215</x>
      <y>2125</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locate_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>221</x>
      <y>2118</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>191</x>
      <y>2128</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
start &lt; files-&gt;next_fd
start不能小于next_fd</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>182</x>
      <y>2135</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start = files-&gt;next_fd
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>201</x>
      <y>2136</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>newfd = start
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>205</x>
      <y>2128</y>
      <w>17</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
newfd在expand_files统一</panel_attributes>
    <additional_attributes>140.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>219</x>
      <y>2128</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
start &lt; files-&gt;max_fdset
</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>218</x>
      <y>2136</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_next_zero_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>236</x>
      <y>2137</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>申请到的fd要小于
RLIMIT_NOFILE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>219</x>
      <y>2128</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>255</x>
      <y>2137</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expand_files</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>219</x>
      <y>2128</y>
      <w>43</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>246</x>
      <y>2140</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果需要扩充</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>238</x>
      <y>2146</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>nr&gt;max_fdset  expand_fdset
nr&gt;max_fds   expand_fd_array
error=1(需要repeat，重新查找)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>259</x>
      <y>2140</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不需要扩充</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>266</x>
      <y>2147</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>error=0
沿用申请到的newfd
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>219</x>
      <y>2128</y>
      <w>65</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
start &lt;= files-&gt;next_fd
如果申请到next_fd
</panel_attributes>
    <additional_attributes>10.0;10.0;630.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>275</x>
      <y>2138</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>files-&gt;next_fd = newfd + 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>298</x>
      <y>2126</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>allocate_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>232</x>
      <y>2118</y>
      <w>75</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;730.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>294</x>
      <y>2133</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>FD_SET(fd, files-&gt;open_fds);
FD_CLR(fd, files-&gt;close_on_exec);
fd_install(fd, file)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>303</x>
      <y>2129</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>204</x>
      <y>2118</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>194</x>
      <y>2122</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>files = current-&gt;files
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>391</x>
      <y>2107</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_ioctl
可扩充
cmd参考657页
Documentation/ioctl_number.txt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>332</x>
      <y>2122</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>336</x>
      <y>2110</y>
      <w>63</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>610.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>2110</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file不为空</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>353</x>
      <y>2113</y>
      <w>46</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIOCLEX</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>348</x>
      <y>2122</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_close_on_exec(1)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>367</x>
      <y>2122</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_close_on_exec(0)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>374</x>
      <y>2113</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIOCLEX</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>366</x>
      <y>2130</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>2113</y>
      <w>9</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIONBIO</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>371</x>
      <y>2120</y>
      <w>28</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从用户空间拿参数</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>387</x>
      <y>2128</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>if (on)
	filp-&gt;f_flags |= O_NONBLOCK;
else
	filp-&gt;f_flags &amp;= ~O_NONBLOCK;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>2120</y>
      <w>4</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>2113</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIOASYNC</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>412</x>
      <y>2130</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>414</x>
      <y>2121</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从用户空间拿参数</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>422</x>
      <y>2121</y>
      <w>22</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

(flag ^ filp-&gt;f_flags) &amp; FASYNC
FASYNC发生了变化</panel_attributes>
    <additional_attributes>30.0;10.0;180.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>436</x>
      <y>2131</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;fasync
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>424</x>
      <y>2121</y>
      <w>38</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>452</x>
      <y>2129</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>if (on)
	filp-&gt;f_flags |= FASYNC;
else
	filp-&gt;f_flags &amp;= ~FASYNC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>419</x>
      <y>2134</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flag = on ? FASYNC : 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>424</x>
      <y>2121</y>
      <w>5</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>2113</y>
      <w>98</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
default</panel_attributes>
    <additional_attributes>10.0;10.0;960.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>478</x>
      <y>2132</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file_ioctl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>481</x>
      <y>2122</y>
      <w>13</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISREG</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>522</x>
      <y>2132</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;ioctl
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>491</x>
      <y>2122</y>
      <w>42</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否则
如果filp-&gt;f_op-&gt;ioctl存在</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>503</x>
      <y>2119</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>396</x>
      <y>2110</y>
      <w>113</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1110.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>480</x>
      <y>2135</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
cmd</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>448</x>
      <y>2140</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIBMAP
返回逻辑块号对应的物理块号</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>409</x>
      <y>2154</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.mapping-&gt;a_ops-&gt;bmap存在
2.进程具有CAP_SYS_RAWIO
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>418</x>
      <y>2147</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>435</x>
      <y>2154</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.得到逻辑块号get_user
2.根据逻辑块号获取物理块号
mapping-&gt;a_ops-&gt;bmap
3.返回物理块号put_user
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>446</x>
      <y>2147</y>
      <w>5</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>463</x>
      <y>2140</y>
      <w>20</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIGETBSZ
返回文件设备的总块数</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>458</x>
      <y>2155</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_user(inode-&gt;i_sb-&gt;s_blocksize
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>480</x>
      <y>2140</y>
      <w>22</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIONREAD
返回当前位置到文件末尾的距离</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>484</x>
      <y>2155</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_user(inode-&gt;i_size - filp-&gt;f_pos
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>481</x>
      <y>2135</y>
      <w>36</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filp-&gt;f_op-&gt;ioctl存在</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>507</x>
      <y>2149</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;ioctl
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>620</x>
      <y>2106</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>540</x>
      <y>2109</y>
      <w>89</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制用户空间中源文件名和新文件名</panel_attributes>
    <additional_attributes>870.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>537</x>
      <y>2122</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>from = getname(oldname)
to = getname(newname)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>567</x>
      <y>2122</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>path_init
path_walk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>571</x>
      <y>2109</y>
      <w>58</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
from, 
LOOKUP_POSITIVE和LOOKUP_DIRECTORY置上时，如果找不到
inode会报错</panel_attributes>
    <additional_attributes>560.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>589</x>
      <y>2122</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>path_init
path_walk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>592</x>
      <y>2109</y>
      <w>37</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
to,
LOOKUP_PARENT表示只找到上一层目录</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>612</x>
      <y>2109</y>
      <w>16</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
old_nd.mnt != nd.mnt
安装节点不一致时报错</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>610</x>
      <y>2123</y>
      <w>8</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>-EXDEV
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>624</x>
      <y>2122</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>626</x>
      <y>2109</y>
      <w>7</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>607</x>
      <y>2131</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_hash
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>611</x>
      <y>2125</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在hash和磁盘中找inode</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>630</x>
      <y>2125</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>626</x>
      <y>2129</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果is_dir=0，并且是目录last.name[nd-&gt;last.len]
（如果是目录，这个字符应该是‘\’）
	但是在没找到inode，返回-ENOENT
2.否则返回dentry（没找到d_inode为NULL）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>626</x>
      <y>2109</y>
      <w>49</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!IS_ERR(new_dentry)</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>671</x>
      <y>2127</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>672</x>
      <y>2120</y>
      <w>8</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>691</x>
      <y>2126</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>672</x>
      <y>2120</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>642</x>
      <y>2140</y>
      <w>35</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.源文件inode要存在（old_dentry-&gt;d_inode）
2.新文件may_create
	1.新文件的inode不能存在 new_dentry.d_inode
	2.新文件的目录不是IS_DEADDIR
	3.新文件目录要有MAY_WRITE | MAY_EXEC
3.新文件要和源文件在同一个设备
	dir-&gt;i_dev == inode-&gt;i_dev
4.源文件不能有IS_APPEND  IS_IMMUTABLE标记
5.新文件的dir-&gt;i_op-&gt;link要存在
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>654</x>
      <y>2130</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>686</x>
      <y>2141</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>683</x>
      <y>2134</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_op-&gt;link
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>680</x>
      <y>2130</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>689</x>
      <y>2136</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>717</x>
      <y>2135</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_dir_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>680</x>
      <y>2130</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
DN_CREATE
如果链接建立完成，需要通知父目录
i_dnotify中的通知对象</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>653</x>
      <y>2159</y>
      <w>30</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.建立硬链接的不能是目录
2.inode-&gt;i_nlink不能大于EXT2_LINK_MAX
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>665</x>
      <y>2144</y>
      <w>31</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>688</x>
      <y>2159</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_add_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>693</x>
      <y>2144</y>
      <w>3</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>713</x>
      <y>2156</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //增加inode的硬链接计数
inode-&gt;i_nlink++;
inode-&gt;i_ctime = CURRENT_TIME;
mark_inode_dirty(inode);
atomic_inc(&amp;inode-&gt;i_count);
 //将dentry链接到inode的链表中
d_instantiate(dentry, inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>693</x>
      <y>2144</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>624</x>
      <y>2172</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>629</x>
      <y>2162</y>
      <w>67</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读dir的数据到内存</panel_attributes>
    <additional_attributes>650.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>640</x>
      <y>2173</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rec_len = EXT2_DIR_REC_LEN(namelen)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>655</x>
      <y>2162</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
要添加entry需要的长度</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>693</x>
      <y>2162</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历dir，找到足够的长度容纳
要添加的entry</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>678</x>
      <y>2170</y>
      <w>71</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>1.ext2_check_dir_entry 检查de中的各类属性
2.ext2_match 检查de中是否有和此次添加entry
	相同的name
3.检查当前的de是否可以容纳当前的entry
	能容纳的两个条件：
		1.de-&gt;inode为0，且这个entry的长度rec_len大于此次要添加entry的长度
		2.如果de-&gt;inode不为0，但是这个entry的长度能容纳自己的entryEXT2_DIR_REC_LEN(de-&gt;name_len)
		和要添加的entry的长度
		如果是第2中情况，将之前entyr的长度更新为EXT2_DIR_REC_LEN(de-&gt;name_len)，剩下的位置给要添加的entry
		de1 =de+EXT2_DIR_REC_LEN(de-&gt;name_len)
		de1-&gt;rec_len =(le16_to_cpu(de-&gt;rec_len) - EXT2_DIR_REC_LEN(de-&gt;name_len)
	为要添加的entry，赋值其他的属性
	de-&gt;file_type = EXT2_FT_UNKNOWN;
	if (inode) {
		de-&gt;inode = cpu_to_le32(inode-&gt;i_ino);
		ext2_set_de_type(dir-&gt;i_sb, de, inode-&gt;i_mode);
	} else
		de-&gt;inode = 0;
	de-&gt;name_len = namelen;
	memcpy (de-&gt;name, name, namelen);
	dir-&gt;i_mtime = dir-&gt;i_ctime = CURRENT_TIME;
	dir-&gt;u.ext2_i.i_flags &amp;= ~EXT2_BTREE_FL;
	mark_inode_dirty(dir);
	dir-&gt;i_version = ++event;
	mark_buffer_dirty_inode(bh, dir);
	如果需要同步的话，会通过ll_rw_block写dir，并wait_on_buffer
4.如果没找到，更新位置和下一个entry
	offset += le16_to_cpu(de-&gt;rec_len);
	de = (struct ext2_dir_entry_2 *) ((char *) de + le16_to_cpu(de-&gt;rec_len))
5.如果超过了当前读取的bh，通过ext2_bread读下一个block的dir数据,然后重复上述过程继续查找
	1.如果offset超过了dir的size，更新dir的size和将下一个block都设置为一个entry
		de = (struct ext2_dir_entry_2 *) bh-&gt;b_data;
		de-&gt;inode = 0;
		de-&gt;rec_len = le16_to_cpu(sb-&gt;s_blocksize);
		dir-&gt;i_size = offset + sb-&gt;s_blocksize;
		dir-&gt;u.ext2_i.i_flags &amp;= ~EXT2_BTREE_FL;
		mark_inode_dirty(dir);
	2.如果没超过dir的size，继续查找dir下一个block数据
		de = (struct ext2_dir_entry_2 *) bh-&gt;b_data
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>966</x>
      <y>2118</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_proc_fs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>943</x>
      <y>2126</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>950</x>
      <y>2121</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>918</x>
      <y>2136</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.要注册fs要存在  -EINVAL
2.fs的next指针不能在链表中  -EBUSY
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>926</x>
      <y>2129</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>948</x>
      <y>2129</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>944</x>
      <y>2135</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过find_filesystem在链表file_systems中查询
2.如果查到当前filesystem在链表中存在，返回-EBUSY
3.如果不存在，将当前的filesystem链入到链表中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>995</x>
      <y>2128</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kern_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>974</x>
      <y>2121</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果成功注册</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>981</x>
      <y>2136</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_unnamed_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1001</x>
      <y>2136</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_super
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1045</x>
      <y>2139</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_vfsmnt
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>985</x>
      <y>2131</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>962</x>
      <y>2145</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.在位图unnamed_dev_in_use中从1开始查找
2.如果找到，返回MKDEV(UNNAMED_MAJOR, i)
	否则，返回0.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>976</x>
      <y>2139</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1001</x>
      <y>2131</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>997</x>
      <y>2144</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过get_empty_super，得到super_block结构体
2.对super_block属性做相关的设置
3.通过file_system的read_super将超级块读进来
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1007</x>
      <y>2139</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1009</x>
      <y>2156</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_read_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1014</x>
      <y>2150</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_fs_type
proc_root</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>983</x>
      <y>2164</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>s-&gt;s_blocksize = 1024;
s-&gt;s_blocksize_bits = 10;
s-&gt;s_magic = PROC_SUPER_MAGIC;
s-&gt;s_op = &amp;proc_sops;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>994</x>
      <y>2159</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置超级块的块大小和
操作函数等属性</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1013</x>
      <y>2166</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_get_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1015</x>
      <y>2159</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取根节点</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>999</x>
      <y>2174</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1003</x>
      <y>2169</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加proc_root计数</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1015</x>
      <y>2175</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iget
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1018</x>
      <y>2169</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1020</x>
      <y>2178</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
首先会在hash表中查找，
如果没找到会申请inode结构体
然后利用sb的proc_sops的read_inode读取</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1014</x>
      <y>2185</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_read_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1013</x>
      <y>2193</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_mtime = 
inode-&gt;i_atime = 
inode-&gt;i_ctime = CURRENT_TIME;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1020</x>
      <y>2188</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里只是设置了inode时间
其他属性需要在iget中查看</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1030</x>
      <y>2167</y>
      <w>18</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>root_inode-&gt;i_nlink++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1016</x>
      <y>2159</y>
      <w>23</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
除了idle_task，其他task都
增加inode的硬链接计数</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1053</x>
      <y>2167</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_alloc_root
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1017</x>
      <y>2159</y>
      <w>42</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
给s-&gt;s_root分配root管理</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1104</x>
      <y>2168</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>parse_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1016</x>
      <y>2159</y>
      <w>94</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1040</x>
      <y>2176</y>
      <w>27</w>
      <h>23</h>
    </coordinates>
    <panel_attributes> //generic_ip中存储的inode对应的proc_dir_entry
inode-&gt;u.generic_ip=de (proc_root)
inode-&gt;i_mode = de-&gt;mode;
inode-&gt;i_uid = de-&gt;uid;
inode-&gt;i_gid = de-&gt;gid;
inode-&gt;i_size = de-&gt;size
inode-&gt;i_nlink = de-&gt;nlink
__MOD_INC_USE_COUNT(de-&gt;owner)
如果是块设备/字符设备/FIFO设备
	init_special_inode（reference）
否则：
	inode-&gt;i_op = de-&gt;proc_iops
	inode-&gt;i_fop = de-&gt;proc_fops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1018</x>
      <y>2169</y>
      <w>34</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1069</x>
      <y>2178</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>root_inode-&gt;i_uid=current-&gt;uid
root_inode-&gt;i_gid= current-&gt;gid
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1078</x>
      <y>2171</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1093</x>
      <y>2179</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1097</x>
      <y>2171</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没有要解析的数据
!options</panel_attributes>
    <additional_attributes>120.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1084</x>
      <y>2203</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>strtok</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1061</x>
      <y>2212</y>
      <w>43</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果要解析的数据为空，就解析之前剩下的数据___strtok，
	否则解析传过来的数据
2.通过strspn计算和分个符相同的长度，然后将s更新为和分个符
	不同的sbegin
3.如果sbegin为'\0'，___strtok=NULL
4.否则，通过strpbrk找到剩下字符串中的第一个分隔符，并且
*send++ = '\0';
___strtok = send;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1080</x>
      <y>2206</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1107</x>
      <y>2181</y>
      <w>39</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.通过strtok将字符串通过‘，’拆分开
2.循环检查，利用strchr将this_char用‘=’分隔开
	this_char指向等号前面，value指向等号后面
3.如果this_char是"uid"，利用simple_strtoul将字符串
	转化成整数，然后使root_inode-&gt;i_uid=current-&gt;uid=value
	如果value中有不能解析的（*value最后还有值），返回0
4.同理，如果this_char是"gid"：
	root_inode-&gt;i_gid=value
5.如果都不是，直接返回1
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1090</x>
      <y>2196</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1138</x>
      <y>2204</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>simple_strtoul</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1133</x>
      <y>2196</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1138</x>
      <y>2213</y>
      <w>37</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.首先确认base（是10进制。8进制、还是16进制）
	其中isxdigit表示字符是否是16进制数，可以将
	_ctype对比ASCII表
2.将各个字符换算成整数，乘上base再相加，其中
	isdigit表示字符是否是10进制数
3.更改value的地址，（返回后可以看value是否指向'\0'
	来检查是否满足整数的要求）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1144</x>
      <y>2207</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1115</x>
      <y>2203</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>strchr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1120</x>
      <y>2196</y>
      <w>8</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1106</x>
      <y>2211</y>
      <w>30</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>"movb %%al,%%ah\n"
 //将s字符加载到al中，s++
"1:\tlodsb\n\t"
"cmpb %%ah,%%al\n\t"
"je 2f\n\t"
	// al &amp;al,如果结果为0
	//zf会置1，表示相等
"testb %%al,%%al\n\t"
"jne 1b\n\t"
 //这里置1，后面--，就会变成NULL
"movl $1,%1\n"
 //将s--，并返回
"2:\tmovl %1,%0\n\t"
"decl %0"
:"=a" (__res), "=&amp;S" (d0) : "1" (s),"0" (c));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1119</x>
      <y>2206</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
用于在字符串中找到
相应的字符</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1108</x>
      <y>2171</y>
      <w>20</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
解析options</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1001</x>
      <y>2131</y>
      <w>52</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注意这里的安装目录是NULL
mnt_mountpoint指向自己的root
mnt_parent指向自己
mnt_child mnt_clash都不用指向自己

之后用户层会通过调用
mount nvt proc /dev/null /proc
讲procfs装载到/proc目录下
</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1076</x>
      <y>2136</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>type-&gt;kern_mnt = mnt
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1002</x>
      <y>2131</y>
      <w>84</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将安装节点放在文件系统中
之后用户在mount的时候
会通过	get_sb_single调用</panel_attributes>
    <additional_attributes>10.0;10.0;820.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>829</x>
      <y>2124</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_mknod</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>778</x>
      <y>2137</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>783</x>
      <y>2127</y>
      <w>54</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从用户空款copy name到系统空间</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>803</x>
      <y>2127</y>
      <w>34</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取父目录和子文件的name到nd
注意flag是LOOKUP_PARENT</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>800</x>
      <y>2137</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>path_init
path_walk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>816</x>
      <y>2137</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_create
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>821</x>
      <y>2127</y>
      <w>16</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为子节点创建dentry
注意传递的is_dir是0
表示子节点不能是目录</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>835</x>
      <y>2127</y>
      <w>22</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查看传递进来的参数mode
看要创建的文件的类型
注：不能创建目录</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>830</x>
      <y>2137</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
0
S_IFREG</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>826</x>
      <y>2143</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>841</x>
      <y>2137</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_IFCHR
S_IFBLK
S_IFSOCK</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>849</x>
      <y>2143</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_mknod</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>870</x>
      <y>2136</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //释放父目录和mnt
path_release(&amp;nd)
 //释放临时的name内存
putname(tmp)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>835</x>
      <y>2127</y>
      <w>45</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>823</x>
      <y>2146</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>801</x>
      <y>2150</y>
      <w>36</w>
      <h>13</h>
    </coordinates>
    <panel_attributes> //umask规定进程创建的文件不允许有的权限
1.mode &amp;= ~current-&gt;fs-&gt;umask
2.如果是S_ISCHR或者S_ISBLK时，进程要有
	CAP_MKNOD权限
3.may_create（reference）检查父目录的权限
	，并且子节点不能存在
4.父目录要有dir-&gt;i_op-&gt;mknod
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>841</x>
      <y>2153</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DQUOT_INIT</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>845</x>
      <y>2146</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
磁盘容量相关</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>859</x>
      <y>2153</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_op-&gt;mknod
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>855</x>
      <y>2146</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>860</x>
      <y>2160</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_mknod</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>865</x>
      <y>2156</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_dir_inode_operations</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>882</x>
      <y>2152</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_dir_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>855</x>
      <y>2146</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
DN_CREATE</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>820</x>
      <y>2169</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_new_inode
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>824</x>
      <y>2163</y>
      <w>44</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>420.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>836</x>
      <y>2170</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_uid = current-&gt;fsuid
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>844</x>
      <y>2163</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>858</x>
      <y>2170</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_special_inode
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>864</x>
      <y>2163</y>
      <w>4</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>876</x>
      <y>2170</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_add_entry
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>865</x>
      <y>2163</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将inode号和name加到dir中</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>893</x>
      <y>2170</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>mark_inode_dirty(inode);
d_instantiate(dentry, inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>866</x>
      <y>2163</y>
      <w>35</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将inode标dirty
并将其和dentry关联</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>838</x>
      <y>2177</y>
      <w>46</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>注：
1.现在并不会赋值u.ext2_i.i_data，在ext2_update_inode向硬盘写的时候，
	会检查i_mode，然后写入raw_inode-&gt;i_block
2.在ext2_read_inode时，会根据i_mode值将i_block[0]作为dev去
	init_special_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>862</x>
      <y>2173</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>527</x>
      <y>2143</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ioctl_scanner</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>529</x>
      <y>2135</y>
      <w>16</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_scanner_fops</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>524</x>
      <y>2151</y>
      <w>38</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.根据minor找到dev
	scn_minor = USB_SCN_MINOR(inode);
	dev = p_scn_table[scn_minor]-&gt;scn_dev
2.如果是PV8630_IOCTL_INREQUEST（获取状态信息）
	利用copy_from_user将args数据从用户空间复制过来
	然后利用usb_control_msg发送args.request请求
	最后利用copy_to_user将arg返回到用户空间
注：这里使用usb_rcvctrlpipe，
	USB_TYPE_VENDOR表示寄存器时设备制造商定义，不是标准的（USB_TYPE_STANDARD）
	USB_RECIP_DEVICE表示传输的对象是设备，不是接口或者端点
3.如果是PV8630_IOCTL_OUTREQUEST（向扫描器发出控制命令）
	和获取状态信息相似，只是这里只是单纯的发数据（usb_sndctrlpipe）
	，所以size=0，并且不用返回数据到用户空间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>533</x>
      <y>2146</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>414</x>
      <y>2134</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
鼠标
psaux_fops</panel_attributes>
    <additional_attributes>300.0;10.0;220.0;60.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>410</x>
      <y>2142</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fasync_aux</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>392</x>
      <y>2150</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fasync_helper</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>398</x>
      <y>2145</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>380</x>
      <y>2158</y>
      <w>36</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>1.如果要求将file设置成异步
	通过kmem_cache_alloc向fasync_cache
	申请fasync_struct
2.遍历传入的链表，如果链表中存在和要申请的
	file相同的fasync_struct结构：
	1.如果现在要设置异步，那么将新申请的cache释放：
		fa-&gt;fa_fd = fd;
		kmem_cache_free(fasync_cache, new);
	2.如果现在要设置成同步，那么将链表中的结构删除并释放
		*fp = fa-&gt;fa_next;
		kmem_cache_free(fasync_cache, fa);
		result = 1;
	最后直接返回
3.如果要设置成异步，那么将新申请的结构头插至链表中
	之后返回：
	new-&gt;magic = FASYNC_MAGIC;
	new-&gt;fa_file = filp;
	new-&gt;fa_fd = fd;
	new-&gt;fa_next = *fapp;
	*fapp = new;
	result = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>390</x>
      <y>2153</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
queue-&gt;fasync</panel_attributes>
    <additional_attributes>70.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>280</x>
      <y>2081</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_dup2</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>269</x>
      <y>2089</y>
      <w>35</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.通过file_lock将整个过程锁住
2.通过fcheck检查要复制的oldfd是否超过了max_fds，如果没
	超过，返回file
3.如果复制到的newfd和要复制的oldfd相同，直接解锁返回
4.如果newfd超过了进程的限制RLIMIT_NOFILE，返回EBADF
5.通过get_file增加oldfd的file计数，表示newfd要用
6.通过expand_files在必要时扩展得到newfd
7.如果newfd在open_fds位图中置上，但是files-&gt;fd[newfd]
	却不存在，说明这个fd正在被open占用，直接返回
8.如果经过了7表示可以对newfd进行复制：
	files-&gt;fd[newfd] = file;
	FD_SET(newfd, files-&gt;open_fds);
	FD_CLR(newfd, files-&gt;close_on_exec);
9.如果newfd之前存在file，通过filp_close将其关闭
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>284</x>
      <y>2084</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2082</x>
      <y>55</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_query_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2078</x>
      <y>58</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
name_user</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2055</x>
      <y>62</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
NULL</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2049</x>
      <y>70</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mod = &amp;kernel_module
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2078</x>
      <y>62</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
请求module name存在</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2072</x>
      <y>72</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_mod_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2077</x>
      <y>67</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2071</x>
      <y>78</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>__get_free_page
strncpy_from_user
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2076</x>
      <y>75</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2090</x>
      <y>67</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2094</x>
      <y>71</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是空字符串
</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2098</x>
      <y>71</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2106</x>
      <y>77</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2087</x>
      <y>77</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mod = &amp;kernel_module
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2118</x>
      <y>71</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_mod_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2090</x>
      <y>67</y>
      <w>37</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放name的内存</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2097</x>
      <y>84</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.遍历module_list链表
2.如果flags &amp; MOD_DELETED，就不遍历
3.比较mod-&gt;name，如果成功就找到module
	直接退出
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2110</x>
      <y>80</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2089</x>
      <y>58</y>
      <w>74</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2136</x>
      <y>71</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qm_modules</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2141</x>
      <y>64</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
QM_MODULES</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2128</x>
      <y>78</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.遍历module_list链表
2.计算每个module name的长度，如果buf的空间足够
	则用copy_to_user将name复制到用户空间
3.如果buf的空间不足，则将容纳所有module name所需
	的内存通过put_user返回给用户，sys_call返回-ENOSPC
4.如果一直复制到kernel_module，buf的空间足够，则将
	复制多少个module返回给用户
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2142</x>
      <y>74</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2138</x>
      <y>92</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2143</x>
      <y>89</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2138</x>
      <y>100</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__put_user_size</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2143</x>
      <y>95</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
access_ok(VERIFY_WRITE</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2138</x>
      <y>107</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__put_user_asm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2143</x>
      <y>103</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将x放到地址ptr处
如果出错，返回-EFAULT</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2181</x>
      <y>71</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qm_deps</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2160</x>
      <y>64</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
QM_DEPS</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2229</x>
      <y>21</y>
      <w>17</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>module_ref
描述一组依赖关系
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2231</x>
      <y>25</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dep（A依赖B）(父)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2231</x>
      <y>31</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ref（B被A索引）(子)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2231</x>
      <y>39</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>next_ref
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2203</x>
      <y>21</y>
      <w>19</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>module A
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2206</x>
      <y>26</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>deps
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2218</x>
      <y>26</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
数组</panel_attributes>
    <additional_attributes>10.0;20.0;110.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2221</x>
      <y>31</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>100.0;20.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2275</x>
      <y>21</y>
      <w>19</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>module B
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2278</x>
      <y>34</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>refs
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2268</x>
      <y>34</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
链表
next_ref</panel_attributes>
    <additional_attributes>100.0;20.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2266</x>
      <y>26</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;20.0;90.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2252</x>
      <y>22</y>
      <w>17</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>module_ref
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2254</x>
      <y>26</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dep
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2254</x>
      <y>32</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ref
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2254</x>
      <y>39</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>next_ref
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2245</x>
      <y>39</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ref链表指针</panel_attributes>
    <additional_attributes>90.0;20.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2243</x>
      <y>16</y>
      <w>34</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;110.0;80.0;20.0;290.0;30.0;320.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2278</x>
      <y>40</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>next
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2207</x>
      <y>40</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>next
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2212</x>
      <y>44</y>
      <w>72</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>700.0;10.0;630.0;70.0;100.0;80.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2167</x>
      <y>78</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.不能是kernel_module
2.如果请求的module的MOD_RUNNING 和
	MOD_INITIALIZING都没置，或者置上MOD_DELETED
	就不执行，ret=0
3.遍历module的deps数组（ndeps个），将module依赖的模块
	名称复制到用户空间；如果复制完成，则ret返回依赖模块的数目
	如果没有足够的内存，就ret返回所需要的空间，sys_call返回-ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2185</x>
      <y>74</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2219</x>
      <y>71</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qm_refs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2159</x>
      <y>64</y>
      <w>70</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
QM_REFS</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2213</x>
      <y>78</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.不能是kernel_module
2.如果请求的module的MOD_RUNNING 和
	MOD_INITIALIZING都没置，或者置上MOD_DELETED
	就不执行，ret=0
3.遍历module的refs链表，将已用module的模块
	名称复制到用户空间；如果复制完成，则ret返回引用模块的数目
	如果没有足够的内存，就ret返回所需要的空间，sys_call返回-ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2226</x>
      <y>74</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2285</x>
      <y>69</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qm_symbols</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2160</x>
      <y>64</y>
      <w>132</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
QM_SYMBOLS</panel_attributes>
    <additional_attributes>10.0;10.0;1300.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2255</x>
      <y>78</y>
      <w>39</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果请求的module的MOD_RUNNING 或者
	MOD_INITIALIZING没置，或者置上MOD_DELETED
	就不执行，ret=0
2.检查 buf~buf+mod-&gt;nsyms * 2*sizeof(void *)空间的
	写访问权限access_ok(VERIFY_WRITE
注：这个区间是（address，&amp;name）的组合
	然后在这个区间之后放字符串name，因为字符串name区域
	依靠copy_to_user去确保访问权限，所以在这里不做检查
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2269</x>
      <y>72</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2296</x>
      <y>81</y>
      <w>38</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历mod-&gt;syms数组（长度为mod-&gt;nsyms），
2.如果buf有足够的内存，将（address，&amp;name）放在前两，
	name实体放在所有指针的后面。ret返回sybol的数目
3.如果buf在遍历的过程中没有足够的空间，ret返回所需要的空间
	sys_call返回-ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2291</x>
      <y>72</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2368</x>
      <y>68</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qm_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2160</x>
      <y>64</y>
      <w>215</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
QM_INFO</panel_attributes>
    <additional_attributes>10.0;10.0;2130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2337</x>
      <y>81</y>
      <w>29</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.不能是kernel_module
2.如果buf内存不够，sys_call返回-ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2349</x>
      <y>71</y>
      <w>26</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2368</x>
      <y>79</y>
      <w>45</w>
      <h>16</h>
    </coordinates>
    <panel_attributes> //module的地址
info.addr = (unsigned long)mod;
info.size = mod-&gt;size;
info.flags = mod-&gt;flags;
 //如果module的结构体包含can_unload指针，返回-1
 //否则返回usecount
info.usecount = (mod_member_present(mod, can_unload)
		 &amp;&amp; mod-&gt;can_unload ? -1 : atomic_read(&amp;mod-&gt;uc.usecount));
注：mod_member_present是检测member在不在结构体内
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2373</x>
      <y>71</y>
      <w>8</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2374</x>
      <y>71</y>
      <w>50</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2417</x>
      <y>80</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>ret最后都返回
sizeof(struct module_info)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2560</x>
      <y>59</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_create_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2510</x>
      <y>71</y>
      <w>25</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.进程需要CAP_SYS_MODULE权限
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2520</x>
      <y>62</y>
      <w>48</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2536</x>
      <y>71</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_mod_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2542</x>
      <y>62</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从用户空间获取
创建module的name</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2555</x>
      <y>71</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>2.name+module所占的内存空间，
	不能大于用户要求申请的内存大小
	size &lt; sizeof(struct module)+namelen
3.find_module从module_list中如果找到了
	name一样的 module，返回-EEXIST
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2563</x>
      <y>62</y>
      <w>7</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2584</x>
      <y>71</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>module_map</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2566</x>
      <y>62</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请size大小的虚拟内存</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2584</x>
      <y>78</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2589</x>
      <y>74</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2601</x>
      <y>70</y>
      <w>30</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>memset(mod, 0, sizeof(*mod));
mod-&gt;size_of_struct = sizeof(*mod);
 //链入module_list
mod-&gt;next = module_list;
mod-&gt;name = (char *)(mod + 1);
 //module所占内存大小，module+name
mod-&gt;size = size;
 //复制name到module后面
memcpy((char*)(mod+1), name, namelen+1);

put_mod_name(name);
 //更新module_list链表
module_list = mod;
 //正确的话，返回的是module的地址
return error
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2566</x>
      <y>62</y>
      <w>45</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2822</x>
      <y>56</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_init_module
(init_module时用户传进来的参数
create_module时用户之前在sys_create_module创建的)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2717</x>
      <y>82</y>
      <w>42</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.进程要有CAP_SYS_MODULE
2.通过get_mod_name将create_module的name
	复制到系统空间，再通过find_module查找
	如果找不到，返回-ENOENT
3.通过get_user获取init_module的size_of_struct
	（这个size是module结构体的大小），init_module的persist_start
	至少包含到；另外这个size不能大于module size16个指针

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2736</x>
      <y>59</y>
      <w>94</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>920.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2761</x>
      <y>84</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>mod_tmp = *mod
name_tmp = kmalloc(strlen(mod-&gt;name) + 1
strcpy(name_tmp, mod-&gt;name)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2773</x>
      <y>59</y>
      <w>56</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将create_module的module和name复制到temp
</panel_attributes>
    <additional_attributes>540.0;10.0;10.0;250.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2797</x>
      <y>85</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_from_user
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2802</x>
      <y>59</y>
      <w>30</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将init_module赋值到mod</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2814</x>
      <y>83</y>
      <w>49</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>1.init_module的size不能大于create_module的size
2.mod-&gt;name，mod-&gt;syms，mod-&gt;deps，指向的位置要
	在size_of_struct外。并且所占的内存要在size内
	注：因为sys_create_module返回的是内核module的起始地址，用户应该将
	name的指针指向内核地址，而不是用户空间name的实际地址，所以这里
	mod_bound才会通过。
3.mod-&gt;init，mod-&gt;cleanup要在size_of_struct外。
	并且要在size内
4.异常处理表：
	ex_table_start不能大于ex_table_end
	ex_table_start小于mod的尾端的时候，ex_table_end不能小于
	缓冲区（size）的尾端
	ex_table的大小要被exception_table_entry的大小整除
5.mod-&gt;flags中至少要有一个除了MOD_AUTOCLEAN的flage置上
6.can_unload如果要在module 结构内且不为空时，can_unload函数
	要在缓冲区内
7.kallsyms_end在module内，且不为空，kallsyms_start和kallsyms_end
	指向的地址要在缓冲区内
	kallsyms_start不能大于kallsyms_end
8.archdata和kallsyms相似
9.kernel_data在moduler内，mod-&gt;kernel_data不能为空
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2826</x>
      <y>59</y>
      <w>21</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
对init_module进行filter</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2869</x>
      <y>83</y>
      <w>51</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.通过get_mod_name从用户层将name实体复制到系统空间
	如果name的长度，或者name不一致，返回错误
2.通过copy_from_user将init_module的缓冲区，复制到用户空间
（如果在cache中，需要通过flush_icache_range刷入到内存）
3.将init_module链入到链表
	mod-&gt;next = mod_tmp.next;
	mod-&gt;refs = NULL;
4.遍历mod-&gt;deps，这个数组中不能有自己，并且数组中的元素要在
	module_list链表中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2829</x>
      <y>59</y>
      <w>56</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
对init_module的缓冲区进行filter</panel_attributes>
    <additional_attributes>10.0;10.0;540.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2927</x>
      <y>84</y>
      <w>21</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //ref指向自己
dep-&gt;ref = mod
 //链入到父的链表中（d是父）
dep-&gt;next_ref = d-&gt;refs;
d-&gt;refs = dep;
d-&gt;flags |= MOD_USED_ONCE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2829</x>
      <y>59</y>
      <w>108</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
对module的dep的实体，进行初始化</panel_attributes>
    <additional_attributes>10.0;10.0;1060.0;250.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2954</x>
      <y>85</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes> //n_name 最终的name，name是传进来的参数
 //name_tmp是之前sys_create_module识别的name
put_mod_name(n_name);
put_mod_name(name);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2830</x>
      <y>59</y>
      <w>132</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放临时内存</panel_attributes>
    <additional_attributes>10.0;10.0;1300.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2994</x>
      <y>85</y>
      <w>44</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>mod-&gt;flags |= MOD_INITIALIZING;
atomic_set(&amp;mod-&gt;uc.usecount,1);
 //如果init函数存在，执行init
mod-&gt;init &amp;&amp; (error = mod-&gt;init())

atomic_dec(&amp;mod-&gt;uc.usecount);
mod-&gt;flags = (mod-&gt;flags | MOD_RUNNING) &amp; ~MOD_INITIALIZING;
error = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2830</x>
      <y>59</y>
      <w>175</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1730.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3170</x>
      <y>55</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_delete_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3101</x>
      <y>72</y>
      <w>23</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>进程要有CAP_SYS_MODULE权限
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3109</x>
      <y>58</y>
      <w>70</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>680.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3175</x>
      <y>58</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果name_user不为NULL</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3139</x>
      <y>66</y>
      <w>45</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3132</x>
      <y>72</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_mod_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3152</x>
      <y>73</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3160</x>
      <y>66</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3173</x>
      <y>73</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_mod_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3180</x>
      <y>66</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到后，释放name</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3180</x>
      <y>66</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mod-&gt;refs
如果被依赖，则不能释放</panel_attributes>
    <additional_attributes>20.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3192</x>
      <y>72</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>-EBUSY
goto out;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3181</x>
      <y>66</y>
      <w>50</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
没被使用
!__MOD_IN_USE
如果can_unload在module中，通过can_unload判断
否则通过mod.uc.usecount判断</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3215</x>
      <y>69</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3204</x>
      <y>75</y>
      <w>23</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mod-&gt;flags |= MOD_DELETED
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3235</x>
      <y>75</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3227</x>
      <y>69</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tag_freed为0</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3227</x>
      <y>78</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3216</x>
      <y>84</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>mod-&gt;cleanup
mod-&gt;flags &amp;= ~MOD_RUNNING
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3243</x>
      <y>78</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3240</x>
      <y>83</y>
      <w>35</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.通过mod-&gt;deps数组找到mod依赖的所有module
2.遍历module的refs链表，将mod从其链表中删除
	*pp = dep-&gt;next_ref;
	如果tag_freed为1，且module的refs链表为空
	module.flags |= MOD_JUST_FREED
	注：module_ref脱链之后不用单独释放，因为deps数组
		是和module结构体一起申请的，所以之后一起释放
3.将mod从module_list链表中删除
	注;这里用二重指针更为方便，不用if..else
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3280</x>
      <y>84</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>module_unmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3243</x>
      <y>78</y>
      <w>45</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3280</x>
      <y>90</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3285</x>
      <y>87</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3176</x>
      <y>58</y>
      <w>125</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
name_user为NULL时，
表示内核自动删除module_list中满足条件的module</panel_attributes>
    <additional_attributes>10.0;10.0;1230.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3294</x>
      <y>65</y>
      <w>45</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>条件：
1.mod-&gt;refs指向NULL,表示没有其他module依赖mod
2.MOD_AUTOCLEAN，表示mod允许自动删除
3.MOD_RUNNING，已经成功安装，但是没有free_module-&gt;cleanup
4.！MOD_DELETED，没有free_module
5.MOD_USED_ONCE,模块安装之后受到引用
6.!__MOD_IN_USE，不被使用

上述条件满足且（MOD_VISITED没置或者MOD_JUST_FREED置上）
mod-&gt;flags |= MOD_DELETED;
 //这里可能将其他模块的MOD_JUST_FREED置上
free_module(mod, 1);
 //需要重新遍历module_list链表，因为free_module的tag_freed为1
something_changed = 1;

但是如果MOD_VISITED置上并且MOD_JUST_FREED没置
mod-&gt;flags &amp;= ~MOD_VISITED
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3448</x>
      <y>57</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3360</x>
      <y>69</y>
      <w>44</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.current-&gt;fs-&gt;root要存在，因为进程需要通过
	/sbin/insmod去安装module
2.max_threads规定最大的线程数，因为request_module
	会通过创建thread，所以这里规定request_module创建的
	线程数最大是max_threads/2，
	所以嵌套或者共存的request_module最大是
	max(max_threads/2，MAX_KMOD_CONCURRENT)
3.如果嵌套的request_module数目（kmod_concurrent）超过了最大值
	返回-ENOMEM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3378</x>
      <y>60</y>
      <w>79</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>770.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3411</x>
      <y>70</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kernel_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3416</x>
      <y>60</y>
      <w>41</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3428</x>
      <y>70</y>
      <w>47</w>
      <h>14</h>
    </coordinates>
    <panel_attributes> //存储block的signal，便于之后恢复
tmpsig = current-&gt;blocked;
 //将除SIGKILL和SIGSTOP的signal清掉，以免在安装的途中受到干扰
 //清掉表示在blocked中置1
siginitsetinv(&amp;current-&gt;blocked, sigmask(SIGKILL) | sigmask(SIGSTOP));
 //重新计算pending.signal中是否有被置上的signal（blocked中为0）
 //如果有t-&gt;sigpending置1
recalc_sigpending(current);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3444</x>
      <y>60</y>
      <w>13</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3454</x>
      <y>60</y>
      <w>35</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3482</x>
      <y>72</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //wait子线程
waitpid(pid, NULL, __WCLONE)
 //已经安装完，递减request_module计数
atomic_dec(&amp;kmod_concurrent)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3511</x>
      <y>72</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //恢复mask，并重新检测是否
 //收到相关信号
current-&gt;blocked = tmpsig;
recalc_sigpending(current);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3454</x>
      <y>60</y>
      <w>68</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;660.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3411</x>
      <y>78</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>exec_modprobe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3415</x>
      <y>73</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3371</x>
      <y>86</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.设置环境变量
2.设置argv
	这里相当于/sbin/modprobe -s -k module_name
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3386</x>
      <y>81</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3415</x>
      <y>87</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>exec_usermodehelper</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3416</x>
      <y>81</y>
      <w>9</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3388</x>
      <y>95</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //指向当前线程
curtask = current
 //指向init_task
curtask-&gt;session = 1;
curtask-&gt;pgrp = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3394</x>
      <y>90</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3405</x>
      <y>98</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>use_init_fs_context</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3408</x>
      <y>90</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为线程的根目录可能不是
系统的根目录，所以需要切换成
init_task的根目录</panel_attributes>
    <additional_attributes>160.0;10.0;50.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3389</x>
      <y>108</y>
      <w>29</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>rootmnt = mntget(init_fs-&gt;rootmnt);
root = dget(init_fs-&gt;root);
pwdmnt = mntget(init_fs-&gt;pwdmnt);
pwd = dget(init_fs-&gt;pwd);

our_fs = current-&gt;fs;
our_fs-&gt;umask = init_fs-&gt;umask;
 //设置root pwd，如果之前的root pwd存在
 //将其dput，mntput
set_fs_root(our_fs, rootmnt, root);
set_fs_pwd(our_fs, pwdmnt, pwd);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3395</x>
      <y>101</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取init_task的root、pwd、umask
</panel_attributes>
    <additional_attributes>190.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3413</x>
      <y>101</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
our_fs-&gt;altroot存在</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3420</x>
      <y>110</y>
      <w>18</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //更新altroot
our_fs-&gt;altrootmnt = NULL;
our_fs-&gt;altroot = NULL;
 //将其原来的释放
dput(dentry);
mntput(mnt);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3442</x>
      <y>111</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>dput(root);
mntput(rootmnt);
dput(pwd);
mntput(pwdmnt);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3413</x>
      <y>101</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将原来的root和pwd释放</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3439</x>
      <y>99</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>	sigemptyset(&amp;curtask-&gt;blocked);
	flush_signals(curtask);
	flush_signal_handlers(curtask);
	recalc_sigpending(curtask);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3422</x>
      <y>90</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将父进程处理的信号和相应的action丢弃</panel_attributes>
    <additional_attributes>20.0;10.0;240.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3463</x>
      <y>102</y>
      <w>20</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>if (curtask-&gt;files-&gt;fd[i]) close(i)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3423</x>
      <y>90</y>
      <w>52</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
关闭所有的文件</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3486</x>
      <y>99</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>curtask-&gt;user = INIT_USER;
atomic_inc(&amp;INIT_USER-&gt;__count);
atomic_inc(&amp;INIT_USER-&gt;processes);
atomic_dec(&amp;user-&gt;processes);
free_uid(user);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3423</x>
      <y>90</y>
      <w>71</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复用init_task的user
将之前的user释放</panel_attributes>
    <additional_attributes>10.0;10.0;690.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3516</x>
      <y>99</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>curtask-&gt;euid = curtask-&gt;fsuid = 0;
curtask-&gt;egid = curtask-&gt;fsgid = 0;
 //所有的进程权限都给予这个内核线程
cap_set_full(curtask-&gt;cap_effective);
set_fs(KERNEL_DS)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3424</x>
      <y>90</y>
      <w>107</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
给与线程权限</panel_attributes>
    <additional_attributes>10.0;10.0;1050.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3546</x>
      <y>99</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>execve</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3423</x>
      <y>90</y>
      <w>130</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1280.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3002</x>
      <y>104</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sparcaudio_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3007</x>
      <y>98</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2981</x>
      <y>111</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_register_chrdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2986</x>
      <y>107</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2981</x>
      <y>118</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_chrdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2988</x>
      <y>114</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2958</x>
      <y>121</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果major为0</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2946</x>
      <y>126</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.从 MAX_CHRDEV-1向前遍历，找到
	chrdevs[major].fops为NULL的位置
	赋值：
	chrdevs[major].name = name;
	chrdevs[major].fops = fops;
	return major;
2.如果没找到，返回-EBUSY
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2972</x>
      <y>128</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果major &gt;= MAX_CHRDEV，返回-EINVAL
2.如果chrdevs[major].fops且和当前注册的fops
	不同，返回return -EBUSY
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2986</x>
      <y>121</y>
      <w>6</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3005</x>
      <y>128</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>chrdevs[major].name = name;
chrdevs[major].fops = fops;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2988</x>
      <y>121</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3040</x>
      <y>111</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_mk_dir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3005</x>
      <y>107</y>
      <w>44</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3010</x>
      <y>121</y>
      <w>22</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.name == NULL时，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3020</x>
      <y>114</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3035</x>
      <y>120</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>search_for_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3043</x>
      <y>114</y>
      <w>6</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3029</x>
      <y>129</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_root_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3030</x>
      <y>123</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果dir为NULL
如果通过下面接口无法找到
就返回NULL</panel_attributes>
    <additional_attributes>120.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3014</x>
      <y>136</y>
      <w>14</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>return root_entry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3021</x>
      <y>132</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
root_entry != NULL</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3035</x>
      <y>132</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
root_entry为NULL</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3027</x>
      <y>135</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请root_entry</panel_attributes>
    <additional_attributes>90.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3020</x>
      <y>141</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2901</x>
      <y>144</y>
      <w>130</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果table的size不够
fs_info.num_inodes &gt;= fs_info.table_size</panel_attributes>
    <additional_attributes>1280.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2857</x>
      <y>165</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2863</x>
      <y>159</y>
      <w>41</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注：sizeof *table相当于sizeof(*table)</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2875</x>
      <y>166</y>
      <w>42</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memcpy (table, fs_info.table, sizeof *table *fs_info.num_inodes);
kfree (fs_info.table);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2887</x>
      <y>159</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fs_info.table存在
就copy原来的table到新申请的内存</panel_attributes>
    <additional_attributes>150.0;10.0;70.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2921</x>
      <y>166</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fs_info.table = table
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2901</x>
      <y>159</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新table</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2942</x>
      <y>167</y>
      <w>18</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>namelen = strlen (name)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2948</x>
      <y>144</y>
      <w>83</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 name &amp;&amp; (namelen &lt; 1) 时
重新计算name的长度</panel_attributes>
    <additional_attributes>810.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2966</x>
      <y>144</y>
      <w>65</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请devfs_entry+name长度的内存
并reset</panel_attributes>
    <additional_attributes>630.0;10.0;10.0;220.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2963</x>
      <y>166</y>
      <w>29</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>kmalloc
 memset (new, 0, sizeof *new + namelen);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2999</x>
      <y>144</y>
      <w>33</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置新申请的devfs_entry</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2995</x>
      <y>165</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>new-&gt;parent = parent;
 //注：name是new中的一个字节
if (name) memcpy (new-&gt;name, name, namelen);
new-&gt;namelen = namelen;
 //更新inode号
new-&gt;inode.ino = fs_info.num_inodes + FIRST_INODE;
new-&gt;inode.nlink = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3029</x>
      <y>144</y>
      <w>32</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
新申请的devfs_entry关联到fs_info</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;220.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3033</x>
      <y>166</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>fs_info.table[fs_info.num_inodes] = new;
 //更新num_inodes，记录fs_info中inode的个数
++fs_info.num_inodes;
 //如果新申请的devfs_entry是dev的根目录
if (parent == NULL) return new;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3030</x>
      <y>144</y>
      <w>47</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果新申请的不是dev的根目录
建立new和parent的关系</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3068</x>
      <y>164</y>
      <w>37</w>
      <h>16</h>
    </coordinates>
    <panel_attributes> //u.dir.last表示parent中的最后一个devfs_entry
 //u.dir.first表示parent中第一个devfs_entry
 //这里将new链接到链表最后
new-&gt;prev = parent-&gt;u.dir.last
 //如果first不存在，更新first，不然链接到链表的最后
if (parent-&gt;u.dir.first == NULL) parent-&gt;u.dir.first = new;
else parent-&gt;u.dir.last-&gt;next = new;
 //更新last
parent-&gt;u.dir.last = new;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3046</x>
      <y>140</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>root_entry-&gt;registered = TRUE;
root_entry-&gt;mode = S_IFDIR;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3042</x>
      <y>136</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3079</x>
      <y>139</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>update_devfs_inode_from_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3042</x>
      <y>136</y>
      <w>47</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3107</x>
      <y>151</y>
      <w>61</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>S_ISDIR：
de-&gt;inode.mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;
de-&gt;inode.uid = 0;
de-&gt;inode.gid = 0;

S_ISLNK：
de-&gt;inode.mode = S_IFLNK | S_IRUGO | S_IXUGO;
de-&gt;inode.uid = 0;
de-&gt;inode.gid = 0;

S_ISFIFO：
de-&gt;inode.mode = de-&gt;mode;
de-&gt;inode.uid = de-&gt;u.fifo.uid;
de-&gt;inode.gid = de-&gt;u.fifo.gid;

其他：
 //fcb存在owner
if(u.fcb.auto_owner) de-&gt;inode.mode = (de-&gt;mode &amp; ~S_IALLUGO) | S_IRUGO | S_IWUGO;
else de-&gt;inode.mode = de-&gt;mode;
de-&gt;inode.uid = de-&gt;u.fcb.default_uid;
de-&gt;inode.gid = de-&gt;u.fcb.default_gid;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3091</x>
      <y>142</y>
      <w>36</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置新申请的devfs_entry的inode</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3034</x>
      <y>134</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新root_entry</panel_attributes>
    <additional_attributes>20.0;20.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3123</x>
      <y>139</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3035</x>
      <y>132</y>
      <w>95</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在root_entry下创建名为.devfsd的devfs_entry</panel_attributes>
    <additional_attributes>10.0;10.0;930.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3036</x>
      <y>132</y>
      <w>142</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新.devfsd的devfs_entry</panel_attributes>
    <additional_attributes>10.0;10.0;1400.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3170</x>
      <y>140</y>
      <w>37</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>new-&gt;registered = TRUE;
new-&gt;u.fcb.u.device.major = next_devnum_char &gt;&gt; 8;
new-&gt;u.fcb.u.device.minor = next_devnum_char &amp; 0xff;
++next_devnum_char;
new-&gt;mode = S_IFCHR | S_IRUSR | S_IWUSR;
new-&gt;u.fcb.default_uid = 0;
new-&gt;u.fcb.default_gid = 0;
new-&gt;u.fcb.ops = &amp;devfsd_fops;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3041</x>
      <y>123</y>
      <w>187</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环解析name</panel_attributes>
    <additional_attributes>10.0;10.0;1850.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3213</x>
      <y>137</y>
      <w>55</w>
      <h>45</h>
    </coordinates>
    <panel_attributes>1.找到以‘/’隔离的subname
2.如果是最后一个节点，获取最后一个节点的namelen(stop - subname)
	通过search_for_entry_in_dir在父目录dir中查找，如果找到了entry，
	将其返回；如果没有找到，但是!mkfile，返回NULL;如果要求mkfile，通过create_entry
	在dir中创建subname节点。且：
	if (entry &amp;&amp; is_new) *is_new = TRUE
3.如果subname是../，将dir切换成dir = dir-&gt;parent，并且
	 //不能返回到devfs的父目录
	 if (dir == NULL) return NULL;
	 subname += 3;
    continue;
3.获取dir中查找的name长度(len = ptr - subname)
	并通过search_for_entry_in_dir在父目录中查找
4.如果在父目录dir中没找到entry，并且不要求创建新目录（!mkdir）
	返回NULL
5.如果没找到entry，但是要求mkdir，需要通过create_entry在父目录
	下创建一个名为subname的entry，,并且：
	entry-&gt;mode = S_IFDIR | S_IRUGO | S_IXUGO | S_IWUSR
	//标志新创建
	if (is_new) *is_new = TRUE;
6.如果找到或者创建的的entry不是S_ISDIR，返回NULL
7.改变entry的属性：
	entry-&gt;registered = TRUE;
	entry-&gt;hide = FALSE;
8.遍历下一个：
	subname = ptr + 1;
	dir = entry;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3059</x>
      <y>119</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果没找到entry，返回NULL
2.如果entry不是S_ISDIR，但是
	registered置上，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3048</x>
      <y>114</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3084</x>
      <y>119</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>de-&gt;u.dir.first = NULL;
de-&gt;u.dir.last = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3049</x>
      <y>114</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不是S_ISDIR，并且没有创建（!is_new）</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3101</x>
      <y>117</y>
      <w>45</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>de-&gt;mode = S_IFDIR | S_IRUGO | S_IXUGO;
de-&gt;info = info;
if (!de-&gt;registered) de-&gt;u.dir.num_removable = 0;
de-&gt;registered = TRUE;
de-&gt;show_unreg = (boot_options &amp; OPTION_SHOW) ? TRUE : FALSE;
de-&gt;hide = FALSE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3049</x>
      <y>114</y>
      <w>63</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3221</x>
      <y>189</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3210</x>
      <y>193</y>
      <w>17</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.父目录要是S_ISDIR
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3230</x>
      <y>193</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.遍历parent的子节点链表parent-&gt;u.dir.first
2.根据namelen和name滤出对应的devfs_entry
3.如果在链表中没有找到devfs_entry，返回NULL
4.如果找到了，但是不是S_ISLNK，或者是link，
	但是不要求traverse_symlink，直接返回找到的
	devfs_entry
5.如果需要根据link找到实体（traverse_symlink），
	使用search_for_entry在parent中找curr-&gt;u.symlink.linkname
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3234</x>
      <y>189</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3227</x>
      <y>186</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>search_for_entry_in_dir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3236</x>
      <y>181</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2078</x>
      <y>420</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>uhci_hcd_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2087</x>
      <y>430</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>pci_module_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2064</x>
      <y>430</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>kmem_cache_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2071</x>
      <y>424</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uhci_td
uhci_qh
uhci_urb_priv</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2083</x>
      <y>424</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2075</x>
      <y>441</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>pci_register_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2099</x>
      <y>442</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>pci_unregister_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2080</x>
      <y>434</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uhci_pci_driver</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2089</x>
      <y>434</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果register成功，返回0
否则unregister，然后返回-ENODEV</panel_attributes>
    <additional_attributes>50.0;10.0;180.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2041</x>
      <y>453</y>
      <w>13</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>list_add_tail
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2044</x>
      <y>445</y>
      <w>39</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将pci_driver链接到pci_drivers链表后面</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2080</x>
      <y>445</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2074</x>
      <y>451</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历pci_devices中所有的pci_dev
2.如果dev没有相应的driver（!pci_dev_driver），
	通过pci_announce_device查找和driver match
	的dev去初始化
3.返回所有初始化的dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2073</x>
      <y>466</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_dev_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2077</x>
      <y>460</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2065</x>
      <y>474</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果dev.driver存在，直接返回
2.如果不存在，遍历dev所有的rom resource
	如果其中有一个resource的IORESOURCE_BUSY
	（地址区间已启用）置上，返回pci_compat_driver
3.否则返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2076</x>
      <y>469</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2095</x>
      <y>466</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_announce_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2089</x>
      <y>460</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2095</x>
      <y>474</y>
      <w>35</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.如果drv-&gt;id_table存在，通过pci_match_device遍历
	表中是否有和dev匹配的pci_device_id，如果没有，则
	直接返回0。如果找到通过drv-&gt;probe初始化
2.如果drv-&gt;id_table不存在，则默认是直接初始化drv-&gt;probe
3.如果初始化成功：
	dev-&gt;driver = drv;
	ret = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2102</x>
      <y>469</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2095</x>
      <y>489</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_match_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2099</x>
      <y>486</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2085</x>
      <y>497</y>
      <w>26</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果pci_device_id的vendor、subvendor、class_mask都为空
	则到了table的末尾，直接返回NULL
2.否则，只有在pci_device_id和dev的vendor，device、
	subvendor、subdevice以及class（
	class_mask为~0，表示其要完全相同）
	都相同的情况下，才是和dev匹配的pci_device_id
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2097</x>
      <y>492</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2115</x>
      <y>494</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drv-&gt;probe
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2120</x>
      <y>486</y>
      <w>4</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2115</x>
      <y>502</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_pci_probe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2119</x>
      <y>497</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uhci_pci_driver</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2104</x>
      <y>505</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
向dev的USBLEGSUP寄存器写0</panel_attributes>
    <additional_attributes>180.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2095</x>
      <y>511</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_write_config_word
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2117</x>
      <y>511</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_enable_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2121</x>
      <y>505</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2101</x>
      <y>519</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_enable_device
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2110</x>
      <y>514</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2126</x>
      <y>519</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_set_power_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2122</x>
      <y>514</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2147</x>
      <y>508</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.遍历pci设备的[0,6)号resource
2.resource的flag中IORESOURCE_IO要置上
3.通过check_region检查resource是否被用
	如果被用直接退出
4.通过pci_set_master将USB竞争总线的能力打开
	（能使用DMA功能）
5.通过setup_uhci初始化USB总线（传入usb设备的其实地址和长度）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2121</x>
      <y>505</y>
      <w>38</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2138</x>
      <y>523</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>check_region</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2145</x>
      <y>519</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2133</x>
      <y>530</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__check_region</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2139</x>
      <y>526</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2129</x>
      <y>537</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过__request_region（reference）
	申请对应的resource
2.如果没申请到，说明有conflict，返回EBUSY
3.如果申请到了，通过release_resource将
	之前申请的resource释放（将其从parent.child
	的sibling链表中删除），并通过kfree将其内存释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2138</x>
      <y>533</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2155</x>
      <y>523</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_set_master</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2160</x>
      <y>519</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2149</x>
      <y>531</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_write_config_word
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2148</x>
      <y>526</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
向PCI_COMMAND写
PCI_COMMAND_MASTER</panel_attributes>
    <additional_attributes>120.0;10.0;60.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2167</x>
      <y>531</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_set_master</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2163</x>
      <y>526</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2159</x>
      <y>538</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.更改PCI_LATENCY_TIMER寄存器
	的值，如果原本的值小于16，则取
	pcibios_max_latency（但是最大是64）；
	如果原来的值大于pcibios_max_latency，
	则取pcibios_max_latency
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2166</x>
      <y>534</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2227</x>
      <y>526</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_uhci</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2174</x>
      <y>519</y>
      <w>59</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;570.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2189</x>
      <y>534</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_uhci</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2194</x>
      <y>529</y>
      <w>41</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2185</x>
      <y>578</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_alloc_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2193</x>
      <y>537</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2192</x>
      <y>573</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2182</x>
      <y>585</y>
      <w>30</w>
      <h>23</h>
    </coordinates>
    <panel_attributes> //申请usb_bus
bus = kmalloc
memset(&amp;bus-&gt;devmap, 0
bus-&gt;op = op;
bus-&gt;root_hub = NULL;
bus-&gt;hcpriv = NULL;
bus-&gt;busnum = -1;
bus-&gt;bandwidth_allocated = 0;
bus-&gt;bandwidth_int_reqs  = 0;
bus-&gt;bandwidth_isoc_reqs = 0;

INIT_LIST_HEAD(&amp;bus-&gt;bus_list);
INIT_LIST_HEAD(&amp;bus-&gt;inodes)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2191</x>
      <y>581</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2183</x>
      <y>541</y>
      <w>30</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>kmalloc(sizeof(*uhci)
memset(uhci, 0, sizeof(*uhci));
uhci-&gt;irq = -1;
uhci-&gt;io_addr = io_addr;
uhci-&gt;io_size = io_size;
spin_lock_init(&amp;uhci-&gt;qh_remove_lock);
INIT_LIST_HEAD(&amp;uhci-&gt;qh_remove_list);
spin_lock_init(&amp;uhci-&gt;urb_remove_lock);
INIT_LIST_HEAD(&amp;uhci-&gt;urb_remove_list);
nested_init(&amp;uhci-&gt;urblist_lock);
INIT_LIST_HEAD(&amp;uhci-&gt;urb_list);
spin_lock_init(&amp;uhci-&gt;framelist_lock)

 //框架表
uhci-&gt;fl = (void *)__get_free_page

 //申请bus，并建立关系
bus = usb_alloc_bus(&amp;uhci_device_operations)
uhci-&gt;bus = bus;
bus-&gt;hcpriv = uhci

 //读取port的状态，其状态寄存器是1，表示这个port存在
 //从而确定port的数量。注：前16字节是总线控制器本身
 //后面是port寄存器，每2个字节一个port
 //如果port的数量小于2或者大于8，将其赋值成2
 portstatus = inw(io_addr + 0x10 + (port * 2));
	if (!(portstatus &amp; 0x0080))
		break;
 uhci-&gt;rh.numports = port
 //初始化中断交互队列skeltd
 //1.首先索引[1,9)
 //填充status，buffer（都为0，表示空操作），info（是操作码 	(UHCI_NULL_DATA_SIZE &lt;&lt; 21) | (0x7f &lt;&lt; 8) | USB_PID_IN）
 uhci_fill_td
 //指向上一个skeltd的物理地址
	td-&gt;link	=virt_to_bus(&amp;uhci-&gt;skeltd[i - 1])
 //2.其次索引0，填充和[1，9）相同，
 uhci_fill_td
 //link指向skelqh[0]，uhci_td和uhci_qh是16字节对齐，所以低4位为0，可以填标志
 //UHCI_PTR_QH,表示其指向队列描述块
 uhci-&gt;skel_int1_td.link = virt_to_bus(&amp;uhci-&gt;skel_ls_control_qh) | UHCI_PTR_QH;
 //3.其次是索引9，填充和之前相同
 uhci_fill_td
 //UHCI_PTR_TERM,表示结束位
 uhci-&gt;skel_term_td.link = UHCI_PTR_TERM;

 //初始化队列描述块skelqh
 //索引0，link指向下一个队列描述块，element是队列头指针（都初始化为结束，只有最后一个指向skeltd[9]）
 uhci-&gt;skel_ls_control_qh.link = virt_to_bus(&amp;uhci-&gt;skel_hs_control_qh) | UHCI_PTR_QH;
 uhci-&gt;skel_ls_control_qh.element = UHCI_PTR_TERM;
 //索引1
 uhci-&gt;skel_hs_control_qh.link = virt_to_bus(&amp;uhci-&gt;skel_bulk_qh) | UHCI_PTR_QH;
 uhci-&gt;skel_hs_control_qh.element = UHCI_PTR_TERM;
 //索引2
 uhci-&gt;skel_bulk_qh.link = virt_to_bus(&amp;uhci-&gt;skel_term_qh) | UHCI_PTR_QH;
 uhci-&gt;skel_bulk_qh.element = UHCI_PTR_TERM
 //索引3，最后一个，link指向结束
 uhci-&gt;skel_term_qh.link = UHCI_PTR_TERM;
 uhci-&gt;skel_term_qh.element = virt_to_bus(&amp;uhci-&gt;skel_term_td)

注：链表skeltd[8] -link-&gt; ..-link-&gt; skeltd[0] -link-&gt; ls_qh -link-&gt; hs_qh -link-&gt; bulk_qh -link-&gt; term_qh -link-&gt;NULL
																															      |
																															      element
																															      |
																															      skeltd[9]
 //将skeltd（irq）[0,7]数组分配到fl的第（2^n-1）个框架结构中
 //所以第n个skeltd是（2^n）ms执行一次（注：虽然只链接了第n个skeltd到fl中，但是skeltd通过link链接在一起）
 uhci-&gt;fl-&gt;frame[i] =  virt_to_bus(irq)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2205</x>
      <y>535</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;driver_data = uhci
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2211</x>
      <y>529</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2229</x>
      <y>529</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
请求resource
uhci-&gt;io_addr(len=io_size)</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2224</x>
      <y>534</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_region
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2237</x>
      <y>534</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reset_hc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2232</x>
      <y>529</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2229</x>
      <y>540</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //向USB控制器发送”全局总清“命令，将其初始化
outw(USBCMD_GRESET, io_addr + USBCMD)
wait_ms(50);
outw(0, io_addr + USBCMD);
wait_ms(10);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2239</x>
      <y>537</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2262</x>
      <y>534</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_register_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2232</x>
      <y>529</y>
      <w>38</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2253</x>
      <y>541</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_next_zero_bit
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2247</x>
      <y>537</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从1开始查找busmap.busmap中是否有空闲的位</panel_attributes>
    <additional_attributes>200.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2266</x>
      <y>537</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
busnum &lt; USB_MAXBUS
如果有空闲位</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2267</x>
      <y>542</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>set_bit(busnum, busmap.busmap);
bus-&gt;busnum = busnum
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2295</x>
      <y>542</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_add
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2266</x>
      <y>537</y>
      <w>36</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将bus的bus_list链接到usb_bus_list链表中</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2308</x>
      <y>542</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usbdevfs_add_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2266</x>
      <y>537</y>
      <w>50</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2297</x>
      <y>549</y>
      <w>44</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.遍历usb的超级块链表superlist，然后通过new_bus_inode
	在sb中添加inode
2.通过update_special_inodes检查special数组中如果
	存在inode，将其时间更新
	inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME
3.执行usbdevfs_conn_disc_event：
	wake_up(&amp;deviceconndiscwq);
	conndiscevcnt++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2315</x>
      <y>545</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2309</x>
      <y>566</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>new_bus_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2314</x>
      <y>562</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2285</x>
      <y>576</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2288</x>
      <y>569</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
busnum 不能大于255
在超级块中获取IBUS | (busnum &lt;&lt; 8)号inode</panel_attributes>
    <additional_attributes>270.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2313</x>
      <y>572</y>
      <w>36</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;
inode-&gt;i_uid = sb-&gt;u.usbdevfs_sb.busuid;
inode-&gt;i_gid = sb-&gt;u.usbdevfs_sb.busgid;
inode-&gt;i_mode = sb-&gt;u.usbdevfs_sb.busmode | S_IFDIR;
inode-&gt;i_op = &amp;usbdevfs_bus_inode_operations;
inode-&gt;i_fop = &amp;usbdevfs_bus_file_operations;
 //从inode能找到bus
inode-&gt;u.usbdev_i.p.bus = bus;
 //将inode挂入到sb的链表中
list_add_tail(&amp;inode-&gt;u.usbdev_i.slist, &amp;sb-&gt;u.usbdevfs_sb.ilist);
 //将inode挂入到bus的链表中
list_add_tail(&amp;inode-&gt;u.usbdev_i.dlist, &amp;bus-&gt;inodes);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2315</x>
      <y>569</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2285</x>
      <y>586</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_new_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2289</x>
      <y>579</y>
      <w>3</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.()</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2289</x>
      <y>589</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.()</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2281</x>
      <y>594</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;read_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2289</x>
      <y>597</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usbdevfs_read_super-&gt;usbdevfs_sops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2281</x>
      <y>603</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usbdevfs_read_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2257</x>
      <y>612</y>
      <w>32</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_ctime = inode-&gt;i_mtime = inode-&gt;i_atime = CURRENT_TIME;
inode-&gt;i_mode = S_IFREG;
inode-&gt;i_gid = inode-&gt;i_uid = 0;
INIT_LIST_HEAD(&amp;inode-&gt;u.usbdev_i.dlist);
INIT_LIST_HEAD(&amp;inode-&gt;u.usbdev_i.slist);
inode-&gt;u.usbdev_i.p.dev = NULL;
inode-&gt;u.usbdev_i.p.bus = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2273</x>
      <y>606</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2293</x>
      <y>612</y>
      <w>37</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果是ISPECIAL:
	1.如果是root_inode
	inode-&gt;i_op = &amp;usbdevfs_root_inode_operations;
	inode-&gt;i_fop = &amp;usbdevfs_root_file_operations;
	inode-&gt;i_mode = S_IFDIR | S_IRUGO | S_IXUGO;
	return;
	2.如果超过了ISPECIAL类型中inode号的限制，直接return
	3.如果是其他special类型的inode
	spec = &amp;special[inode-&gt;i_ino-(IROOT+1)];
	inode-&gt;i_fop = spec-&gt;fops;
	return;
2.如果是其他类型，直接return
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2286</x>
      <y>606</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查看inode的类型
ITYPE(inode-&gt;i_ino)</panel_attributes>
    <additional_attributes>20.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2359</x>
      <y>536</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_hc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2232</x>
      <y>529</y>
      <w>132</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1300.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2344</x>
      <y>542</y>
      <w>43</w>
      <h>19</h>
    </coordinates>
    <panel_attributes> //reset host controller,并在timeout时间内检测其是否置上
outw (USBCMD_HCRESET, io_addr + USBCMD)
 //打开USB的四种中断: 超时，唤醒，规定的交互完成，short_packet
outw (USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP, io_addr + USBINTR)
 //将框架寄存器设置为0，并将其地址赋给相应的寄存器，表示从s-&gt;framelist[0]开始扫描
outw (0, io_addr + USBFRNUM);
outl (virt_to_bus (s-&gt;framelist), io_addr + USBFLBASEADD);
 //USBCMD_RS启动USB控制器
outw (USBCMD_RS | USBCMD_CF | USBCMD_MAXP, io_addr + USBCMD);
s-&gt;apm_state = 1;
s-&gt;running = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2362</x>
      <y>539</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2390</x>
      <y>535</y>
      <w>32</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.通过request_irq请求irq，其中：
	action-&gt;handler = uhci_interrupt;
	action-&gt;flags = SA_SHIRQ;
	action-&gt;name =  "usb-uhci";
	action-&gt;dev_id = uhci;（uhci对象）
2.如果请求成功：
	uhci-&gt;irq = irq;
	//设置USBLEGSUP
	pci_write_config_word(dev, USBLEGSUP, USBLEGSUP_DEFAULT)
	//启用根集中器
	uhci_start_root_hub（）
3.如果irq没请求成功，或者根集中器启动失败
	reset_hc(uhci);
	release_region(uhci-&gt;io_addr, uhci-&gt;io_size);
	release_uhci(uhci);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2396</x>
      <y>563</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_start_root_hub</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2232</x>
      <y>529</y>
      <w>172</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1700.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2404</x>
      <y>560</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2362</x>
      <y>570</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_alloc_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2370</x>
      <y>566</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2355</x>
      <y>576</y>
      <w>27</w>
      <h>20</h>
    </coordinates>
    <panel_attributes> //申请usb_device
dev = kmalloc(sizeof(*dev)

memset(dev, 0, sizeof(*dev))
 //这里bus=uhci-&gt;bus，parent=NULL(因为申请的是根集中器)
dev-&gt;bus = bus;
dev-&gt;parent = parent;
atomic_set(&amp;dev-&gt;refcnt, 1);
INIT_LIST_HEAD(&amp;dev-&gt;inodes);
INIT_LIST_HEAD(&amp;dev-&gt;filelist);

dev-&gt;bus-&gt;op-&gt;allocate(dev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2368</x>
      <y>573</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2360</x>
      <y>599</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;bus-&gt;op-&gt;allocate
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2367</x>
      <y>595</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2367</x>
      <y>602</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uhci_device_operations
这里直接返回0</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2362</x>
      <y>606</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_alloc_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2381</x>
      <y>570</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci-&gt;bus-&gt;root_hub = dev
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2389</x>
      <y>566</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根集中器的usb_dev赋值</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2405</x>
      <y>570</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2401</x>
      <y>566</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2394</x>
      <y>577</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>dev-&gt;descriptor.bMaxPacketSize0 = 8
 //从dev-&gt;bus-&gt;devmap.devicemap中找到空闲的devnum
 //如果定义了DEVNUM_ROUND_ROBIN，则从devnum_next开始查找
 //并更新devnum_next= devnum + 1
devnum = find_next_zero_bit
 //如果找到的devnum有效：devnum &lt; 128
 set_bit(devnum, dev-&gt;bus-&gt;devmap.devicemap);
	dev-&gt;devnum = devnum
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2411</x>
      <y>573</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2468</x>
      <y>567</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_new_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2401</x>
      <y>566</y>
      <w>74</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2427</x>
      <y>587</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_set_address</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2427</x>
      <y>605</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_control_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2431</x>
      <y>570</y>
      <w>45</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2431</x>
      <y>590</y>
      <w>46</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_snddefctrl：定义了pipe，__default_pipe中devnum和endpoint为0
(30~31,传输方式，成块传输、等时传输，中断传输，控制传输
26，指示是否为低速设备（dev-&gt;slow）
8~14位，设备号devnum，没被设置地址前是0
15~18位，endpoint号
7位，0指示输出，1指示输入)
USB_REQ_SET_ADDRESS：命令码，设置地址
dev-&gt;devnum：要设置的设备地址</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2427</x>
      <y>576</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //设置输入，输出预取信包的大小
dev-&gt;epmaxpacketin [0] = 8;
dev-&gt;epmaxpacketout[0] = 8
usb_set_address(dev)
wait_ms(10)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2432</x>
      <y>584</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2451</x>
      <y>578</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_get_descriptor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2456</x>
      <y>570</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
先读8个字节，将
支持的信包容量读出</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2449</x>
      <y>585</y>
      <w>34</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.将buf(dev-&gt;descriptor)清0
	memset(buf,0,size)
2.请求描述块，如果请求大小为0，则retry（总共5次）
	//这里type=USB_DT_DEVICE，表示设备描述块
	//usb_rcvctrlpipe中定义了devnum+endpoint和方向USB_DIR_IN
	usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
		USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
		(type &lt;&lt; 8) + index, 0, buf, size, HZ * GET_TIMEOUT)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2458</x>
      <y>581</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2468</x>
      <y>578</y>
      <w>30</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;epmaxpacketin [0] = dev-&gt;descriptor.bMaxPacketSize0;
dev-&gt;epmaxpacketout[0] = dev-&gt;descriptor.bMaxPacketSize0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2473</x>
      <y>570</y>
      <w>23</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据读进来的设备描述块
设置控制交互信包的最大容量</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2500</x>
      <y>577</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_get_device_descriptor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2473</x>
      <y>570</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2488</x>
      <y>585</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.再次通过usb_get_descriptor读取设备描述块
	此次读取的size是sizeof(dev-&gt;descriptor)
2.将bcdUSB，idVendor，idProduct，bcdDevice
	从小端模式转化成cpu使用的模式
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2503</x>
      <y>580</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2524</x>
      <y>577</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_get_configuration</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2472</x>
      <y>570</y>
      <w>64</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2519</x>
      <y>585</y>
      <w>40</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.filter:配置描述快的数量需要在：
	1&lt;dev-&gt;descriptor.bNumConfigurations&lt;USB_MAXCONFIG
2.申请配置描述快数组，并清0
	dev-&gt;config =kmalloc
	memset(dev-&gt;config, 0,
3.申请原始的配置描述快指针数组
	dev-&gt;rawdescriptors=kmalloc
4.循环bNumConfigurations次读取配置描述块：
	1.通过usb_get_descriptor读取配置描述块（USB_DT_CONFIG）
		的前8字节。从而获取到配置描述快的大小（wTotalLength）
	2.通过kmalloc为读进来的原始配置描述块申请内存
	3.然后再次通过usb_get_descriptor读取配置描述快（USB_DT_CONFIG）
		这次的长度是wTotalLength，并将存储配置描述块的指针赋值：
		dev-&gt;rawdescriptors[cfgno] = bigbuffer
	4.通过usb_parse_configuration根据配置描述块解析出各种层次的描述块
		并建立相应的数据结构
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2532</x>
      <y>580</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2529</x>
      <y>615</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_parse_configuration</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2536</x>
      <y>611</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2519</x>
      <y>621</y>
      <w>44</w>
      <h>47</h>
    </coordinates>
    <panel_attributes>1.通过memcpy将buffer中的原始数据拷贝前9字节（USB硬件管理信息）
	到对应的dev-&gt;config[cfgno]中
2.获取配置描述快的大小：
	size = config-&gt;wTotalLength
3.为usb_interface申请数组（大小为config-&gt;bNumInterfaces，并且其大小
	不能大于32），并将内存空间清0
4.将配置头去掉：
	buffer += config-&gt;bLength;
	size -= config-&gt;bLength
5.遍历所有的interface（bNumInterfaces）
	1.通过usb_descriptor_header解析读进来的数据，
	其中:2&lt;bLength&lt;size,否则返回-1
	2.如果遇到了USB_DT_ENDPOINT，USB_DT_INTERFACE，USB_DT_CONFIG，USB_DT_DEVICE
		则退出未知header的解析
	3.如果不是上述四个，则是未知的header，并继续1~3
	4.如果退出了未知header的解析，
		1.如果不存在未知header（buffer-begin==0），
			config-&gt;extra = NULL;
			config-&gt;extralen = 0
		2.如果存在未知header（buffer-begin!=0),需要为其申请内存，并复制
			config-&gt;extra = kmalloc(len
			memcpy(config-&gt;extra, begin, len);
			config-&gt;extralen = len;
	注：这里如果有多个bNumInterfaces，并且其中的一个interface有未知的header，只要这个interface不在最后
	一个，会造成内存的泄露
	5.通过usb_parse_interface解析上述的四个interface
	6.更新buffer和size，并重新遍历interface
		buffer += retval;
		size -= retval;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2537</x>
      <y>618</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2532</x>
      <y>671</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_parse_interface</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2538</x>
      <y>667</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2519</x>
      <y>677</y>
      <w>44</w>
      <h>61</h>
    </coordinates>
    <panel_attributes>1.首先初始化
	interface-&gt;act_altsetting = 0;
	interface-&gt;num_altsetting = 0;
	//接口描述块数组暂定为4个
	interface-&gt;max_altsetting = USB_ALTSETTINGALLOC
2.为接口描述块数组申请内存，大小为max_altsetting
	interface-&gt;altsetting = kmalloc
3.遍历buffer
	1.如果这个interface存在的接口描述块（num_altsetting）超过了数组的
		界限，更新数组的界限interface-&gt;max_altsetting += USB_ALTSETTINGALLOC
		并为之分配内存interface-&gt;altsetting = kmalloc，并将之前的数据复制到新申请的内存中
		然后将旧数组释放
	2.获取存放接口描述快的内存，并更新num_altsetting：
		ifp = interface-&gt;altsetting + interface-&gt;num_altsetting;
		interface-&gt;num_altsetting++;
	3.将接口描述块存储到数组中并更新buffer，parse，size
		memcpy(ifp, buffer, USB_DT_INTERFACE_SIZE)
		buffer += ifp-&gt;bLength;
		parsed += ifp-&gt;bLength;
		size -= ifp-&gt;bLength;
	4.继续向下遍历buffer，识别出不能识别的header（和usb_parse_configuration相似）
		将其放入到：
		ifp-&gt;extra
		ifp-&gt;extralen
	5.如果遇到了USB_DT_CONFIG或者USB_DT_DEVICE说明遇到了下一个配置或者设备描述块
		直接返回上层，让usb_parse_configuration处理
	6.为ifp-&gt;endpoint申请数组，大小为bNumEndpoints（不能大于USB_MAXENDPOINTS），
		并清0
	7.遍历所有的endpoint(bNumEndpoints),通过usb_parse_endpoint对其进行解析
		并更新：
		buffer += retval;
		parsed += retval;
		size -= retval;	
	8.更新完endpoint之后，如果size小于USB_DT_INTERFACE_SIZE，说明读进来的描述块已经读完
		如果不为USB_DT_INTERFACE，说明读到了下一个设备或者配置描述块
		如果bAlternateSetting为0，说明读到了下一个interface
		都将退出，由上层usb_parse_endpoin继续处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2538</x>
      <y>674</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2531</x>
      <y>741</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_parse_endpoint</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2538</x>
      <y>737</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2518</x>
      <y>748</y>
      <w>43</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.filter：header-&gt;bLength不能大于读进来的数据的size
			bDescriptorType必须是USB_DT_ENDPOINT
2.将读进来的数据复制到endpoint中（对于视频是9，其他的长度是7）
3.根据cpu的大小端改变endpoint-&gt;wMaxPacketSize的格式
4.将其他未识别的数据存放在endpoint-&gt;extra中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2537</x>
      <y>744</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2565</x>
      <y>577</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_set_configuration</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2472</x>
      <y>570</y>
      <w>105</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1030.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2562</x>
      <y>585</y>
      <w>27</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.在dev.config的数组中找到和configuration
	一样的usb_config_descriptor
2.如果没找到，返回EINVAL
	如果找到了，通过usb_control_msg给usb_sndctrlpipe
	设置（USB_REQ_SET_CONFIGURATION）configuration
3.更新正在使用的configuration
	dev-&gt;actconfig = cp;
	dev-&gt;toggle[0] = 0;
	dev-&gt;toggle[1] = 0;
4.通过usb_set_maxpacket更新endpoint
	最大传输信包的数量
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2573</x>
      <y>580</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2567</x>
      <y>606</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_set_maxpacket</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2574</x>
      <y>603</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2565</x>
      <y>613</y>
      <w>43</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.遍历dev激活的configuration（dev-&gt;actconfig）
	下的所有interface（bNumInterfaces）中的
	所有endpoint（bNumEndpoints）：
	1.如果bmAttributes是USB_ENDPOINT_XFER_CONTROL
	（控制交互是双向的）：
	dev-&gt;epmaxpacketout[b] = ep[e].wMaxPacketSize;
	dev-&gt;epmaxpacketin [b] = ep[e].wMaxPacketSize
	2.如果是输出型endpoint，并且大于既有的epmaxpacketout
		将其更新
		dev-&gt;epmaxpacketout[b] = ep[e].wMaxPacketSize
	3.如果是输入型的endpoint，并且大于存储endpoint的epmaxpacketin
	dev-&gt;epmaxpacketin [b] = ep[e].wMaxPacketSize
注：bEndpointAddress的低四位存储的是endpoint的序号
	第4位存储的是endpoint的方向，0表示输出
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2576</x>
      <y>609</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2593</x>
      <y>577</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usbdevfs_add_device
（和usbdevfs_add_bus类似）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2473</x>
      <y>570</y>
      <w>131</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2618</x>
      <y>577</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_find_drivers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2474</x>
      <y>570</y>
      <w>155</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1530.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2608</x>
      <y>583</y>
      <w>38</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.遍历dev激活configuration所有的interface（bNumInterfaces）
	通过usb_interface_claimed检查改interface是否被认领
	如果没被认领，通过usb_find_interface_driver扫描驱动队列
	为其寻找driver
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2626</x>
      <y>580</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2600</x>
      <y>593</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_interface_claimed</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2607</x>
      <y>589</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2592</x>
      <y>599</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.检查interface是否有driver
	（iface-&gt;driver != NULL）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2601</x>
      <y>596</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2630</x>
      <y>593</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_find_interface_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2630</x>
      <y>589</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2614</x>
      <y>600</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.dev要存在
2.ifnum不能大于bNumInterfaces
3.根据interface号（ifnum）找到interface
	interface = dev-&gt;actconfig-&gt;interface + ifnum
4.通过usb_interface_claimed检测interface.driver
	不能存在
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2627</x>
      <y>596</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2647</x>
      <y>600</y>
      <w>39</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.遍历usb_driver_list
	1.如果driver-&gt;id_table存在，遍历dev所有的interface
		通过usb_match_id检查这个id是否和dev还有其中的interface
		匹配，如果匹配，通过driver-&gt;probe将其初始化
	2.如果id不存在，直接通过driver-&gt;probe将其初始化
	注：如果已经初始化，则返回NULL
2.如果初始化完成，通过usb_driver_claim_interface完成认领：
	iface-&gt;driver = driver;
	iface-&gt;private_data = priv
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2639</x>
      <y>596</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2663</x>
      <y>576</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>call_policy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2474</x>
      <y>570</y>
      <w>197</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
热插拔相关
注意创建内核线程时使用了VCLONE_VFORK</panel_attributes>
    <additional_attributes>10.0;10.0;1950.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2405</x>
      <y>374</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2364</x>
      <y>381</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_major_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2369</x>
      <y>377</y>
      <w>44</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>420.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2349</x>
      <y>390</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_register_chrdev
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2356</x>
      <y>384</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
USB_MAJOR,usb_fops</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2371</x>
      <y>390</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_mk_dir
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2368</x>
      <y>384</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs下的目录
usb_devfs_handle</panel_attributes>
    <additional_attributes>20.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2399</x>
      <y>381</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usbdevfs_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2405</x>
      <y>377</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2387</x>
      <y>389</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>INIT_LIST_HEAD
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2388</x>
      <y>384</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化special数组的inodes链表</panel_attributes>
    <additional_attributes>160.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2403</x>
      <y>389</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2402</x>
      <y>384</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usbdevfs_driver</panel_attributes>
    <additional_attributes>20.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2419</x>
      <y>389</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2403</x>
      <y>384</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2439</x>
      <y>389</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_mkdir
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2403</x>
      <y>384</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usbdir</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2397</x>
      <y>396</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.new_driver-&gt;fops存在时，usb_minors对应的设备
	要为空，如果为空，将其赋值：
	usb_minors[new_driver-&gt;minor/16] = new_driver
2.将new_driver的driver_list链接到usb_driver_list中
3.调用usb_scan_devices
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2409</x>
      <y>392</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2403</x>
      <y>409</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_scan_devices</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2409</x>
      <y>405</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2409</x>
      <y>412</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历usb_bus_list链表
中bus的根集中器</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2403</x>
      <y>416</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_check_support</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2393</x>
      <y>422</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.dev要存在
2.遍历dev-&gt;children，递归usb_check_support
	为其子设备认领driver
3.如果该设备激活的configuration不存在，该设备不在认领driver
4.如果configuration存在，且其devnum有效，遍历其interface
	通过usb_find_interface_driver为interface认领driver
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2409</x>
      <y>419</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2463</x>
      <y>382</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2410</x>
      <y>377</y>
      <w>61</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;590.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2453</x>
      <y>389</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_register
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2459</x>
      <y>385</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hub_driver</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2468</x>
      <y>385</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2489</x>
      <y>396</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2488</x>
      <y>389</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kernel_thread
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2494</x>
      <y>392</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2457</x>
      <y>392</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.()
usb_find_interface_driver</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2452</x>
      <y>400</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hub_probe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2442</x>
      <y>407</y>
      <w>36</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.集中器的子设备号(bInterfaceSubClass)要是0或者1
2.除了默认的控制端点（代码中没有），还要有一个（bNumEndpoints）
	中断(USB_ENDPOINT_XFER_INT)交互的输入(USB_DIR_IN)端点
3.申请usb_hub数据结构，并初始化
	hub = kmalloc(sizeof(*hub)
	memset(hub, 0
	INIT_LIST_HEAD(&amp;hub-&gt;event_list);
	//hub和dev关联
	hub-&gt;dev = dev
	INIT_LIST_HEAD(&amp;hub-&gt;hub_list);
	//将hub加到hub_list链表中
	list_add(&amp;hub-&gt;hub_list, &amp;hub_list);
4.通过usb_hub_configure对hub进一步初始化，其中有对中断传输
	查询状态进行初始化
5.如果成功，return hub
	如果不成功，将hub从链表中删除，并释放hub内存
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2457</x>
      <y>403</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2450</x>
      <y>436</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_configure</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2455</x>
      <y>432</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2402</x>
      <y>445</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2407</x>
      <y>439</y>
      <w>50</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hub-&gt;descriptor
HUB_DESCRIPTOR_MAX_SIZE</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2421</x>
      <y>446</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_get_hub_descriptor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2428</x>
      <y>439</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取hub描述符
放在 hub-&gt;descriptor中</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2420</x>
      <y>453</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_control_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2428</x>
      <y>449</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
USB_REQ_GET_DESCRIPTOR
USB_DIR_IN | USB_RT_HUB</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2443</x>
      <y>445</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>hub-&gt;nports = 
dev-&gt;maxchild = 
			hub-&gt;descriptor-&gt;bNbrPorts
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2450</x>
      <y>439</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2464</x>
      <y>445</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_get_hub_status</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2454</x>
      <y>439</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2462</x>
      <y>454</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_control_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2470</x>
      <y>448</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
USB_REQ_GET_STATUS
USB_DIR_IN | USB_RT_HUB</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2454</x>
      <y>439</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请中断传输</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2490</x>
      <y>444</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.获取中断传输的pipe和最大信包maxp（不能大于hub-&gt;buffer）
2.通过usb_alloc_urb为hub-&gt;urb申请urb_t
3.通过宏FILL_INT_URB填充urb结构体
4.将urb提交，申请uhci_td链入到skeltd中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2485</x>
      <y>454</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_alloc_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2490</x>
      <y>451</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2459</x>
      <y>461</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.申请urb和iso_packets个iso_packet_descriptor_t
2.初始化urb：
	memset(urb, 0, sizeof(*urb))
	spin_lock_init(&amp;urb-&gt;lock)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2473</x>
      <y>457</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2502</x>
      <y>455</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>FILL_INT_URB
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2509</x>
      <y>451</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2496</x>
      <y>461</y>
      <w>25</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>hub-&gt;urb-&gt;dev=dev;\
hub-&gt;urb-&gt;pipe=pipe;\
hub-&gt;urb-&gt;transfer_buffer=hub-&gt;buffer;\
hub-&gt;urb-&gt;transfer_buffer_length=maxp;\
hub-&gt;urb-&gt;complete=hub_irq;\
hub-&gt;urb-&gt;context=hub;\
hub-&gt;urb-&gt;interval=endpoint-&gt;bInterval;\
hub-&gt;urb-&gt;start_frame=-1;\
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2506</x>
      <y>458</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2526</x>
      <y>455</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_submit_urb
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2513</x>
      <y>451</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2523</x>
      <y>462</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>urb-&gt;dev-&gt;bus-&gt;op-&gt;submit_urb
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2532</x>
      <y>458</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果urb和urb.dev存在</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2528</x>
      <y>444</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up(&amp;khubd_wait);
usb_hub_power_on(hub);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2454</x>
      <y>439</y>
      <w>81</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;790.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2504</x>
      <y>478</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hub_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2508</x>
      <y>475</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2497</x>
      <y>481</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查集中器hub的状态</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2471</x>
      <y>485</y>
      <w>32</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果urb-&gt;status为0，表示中断交互正常完成
2.如果status显示没有文件（-ENOENT），直接退出
3.如果是其他错误，错误十次之后，记录
	hub-&gt;error = urb-&gt;status
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2511</x>
      <y>485</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果等待队列khubd_wait不为空，将hub的event_list
	加入到hub_event_list中，并唤醒khubd_wait
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2509</x>
      <y>481</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2480</x>
      <y>403</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>daemonize</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2485</x>
      <y>399</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2479</x>
      <y>410</y>
      <w>19</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>exit_mm
current-&gt;session = 1;
current-&gt;pgrp = 1;
exit_fs(current);	/* current-&gt;fs-&gt;count--; */
fs = init_task.fs;
current-&gt;fs = fs;
atomic_inc(&amp;fs-&gt;count);
exit_files(current);
current-&gt;files = init_task.files;
atomic_inc(&amp;current-&gt;files-&gt;count);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2485</x>
      <y>406</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
退出所有的用户资源</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2495</x>
      <y>404</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>strcpy(current-&gt;comm, "khubd")
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2494</x>
      <y>399</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
指定thread的名称</panel_attributes>
    <additional_attributes>20.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2518</x>
      <y>404</y>
      <w>26</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.通过usb_hub_events处理集中器
	的状态变化
2.通过interruptible_sleep_on等待
	唤醒
3.唤醒之后检测是否有信号pending
	（一般是存在的），然后再去处理
	集中器事件
注：这里先处理usb_hub_events是为了
	处理根集中器的状态
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2495</x>
      <y>399</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
do..while</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2530</x>
      <y>420</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_events</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2532</x>
      <y>418</y>
      <w>6</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2501</x>
      <y>429</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过usb_hub_reset重置集中器
2.如果出错，通过usb_hub_disconnect
	断开链接，并继续遍历下一个hub
3.重置error
	hub-&gt;nerrors = 0;
	hub-&gt;error = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2535</x>
      <y>422</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
while读取链表hub_event_list
获取链表中的usb_hub和hub对应的dev = hub-&gt;dev
并将其temp实体从链表中移除，并初始化</panel_attributes>
    <additional_attributes>10.0;20.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2517</x>
      <y>425</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hub-&gt;error
如果出错超过10次</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2535</x>
      <y>425</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历hub的所有端口
hub-&gt;nports</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2548</x>
      <y>431</y>
      <w>35</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.通过usb_get_port_status获取port的状态
2.如果port的链接状态发生了变化（USB_PORT_STAT_C_CONNECTION）
	通过usb_hub_port_connect_change进行处理
3.如果enable状态发生了变化（USB_PORT_STAT_C_ENABLE），
	通过usb_clear_port_feature将USB_RT_PORT的ENABLE改变的状态信息
	清除。
	如果此时port状态是没有enable，但是connect，并且该端口上
	有设备（dev-&gt;children[i])），需要通过usb_hub_port_connect_change
	进行处理
4.如果SUSPEND状态位发生了变化，通过usb_clear_port_feature
	将SUSPEND改变的状态清除
5.如果过流（OVERCURRENT）状态发生了变化，通过usb_clear_port_feature
	清除其改变的状态，并通过usb_hub_power_on将hub中每个port的POWER置上
6.如果RESET状态发生了变化，通过usb_clear_port_feature清除RESET改变的状态
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2535</x>
      <y>425</y>
      <w>59</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;570.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2586</x>
      <y>431</y>
      <w>27</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.通过usb_get_hub_status获取hub的状态
2.如果获取hub状态出错，直接报错
	如果成功：
		1.如果POWER状态发生了改变，通过usb_clear_hub_feature
		将其POWER状态清掉
		2.如果其OVERCURRENT状态发生了改变，通过usb_clear_hub_feature
		将其OVERCURRENT状态，并通过usb_hub_power_on将hub中每个port的POWER置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2556</x>
      <y>458</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_port_connect_change</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2566</x>
      <y>454</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2552</x>
      <y>465</y>
      <w>34</w>
      <h>54</h>
    </coordinates>
    <panel_attributes>1.通过usb_clear_port_feature将CONNECTION改变的状态
	清除
2.如果该hub当前端口有子设备（hub-&gt;children[port]）
	通过usb_disconnect将子设备断开
注：1.如果连接状态从无到有，children不可能存在，如果存在
		只有可能是之前没被清除，所以现在将其断开，之后再申请
	2.如果连接状态从有到无，需要将usb设备断开
3.如果设备现在断开了（连接状态是从有到无）
	1.如果此时端口是ENABLE的，通过usb_hub_port_disable
		将hub的该端口禁止
	2.直接return
4.（现在连接状态一定是从无到有）申请tempstr（存储之前的port路径）
	和portstr（存储总的port路径）
5.可以尝试两次去初始化port
	1.通过usb_alloc_dev申请usb_dev,parent是hub
		hub-&gt;children[port] = dev
	2.通过usb_hub_port_reset将该port reset
	3.通过usb_connect申请dev-&gt;devnum
	4.找到当前port从根集中器到当前port的port路径，存储到portstr
		并打印
	5.通过usb_new_device
		1.将dev的地址设置为dev-&gt;devnum
		2.获取设备的设备描述块和配置描述块（包括接口和endpoint）存放在内存中
		3.将configuration默认设置为0号描述符
		4.如果相应的usb驱动已经安装，会通过usb_find_drivers去初始化设备
			否则会在后续安装usb驱动的时候初始化
	6.如果usb_new_device出错了，先通过usb_free_dev将usb_dev释放，
		然后再去尝试初始化port
		如果usb_new_device成功了，将之前申请的tempstr和
		portstr释放，并返回
	7.如果两次尝试初始化都失败了：
		hub-&gt;children[port] = NULL;
		usb_hub_port_disable(hub, port)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2566</x>
      <y>461</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2570</x>
      <y>522</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_port_disable</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2570</x>
      <y>518</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2571</x>
      <y>528</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_clear_port_feature
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2579</x>
      <y>525</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
清除port的enable状态</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2546</x>
      <y>518</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2541</x>
      <y>523</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_disconnect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2608</x>
      <y>522</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_port_reset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2578</x>
      <y>518</y>
      <w>39</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2514</x>
      <y>526</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
清除actconfig中的所有interface</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2495</x>
      <y>534</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>driver-&gt;disconnect
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2501</x>
      <y>530</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2510</x>
      <y>534</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_driver_release_interface</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2514</x>
      <y>530</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2494</x>
      <y>541</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hub_disconnect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2508</x>
      <y>541</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>iface-&gt;driver = NULL;
iface-&gt;private_data = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2517</x>
      <y>537</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2499</x>
      <y>537</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hub_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2481</x>
      <y>548</y>
      <w>31</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.将hub从链表中删除，并初始化
	//从khubd的等待链表hub_event_list中删除
	list_del(&amp;hub-&gt;event_list);
	INIT_LIST_HEAD(&amp;hub-&gt;event_list);
	//从所有hub的管理链表hub_list中删除
	list_del(&amp;hub-&gt;hub_list);
	INIT_LIST_HEAD(&amp;hub-&gt;hub_list);
2.如果hub-&gt;urb存在：
	usb_unlink_urb(hub-&gt;urb);-&gt; urb-&gt;dev-&gt;bus-&gt;op-&gt;unlink_urb
	usb_free_urb(hub-&gt;urb);
	hub-&gt;urb = NULL;
3.如果设备描述块hub-&gt;descriptor存在，将其释放：
	kfree(hub-&gt;descriptor);
	hub-&gt;descriptor = NULL
4.释放hub:
	kfree(hub)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2498</x>
      <y>544</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2524</x>
      <y>526</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
递归释放掉usb_dev的所有子设备
dev-&gt;children（最多只有USB_MAXCHILDREN个）</panel_attributes>
    <additional_attributes>220.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2529</x>
      <y>532</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_disconnect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2542</x>
      <y>532</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>call_policy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2545</x>
      <y>526</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
热插拔相关</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2555</x>
      <y>532</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //将devnum在devicemap中清除
clear_bit(dev-&gt;devnum, &amp;dev-&gt;bus-&gt;devmap.devicemap);
usbdevfs_remove_device(dev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2543</x>
      <y>526</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果设备号dev-&gt;devnum存在</panel_attributes>
    <additional_attributes>30.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2567</x>
      <y>533</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_free_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2545</x>
      <y>526</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2557</x>
      <y>540</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果dev-&gt;refcnt递减至0，需要彻底释放dev：
	1.dev-&gt;bus-&gt;op-&gt;deallocate(dev)
	2.通过usb_destroy_configuration
		1.释放掉原始数据的rawdescriptors（指针数组，指针
		指向原始数据）
		2.释放掉从原始数据中提取的管理结构，config--interface--endpoint
	3.释放掉dev：
		kfree(dev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2573</x>
      <y>536</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2601</x>
      <y>529</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.设置port的reset状态
2.通过usb_hub_port_wait_reset检测port是否在delay时间
	内reset
3.如果在delay时间reset，清掉reset改变的状态信息，并return 0
	如果在delay时间内没检测到reset，将delay时间换成HUB_LONG_RESET_TIME
	之后，再去将尝试将port reset
4.如果两次都没reset，return -1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2615</x>
      <y>525</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2616</x>
      <y>540</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2606</x>
      <y>544</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_port_wait_reset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2597</x>
      <y>551</y>
      <w>42</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.等待delay的时间
2.通过usb_get_port_status获取port的状态
3.如果port的CONNECTION从有到无，返回-1
4.如果完成了reset（RESET状态没有），并且
	ENABLE置上时：
	1.dev-&gt;slow在LOW_SPEED置上时，是1，否则为0
	2.return 0
5.如果检测时间超过了2*HUB_SHORT_RESET_TIME，就换算
	成HUB_LONG_RESET_TIME继续检测是否reset
6.等到HUB_RESET_TIMEOUT时间就return -1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2615</x>
      <y>547</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2686</x>
      <y>396</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_scanner_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2691</x>
      <y>399</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
scanner_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2687</x>
      <y>403</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_register
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2692</x>
      <y>406</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.()</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2687</x>
      <y>411</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>probe_scanner</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2649</x>
      <y>420</y>
      <w>30</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.下面两种情况的其中之一满足，就是有效的dev（valid_device）：
	1.遍历scanner_device_ids数组，查看其中是否有和
	设备描述块的idVendor和idProduct一致的项
	2.用户定义的vendor和product和设备描述块中的相同
2.配置描述块的数量（bNumConfigurations）和接口的数量
	（bNumInterfaces）都要是1
3.接口中endpoint的数量（bNumEndpoints）不是2就是3个
	如果是2个，就分别是成块传输的输入和输出
	如果是3个，就分别是成块传输的输入，输出和中断传输

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2661</x>
      <y>414</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2684</x>
      <y>420</y>
      <w>36</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.找到p_scn_table中空闲的scn_usb_data指针位
注：minor的高4位指示的是usb_driver的位置
	后4位指示的是特定的usb设备的位置(就是这里在p_scn_table中的位置)
2.申请scn_usb_data，并初始化为0
	scn = kmalloc
	memset (scn, 0,
3.如果有中断传输的endpoint（have_intr），设置urb
	scn-&gt;scn_irq-&gt;dev=dev;\
	scn-&gt;scn_irq-&gt;pipe=usb_rcvintpipe(dev, have_intr);\
	scn-&gt;scn_irq-&gt;transfer_buffer=&amp;scn-&gt;button;\
	scn-&gt;scn_irq-&gt;transfer_buffer_length=1;\
	scn-&gt;scn_irq-&gt;complete=irq_scanner;\
	scn-&gt;scn_irq-&gt;context=scn;\
	scn-&gt;scn_irq-&gt;interval=250;\
	scn-&gt;scn_irq-&gt;start_frame=-1;\
4.为scanner的ouput buffer和input buffer申请内存
	scn-&gt;obuf =kmalloc(OBUF_SIZE
	scn-&gt;ibuf = kmalloc(IBUF_SIZE
5.初始化scanner：
	//分别指示成块传输的输入，成块传输的输出，中断传输的endpoint号
	scn-&gt;bulk_in_ep = have_bulk_in;
	scn-&gt;bulk_out_ep = have_bulk_out;
	scn-&gt;intr_ep = have_intr;
	scn-&gt;present = 1;
	scn-&gt;scn_dev = dev;
	//在p_scn_table中的位置
	scn-&gt;scn_minor = scn_minor;
	scn-&gt;isopen = 0;
	init_MUTEX(&amp;(scn-&gt;gen_lock))
	p_scn_table[scn_minor] = scn
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2692</x>
      <y>414</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2371</x>
      <y>612</y>
      <w>23</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>dr = kmalloc(sizeof(devrequest)
 //8位，最高位-方向，5~6--寄存器类型，是否是标准的，0~4--操作的对象
dr-&gt;requesttype = requesttype;
 //操作的类型
dr-&gt;request = request;
 //参数
dr-&gt;value = cpu_to_le16p(&amp;value);
 //设备/接口/endpoint具体的单元（“设备”的缓冲区地址寄存器）
dr-&gt;index = cpu_to_le16p(&amp;index);
	//读写缓冲区大小
dr-&gt;length = cpu_to_le16p(&amp;size)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2381</x>
      <y>608</y>
      <w>54</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请devrequest，并初始化</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2425</x>
      <y>613</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_internal_control_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2450</x>
      <y>612</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kfree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2432</x>
      <y>608</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放devrequest</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2432</x>
      <y>608</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2396</x>
      <y>620</y>
      <w>23</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>urb = usb_alloc_urb(0)
spin_lock_init(&amp;urb-&gt;lock);\
urb-&gt;dev=usb_dev;\
urb-&gt;pipe=pipe;\
urb-&gt;setup_packet=devrequest;\
urb-&gt;transfer_buffer=data;\
urb-&gt;transfer_buffer_length=len;\
urb-&gt;complete=usb_api_blocking_completion;\
urb-&gt;context=0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2404</x>
      <y>616</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请urb（reference），并初始化CONTROL_URB</panel_attributes>
    <additional_attributes>300.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2427</x>
      <y>624</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_start_wait_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2433</x>
      <y>616</y>
      <w>5</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2466</x>
      <y>618</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果出错，返回错误信息
	否则返回buffer实际长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2433</x>
      <y>616</y>
      <w>40</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2086</x>
      <y>642</y>
      <w>27</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.声明局部变量wait，wqh（等待队列）
2.
	//将等待队列放在awd中，
	awd.wakeup = &amp;wqh;
	init_waitqueue_head(&amp;wqh); 	
	current-&gt;state = TASK_INTERRUPTIBLE;
	//将wait放到等待队列中
	add_wait_queue(&amp;wqh, &amp;wait);
	//之后在中断时可通过urb找到其等待队列
	urb-&gt;context = &amp;awd
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2095</x>
      <y>627</y>
      <w>342</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>3400.0;10.0;3220.0;90.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2128</x>
      <y>643</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_submit_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2135</x>
      <y>627</y>
      <w>303</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>3010.0;10.0;2840.0;100.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2122</x>
      <y>649</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>urb-&gt;dev-&gt;bus-&gt;op-&gt;submit_urb
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2133</x>
      <y>646</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2134</x>
      <y>652</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
alloc_uhci-&gt;uhci_device_operations</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2129</x>
      <y>655</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_submit_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2079</x>
      <y>661</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.urb要存在
2.urb-&gt;dev，urb-&gt;dev-&gt;bus，
	urb-&gt;dev-&gt;bus-&gt;hcpriv（存储的是uhci）
	都要存在
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2088</x>
      <y>658</y>
      <w>49</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2105</x>
      <y>658</y>
      <w>33</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是根集中器
(usb_pipedevice(urb-&gt;pipe) == uhci-&gt;rh.devnum)
就不需要usb总线参与，
直接操作root_hub的
寄存器</panel_attributes>
    <additional_attributes>300.0;10.0;20.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2100</x>
      <y>668</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rh_submit_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2134</x>
      <y>658</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不是根集中器</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2128</x>
      <y>662</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果能找到dev和pipe相同的urb
并且不是需要串行化成块传输（USB_QUEUE_BULK）
返回ENXIO</panel_attributes>
    <additional_attributes>180.0;10.0;160.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2138</x>
      <y>665</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_find_urb_ep</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2125</x>
      <y>671</y>
      <w>38</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.取pipe的最高2位，查看是不是等时传输（usb_pipeisoc）
	如果是，返回NULL
	注：等时传输等时传输中有时间戳信息，不能造成交互夹杂（猜测）。
		等时传输有1个交互，每个交互中有2个信包（传令，数据，没有握手）。
2.通过nested_lock给urblist_lock上锁。这个上锁机制是：如果是同进程给其
	上锁，只是增加锁的count；如果是不同进程则是通过spin_lock自旋
3.遍历uhci-&gt;urb_list链表，如果传进来的urb和链表中的urb的dev和pipe
	相同，则在nested_unlock解锁之后，返回链表中的urb
4.否则在nested_unlock解锁之后，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2143</x>
      <y>668</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2153</x>
      <y>665</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_inc_dev_use
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2144</x>
      <y>662</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加urb-&gt;dev-&gt;refcnt计数</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2170</x>
      <y>665</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_alloc_urb_priv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2145</x>
      <y>662</y>
      <w>34</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2166</x>
      <y>671</y>
      <w>24</w>
      <h>17</h>
    </coordinates>
    <panel_attributes> //申请urb_priv，并初始化
urbp = kmem_cache_alloc(uhci_up_cachep
memset((void *)urbp, 0
urbp-&gt;inserttime = jiffies;
urbp-&gt;urb = urb;

INIT_LIST_HEAD(&amp;urbp-&gt;list);
INIT_LIST_HEAD(&amp;urbp-&gt;urb_queue_list);

urb-&gt;hcpriv = urbp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2177</x>
      <y>668</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2144</x>
      <y>661</y>
      <w>75</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_pipetype(urb-&gt;pipe)
查看传输的类型</panel_attributes>
    <additional_attributes>10.0;10.0;730.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2009</x>
      <y>703</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_submit_control</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2015</x>
      <y>664</y>
      <w>204</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_CONTROL</panel_attributes>
    <additional_attributes>2020.0;10.0;1770.0;270.0;10.0;390.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1994</x>
      <y>711</y>
      <w>35</w>
      <h>21</h>
    </coordinates>
    <panel_attributes> //0~7位定义交互类型（setup）,8~18定义为dev endpoint
 //后面21~31定义信包的长度
destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | USB_PID_SETUP
 //26位表示是否为低速设备，23位 1表示等待执行（TD_CTRL_ACTIVE），0表示已经执行
 //27位表示允许出错的次数（3）
status = (urb-&gt;pipe &amp; TD_CTRL_LS) | TD_CTRL_ACTIVE | (3 &lt;&lt; 27)

td = uhci_alloc_td(urb-&gt;dev)
uhci_add_td_to_urb(urb, td);
 //(7 &lt;&lt; 21)表示信包的长度是（7+1）=8字节
uhci_fill_td(td, status, destination | (7 &lt;&lt; 21),
	virt_to_bus(urb-&gt;setup_packet));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2003</x>
      <y>706</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备setup交互</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1969</x>
      <y>734</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_alloc_td</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1974</x>
      <y>731</y>
      <w>26</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1961</x>
      <y>740</y>
      <w>28</w>
      <h>24</h>
    </coordinates>
    <panel_attributes> //申请uhci_td
td = kmem_cache_alloc(uhci_td_cachep
 //bit0是1表示链接终结，bit1是1表示队列头
 //bit2是1表示纵向执行，0表示横向执行
td-&gt;link = UHCI_PTR_TERM;
td-&gt;buffer = 0;

td-&gt;frameptr = NULL;
td-&gt;nexttd = td-&gt;prevtd = NULL;
td-&gt;dev = dev;
INIT_LIST_HEAD(&amp;td-&gt;list);

 //增加dev-&gt;refcnt计数
usb_inc_dev_use(dev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1974</x>
      <y>737</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1993</x>
      <y>736</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_add_td_to_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2002</x>
      <y>730</y>
      <w>26</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这是将td挂入到链表urb_priv中，
这里是虚拟地址，以便cpu遍历
为了usb DMA设备遍历，还有一个
物理地址链表头uhci_qh
</panel_attributes>
    <additional_attributes>40.0;20.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1991</x>
      <y>744</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>td-&gt;urb = urb;
 //将td挂入到urb-&gt;hcpriv指向的urb_priv链表中
list_add_tail(&amp;td-&gt;list, &amp;urbp-&gt;list);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2000</x>
      <y>739</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2020</x>
      <y>736</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_fill_td</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2015</x>
      <y>731</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2020</x>
      <y>743</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>td-&gt;status = status;
 //destination
td-&gt;info = info;
 //setup_packet
td-&gt;buffer = buffer;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2026</x>
      <y>739</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2014</x>
      <y>706</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备数据交互</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2033</x>
      <y>711</y>
      <w>30</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.针对数据交互，更新destination和status
 //将setup清除，看其pipe的输入输出特性，看是USB_PID_IN还是USB_PID_OUT
destination ^= (USB_PID_SETUP ^ usb_packetid(urb-&gt;pipe));
 //如果urb-&gt;transfer_flags中USB_DISABLE_SPD（short packet dected）没被置上
status |= TD_CTRL_SPD
2.遍历传输数据的长度urb-&gt;transfer_buffer_length，单次交互最长信包长度是epmaxpacketout或者epmaxpacketin
	1.申请td=uhci_alloc_td(urb-&gt;dev)
	2.data0和data1信包指示连续信包：
	destination ^= 1 &lt;&lt; TD_TOKEN_TOGGLE;
	3.将td加入到urb_priv链表中，并初始化
		uhci_add_td_to_urb(urb, td);
		//长度是pktsze，buffer是urb-&gt;transfer_buffer
		uhci_fill_td(td, status, destination | ((pktsze - 1) &lt;&lt; 21),
			virt_to_bus(data));
	4.更新长度和buffer，直到传输数据完成
		data += pktsze;
		len -= pktsze;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2014</x>
      <y>706</y>
      <w>66</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备状态交互</panel_attributes>
    <additional_attributes>10.0;10.0;640.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2065</x>
      <y>711</y>
      <w>29</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.申请td = uhci_alloc_td(urb-&gt;dev);
2.清除交互的属性（destination &amp;= ~TD_PID;）
	如果数据交互是输出，或者不要求传输数据
	destination |= USB_PID_IN
	否则为：
	destination |= 1 &lt;&lt; TD_TOKEN_TOGGLE;
3.清除status中的short packet dected
	status &amp;= ~TD_CTRL_SPD
4.加入到urb_priv链表中，并初始化
	uhci_add_td_to_urb(urb, td);
	//TD_CTRL_IOC表示交互完成之后向cpu发送中断
	uhci_fill_td(td, status | TD_CTRL_IOC,
		destination | (UHCI_NULL_DATA_SIZE &lt;&lt; 21), 0)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2015</x>
      <y>706</y>
      <w>128</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将td挂入到usb总线的调度队列</panel_attributes>
    <additional_attributes>10.0;10.0;1260.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2125</x>
      <y>710</y>
      <w>38</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.通过uhci_alloc_qh申请队列头uhci_qh
2.通过uhci_insert_tds_in_qh将urbp中的td挂入到qh的链表中
	如果是低速设备(TD_CTRL_LS)，深度优先，纵向连接,通过uhci_insert_qh将其插入到skel_ls_control_qh中
	如果是高速设备，宽度优先，横向连接，通过uhci_insert_qh将其插入到skel_hs_control_qh中，并通过uhci_inc_fsbr
		使term_qh的link指向hs_qh，使总线的空闲的时候能继续执行hs_qh后面的qh
3.将qh和urbp关联，并将urb挂入到uhci链表中
	urbp-&gt;qh = qh;
	//将urb挂入到uhci-&gt;urb_list
	uhci_add_urb_list(uhci, urb);
	//表示正在处理这个urb，需要在中断中将其complete
	return -EINPROGRESS
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2094</x>
      <y>732</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_alloc_qh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2082</x>
      <y>738</y>
      <w>25</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>qh = kmem_cache_alloc(uhci_qh_cachep
qh-&gt;element = UHCI_PTR_TERM;
qh-&gt;link = UHCI_PTR_TERM;

qh-&gt;dev = dev;
qh-&gt;prevqh = qh-&gt;nextqh = NULL;

INIT_LIST_HEAD(&amp;qh-&gt;remove_list);

usb_inc_dev_use(dev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2090</x>
      <y>735</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请uhci_qh，并初始化</panel_attributes>
    <additional_attributes>100.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2113</x>
      <y>732</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_insert_tds_in_qh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2109</x>
      <y>738</y>
      <w>36</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.遍历urb-&gt;hcpriv（urbp）链表
2.如果链表是空（head == tmp）直接返回
3.将qh-&gt;element指向链表中的第一个td
	如果是低速设备将纵向连接（UHCI_PTR_DEPTH）置上
4.然后遍历链表中剩下的td用td.link指针连接到第一个td的
	链表中（qh-&gt;element）
5.最后一个td指向UHCI_PTR_TERM（表示连接的终结）
注：1.qh.element和td.link指向的都是物理地址，后4位
		是对齐的，用于指示
	2.qh-&gt;element指向一个urb的td队列，纵向连接
	 qh-&gt;link用于队列之间的连接，横向连接
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2121</x>
      <y>735</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2150</x>
      <y>732</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_insert_qh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2147</x>
      <y>738</y>
      <w>31</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.将申请的qh连接到规定的qh链表中（头插）（虚拟地址连接）
	qh-&gt;nextqh = skelqh-&gt;nextqh;
	qh-&gt;prevqh = skelqh;
	if (skelqh-&gt;nextqh)
		skelqh-&gt;nextqh-&gt;prevqh = qh;
	skelqh-&gt;nextqh = qh;
2.将申请的qh插入到规定qh的link链表中（物理地址连接）
	qh-&gt;link = skelqh-&gt;link;
	skelqh-&gt;link = virt_to_bus(qh) | UHCI_PTR_QH;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2156</x>
      <y>735</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2182</x>
      <y>732</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_inc_fsbr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2180</x>
      <y>738</y>
      <w>34</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果urb-&gt;transfer_flags的USB_NO_FSBR
	没置上，且urbp-&gt;fsbr为0时：
	urbp-&gt;fsbr=1
	如果uhci-&gt;fsbr为0（注意这里是uhci）
	uhci-&gt;fsbr++
	//term是终结的qh，现在将其指向hs_qh，在总线空闲的时候，
	//会返回到hs_qh继续执行
	uhci-&gt;skel_term_qh.link = virt_to_bus(&amp;uhci-&gt;skel_hs_control_qh) | UHCI_PTR_QH
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2186</x>
      <y>735</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2099</x>
      <y>728</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2121</x>
      <y>728</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2131</x>
      <y>728</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2132</x>
      <y>728</y>
      <w>56</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;540.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2134</x>
      <y>658</y>
      <w>359</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;3570.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2473</x>
      <y>663</y>
      <w>38</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.记录提交urb之后的返回状态
	urb-&gt;status = ret
2.如果是返回状态是-EINPROGRESS，说明urb正在被处理，
	需要中断之后提醒uhci结束，所以ret=0
	如果是其他状态，说明urb已经被处理完，或者产生一些错误
	需要将提交的urb摧毁(uhci_unlink_generic)，并
	递减对dev.rfecnt的引用 
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2463</x>
      <y>679</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_unlink_generic</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2504</x>
      <y>680</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_dec_dev_use</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2470</x>
      <y>674</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2485</x>
      <y>674</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2506</x>
      <y>687</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_free_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2511</x>
      <y>683</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
reference</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2434</x>
      <y>685</y>
      <w>13</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.urb_priv要存在
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2439</x>
      <y>682</y>
      <w>34</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2449</x>
      <y>685</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_dec_fsbr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2455</x>
      <y>682</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2435</x>
      <y>690</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果urb-&gt;transfer_flags的USB_NO_FSBR
	没置上，且urbp-&gt;fsbr为1时：
	urbp-&gt;fsbr=0
	先递减uhci-&gt;fsbr，如果uhci-&gt;fsbr为0（注意这里是uhci）
	//term是终结的qh，
	uhci-&gt;skel_term_qh.link =UHCI_PTR_TERM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2449</x>
      <y>688</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2463</x>
      <y>686</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_remove_urb_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2468</x>
      <y>682</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过nested_lock锁住
uhci-&gt;urblist_lock</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2462</x>
      <y>691</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.将urb.urb_list在uhci-&gt;urb_list
	链表中，通过list_del将urb从链表中
	删除，并初始化uhci-&gt;urb_list
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2466</x>
      <y>689</y>
      <w>6</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2486</x>
      <y>686</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_remove_qh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2470</x>
      <y>682</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果urbp-&gt;qh存在</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2477</x>
      <y>693</y>
      <w>20</w>
      <h>17</h>
    </coordinates>
    <panel_attributes> //将qh从虚拟地址链表和物理地址链表中断开
if (qh-&gt;prevqh) {
	qh-&gt;prevqh-&gt;nextqh = qh-&gt;nextqh;
	qh-&gt;prevqh-&gt;link = qh-&gt;link;
}
if (qh-&gt;nextqh)
	qh-&gt;nextqh-&gt;prevqh = qh-&gt;prevqh;
 //初始化qh链表指针
qh-&gt;prevqh = qh-&gt;nextqh = NULL;
qh-&gt;element = qh-&gt;link = UHCI_PTR_TERM;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2483</x>
      <y>689</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2498</x>
      <y>693</y>
      <w>21</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果qh在skelqh队列中(delay)	
	1.如果uhci-&gt;qh_remove_list为空
		通过uhci_set_next_interrupt将
		skel最后一个td(uhci-&gt;skel_term_td.status)
		的TD_CTRL_IOC置上，使其结束之后
		向cpu发送中断，让cpu将qh_remove_list
		链表中的qh回收
	2.通过list_add将qh.remove_list加入到
		qh_remove_list链表中（有可能usb控制器暂时
		还没出这个qh，需要放在remove_list中冷却）
2.如果不在skelqh队列中，通过uhci_free_qh
	将qh释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2492</x>
      <y>689</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2502</x>
      <y>714</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_free_qh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2508</x>
      <y>711</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2498</x>
      <y>720</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.如果qh-&gt;dev存在，通过usb_dec_dev_use递减其rfecnt
2.将qh释放给uhci_qh_cachep
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2507</x>
      <y>717</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2408</x>
      <y>638</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //释放urb
usb_free_urb(urb);
current-&gt;state = TASK_RUNNING;
 //将wait从等待队列wqh中删除
remove_wait_queue(&amp;wqh, &amp;wait);
 //返回出错信息
return status;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2416</x>
      <y>627</y>
      <w>26</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果出错（status不为0）
-EINPROGRESS已经将status转化成0
并将其存在urb-&gt;status中</panel_attributes>
    <additional_attributes>200.0;10.0;50.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2437</x>
      <y>631</y>
      <w>50</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.如果原始信息urb-&gt;status显示是EINPROGRESS，（表示urb正在被处理，需要等待）
	如果定义了timeout，通过schedule_timeout使进程休眠，到timeout时间唤醒（或者中间有其他进程唤醒）
	status和timeout记录剩余的时间
	如果原来正常返回，表示urb已经处理完，status=1
2.将进程的状态设置为running，并将wait从等待队列中删除
3.如果status为0，表示timeout时间到了，进程才被唤醒：
	//如果正常处理完成，usb将link element等物理地址清除
	//但是timeout需要通过unlink将其物理地址链表清除
	usb_unlink_urb(urb);  // remove urb safely
	status = -ETIMEDOUT;
	如果因为被处理完而被唤醒，将其原始状态返回
	status = urb-&gt;status
4.如果要求返回actual_length
	*actual_length = urb-&gt;actual_length
5.通过usb_free_urb释放urb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2435</x>
      <y>627</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2494</x>
      <y>637</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_unlink_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2486</x>
      <y>636</y>
      <w>13</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2489</x>
      <y>643</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>urb-&gt;dev-&gt;bus-&gt;op-&gt;unlink_urb
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2500</x>
      <y>640</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2500</x>
      <y>646</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uhci_device_operations</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2494</x>
      <y>649</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_unlink_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2215</x>
      <y>664</y>
      <w>11</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_BULK</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2210</x>
      <y>690</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_submit_bulk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2126</x>
      <y>698</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.要读的长度len &lt; 0，返回EINVAL
2.如果是低速设备（TD_CTRL_LS），返回EINVAL
	（因为成块传输的数据量大，可能没办法通过深度优先
	在1ms内将数据传输完成）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2152</x>
      <y>693</y>
      <w>66</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>640.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2163</x>
      <y>698</y>
      <w>39</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.destination：设备号+方向
	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe)
2.status：td传输标记+出错次数+SPD(short packer dectected)
	status = TD_CTRL_ACTIVE | (3 &lt;&lt; TD_CTRL_C_ERR_SHIFT)
	如果urb的USB_DISABLE_SPD没置上，
	status |= TD_CTRL_SPD
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2169</x>
      <y>693</y>
      <w>50</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备数据</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2205</x>
      <y>699</y>
      <w>27</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.循环准备len长度的数据交互，每个交互的最大长度
	是maxsze
	1.利用uhci_alloc_td申请交互td
	2.通过uhci_add_td_to_urb将td加入到链表urbp-&gt;list中
	3.利用uhci_fill_td填充td：
	info=destination | ((pktsze - 1) &lt;&lt; 21) |TD_TOKEN_TOGGLE(事先有翻转)
	buffer=virt_to_bus(data)
	4.更新buffer和长度
	data += pktsze;
	len -= maxsze;
	5.如果是最后一个td（len &lt;= 0）
	td-&gt;status |= TD_CTRL_IOC
	6.通过usb_dotoggle将urb-&gt;dev-&gt;toggle[out]对应的endpoint中翻转
	（之后用于TD_TOKEN_TOGGLE位）
注：利用do..while，所以即使len=0，还是有一个数据td
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2209</x>
      <y>693</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备数据交互</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2236</x>
      <y>699</y>
      <w>42</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.利用uhci_alloc_qh申请qh，并赋值给urbp
	urbp-&gt;qh = qh
2.通过uhci_insert_tds_in_qh将urbp.list中的
	td通过物理指针element link链接在qh中
3.如果该传输urb被标记为USB_QUEUE_BULK，
	并且在uhci中有和其dev和endpoint相同的
	eurb，将新添加进去的urbp标记成不是队列头
	（urbp-&gt;queued = 1），并通过uhci_append_queued_urb
	将其加入到队列中
	如果上述情况不满足，通过uhci_insert_qh将其加入到skel_bulk_qh
	后
4.通过uhci_add_urb_list将urb加入到uhci-&gt;urb_list链表中
5.通过uhci_inc_fsbr查看该urb是否需要usb总线空闲时间，如果需要
	递增uhci-&gt;fsbr，并将term_qh链接到hs_qh
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2215</x>
      <y>693</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备qh</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2249</x>
      <y>726</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_append_queued_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2257</x>
      <y>722</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2240</x>
      <y>733</y>
      <w>37</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.找到队列的队列头furbp：
	1.如果eurbp-&gt;queued=0，那么eurbp就是队列头
	2.如果queued=1，那么就顺着eurbp-&gt;urb_queue_list链表
	查找，直到找到turbp-&gt;queued为0的urbp退出（或者整个链表查找完，没找到也退出）
	注：这里tmp = tmp-&gt;next位置应该是个bug
2.通过furbp-&gt;urb_queue_list.prev找到最后一个urbp（lurbp）
3.找到lurbp的最后一个td：
	ltd= list_entry(lurbp-&gt;list.prev, struct uhci_td, list)
4.找到要插入队列urbp的第一个td：
	td = list_entry(urbp-&gt;list.next, struct uhci_td, list)
5.将ltd链接到td
	ltd-&gt;link = virt_to_bus(td)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2257</x>
      <y>729</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2216</x>
      <y>664</y>
      <w>93</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_INTERRUPT</panel_attributes>
    <additional_attributes>10.0;10.0;910.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2290</x>
      <y>685</y>
      <w>38</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果urb没被分配带宽urb-&gt;bandwidth == 0
	1.通过usb_check_bandwidth计算该交互需要的带宽
	2.如果返回错误（小于0），返回错误信息
		如果bustime正确返回，通过uhci_submit_interrupt将
		urb提交，并通过usb_claim_bandwidth将bustime申请带宽
2.如果urb已经被分配带宽，直接通过uhci_submit_interrupt将urb提交
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2283</x>
      <y>700</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_check_bandwidth</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2289</x>
      <y>695</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2280</x>
      <y>707</y>
      <w>33</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.通过usb_calc_bus_time计算该传输需要的bustime
	主要和usb_maxpacket相关。但是在计算时会考虑
	是否是低速设备，传输的方向、是否是等时传输
2.如果是等时传输，因为会将等时传输的包放在不同的框架中
	所以bustime/=number_of_packets（每个信包构成一个交互）
	如果是中断传输，就是之前计算的bustime
3.计算如果加入该urb之后的带宽：
	new_alloc=dev-&gt;bus-&gt;bandwidth_allocated+ (int)bustime
4.如果没有带宽检查，直接返回bustime；如果有，在总体带宽大于框架
	时间的90%时，会报USB_ST_BANDWIDTH_ERROR，其他情况，返回bustime
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2289</x>
      <y>703</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2340</x>
      <y>701</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_claim_bandwidth</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2317</x>
      <y>695</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2354</x>
      <y>708</y>
      <w>28</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>dev-&gt;bus-&gt;bandwidth_allocated += bustime
 //如果是等时传输
dev-&gt;bus-&gt;bandwidth_isoc_reqs++
 //如果是中断传输
dev-&gt;bus-&gt;bandwidth_int_reqs++

urb-&gt;bandwidth = bustime
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2348</x>
      <y>704</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2317</x>
      <y>703</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_submit_interrupt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2311</x>
      <y>695</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2315</x>
      <y>710</y>
      <w>33</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.要发送的长度transfer_buffer_length，
	不能大于usb_maxpacket，因为中断传输
	只有一个交互
2.准备数据
	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe);
	status = (urb-&gt;pipe &amp; TD_CTRL_LS) | TD_CTRL_ACTIVE | TD_CTRL_IOC;
3.准备td：
	td = uhci_alloc_td
	//准备TD_TOKEN_TOGGLE位，和长度
	destination |= usb_gettoggle&lt;&lt; TD_TOKEN_TOGGLE | ((urb-&gt;transfer_buffer_length - 1) &lt;&lt; 21)
	//翻转(dev)-&gt;toggle[out]
	usb_dotoggle
4.建立td的关系
	//将td加入到urbp.list
	uhci_add_td_to_urb(urb, td);
	uhci_fill_td(td, status, destination,
		virt_to_bus(urb-&gt;transfer_buffer));
	//将td的物理链表挂入到框架对应的td下
	uhci_insert_td(uhci, &amp;uhci-&gt;skeltd[__interval_to_skel(urb-&gt;interval)], td);
	//将urb挂入到uhci-&gt;urb_list链表中
	uhci_add_urb_list(uhci, urb)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2325</x>
      <y>706</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2324</x>
      <y>747</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__interval_to_skel</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2331</x>
      <y>743</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2323</x>
      <y>753</y>
      <w>16</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>interval		实际间隔		index
0~1			int1			0
2~3			int2			1
4~7			int4			2
8~15			int8			3
16~31			int16			4
32~63			int32			5
64~127		int64			6
128~255		int128		7
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2330</x>
      <y>750</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2216</x>
      <y>664</y>
      <w>183</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_ISOCHRONOUS</panel_attributes>
    <additional_attributes>10.0;10.0;1810.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2385</x>
      <y>685</y>
      <w>37</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果传输urb之前没被分配带宽（urb-&gt;bandwidth == 0）
	1.如果需要发的信包的数量（number_of_packets）小于0，返回EINVAL
	2.通过usb_check_bandwidth为等时交互分配bustime，如果出现错误，直接返回
	3.通过uhci_submit_isochronous将urb提交
	4.如果urb在框架内执行，通过usb_claim_bandwidth将urb的带宽加在总线上
2.如果之前被分配过带宽，直接使用uhci_submit_isochronous将urb提交
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2395</x>
      <y>698</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_submit_isochronous</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2403</x>
      <y>695</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2387</x>
      <y>704</y>
      <w>39</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.准备数据：
	//激活td，等时传输
	status = TD_CTRL_ACTIVE | TD_CTRL_IOS;
	//pipe 方向
	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe)
2.通过isochronous_find_start寻找等时传输的首个框架
3.要从urb-&gt;start_frame，分配number_of_packets依次到每个框架内：
	1.如果urb-&gt;iso_frame_desc[i].length为0，该框架内不分配
	2.如果该框架内需要分配交互，通过uhci_alloc_td申请td结构
	3.通过uhci_add_td_to_urb将td加入到urbp.list链表中
	4.通过uhci_fill_td填充td
		长度为urb-&gt;iso_frame_desc[i].length
		buffer为：urb-&gt;transfer_buffer + urb-&gt;iso_frame_desc[i].offset
	5.如果是最后一个td（i + 1 &gt;= urb-&gt;number_of_packets）：
		td-&gt;status |= TD_CTRL_IOC;
	6.通过uhci_insert_td_frame_list将td挂入到框架中
4.通过uhci_add_urb_list将urb挂入到uhci-&gt;urb_list中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2404</x>
      <y>701</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2376</x>
      <y>737</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>isochronous_find_start</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2383</x>
      <y>732</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2359</x>
      <y>744</y>
      <w>36</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.number_of_packets不能大于900
2.通过isochronous_find_limits查看是否有在框架内的urb
	的pipe和dev和此次交互相同，如果有，得到其结束的框架号
	并返回0；没有返回-1
3.如果要求尽快传输（transfer_flags &amp; USB_ISO_ASAP），
	如果2步返回-1，通过uhci_get_current_frame_number得到正在运行的框架号：
	urb-&gt;start_frame = (curframe + 10) % UHCI_NUMFRAMES;
	如果2步返回0：
	urb-&gt;start_frame = end
4.如果不要求尽快传输
	urb-&gt;start_frame %= UHCI_NUMFRAMES
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2376</x>
      <y>740</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2368</x>
      <y>766</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>isochronous_find_limits</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2357</x>
      <y>773</y>
      <w>35</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.遍历uhci-&gt;urb_list链表，看其中有没有和现在要操作的传输
	相同的dev，pipe，并处于EINPROGRESS（不是当前操作的传输）
	start记录第一个u-&gt;start_frame
	last_urb记录最后一个传输
2.如果有相同的urb
	*end = (last_urb-&gt;start_frame + last_urb-&gt;number_of_packets) &amp; 1023;
	ret = 0;
	否则
	ret = -1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2375</x>
      <y>762</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2374</x>
      <y>769</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2409</x>
      <y>737</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_insert_td_frame_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2401</x>
      <y>732</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2407</x>
      <y>740</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
加入到物理链表中</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2398</x>
      <y>744</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //td为链表头，所以frameptr有值
td-&gt;frameptr = &amp;uhci-&gt;fl-&gt;frame[framenum];
td-&gt;link = uhci-&gt;fl-&gt;frame[framenum];
uhci-&gt;fl-&gt;frame[framenum] = virt_to_bus(td)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2413</x>
      <y>740</y>
      <w>26</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果当前td不是该链表中的最后一个td
（不是term，或者没链接到qh）</panel_attributes>
    <additional_attributes>50.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2427</x>
      <y>743</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //获取下一个td的虚拟地址
nexttd = (struct uhci_td *)uhci_ptr_to_virt(td-&gt;link);
 //虚拟链表连接
td-&gt;nexttd = nexttd;
nexttd-&gt;prevtd = td;
 //链表头已经发生转变，所以赋值为NULL
nexttd-&gt;frameptr = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2061</x>
      <y>673</y>
      <w>47</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.如果是中断传输（PIPE_INTERRUPT）
	uhci-&gt;rh.urb = urb;
	uhci-&gt;rh.send = 1;
	uhci-&gt;rh.interval = urb-&gt;interval;
	rh_init_int_timer(urb)
	return 0
2.因为根集中器是和controller在一起，不需要通过总线usb总线访问，
	可以直接通过io地址读写相应的状态和数据.
	通过解析cmd（urb-&gt;setup_packet），数据存放在urb-&gt;transfer_buffer中，
	数据的预期长度是urb-&gt;transfer_buffer_length
3.处理完urb之后，更新actual_length,并执行urb-&gt;complete
	urb-&gt;actual_length = len;
	urb-&gt;status = stat;
	if (urb-&gt;complete)
		urb-&gt;complete(urb);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2092</x>
      <y>671</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2050</x>
      <y>679</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2044</x>
      <y>681</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rh_init_int_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2023</x>
      <y>687</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.赋值usb polling的间隔
	uhci-&gt;rh.interval = urb-&gt;interval
2.赋值timer，并添加：
	init_timer(&amp;uhci-&gt;rh.rh_int_timer);
	uhci-&gt;rh.rh_int_timer.function = rh_int_timer_do;
	uhci-&gt;rh.rh_int_timer.data = (unsigned long)urb;
	uhci-&gt;rh.rh_int_timer.expires = jiffies + (HZ * (urb-&gt;interval &lt; 30 ? 30 : urb-&gt;interval)) / 1000;
	add_timer(&amp;uhci-&gt;rh.rh_int_timer)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2043</x>
      <y>684</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1977</x>
      <y>696</y>
      <w>52</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>500.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1972</x>
      <y>700</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rh_int_timer_do</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1948</x>
      <y>707</y>
      <w>41</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.通过rh_send_irq获取port中USBPORTSC1寄存器的状态
	存储到urb-&gt;transfer_buffer中，并：
	urb-&gt;actual_length = len;
	urb-&gt;status = USB_ST_NOERROR;
	返回0
2.遍历uhci-&gt;urb_list中的urb
	1.如果urb要求做空闲时间回收（fsbr），但是却长期没得到执行
	（jiffies&lt;urbp-&gt;inserttime + IDLE_TIMEOUT）,通过
	uhci_fsbr_timeout断开其回收机制
	2.如果urb设置了timeout时间（u-&gt;timeout），并且已经timeout（jiffies&lt;u-&gt;timeout）
	将urb.transfer_flags的USB_ASYNC_UNLINK | USB_TIMEOUT_KILLED置上
	并且通过uhci_unlink_urb将urb的交互队列从框架中移除
3.	通过rh_init_int_timer重新将timer添加
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1974</x>
      <y>703</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1946</x>
      <y>732</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_fsbr_timeout</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1952</x>
      <y>729</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1939</x>
      <y>739</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过uhci_dec_fsbr将总线回收断开
2.urbp-&gt;fsbr_timeout = 1
3.遍历urbp-&gt;list中的td，将第一个TD_CTRL_ACTIVE
	的td中的TD_CTRL_IOC置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1948</x>
      <y>735</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2919</x>
      <y>387</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>amd7930_init/
init_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2919</x>
      <y>396</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>amd7930_attach</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2924</x>
      <y>390</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2915</x>
      <y>405</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_sparcaudio_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2924</x>
      <y>399</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
amd7930向上层模块sparcaudio注册
sparcaudio在sparcaudio_init中向内核注册
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2918</x>
      <y>413</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2923</x>
      <y>408</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2864</x>
      <y>423</y>
      <w>59</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.节点名name不能为NULL
2.如果传递的ops为NULL,
	1.如果是S_ISBLK，返回blkdevs[major].bdops（并打印消息）
	2.如果是其他设备，返回NULL，打印错误
3.如果是S_ISDIR，返回NULL
4.S_ISLNK，返回NULL
5.如果是S_ISCHR，并且要求自动分配设备号，next_devnum_char不能大于MAX_DEVNUM
	如果不大于：
	major = next_devnum_char &gt;&gt; 8;
	minor = next_devnum_char &amp; 0xff;
	++next_devnum_char;
6.如果是S_ISBLK，并且要求自动分配设备号，next_devnum_block不能大于MAX_DEVNUM
	如果不大于：
	major = next_devnum_block &gt;&gt; 8;
	minor = next_devnum_block &amp; 0xff;
	++next_devnum_block;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2891</x>
      <y>416</y>
      <w>34</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2927</x>
      <y>424</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>search_for_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2916</x>
      <y>416</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在devfs中找name，如果没找到就创建</panel_attributes>
    <additional_attributes>80.0;10.0;170.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2923</x>
      <y>416</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不是新创建的
!is_new</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2944</x>
      <y>424</y>
      <w>34</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.一定要是S_ISCHR  S_ISBLK  S_ISREG其中一个
2.de-&gt;registered不能为true
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2979</x>
      <y>423</y>
      <w>54</w>
      <h>52</h>
    </coordinates>
    <panel_attributes>1.de-&gt;registered = TRUE;
2.如果是S_ISCHR或者S_ISBLK
	de-&gt;u.fcb.u.device.major = major;
	de-&gt;u.fcb.u.device.minor = minor;
	如果是S_ISREG
	de-&gt;u.fcb.u.file.size = 0
3.如果是其他设备，返回NULL
4.de-&gt;info = info;
  de-&gt;mode = mode;
5.如果是指定current为owner（DEVFS_FL_CURRENT_OWNER）
	de-&gt;u.fcb.default_uid = current-&gt;uid;
	de-&gt;u.fcb.default_gid = current-&gt;gid;
	否则：
	de-&gt;u.fcb.default_uid = 0;
	de-&gt;u.fcb.default_gid = 0;
6. 
 //之前不是设置registered了吗？
	 de-&gt;registered = TRUE;
	 //设置ops
	 de-&gt;u.fcb.ops = ops;
 	de-&gt;u.fcb.auto_owner = (flags &amp; DEVFS_FL_AUTO_OWNER) ? TRUE : FALSE;
 	de-&gt;u.fcb.aopen_notify = (flags &amp; DEVFS_FL_AOPEN_NOTIFY) ? TRUE : FALSE;
7.DEVFS_FL_REMOVABLE：
	de-&gt;u.fcb.removable = TRUE;
	++de-&gt;parent-&gt;u.dir.num_removable;
8.
	de-&gt;u.fcb.open = FALSE;
    de-&gt;show_unreg = ( (boot_options &amp; OPTION_SHOW)
			|| (flags &amp; DEVFS_FL_SHOW_UNREG) ) ? TRUE : FALSE;
    de-&gt;hide = (flags &amp; DEVFS_FL_HIDE) ? TRUE : FALSE;
    de-&gt;no_persistence = (flags &amp; DEVFS_FL_NO_PERSISTENCE) ? TRUE : FALSE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2924</x>
      <y>416</y>
      <w>83</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;810.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3038</x>
      <y>423</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfsd_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2924</x>
      <y>416</y>
      <w>123</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1210.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2850</x>
      <y>530</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_select</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2839</x>
      <y>533</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取用户层的tvp</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2825</x>
      <y>541</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过verify_area验证tvp的VERIFY_READ权限
	然后通过__get_user获取用户层的tv_sec和tv_usec
2.filter:tv_sec和tv_usec不能小于0
3.将tvp的时间转化成hz（timeout）
注：ROUND_UP是如果超出了bound，就按bound算
	1s=1hz=(1000000/hz)us
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2858</x>
      <y>539</y>
      <w>39</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.n不能小于0（n表示位图的个数）
2.当n超过进程的max_fdset时：
	n = current-&gt;files-&gt;max_fdset
3.通过FDS_BYTES计算n需要size的空间（几个long型大小）
4.通过select_bits_alloc申请6个size长度的
	这6个空间分别用于
	//要求监测的输入，输出，异常
	fds.in      = (unsigned long *)  bits;
	fds.out     = (unsigned long *) (bits +   size);
	fds.ex      = (unsigned long *) (bits + 2*size);
	//因为唤醒的输入，输出，异常
	fds.res_in  = (unsigned long *) (bits + 3*size);
	fds.res_out = (unsigned long *) (bits + 4*size);
	fds.res_ex  = (unsigned long *) (bits + 5*size);
5.通过get_fd_set将要求监测的输入（inp），输出（outp）
	，异常（exp）复制到内核空间，并通过zero_fd_set将其清0
6.通过do_select对要求的文件进行监测，并等待监测结果
7.如果tvp存在，并且进程的personality STICKY_TIMEOUTS标记
	置上，timeout剩余事件转化为us，s，并将其通过put_user
	放在用户空间中
8.检查是否有错（ret&lt;0）,是否有signal_pending，直接返回
9.将fds.res_in，res_out，res_ex中的数据通过set_fd_set
	放到用户空间
10.通过select_bits_free将申请的6个size长度的bits释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2857</x>
      <y>533</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2846</x>
      <y>573</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_fd_set</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2850</x>
      <y>567</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2837</x>
      <y>579</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过FDS_BYTES获取位图的实际字节数
2.通过verify_area验证写权限
注：虽然这里是读，但是之后需要对齐进行写，
	所以这里直接验证写权限
3.通过__copy_from_user从用户层将数据复制到内核空间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2851</x>
      <y>576</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2885</x>
      <y>573</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_select
主要是申请多个wait结构（poll_table）
其他一个wait一样，都是挂在相应inode的等待队列中</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2873</x>
      <y>567</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2873</x>
      <y>580</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>max_select_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2878</x>
      <y>576</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
files-&gt;file_lock</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2865</x>
      <y>586</y>
      <w>26</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.首先获取不足long长度的mask
	set =~(~0UL &lt;&lt; (n &amp; (__NFDBITS-1)))
2.如果mask存在，获取其关心的mask
	set &amp;= BITS(fds, n);
注：BITS表示in，out，ex中关心的fd
3.如果set存在，且其关心的fd都没有关闭（!(set &amp; ~*open_fds)）
	直接去计算max
4.如果关心的fd有关的，返回EBADF
5.然后按照long去遍历低字节
	1.在这个long中存在关心的fd（set不为0）
	2.所有关心的fd都没有关闭（set &amp; ~*open_fds），否则返回EBADF
	3.如果max得到了，continue（这里去5.2检查传入数据的有效性）
6.返回max
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2877</x>
      <y>583</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从高bit向低遍历</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2893</x>
      <y>580</y>
      <w>16</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //初始化table
poll_initwait(&amp;table);
 //如果timeout存在
wait = &amp;table;
 //如果timeout为0
wait = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2890</x>
      <y>576</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2890</x>
      <y>576</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2910</x>
      <y>580</y>
      <w>42</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.将task的状态设置为TASK_INTERRUPTIBLE
2.遍历要关注的最大fd，
	1.通过bit &amp; BITS(fds, off)，检查这个fd是否关心
	2.如果改fd是其关心的，通过fget得到file：
		mask = file-&gt;f_op-&gt;poll(file, wait)
		fput(file)
	3.检查mask中POLLIN_SET，POLLOUT_SET,POLLEX_SET是否
		置上，如果置上通过ISSET检查是否关心，如果关心
		//x是__RES_IN，__RES_OUT，__RES_EX
		SET(bit, x(fds,off));
		retval++;
		wait = NULL;
3.将所有关注的fd遍历完之后，如果有关注的fd事件发生（retval）
	不需要休眠（!__timeout）或者有signal_pending，跳出死循环
4.检查table.error，如果有错，跳出死循环
5.__timeout = schedule_timeout(__timeout)
	当其因为事件发生，或者因为timeout而醒来时，因为是死循环，所以
	从1再次开始检测
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2916</x>
      <y>621</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_poll</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2916</x>
      <y>614</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;poll
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2921</x>
      <y>609</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2921</x>
      <y>617</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
read_pipe_fops</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2901</x>
      <y>614</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_poll</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2906</x>
      <y>609</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2899</x>
      <y>620</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>pt-&gt;error = 0;
pt-&gt;table = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2905</x>
      <y>617</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2904</x>
      <y>628</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>poll_wait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2908</x>
      <y>624</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
&amp;inode.i_pipe-&gt;wait</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2908</x>
      <y>631</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果poll_table和wait_queue_head_t
都存在</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2903</x>
      <y>635</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__pollwait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2875</x>
      <y>638</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果poll_table中table不存在
或者table中entry满了
（(table-&gt;entry+1) &gt; PAGE_SIZE + table）
注：table-&gt;entry指向空闲的entry，table-&gt;entry+1
	指的是空闲entry填满之后的地址</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2864</x>
      <y>644</y>
      <w>27</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.通过__get_free_page获取poll_table_page
	（new_table），并初始化
	//空闲的entry，指向第一个
	new_table-&gt;entry = new_table-&gt;entries;
	//table头插至链表中
	new_table-&gt;next = table;
	p-&gt;table = new_table;
	table = new_table;
	注：这里这个管理结构在page中，之后就全是数组entries了
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2902</x>
      <y>643</y>
      <w>32</w>
      <h>19</h>
    </coordinates>
    <panel_attributes> //获取空闲的entry
entry = table-&gt;entry;
table-&gt;entry = entry+1;
 //初始化entry
get_file(filp);
entry-&gt;filp = filp;
entry-&gt;wait_address = wait_address;
init_waitqueue_entry(&amp;entry-&gt;wait, current);//初始化wait
 //将wait插入到等待队列中
add_wait_queue(wait_address,&amp;entry-&gt;wait);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2900</x>
      <y>638</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取空闲的entry放到inode的等待队列中</panel_attributes>
    <additional_attributes>80.0;10.0;180.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2921</x>
      <y>624</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
先遍历一遍
查看是否有使进程醒着的原因</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2939</x>
      <y>630</y>
      <w>25</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.mask = POLLIN | POLLRDNORM;
1.PIPE_EMPTY（inode.i_size==0）：
	mask = POLLOUT | POLLWRNORM;
2.!(inode).i_pipe-&gt;writers
	&amp;&amp; filp-&gt;f_version !=(inode).i_pipe-&gt;w_counter
	mask |= POLLHUP;
3.! (!PIPE_READERS(*inode))
		mask |= POLLERR;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2956</x>
      <y>581</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;state = TASK_RUNNING
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2891</x>
      <y>576</y>
      <w>74</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
跳出之前，因为在死循环第一步将其状态设置为TASK_INTERRUPTIBLE</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2985</x>
      <y>581</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>poll_freewait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2892</x>
      <y>576</y>
      <w>99</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;970.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2972</x>
      <y>587</y>
      <w>36</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.遍历p-&gt;table链表
2.得到空闲的entry（p-&gt;entry）
3.然后通过do..while释放p-&gt;entries
	中的所有entry：
	entry--;
	remove_wait_queue(entry-&gt;wait_address,&amp;entry-&gt;wait);
	fput(entry-&gt;filp);
4.然后在遍历下一个table：
	old = p;
	p = p-&gt;next;
	free_page((unsigned long) old);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2989</x>
      <y>584</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3065</x>
      <y>544</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.打开文件
2.设置号SIGIO的信号响应
2.将文件与本进程（要通知的进程）关联（fcntl）
3.iocntl为file添加通知本进程的fasync
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3058</x>
      <y>559</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_fcntl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3041</x>
      <y>566</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3061</x>
      <y>567</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_fcntl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3083</x>
      <y>567</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3047</x>
      <y>562</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过fd获取file</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3065</x>
      <y>562</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放file</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3064</x>
      <y>562</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3060</x>
      <y>570</y>
      <w>10</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
F_SETOWN
设置f_owner</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3043</x>
      <y>577</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_owner.pid = arg;
filp-&gt;f_owner.uid = current-&gt;uid;
filp-&gt;f_owner.euid = current-&gt;euid;
注：inode是对磁盘的抽象
	dentry是对路径的抽象（路径+inode）
	file是对进程的抽象（进程+dentry）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3073</x>
      <y>578</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_fcntl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3067</x>
      <y>570</y>
      <w>14</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sock_fcntl</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3124</x>
      <y>559</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_mouse_event</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3132</x>
      <y>562</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
head != queue-&gt;tail
如果buffer没满</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3131</x>
      <y>566</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3126</x>
      <y>571</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kill_fasync</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3124</x>
      <y>577</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__kill_fasync</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3130</x>
      <y>574</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
&amp;queue-&gt;fasync, SIGIO, POLL_IN
fasync_lock</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3119</x>
      <y>584</y>
      <w>30</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.遍历链表，如果magic != FASYNC_MAGIC
	直接返回
2.获取file.f_owner
3.如果f_owner.pid不为0，并且不是在fown-&gt;signum == 0
	的时候发SIGURG
	通过send_sigio将信号发送
4.遍历链表的下一个
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3130</x>
      <y>580</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3129</x>
      <y>600</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>send_sigio</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3133</x>
      <y>596</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3119</x>
      <y>607</y>
      <w>30</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果pid&gt;0,通过find_task_by_pid在hash表中
	查找task，并通过send_sigio_to_task将信号发出去
2.如果pid=0（或者pid暂时没存储到hash中），遍历task链表，
	通过send_sigio_to_task发送信号
3.如果pid&lt;0，遍历task链表，查找进程组号和-pid相同的
	进程，并通过send_sigio_to_task对这些进程发送信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3133</x>
      <y>603</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tasklist_lock</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3127</x>
      <y>621</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>send_sigio_to_task</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3134</x>
      <y>617</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3069</x>
      <y>585</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.socki_lookup通过inode找到sock
2.如果sock存在，且其ops存在，调用sock_no_fcntl
3.否则返回EINVAL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3078</x>
      <y>581</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3075</x>
      <y>594</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_no_fcntl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3081</x>
      <y>591</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3067</x>
      <y>600</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.根据sock获取sk
2.如果是F_SETOWN：
	1.要满足当前进程组是-arg，或者当前进程是arg，或者当前进程有CAP_KILL权限这三个条件之一
	2.sk-&gt;proc = arg
 如果是F_GETOWN，返回sk-&gt;proc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3080</x>
      <y>597</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1680</x>
      <y>37</y>
      <w>66</w>
      <h>67</h>
    </coordinates>
    <panel_attributes>dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1532</x>
      <y>37</y>
      <w>58</w>
      <h>66</h>
    </coordinates>
    <panel_attributes>VFS
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1608</x>
      <y>37</y>
      <w>48</w>
      <h>67</h>
    </coordinates>
    <panel_attributes>file_system
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1611</x>
      <y>41</y>
      <w>40</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>do_initcalls
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1613</x>
      <y>44</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>module_init(init_ext2_fs)
(FS_REQUIRES_DEV)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1625</x>
      <y>47</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1614</x>
      <y>57</y>
      <w>35</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>module_init(init_proc_fs)
(FS_SINGLE)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1624</x>
      <y>59</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1624</x>
      <y>64</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kern_mount
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1611</x>
      <y>81</y>
      <w>40</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>filesystem_setup
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1613</x>
      <y>84</y>
      <w>35</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>init_devfs_fs
(FS_SINGLE)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1625</x>
      <y>86</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1625</x>
      <y>91</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kern_mount
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1564</x>
      <y>57</y>
      <w>49</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sys_mount</panel_attributes>
    <additional_attributes>10.0;20.0;470.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1564</x>
      <y>89</y>
      <w>49</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
do_mount
在/dev上安装devfs</panel_attributes>
    <additional_attributes>10.0;20.0;470.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1499</x>
      <y>54</y>
      <w>14</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>用户
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1500</x>
      <y>84</y>
      <w>14</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>内核
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1696</x>
      <y>45</y>
      <w>38</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>(FS_REQUIRES_DEV)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1689</x>
      <y>67</y>
      <w>50</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>(FS_SINGLE)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1707</x>
      <y>51</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>实际存在的块设备
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1636</x>
      <y>65</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_fs_type</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1637</x>
      <y>72</y>
      <w>30</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_fs_type</panel_attributes>
    <additional_attributes>10.0;210.0;280.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1664</x>
      <y>71</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建设备</panel_attributes>
    <additional_attributes>10.0;20.0;250.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1553</x>
      <y>89</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mount_devfs_fs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1513</x>
      <y>89</y>
      <w>42</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1552</x>
      <y>57</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_call
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1512</x>
      <y>58</y>
      <w>42</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1692</x>
      <y>74</y>
      <w>44</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>dev: MKDEV(UNNAMED_MAJOR, i)
sb:	get_empty_super和属性初始化
root:	type-&gt;read_super 
		proc通过proc_root新建inode和dentry，并赋值
		devfs通过root_entry新建inode和dentry，并赋值
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1616</x>
      <y>5</y>
      <w>30</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1631</x>
      <y>31</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
type-&gt;read_super </panel_attributes>
    <additional_attributes>10.0;60.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1625</x>
      <y>12</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>super
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1625</x>
      <y>20</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>root:inode
		dentry
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1564</x>
      <y>19</y>
      <w>54</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;180.0;520.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1645</x>
      <y>17</y>
      <w>68</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
procfs的read/write能转接到虚拟设备对应的read/write，所以设备驱动可以在proc中不需要有主次设备号
</panel_attributes>
    <additional_attributes>10.0;10.0;660.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1794</x>
      <y>16</y>
      <w>73</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>ext2.i_fop
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1803</x>
      <y>23</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>S_ISCHR：def_chr_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1803</x>
      <y>31</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>S_ISBLK：def_blk_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1803</x>
      <y>39</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>S_ISFIFO：def_fifo_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1803</x>
      <y>47</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>S_ISSOCK：bad_sock_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1839</x>
      <y>23</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>chrdevs[major].fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1827</x>
      <y>23</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filp-&gt;f_op替换为</panel_attributes>
    <additional_attributes>10.0;20.0;120.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1793</x>
      <y>63</y>
      <w>74</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>procfs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1802</x>
      <y>70</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>S_ISREG：proc_file_operations
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1826</x>
      <y>69</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_file_read</panel_attributes>
    <additional_attributes>10.0;30.0;130.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1826</x>
      <y>71</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_file_write</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1839</x>
      <y>68</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_proc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1839</x>
      <y>73</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>write_proc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1815</x>
      <y>73</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
可以自定义</panel_attributes>
    <additional_attributes>10.0;80.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1810</x>
      <y>81</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1792</x>
      <y>105</y>
      <w>77</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>System
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1803</x>
      <y>118</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1830</x>
      <y>128</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>def_blk_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1820</x>
      <y>121</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISBLK</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1820</x>
      <y>113</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISCHR</panel_attributes>
    <additional_attributes>10.0;50.0;160.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1848</x>
      <y>107</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de-&gt;u.fcb.ops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1835</x>
      <y>109</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
de-&gt;u.fcb.ops存在</panel_attributes>
    <additional_attributes>10.0;50.0;130.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1848</x>
      <y>115</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>chrdevs[major].fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1834</x>
      <y>113</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不存在</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1574</x>
      <y>964</y>
      <w>51</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops/inet_dgram_ops
2.6.20</panel_attributes>
    <additional_attributes>10.0;20.0;490.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1617</x>
      <y>967</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1608</x>
      <y>973</y>
      <w>30</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过ip_mc_drop_socket将多播列表删除
2.如果sk的SOCK_LINGER设置，并且进程的
	PF_EXITING没置上，设置timeout时间为
	sk_lingertime
3.sock-&gt;sk = NULL
4.sk-&gt;sk_prot-&gt;close关闭sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1621</x>
      <y>970</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1618</x>
      <y>988</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;close
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1625</x>
      <y>983</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1625</x>
      <y>991</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1619</x>
      <y>995</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_close</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1617</x>
      <y>1002</y>
      <w>33</w>
      <h>65</h>
    </coordinates>
    <panel_attributes>1.sk-&gt;shutdown = SHUTDOWN_MASK
2.如果sk的状态是TCP_LISTEN
	1.通过tcp_set_state将sk的状态设置为TCP_CLOSE
	2.通过tcp_listen_stop终止监听
	3.跳到adjudge_to_death
3.释放队列receive_queue中的所有skb，并统计没被
	读取的数据data_was_unread，最后通过sk_stream_mem_reclaim
	进行内存的回收
4.根据状态决定close的动作
	1.如果有数据没被读取data_was_unread
		tcp_set_state(sk, TCP_CLOSE);
		tcp_send_active_reset(sk, GFP_KERNEL);
	2.如果有SOCK_LINGER，但是sk_lingertime为0
		sk-&gt;sk_prot-&gt;disconnect
	3.如果tcp_close_state检查到要发fin，通过
		tcp_send_fin发送fin
5.通过sk_stream_wait_close等待fin的ack
6.adjudge_to_death：
	1.sock_orphan(sk);
		atomic_inc(sk-&gt;sk_prot-&gt;orphan_count);
	2.如果sk的状态在lock时从其他状态变为TCP_CLOSE
		跳到out，通过sock_put释放sk
	3.如果sk的状态是TCP_FIN_WAIT2
		1.如果linger2小于0，直接给peer发送rst
			tcp_set_state(sk, TCP_CLOSE);
			tcp_send_active_reset(sk, GFP_ATOMIC);
		2.如果设置了linger2
			1.通过tcp_fin_time获取close的最长等待时间
			注：最小为4rto-1/2rto
			2.如果超过了1min，通过inet_csk_reset_keepalive_timer
				修改sk_timer为timeout-1min
			3.否则通过tcp_time_wait等待timeout时间到close，最后
				跳到out，释放sk
	4.如果sk状态没到close
		1.通过sk_stream_mem_reclaim释放sk内存
		2.如果orphan_count超过限制，或者内存超过限制
			tcp_set_state(sk, TCP_CLOSE);
			tcp_send_active_reset(sk, GFP_ATOMIC);
	5.如果sk是close，通过inet_csk_destroy_sock释放sk的所有关系
	6.sock_put释放sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1625</x>
      <y>998</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1623</x>
      <y>1071</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_listen_stop</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1618</x>
      <y>1078</y>
      <w>30</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.通过tcp_delete_keepalive_timer停止timer
2.取出监听队列tp-&gt;listen_opt，并释放
3.取出接收队列accept_queue，并释放(链接建立完成，但是没accept)
4.遍历监听队列的hash表syn_table(部分链接)，通过tcp_openreq_free
	将open_req释放，最后通过kfree释放掉监听队列
5.遍历接收队列
	1.通过sk-&gt;sk_prot-&gt;disconnect将req中的sk断开连接
	2.通过sock_orphan设置sk的状态SOCK_DEAD
	3.递增sk-&gt;sk_prot-&gt;orphan_count
	4.通过inet_csk_destroy_sock断开sk和其他对象的链接
	5.通过sk_acceptq_removed递减sk_ack_backlog
	6.通过__reqsk_free释放req
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1618</x>
      <y>1098</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_delete_keepalive_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1627</x>
      <y>1095</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1618</x>
      <y>1104</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过timer_pending查看timer是否被设置
2.如果被设置通过del_timer将timer移除
3.移除后，通过__sock_put递减sk的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1624</x>
      <y>1101</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1649</x>
      <y>1098</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_orphan</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1644</x>
      <y>1095</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1646</x>
      <y>1104</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>sock_set_flag(sk, SOCK_DEAD);
	sk-&gt;sk_socket = NULL;
	sk-&gt;sk_sleep  = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1652</x>
      <y>1101</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1629</x>
      <y>1074</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1658</x>
      <y>1071</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_stream_wait_close</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1652</x>
      <y>1078</y>
      <w>27</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果需要设置睡眠时间
	1.通过DEFINE_WAIT定义wait
	2.循环等待事件
		1.通过prepare_to_wait将wait加入到sk_sleep
		并将task设置为TASK_INTERRUPTIBLE
		2.通过sk_wait_event睡眠等待sk_stream_closing
		注：sk_stream_closing中的三个状态都是在等待对方的ack
		3.知道等到signal_pending或者timeout耗尽
	3.通过finish_wait设置taskTASK_RUNNING
		并且将wait脱链
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1665</x>
      <y>1074</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1628</x>
      <y>1066</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1639</x>
      <y>1066</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>731</x>
      <y>569</y>
      <w>388</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bfs_fs_type
</panel_attributes>
    <additional_attributes>10.0;20.0;3860.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1111</x>
      <y>572</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bfs_read_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>767</x>
      <y>595</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>748</x>
      <y>599</y>
      <w>41</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.根据主次设备号设置blksize_size
2.sync_buffers等待所有的dirty bh同步，lock bh解锁
3.遍历所有的lru_list
	1.对应类型的链表要存在
	2.设备要相同，size不同时才会处理
	3.如果被locked，通过wait_on_buffer等待解锁
	4.如果bh.b_count为0，
		1.buffer_dirty时，警告
		2.remove_inode_queue将bh从inode的i_dirty_buffers中移出
		3.__remove_from_queues将bh从对应的lru中移除
		4.put_last_free将bh放到free_list中
	5.如果还有引用
		1.通过atomic_set_buffer_clean将bh的BH_Dirty清掉
		2.如果之前是BH_Dirty，通过__refile_buffer调整bh在lru中的位置
		3.通过clear_bit将BH_Uptodate清掉
	6.如果之前遍历，有bh locked，重新循环
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>743</x>
      <y>630</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>731</x>
      <y>637</y>
      <w>34</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.遍历lru_list[BUF_DIRTY]
	1.要遍历两遍
	2.bh.dev的设备要相同
	3.如果bh被locked
		1.如果wait为0，不做处理
		2.如果wait为1，第一次pass不做处理
		3.如果需要处理，通过wait_on_buffer等待bh解锁
			解锁之后重新遍历
	4.如果解锁的bh没有uptodate，返回EIO，并不做处理
	5.如果bh没有dirty，或者pass过2次，不做处理
	6.通过ll_rw_block提交写请求
	7.重复遍历dirty lru
2.遍历lru_list[BUF_LOCKED]
	1.如果没有locked，直接退出同步
	2.要遍历两遍
	3.bh.dev的设备要相同
	4.如果bh被locked
		1.如果wait为0，不做处理
		2.如果wait为1，第一次pass不做处理
		3.如果需要处理，通过wait_on_buffer等待bh解锁
			解锁之后重新遍历
3.retry表示之前有被pending的lock，需要重新遍历
	pass表示除了pending的没有dirty和lock的，不能超过两次
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>749</x>
      <y>633</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>775</x>
      <y>631</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_inode_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>781</x>
      <y>634</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>770</x>
      <y>638</y>
      <w>34</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.如果bh.inode有指定
	1.通过__remove_inode_queue将其从其链表中删除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>776</x>
      <y>645</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__remove_inode_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>783</x>
      <y>641</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>768</x>
      <y>652</y>
      <w>30</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.bh-&gt;b_inode = NULL
2.将b_inode_buffers从i_dirty_buffers中脱链
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>783</x>
      <y>648</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>813</x>
      <y>630</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__remove_from_queues</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>807</x>
      <y>637</y>
      <w>39</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.通过__hash_unlink将bh从hash表中删除(b_next,b_pprev)
2.__remove_from_lru_list从lru链表中删除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>823</x>
      <y>633</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>818</x>
      <y>644</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__remove_from_lru_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>826</x>
      <y>640</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>807</x>
      <y>651</y>
      <w>33</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.脱离环形链表
	bh-&gt;b_prev_free-&gt;b_next_free = bh-&gt;b_next_free;
	bh-&gt;b_next_free-&gt;b_prev_free = bh-&gt;b_prev_free;
2.lru链表指向下一个
	lru_list[blist] = bh-&gt;b_next_free;
	nr_buffers_type[blist]--;
	size_buffers_type[blist] -= bh-&gt;b_size;
3.bh-&gt;b_next_free = bh-&gt;b_prev_free = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>827</x>
      <y>647</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>855</x>
      <y>629</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_last_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>848</x>
      <y>636</y>
      <w>27</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.释放bh
	bh-&gt;b_state = 0
	bh-&gt;b_dev = B_FREE
2.链入到free_list
	*bhp = bh;
	bh-&gt;b_prev_free = bh;
	和环形链表
	bh-&gt;b_next_free = *bhp;
	bh-&gt;b_prev_free = (*bhp)-&gt;b_prev_free;
	(*bhp)-&gt;b_prev_free-&gt;b_next_free = bh;
	(*bhp)-&gt;b_prev_free = bh;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>861</x>
      <y>632</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>748</x>
      <y>625</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>767</x>
      <y>625</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>775</x>
      <y>625</y>
      <w>45</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>777</x>
      <y>625</y>
      <w>83</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;810.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1105</x>
      <y>579</y>
      <w>34</w>
      <h>76</h>
    </coordinates>
    <panel_attributes>1.初始化block size
	dev = s-&gt;s_dev;
	set_blocksize(dev, BFS_BSIZE);
	s-&gt;s_blocksize = BFS_BSIZE;
	s-&gt;s_blocksize_bits = BFS_BSIZE_BITS;
2.通过bread获取第0个block
3.s_magic得是BFS_MAGIC
4.初始化sb
	s-&gt;s_magic = BFS_MAGIC;
	s-&gt;su_bfs_sb = bfs_sb;
	s-&gt;su_sbh = bh;
	//last inode num
	s-&gt;su_lasti = (bfs_sb-&gt;s_start - BFS_BSIZE)/sizeof(struct bfs_inode) 
			+ BFS_ROOT_INO - 1
	//申请inode位图
	s-&gt;su_imap = kmalloc(imap_len, GFP_KERNEL);
	memset(s-&gt;su_imap, 0, imap_len);
	for (i=0; i&lt;BFS_ROOT_INO; i++) 
		set_bit(i, s-&gt;su_imap);
	//操作方法
	s-&gt;s_op = &amp;bfs_sops;
	//block数量
	s-&gt;su_blocks = (bfs_sb-&gt;s_end + 1)&gt;&gt;BFS_BSIZE_BITS; /* for statfs(2) */
	//free block的数量（除去sb，inode）
	s-&gt;su_freeb = (bfs_sb-&gt;s_end + 1 - bfs_sb-&gt;s_start)&gt;&gt;BFS_BSIZE_BITS;
	s-&gt;su_freei = 0;
	s-&gt;su_lf_eblk = 0;
	s-&gt;su_lf_sblk = 0;
	s-&gt;su_lf_ioff = 0;
5.通过iget获取root_inode，并申请root
	s-&gt;s_root = d_alloc_root(inode)
6.通过iget获取所有的inode
	1.如果inode号为0
		s-&gt;su_freei++;
	2.如果inode被占用
		1.置位图
			set_bit(i, s-&gt;su_imap);
			s-&gt;su_freeb -= inode-&gt;i_blocks;
		2.sb记录最大的eblock
			s-&gt;su_lf_eblk = inode-&gt;iu_eblock;
			s-&gt;su_lf_sblk = inode-&gt;iu_sblock;
			//最大使用inode的偏移
			s-&gt;su_lf_ioff = BFS_INO2OFF(i);
7.如果不是read_only，因为更改了sb
	1.mark_buffer_dirty将sb的bh置上dirty
	2.s-&gt;s_dirt = 1
8.返回sb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1117</x>
      <y>575</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1093</x>
      <y>231</y>
      <w>198</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bfs_sops</panel_attributes>
    <additional_attributes>10.0;10.0;1960.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1283</x>
      <y>234</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bfs_read_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1269</x>
      <y>241</y>
      <w>40</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>1.inode号要在BFS_ROOT_INO~su_lasti
2.获取inode所在的block号，通过bread读取block
3.算出inode在block中的偏移
	off = (ino - BFS_ROOT_INO) % BFS_INODES_PER_BLOCK;
	di = (struct bfs_inode *)bh-&gt;b_data + off;
4.初始化inode
	1.inode-&gt;i_mode = 0x0000FFFF &amp; di-&gt;i_mode;
	2.如果是BFS_VDIR
		inode-&gt;i_mode |= S_IFDIR;
		inode-&gt;i_op = &amp;bfs_dir_inops;
		inode-&gt;i_fop = &amp;bfs_dir_operations;
	3.如果是BFS_VREG
		inode-&gt;i_mode |= S_IFREG;
		inode-&gt;i_op = &amp;bfs_file_inops;
		inode-&gt;i_fop = &amp;bfs_file_operations;
		inode-&gt;i_mapping-&gt;a_ops = &amp;bfs_aops;
	4.inode-&gt;i_uid = di-&gt;i_uid;
		inode-&gt;i_gid = di-&gt;i_gid;
		inode-&gt;i_nlink = di-&gt;i_nlink;
		inode-&gt;i_size = BFS_FILESIZE(di);
		inode-&gt;i_blocks = BFS_FILEBLOCKS(di);
		inode-&gt;i_blksize = PAGE_SIZE;
		inode-&gt;i_atime = di-&gt;i_atime;
		inode-&gt;i_mtime = di-&gt;i_mtime;
		inode-&gt;i_ctime = di-&gt;i_ctime;
		inode-&gt;iu_dsk_ino = di-&gt;i_ino;
		inode-&gt;iu_sblock = di-&gt;i_sblock;
		inode-&gt;iu_eblock = di-&gt;i_eblock;
5.brelse释放bh
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1289</x>
      <y>237</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1099</x>
      <y>120</y>
      <w>196</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bfs_read_inode
bfs_dir_inops</panel_attributes>
    <additional_attributes>10.0;10.0;1940.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1286</x>
      <y>134</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bfs_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1273</x>
      <y>141</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.名字长度不能超过BFS_NAMELEN
2.bfs_find_entry寻找dir所在的inode num
3.如果找到了inode，通过iget获取inode
4.d_add将inode和dentry关联
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1291</x>
      <y>137</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1281</x>
      <y>152</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bfs_find_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1270</x>
      <y>159</y>
      <w>44</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.文件的名字长度不能超过BFS_NAMELEN
2.从iu_sblock开始读取block
	1.如果之前没读取过block，通过bread读取，如果没获取到bh，遍历下一个block
	2.遍历该block中所有的bfs_dirent(长度是BFS_DIRENT_SIZE)
		通过bfs_namecmp对比name，如果相同即返回
			*res_dir = de;
			return bh;
	3.如果block没遍历完，继续遍历下一个bfs_dirent
	4.否则，遍历下一个block
		brelse(bh);
		bh = NULL;
		offset = 0;
		block++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1286</x>
      <y>155</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1286</x>
      <y>148</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
</diagram>
