<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram program="umlet" version="14.3.0">
  <zoom_level>1</zoom_level>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1644</x>
      <y>81</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_kernel
bg=red</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1265</x>
      <y>52</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>startup_32</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1044</x>
      <y>67</y>
      <w>22</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>ds=es=fs=gs=__KERNEL_DS

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1056</x>
      <y>55</y>
      <w>216</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置相应的数据段</panel_attributes>
    <additional_attributes>2140.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1069</x>
      <y>66</y>
      <w>45</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>	movl $pg0-__PAGE_OFFSET,%edi /* initialize page tables */
	movl $007,%eax		/* "007" doesn't mean with right to kill, but
				   PRESENT+RW+USER */
2:	stosl					//将eax加载到edi对应的地址中，因为前面有cld，所以edi自增4
	add $0x1000,%eax
	cmp $empty_zero_page-__PAGE_OFFSET,%edi
	jne 2b
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1085</x>
      <y>55</y>
      <w>187</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化PT</panel_attributes>
    <additional_attributes>1850.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1116</x>
      <y>68</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>	movl $swapper_pg_dir-__PAGE_OFFSET,%eax
	movl %eax,%cr3		/* set the page table pointer.. */
	movl %cr0,%eax
	orl $0x80000000,%eax
	movl %eax,%cr0		/* ..and set paging (PG) bit */
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1129</x>
      <y>55</y>
      <w>143</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化PGD</panel_attributes>
    <additional_attributes>1410.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1155</x>
      <y>55</y>
      <w>117</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化栈</panel_attributes>
    <additional_attributes>1150.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1153</x>
      <y>69</y>
      <w>14</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lss stack_start,%esp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1170</x>
      <y>69</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>	xorl %eax,%eax
	movl $ SYMBOL_NAME(__bss_start),%edi
	movl $ SYMBOL_NAME(_end),%ecx
	subl %edi,%ecx
	rep
	stosb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1184</x>
      <y>55</y>
      <w>88</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
clear bss</panel_attributes>
    <additional_attributes>860.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1209</x>
      <y>71</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>call setup_idt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1212</x>
      <y>55</y>
      <w>60</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化idt（中断描述表）</panel_attributes>
    <additional_attributes>580.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1210</x>
      <y>78</y>
      <w>11</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>IDT

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1210</x>
      <y>78</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ignore_int(高16)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1210</x>
      <y>82</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>8E00
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1210</x>
      <y>86</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>KERNEL_CS
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1210</x>
      <y>90</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ignore_int(低16)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1214</x>
      <y>73</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1142</x>
      <y>80</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>ENTRY(stack_start)
.long SYMBOL_NAME(init_task_union)+8192
.long __KERNEL_DS
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1157</x>
      <y>71</y>
      <w>5</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1260</x>
      <y>45</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arch/i386/kernel/head.S
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1270</x>
      <y>48</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1145</x>
      <y>85</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arch/i386/kernel/init_task.c</panel_attributes>
    <additional_attributes>120.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1142</x>
      <y>92</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>union task_union init_task_union 
	__attribute__((__section__(".data.init_task"))) =
		{ INIT_TASK(init_task_union.task) };
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>98</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
include/linux/sched.h</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1144</x>
      <y>105</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>#define INIT_TASK(tsk)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1152</x>
      <y>108</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
include/asm-i386/processor.h</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1144</x>
      <y>115</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>#define INIT_THREAD
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1220</x>
      <y>71</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arch/i386/kernel/trap.c</panel_attributes>
    <additional_attributes>10.0;20.0;170.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1237</x>
      <y>71</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>struct desc_struct idt_table[256] 
__attribute__((__section__(".data.idt"))) = { {0, 0}, };
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1270</x>
      <y>55</y>
      <w>39</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制参数到empty_zero_page开始的2K的块
复制命令行到empty_zero_page+2K开始的2K的块

参数位置引用定义在：arch/i386/kernel/setup.c</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1275</x>
      <y>71</y>
      <w>45</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>	movl $ SYMBOL_NAME(empty_zero_page),%edi
	movl $512,%ecx
	cld
	rep
	movsl			//将esi的内容复制到edi指向的地址中，esi和edi自增4（cld）
	xorl %eax,%eax
	movl $512,%ecx
	rep
	stosl
	movl SYMBOL_NAME(empty_zero_page)+NEW_CL_POINTER,%esi
	andl %esi,%esi
	jnz 2f			# New command line protocol
	cmpw $(OLD_CL_MAGIC),OLD_CL_MAGIC_ADDR
	jne 1f
	movzwl OLD_CL_OFFSET,%esi
	addl $(OLD_CL_BASE_ADDR),%esi
2:
	movl $ SYMBOL_NAME(empty_zero_page)+2048,%edi
	movl $512,%ecx
	rep
	movsl
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1328</x>
      <y>73</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>checkCPUtype
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1270</x>
      <y>55</y>
      <w>64</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检测cpu的类型</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1346</x>
      <y>74</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lgdt gdt_descr
lidt idt_descr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1271</x>
      <y>55</y>
      <w>82</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
加载gdt和IDT</panel_attributes>
    <additional_attributes>10.0;10.0;800.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1270</x>
      <y>55</y>
      <w>102</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1000.0;170.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1369</x>
      <y>71</y>
      <w>283</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
主cpu
init/main.c</panel_attributes>
    <additional_attributes>10.0;10.0;2810.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1369</x>
      <y>71</y>
      <w>1898</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
次cpu

arch/i386/kernel/smpboot.c</panel_attributes>
    <additional_attributes>10.0;10.0;18960.0;270.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3260</x>
      <y>98</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>initialize_secondary</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3256</x>
      <y>106</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>"movl %0,%%esp\n\t"
"jmp *%1"
:
:"r" (current-&gt;thread.esp),"r" (current-&gt;thread.eip));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3266</x>
      <y>101</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1408</x>
      <y>99</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_arch</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1414</x>
      <y>84</y>
      <w>236</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arch/i386/kernel/setup.c</panel_attributes>
    <additional_attributes>2340.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1142</x>
      <y>150</y>
      <w>35</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>ROOT_DEV = to_kdev_t(ORIG_ROOT_DEV);
drive_info = DRIVE_INFO;
screen_info = SCREEN_INFO;
apm_info.bios = APM_BIOS_INFO;
if( SYS_DESC_TABLE.length != 0 ) {
MCA_bus = SYS_DESC_TABLE.table[3] &amp;0x2;
machine_id = SYS_DESC_TABLE.table[0];
machine_submodel_id = SYS_DESC_TABLE.table[1];
BIOS_revision = SYS_DESC_TABLE.table[2];
}
aux_device_present = AUX_DEVICE_INFO;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1155</x>
      <y>102</y>
      <w>262</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据boot中的参数
设置相应的全局变量</panel_attributes>
    <additional_attributes>2600.0;10.0;10.0;480.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1182</x>
      <y>146</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_memory_region</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1188</x>
      <y>102</y>
      <w>229</w>
      <h>46</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2270.0;10.0;10.0;440.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1178</x>
      <y>153</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_e820_map</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1184</x>
      <y>149</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1177</x>
      <y>161</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_memory_region</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1183</x>
      <y>156</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果申明了A0000
到100000的内存区域，则忽略</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1177</x>
      <y>169</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>e820.map[x].addr = start;
e820.map[x].size = size;
e820.map[x].type = type;
e820.nr_map++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1183</x>
      <y>164</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1204</x>
      <y>102</y>
      <w>213</w>
      <h>47</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2110.0;10.0;10.0;450.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1202</x>
      <y>147</y>
      <w>30</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>	init_mm.start_code = (unsigned long) &amp;_text;
	init_mm.end_code = (unsigned long) &amp;_etext;
	init_mm.end_data = (unsigned long) &amp;_edata;
	init_mm.brk = (unsigned long) &amp;_end;

	code_resource.start = virt_to_bus(&amp;_text);
	code_resource.end = virt_to_bus(&amp;_etext)-1;
	data_resource.start = virt_to_bus(&amp;_etext);
	data_resource.end = virt_to_bus(&amp;_edata)-1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1234</x>
      <y>149</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>parse_mem_cmdline</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1239</x>
      <y>102</y>
      <w>178</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1760.0;10.0;10.0;470.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1252</x>
      <y>149</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_pfn = PFN_UP(__pa(&amp;_end));
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1257</x>
      <y>102</y>
      <w>160</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
计算首个参与内存分配的页面号</panel_attributes>
    <additional_attributes>1580.0;10.0;10.0;470.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1279</x>
      <y>149</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>max_pfn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1282</x>
      <y>102</y>
      <w>135</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历整个e820
找到最大的页号max_pfn
整个内存的最大页面</panel_attributes>
    <additional_attributes>1330.0;10.0;10.0;470.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1293</x>
      <y>148</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>max_low_pfn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1299</x>
      <y>102</y>
      <w>118</w>
      <h>48</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
系统内存的最大页面</panel_attributes>
    <additional_attributes>1160.0;10.0;10.0;460.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1305</x>
      <y>142</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_bootmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1305</x>
      <y>149</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_bootmem_core</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1309</x>
      <y>102</y>
      <w>109</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将start_pfn到max_low_pfn保留</panel_attributes>
    <additional_attributes>1070.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1311</x>
      <y>145</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1289</x>
      <y>156</y>
      <w>47</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>bdata-&gt;node_bootmem_map = phys_to_virt(_end &lt;&lt; PAGE_SHIFT);
bdata-&gt;node_boot_start = (0 &lt;&lt; PAGE_SHIFT);
bdata-&gt;node_low_pfn = max_low_pfn;
memset(bdata-&gt;node_bootmem_map, 0xff, mapsize)（位图）
注：node_boot_start表示内存的初始位置，即0
node_bootmem_map：从内核结束的位置开始，从这里开始存储系统内存
						的分配位图这里的位图显示的是系统内存的页面分布情况，1表示占用
						在free_bootmem中会没被占用的页面置为0
node_low_pfn：系统内存最大页面号（不包含最尾端的128M）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1311</x>
      <y>152</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1320</x>
      <y>141</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_bootmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1324</x>
      <y>102</y>
      <w>93</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将0~max_low_pfn所有type为E820_RAM
的区域释放</panel_attributes>
    <additional_attributes>910.0;10.0;10.0;390.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1322</x>
      <y>149</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>test_and_clear_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1325</x>
      <y>144</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1340</x>
      <y>140</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reserve_bootmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1344</x>
      <y>102</y>
      <w>73</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里将内核区域和系统页面映射位图
还有最开始的一个页面
置为已用</panel_attributes>
    <additional_attributes>710.0;10.0;10.0;380.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1345</x>
      <y>143</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1340</x>
      <y>149</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>test_and_set_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1396</x>
      <y>138</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>paging_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1401</x>
      <y>102</y>
      <w>56</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arch/i386/mm/init.c
将访问0xC0000000-0xCFFFFFFF时，访问的是0x00000000-0x3FFFFFFF</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;360.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1372</x>
      <y>146</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pagetable_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1378</x>
      <y>141</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
虚拟内存的制作只到了max_low_pfn
后128MB的虚拟内存留给vmlist</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1341</x>
      <y>156</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_bootmem_low_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1349</x>
      <y>149</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为pte申请页面</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1369</x>
      <y>157</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_pmd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1373</x>
      <y>149</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
对于32位寻址，pgd和pmd相同</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1340</x>
      <y>162</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__alloc_bootmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1347</x>
      <y>159</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1339</x>
      <y>171</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__alloc_bootmem_core</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1346</x>
      <y>165</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1342</x>
      <y>174</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1360</x>
      <y>164</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>*pmd=_KERNPG_TABLE + __pa(pte)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1373</x>
      <y>160</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1436</x>
      <y>23</y>
      <w>83</w>
      <h>45</h>
    </coordinates>
    <panel_attributes>#define __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))  //将内核实际地址转换成虚拟地址
#define PAGE_MASK	(~(PAGE_SIZE-1))  //对page取整
#define pmd_page(pmd) \
((unsigned long) __va(pmd_val(pmd) &amp; PAGE_MASK)) //pmd所在页面的起始虚拟地址
#define __pte_offset(address) \
		((address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1))  //虚拟地址在页表中的偏移
#define pmd_offset(dir, address) ((pmd_t *) pgd_page(*(dir)) + \
			__pmd_offset(address))					//将address中页表部分提取出来，在*dir指向页表中的偏移


typedef struct { unsigned long pgprot; } pgprot_t;

#define pmd_val(x)	((x).pmd)
#define pgd_val(x)	((x).pgd)
#define pgprot_val(x)	((x).pgprot)

#define __pte(x) ((pte_t) { (x) } )
#define __pmd(x) ((pmd_t) { (x) } )
#define __pgd(x) ((pgd_t) { (x) } )
#define __pgprot(x)	((pgprot_t) { (x) } )
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1376</x>
      <y>149</y>
      <w>29</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将实际的物理地址写入pte中</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1390</x>
      <y>166</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>*pte = mk_pte_phys(__pa(vaddr), PAGE_KERNEL)
注：PAGE_KERNEL中没有_PAGE_USER，表示cpl
	是3的时候，mmu访问时会出现页错误
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1460</x>
      <y>157</y>
      <w>41</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__asm__( "movl %%ecx,%%cr3\n" ::"c"(__pa(swapper_pg_dir)));
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1399</x>
      <y>141</y>
      <w>81</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将内存中的页面映射重新装入高速缓存中</panel_attributes>
    <additional_attributes>10.0;10.0;790.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1829</x>
      <y>47</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__alloc_bootmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1826</x>
      <y>56</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__alloc_bootmem_core
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1835</x>
      <y>50</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历pgdat_list</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1324</x>
      <y>178</y>
      <w>70</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.检查需要申请的size，和需要对齐的字节，看是否满足要求
2.preferred，对align对齐，要申请的内存要比goal高，也就是要申请的起始idx
	areasize对page对齐，表示要处理几个页面
	incr：遍历的过程中，需要对align对齐
3.从preferred开始找到node_bootmem_map位图中为0的idx，然后从idx开始向后看
	是否在要申请的页面的范围内有页面被占用，如果被占用且不是从0开始查找的，就从0开始
	重新查找，如果是从0开始查找的，就返回NULL.（这里应该是为了不让内存成为一个个小碎片。
	如果有内存在想要申请的大块内存的中间，可能就需要等待）
	如果连续的areasize的页面没被占用，就申请到了，记录最开始的页面为start
4.如果align没有到一页对齐，并且要申请的页面和之前申请的页面紧挨着，并且那个页面还有内存没被使用
	，就从前一个还没申请完的页面开始，其中得更新areasize：需要新占用的页面，bdata-&gt;last_pos：
	更新最后一个申请的页面，bdata-&gt;last_offset：在上述页面中的偏移。ret：内存开始的虚拟地址
5.如果页面4的情况不满足，就直接申请过areasize个页面
6.在node_bootmem_map位图中置上相应的位，并且将申请的内存清0.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1851</x>
      <y>101</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_all_bootmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1849</x>
      <y>109</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_all_bootmem_core</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1858</x>
      <y>104</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
contig_page_data</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1838</x>
      <y>119</y>
      <w>41</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.查看node_bootmem_map中没被占用的页面，将这些页面
	Reserved标记清除，将couter置1，并释放页面，这里所占据
	的初始页面存储在pgdat-&gt;node_mem_map中
2.将node_bootmem_map所占据的页面释放，并将Reserved
	标记清除，count置1，并释放页面
3.bdata-&gt;node_bootmem_map = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1858</x>
      <y>112</y>
      <w>3</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1505</x>
      <y>159</y>
      <w>44</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>if (low &lt; max_dma)
	zones_size[ZONE_DMA] = low; //low是16M对应的页面
else {
	zones_size[ZONE_DMA] = max_dma;//max_low_pfn对应的页面
	zones_size[ZONE_NORMAL] = low - max_dma;
	zones_size[ZONE_HIGHMEM] = high - low;//highend_pfn对应的页面
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1400</x>
      <y>141</y>
      <w>119</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1170.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1579</x>
      <y>156</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_area_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1400</x>
      <y>141</y>
      <w>184</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1820.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1574</x>
      <y>163</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_area_init_core</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1583</x>
      <y>159</y>
      <w>38</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
0, &amp;contig_page_data, &amp;mem_map, zones_size, 0, 0, 0</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1553</x>
      <y>170</y>
      <w>64</w>
      <h>71</h>
    </coordinates>
    <panel_attributes>1.算出传入zones总共有totalpages页面
2.初始化链表active_list inactive_list
3.通过alloc_bootmem_node申请系统内存（查找的起始点从16MB开始）
	申请的大小为（totalpages+1）个page的大小
	得到的起始地址对page取整，并将起始地址赋给mem_map，
	contig_page_data.node_mem_map//节点页在mem_map中的起始位置
	pgdat-&gt;node_size = totalpages;
	pgdat-&gt;node_start_paddr = 0;
	pgdat-&gt;node_start_mapnr = 0;//节点相对于mem_map的偏移
	pgdat-&gt;nr_zones = 0;
4.初始化page结构
	set_page_count(p, 0);
	SetPageReserved(p)
	p.wait.lock=WAITQUEUE_RW_LOCK_UNLOCKED
	INIT_LIST_HEAD(p.wait.task_list)
	INIT_LIST_HEAD(p.list) //free_area 链接的链表
5.初始化节点的zone
pgdat-&gt;node_zones[j].size = zones_size[j];
pgdat-&gt;node_zones[j].name = zone_names[j]; //DMA/normal/highmem
pgdat-&gt;node_zones[j].lock = SPIN_LOCK_UNLOCKED;
pgdat-&gt;node_zones[j].zone_pgdat = pgdat;
pgdat-&gt;node_zones[j].free_pages = 0;
pgdat-&gt;node_zones[j].need_balance = 0;
pgdat-&gt;nr_zones = j+1
mask = (realsize / zone_balance_ratio[j]);
if (mask &lt; zone_balance_min[j])
	mask = zone_balance_min[j];
else if (mask &gt; zone_balance_max[j])
	mask = zone_balance_max[j];
zone-&gt;pages_min = mask;  //设置water_mark
zone-&gt;pages_low = mask*2;
zone-&gt;pages_high = mask*3;
zone-&gt;zone_mem_map = mem_map + offset; //该节点所有区域的偏移是一样的
zone-&gt;zone_start_mapnr = offset;
zone-&gt;zone_start_paddr = 0;
6.记录page所在的zone（page-&gt;zone），和page的虚拟地址（page-&gt;virtual）
7.初始化链表zone-&gt;free_area[i].free_list
	zone-&gt;free_area[MAX_ORDER-1].map = NULL
8.初始化伙伴算法中的标志位map
	bitmap_size = (size-1) &gt;&gt; (i+4); //i+4=i+1+3,+1的原因是和伙伴共用一个位，+3的原因是一个字节有8位
												//这里可以看到所有的page在所有的order中都有映射，只不过这个page可能在其他块当中
	bitmap_size = LONG_ALIGN(bitmap_size+1);//对字节取整
	zone-&gt;free_area[i].map = 
	  (unsigned long *) alloc_bootmem_node(pgdat, bitmap_size);//获取map的内存空间，并将所有的位置0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1580</x>
      <y>166</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1619</x>
      <y>170</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>build_zonelists</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1585</x>
      <y>166</y>
      <w>40</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1618</x>
      <y>178</y>
      <w>46</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>gfp_mask中（__GFP_DMA置上时，不管__GFP_HIGHMEM）
__GFP_HIGHMEM：zonelist中会依次存储ZONE_HIGHMEM ZONE_NORMAL ZONE_DMA
没有__GFP_HIGHMEM和__GFP_DMA：zonelist中会依次存储ZONE_NORMAL ZONE_DMA
__GFP_DMA：zonelist中只会存储ZONE_DMA
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1623</x>
      <y>173</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注意没有break</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1400</x>
      <y>159</y>
      <w>39</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__fix_to_virt(__end_of_fixed_addresses - 1) &amp; PMD_MASK
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1376</x>
      <y>149</y>
      <w>40</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取fix_adress最低位的
22~32位</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1422</x>
      <y>155</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fixrange_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1377</x>
      <y>149</y>
      <w>53</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请pte，并填入pmd
但是并没有将页表填入pte</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1439</x>
      <y>155</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pkmap_page_table
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1377</x>
      <y>149</y>
      <w>69</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将从Fe000000开始的4MB的虚拟内存的pte赋给</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1650</x>
      <y>84</y>
      <w>209</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
linux/arch/i386/mm/init.c</panel_attributes>
    <additional_attributes>10.0;10.0;1740.0;90.0;2070.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1853</x>
      <y>93</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mem_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1857</x>
      <y>96</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从这开始bootmem就不再使用
而使用mem_map</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1807</x>
      <y>106</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>highmem_start_page = mem_map + highstart_pfn;
max_mapnr = num_physpages = highend_pfn;
high_memory = (void *) __va(max_low_pfn * PAGE_SIZE)
memset(empty_zero_page, 0, PAGE_SIZE);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1827</x>
      <y>96</y>
      <w>31</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1882</x>
      <y>100</y>
      <w>51</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>for (tmp = 0; tmp &lt; max_low_pfn; tmp++) //对于低896M,计算reservedpages
	if (page_is_ram(tmp) &amp;&amp; PageReserved(mem_map+tmp))
		reservedpages++;
//对于高于896M的区域
if (!page_is_ram(tmp)) {
		SetPageReserved(page);
		continue;
	}
	if (bad_ppro &amp;&amp; page_kills_ppro(tmp))
	{
		SetPageReserved(page);
		continue;
	}
	ClearPageReserved(page);
	set_bit(PG_highmem, &amp;page-&gt;flags);
	atomic_set(&amp;page-&gt;count, 1);
	__free_page(page);
	totalhigh_pages++;
}
totalram_pages += totalhigh_pages;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1857</x>
      <y>96</y>
      <w>50</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1766</x>
      <y>97</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_sizes_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1650</x>
      <y>84</y>
      <w>122</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1200.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1768</x>
      <y>108</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cs_cachep
cs_dmacachep
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1775</x>
      <y>100</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为cache_sizes中不同size的
通用缓冲区申请cache</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>833</x>
      <y>46</y>
      <w>102</w>
      <h>107</h>
    </coordinates>
    <panel_attributes>1.并发产生的问题
	1.原子性：因为中断导致一些共享资源的竞争，如果在并发程序中，只要一个线程有store操作，就可能产生资源的竞争
	2.顺序性：cpu在执行的时候，因为下一句指令和当前的指令没产生任何影响，所以在当前指令可能会miss，例如：
				peterson算法：
					T1								T2
				store(flag1,1)				store(flage2,1)
				store(turn,2)				store(turn,1)			//礼让，让对方先执行
				load(flag2)					load(flag1)
				load(turn)					load(turn)
			while(flag2&amp;&amp;turn==2);	while(flag1&amp;&amp;turn==1);   //如果不是自己执行就自旋
			因为对于T1而言，在读flag2之前无需对flag2进行操作，而store（flag1）需要在总线空闲的状态去操作，所以可能
			是先读的flag2，因为此时flag2还没置上，此时如果切换到T2，也有可能是乱序执行，先读的flag1，导致此时读的flag1和
			flag2都是0，所以T1和T2都可能进入临界区。
		这个是因为cpu为了使得单线程执行更加优化而设计的，但是在并发的时候，因为cpu的乱序执行，导致了两者同时进入临界区。
	3.可见性：在不同的核内，都存在store buffer，cpu在load和store的过程中，可能都没讲变量放在内存中，而是放在store buffer中
				这就导致如果core0对内存进行了写操作，其他core根本看不见，从而使不同的核在操作内存时并没有考虑到另一个核对内存的写
2.原子操作
	1.单个的汇编代码并不是一个原子操作，例如__asm__（addq $1,%0 :"m"(*addr)）,这条内联汇编指令会转换成说一次load，或者一次
		store或者本地的操作
	2.cpu提供的原子操作：
		1.cpu提供的原子操作指令 如x86 test_and_set，这个指令会使读和写操作会不做打断的完成
		2.x86提供的总线锁：例如上述指令，加上lock， __asm__（lock addq $1,%0 :"m"(*addr)）,但是这个lock会将总线锁住，使cpu没办法通过总线访问
		内存
		3.RISCV的架构提供了LR/SC的缓存锁，在LR的时候，会将变量对应的缓存加载，并对缓存做标记；当SC的时候，会检查是否有本cpu的标记，如果有，则将
		变量存入到缓存，并且将缓存上的所有cpu的标记全部清除，如果没有标记则会反应错误，程序需要while重新执行。
			但是这个缓存锁可能只对不同核之间有效（猜测），同一个核之间可能需要另外的方法实现临界区
	3.原子操作保证了内存操作的原子性；另外在原子操作前后cpu也不会乱序执行，保证了顺序性；在原子操作前后，会将缓存中的数据写入到内存中，保证了可见性
3.自旋锁
	1.通过原子操作，保证了cpu在不受打断的过程中完成检查锁和设置锁的过程，通过锁，保证了临界区内内存操作的安全性。
	2.但是liveness确得不到保障，因为在spinlock的过程中，其他线程都在自旋等待，如果在spinlock期间发生了中断，导致spinlock的时间过长（或者如果两个线程
		在同一个核上，即使从当前线程调度到另一个线程，那个线程也是自旋等待），导致线程自旋时间过长，影响cpu的性能，所以在操作系统中spinlock一般会在外面包
		一层禁止中断的代码：
		disableinterrupt（）//在禁止中断的时候，需要将eflag压进栈，是为了防止在spinlock中的因为一些其他锁的需求而禁止中断
		sinlock（）
		
		disableinterrupt（）//压eflag，此时应该是禁止中断
		sinlock（）

		un_sinlock()
		enableinterrupt()//虽然打开了中断，但是将eflag pop，所以此时中断还是关着的

		un_sinlock()
		enableinterrupt()//在开中断的时候将eflag pop
4.互斥锁
	互斥锁，是因为线程要长时间呆在临界区，另外自旋锁实现的时候需要关闭中断，但是有时线程释放锁，是在中断中进行的（例如文件的读写）
	所以同样通过原子操作将临界区锁住，但是当无法获得锁的时候，将task的状态设置成等待状态，从而将cpu的使用权交出去，保证cpu的性能

5.同步
	1.条件变量,用一个大锁保证条件和操作变量的原子性
		mutex_lock(&amp;mutex)
		while(!condition) sleep(quene,&amp;mutex)//在睡的时候解锁，在醒的时候上锁
		condition signal(quene)
		mutex_unlock(&amp;mutex)
	2.信号量
		注意每一个状态都要设置一个信号量（例如，队列里面满和空两个状态）
	3.主从结构：
		每个consumer想要消费时，需要向master申请；同样需要生产的时候也需要向master申请
	注：条件变量和主从结构的效率较低，但是代码较好实现；信号量则与他们相反

6.并发编程中注意的问题：
	1.死锁：1.主要是lock（A）..lock(A)，在同一个线程中获取锁（例如在中断中获取lock（A），导致线程的死锁）
			2.是lock（A） lock（B）,另一个线程lock（B） lock(A)，这个解决办法是按照顺序获取锁，例如两个线程都按照lock（A） lock(B)的线程获取锁
			3.同步造成的死锁，例如 A醒通知B醒 ，B醒通知A睡，A睡的时候通知B睡，B睡通知A醒
	2.原子违反：没对变量进行上锁
		顺序违反，没对线程进行同步
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1515</x>
      <y>98</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>trap_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1551</x>
      <y>98</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_IRQ</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1521</x>
      <y>84</y>
      <w>131</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
系统保留中断的 IDT</panel_attributes>
    <additional_attributes>1290.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1556</x>
      <y>84</y>
      <w>94</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
外设中断的IDT
</panel_attributes>
    <additional_attributes>920.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1495</x>
      <y>104</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>set_trap_gate(14,&amp;page_fault)
set_system_gate(0x80,&amp;system_call)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1504</x>
      <y>101</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1551</x>
      <y>106</y>
      <w>58</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>void (*interrupt[NR_IRQS])(void) 中断服务函数指针数组 名字结构为IRQ##x##y##_interrupt
BUILD_16_IRQS(0x0)  中断服务函数 BUILD_IRQ(x##y) 

"pushl $"#nr"-256
"jmp common_interrupt"
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1539</x>
      <y>103</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_ISA_irqs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1545</x>
      <y>101</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1554</x>
      <y>101</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1734</x>
      <y>105</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>softirq_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1650</x>
      <y>84</y>
      <w>91</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;890.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1726</x>
      <y>112</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tasklet_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1753</x>
      <y>112</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>open_softirq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1741</x>
      <y>108</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TASKLET_SOFTIRQ
HI_SOFTIRQ</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1731</x>
      <y>108</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bh_action</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1722</x>
      <y>118</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>t-&gt;func = func;
t-&gt;data = data;
t-&gt;state = 0;
atomic_set(&amp;t-&gt;count, 0);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1729</x>
      <y>115</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1751</x>
      <y>119</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>softirq_vec[nr].data = data
softirq_vec[nr].action = action
softirq_mask(i) |= (1&lt;&lt;nr)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1758</x>
      <y>115</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
softirq_vec
表示软中断通道</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1629</x>
      <y>99</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sched_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1634</x>
      <y>84</y>
      <w>19</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1619</x>
      <y>108</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_bh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1623</x>
      <y>102</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TIMER_BH
TQUEUE_BH
IMMEDIATE_BH</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1603</x>
      <y>116</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bh_base[nr] = routine
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1625</x>
      <y>116</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1609</x>
      <y>111</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1622</x>
      <y>111</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1670</x>
      <y>99</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>time_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1649</x>
      <y>84</y>
      <w>29</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1641</x>
      <y>106</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>xtime.tv_sec = get_cmos_time();
xtime.tv_usec = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1648</x>
      <y>102</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从cmos芯片获取时间
这个芯片由电池供电</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1666</x>
      <y>107</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cpu_has_tsc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1673</x>
      <y>102</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tsc是提供时钟的精度</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1685</x>
      <y>107</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_irq
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1673</x>
      <y>102</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
0，irq0</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1677</x>
      <y>114</y>
      <w>31</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>irq0因为SA_SHIRQ没置，所以由时钟中断独占
	因为SA_INTERRUPT置上，所以不允许被打断
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1691</x>
      <y>110</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>5205</x>
      <y>5667</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>Use case 1</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1650</x>
      <y>84</y>
      <w>574</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;5720.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2002</x>
      <y>91</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_root_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1973</x>
      <y>98</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_misc_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1979</x>
      <y>94</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1937</x>
      <y>109</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>simple_ones
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1942</x>
      <y>101</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化在/proc下生成的节点
name  read_proc</panel_attributes>
    <additional_attributes>380.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1964</x>
      <y>110</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_proc_read_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1970</x>
      <y>101</y>
      <w>14</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为数组simple_ones
创建节点</panel_attributes>
    <additional_attributes>100.0;10.0;20.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1883</x>
      <y>139</y>
      <w>33</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>如果parent不存在，则需要通过xlate_proc_name
在proc_root中查到相应的component
注：1.de-&gt;subdir表示其子节点
	其所有的子节点通过（de-&gt;next）
	链表连接
	2.strchr在找不到'/'的时候，返回NULL
	此时会将parent赋值。从这里可以知道，如果parent
	为NULL,创建的节点最后不能带'/'
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1900</x>
      <y>134</y>
      <w>46</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1931</x>
      <y>134</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1924</x>
      <y>141</y>
      <w>46</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.kmalloc申请proc_dir_entry和name的内存
2.将proc_dir_entry区域清空
3.将name复制到proc_dir_entry后面
4.赋值name属性
	ent-&gt;name = ((char *) ent) + sizeof(*ent);
	ent-&gt;namelen = len;
5.如果是dir，如果没有任何权限，添加读、执行权限给u/g/o
	ent-&gt;proc_fops = &amp;proc_dir_operations;
	ent-&gt;proc_iops = &amp;proc_dir_inode_operations;
	ent-&gt;nlink = 2;
	如果不是dir，如果类型没置（reg、dir等这种属性），添加S_IFREG属性
				如果权限没置，添加读属性给u/g/o
			 ent-&gt;nlink = 1
6.ent-&gt;mode = mode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2006</x>
      <y>138</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1944</x>
      <y>134</y>
      <w>70</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1988</x>
      <y>144</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>make_inode_number</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1976</x>
      <y>152</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过find_first_zero_bit在proc_alloc_map
	中查找空闲位
2.利用set_bit将proc_alloc_map找到的空闲位置上
3.返回PROC_DYNAMIC_FIRST + i
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1985</x>
      <y>147</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1993</x>
      <y>141</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2014</x>
      <y>149</y>
      <w>18</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //赋值找到的inode号
dp-&gt;low_ino = i;
 //连入到目录树
dp-&gt;next = dir-&gt;subdir;
dp-&gt;parent = dir;
dir-&gt;subdir = dp;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2013</x>
      <y>141</y>
      <w>7</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2036</x>
      <y>149</y>
      <w>30</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果是dir
	dp-&gt;proc_fops = &amp;proc_dir_operations;
	dp-&gt;proc_iops = &amp;proc_dir_inode_operations;
	dir-&gt;nlink++
2.如果是link
	dp-&gt;proc_iops = &amp;proc_link_inode_operations;
3.如果是reg
	dp-&gt;proc_fops = &amp;proc_file_operations
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2013</x>
      <y>141</y>
      <w>34</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1946</x>
      <y>119</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_proc_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1954</x>
      <y>113</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1943</x>
      <y>122</y>
      <w>12</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1965</x>
      <y>120</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes> //赋值simple_ones中定义的函数
res-&gt;read_proc=read_proc;
res-&gt;data=data;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1973</x>
      <y>113</y>
      <w>4</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1979</x>
      <y>101</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建reg读文件
</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1988</x>
      <y>104</y>
      <w>39</w>
      <h>31</h>
    </coordinates>
    <panel_attributes> //创建kmg节点
create_proc_entry("kmsg", S_IRUSR
entry-&gt;proc_fops = &amp;proc_kmsg_operations
 //创建kcore节点
create_proc_entry("kcore", S_IRUSR,
proc_root_kcore-&gt;proc_fops = &amp;proc_kcore_operations;
proc_root_kcore-&gt;size =
		(size_t)high_memory - PAGE_OFFSET + PAGE_SIZE
 //如果prof_shift存在，创建profile
create_proc_entry("profile", S_IWUSR | S_IRUGO
entry-&gt;proc_fops = &amp;proc_profile_operations;
entry-&gt;size = (1+prof_len) * sizeof(unsigned int);
 //定义了__powerpc__，创建ppc_htab
entry = create_proc_entry("ppc_htab", S_IRUGO|S_IWUSR
entry-&gt;proc_fops = &amp;ppc_htab_operations
	//创建slabinfo
create_proc_read_entry("slabinfo", S_IWUSR | S_IRUGO, NULL,
			       slabinfo_read_proc
entry-&gt;write_proc = slabinfo_write_proc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2008</x>
      <y>94</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2029</x>
      <y>100</y>
      <w>37</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>proc_net = proc_mkdir("net"
proc_mkdir("sysvipc"
proc_sys_root = proc_mkdir("sys"
proc_root_fs = proc_mkdir("fs"
proc_root_driver = proc_mkdir("driver"
proc_mkdir("openprom"
注：proc_mkdir和create_proc_entry类似，
	只不过是专用来创建dir。 mode也不在是参数，
	直接赋值ent-&gt;mode = S_IFDIR | S_IRUGO | S_IXUGO
	其他和create_proc_entry创建目录一样
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2077</x>
      <y>100</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_tty_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2007</x>
      <y>94</y>
      <w>77</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;750.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2069</x>
      <y>107</y>
      <w>41</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.创建tty目录
	proc_mkdir("tty"
2.在tty下创建ldisc和driver两个目录
	proc_tty_ldisc = proc_mkdir("tty/ldisc"
	proc_tty_driver = proc_mkdir("tty/driver"
3.在tty下创建两个reg文件，并赋值read_proc
	create_proc_read_entry("tty/ldiscs", 0, 0, tty_ldiscs_read_proc
	create_proc_read_entry("tty/drivers", 0, 0, tty_drivers_read_proc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2083</x>
      <y>103</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2128</x>
      <y>101</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_device_tree_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2008</x>
      <y>94</y>
      <w>129</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1270.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2114</x>
      <y>110</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_mkdir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2119</x>
      <y>104</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建device-tree目录</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2131</x>
      <y>111</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_path_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2134</x>
      <y>104</y>
      <w>6</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2150</x>
      <y>111</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_node</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2135</x>
      <y>104</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2155</x>
      <y>100</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_bus = proc_mkdir("bus"
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2008</x>
      <y>94</y>
      <w>158</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1560.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1654</x>
      <y>83</y>
      <w>1349</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;13470.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2995</x>
      <y>94</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kernel_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2996</x>
      <y>101</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3000</x>
      <y>97</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
第一个内核线程</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2989</x>
      <y>108</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_basic_setup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2994</x>
      <y>104</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2988</x>
      <y>111</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将所有静态编译的module_init的
函数指针链接到.initcall.init
moudule_init的申明在
linux/include/linux/init.h</panel_attributes>
    <additional_attributes>70.0;10.0;140.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2996</x>
      <y>118</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_initcalls</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2983</x>
      <y>121</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
__initcall_start应该是第一个函数指针的地址
但是在这里却被申明为函数指针（不清楚原因）
在3.4.2中被声明为函数指针的地址</panel_attributes>
    <additional_attributes>190.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2980</x>
      <y>127</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>do {
	(*call)();
	call++;
} while (call &lt; &amp;__initcall_end);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3006</x>
      <y>128</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_scheduled_tasks</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3001</x>
      <y>121</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2994</x>
      <y>111</y>
      <w>52</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3037</x>
      <y>115</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filesystem_setup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3029</x>
      <y>123</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_devfs_fs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3034</x>
      <y>118</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3020</x>
      <y>132</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3043</x>
      <y>133</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kern_mount
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3020</x>
      <y>126</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将filesystem放到file_systems
链表中</panel_attributes>
    <additional_attributes>140.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3032</x>
      <y>126</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将mnt放在type.kern_mnt中
然后用户通过sys_mount去安装
至根目录上</panel_attributes>
    <additional_attributes>20.0;10.0;180.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2994</x>
      <y>111</y>
      <w>186</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1840.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3172</x>
      <y>121</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mount_devfs_fs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3152</x>
      <y>130</y>
      <w>30</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>boot_options的OPTION_NOMOUNT不能置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3166</x>
      <y>124</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3184</x>
      <y>129</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3176</x>
      <y>124</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
安装devfs到/dev下</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3044</x>
      <y>140</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_super
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3049</x>
      <y>136</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3044</x>
      <y>147</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>type-&gt;read_super
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3050</x>
      <y>143</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_fs_type</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3044</x>
      <y>154</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_read_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3050</x>
      <y>150</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2985</x>
      <y>165</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_root_entry
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2991</x>
      <y>157</y>
      <w>62</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>600.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3004</x>
      <y>164</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>atomic_set (&amp;fs_info.devfsd_overrun_count, 0);
init_waitqueue_head (&amp;fs_info.devfsd_wait_queue);
init_waitqueue_head (&amp;fs_info.revalidate_wait_queue);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3020</x>
      <y>157</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3041</x>
      <y>162</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>fs_info.sb = sb;
sb-&gt;u.generic_sbp = &amp;fs_info;
sb-&gt;s_blocksize = 1024;
sb-&gt;s_blocksize_bits = 10;
sb-&gt;s_magic = DEVFS_SUPER_MAGIC;
sb-&gt;s_op = &amp;devfs_sops;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3050</x>
      <y>157</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3082</x>
      <y>164</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_vfs_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3050</x>
      <y>157</y>
      <w>39</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
root_inode</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3065</x>
      <y>174</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.如果de-&gt;inode.dentry存在，打印问题
	返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3073</x>
      <y>167</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3095</x>
      <y>174</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iget
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3088</x>
      <y>167</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
de-&gt;inode.ino</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3110</x>
      <y>174</y>
      <w>19</w>
      <h>3</h>
    </coordinates>
    <panel_attributes> de-&gt;inode.dentry = dentry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3089</x>
      <y>167</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3100</x>
      <y>177</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3095</x>
      <y>182</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_new_inode
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3100</x>
      <y>185</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3093</x>
      <y>188</y>
      <w>17</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;read_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3101</x>
      <y>190</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_sops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3096</x>
      <y>195</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_read_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3058</x>
      <y>203</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_devfs_entry_from_vfs_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3068</x>
      <y>198</y>
      <w>36</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3037</x>
      <y>211</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.inode不能为NULL
2.inode-&gt;i_ino不能小于FIRST_INODE
3.通过sb得到fs_info
	fs_info = inode-&gt;i_sb-&gt;u.generic_sbp
4.fs_info不能为NULL
5。i_ino不能大于num_inodes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3041</x>
      <y>206</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3066</x>
      <y>206</y>
      <w>18</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
参考create_entry
返回inode对应的设备存储</panel_attributes>
    <additional_attributes>30.0;10.0;140.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3067</x>
      <y>215</y>
      <w>31</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>fs_info-&gt;table[inode-&gt;i_ino - FIRST_INODE]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3093</x>
      <y>203</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_blocks = 0;
inode-&gt;i_blksize = 1024;
inode-&gt;i_op = &amp;devfs_iops;
inode-&gt;i_fop = &amp;devfs_fops;
inode-&gt;i_rdev = NODEV;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3101</x>
      <y>198</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3115</x>
      <y>203</y>
      <w>39</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>S_ISCHR：
	inode-&gt;i_rdev = MKDEV (de-&gt;u.fcb.u.device.major,
			       de-&gt;u.fcb.u.device.minor);
S_ISBLK：
	inode-&gt;i_rdev = MKDEV (de-&gt;u.fcb.u.device.major,
			       de-&gt;u.fcb.u.device.minor);
	inode-&gt;i_bdev = bdget (inode-&gt;i_rdev)
	如果i_bdev存在，但是bd_op不存在，并且de-&gt;u.fcb.ops存在
	inode-&gt;i_bdev-&gt;bd_op = de-&gt;u.fcb.ops
S_ISFIFO：
	inode-&gt;i_fop = &amp;def_fifo_fops
S_ISREG：
	inode-&gt;i_size = de-&gt;u.fcb.u.file.size
S_ISDIR：
	inode-&gt;i_op = &amp;devfs_dir_iops
S_ISLNK：
	inode-&gt;i_op = &amp;devfs_symlink_iops;
	inode-&gt;i_size = de-&gt;u.symlink.length
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3102</x>
      <y>198</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3159</x>
      <y>203</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_mode = de-&gt;inode.mode;
inode-&gt;i_uid = de-&gt;inode.uid;
inode-&gt;i_gid = de-&gt;inode.gid;
inode-&gt;i_atime = de-&gt;inode.atime;
inode-&gt;i_mtime = de-&gt;inode.mtime;
inode-&gt;i_ctime = de-&gt;inode.ctime;
inode-&gt;i_nlink = de-&gt;inode.nlink;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3102</x>
      <y>198</y>
      <w>66</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;640.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3113</x>
      <y>163</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_root = d_alloc_root (root_inode)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3050</x>
      <y>157</y>
      <w>75</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;730.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2596</x>
      <y>113</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2599</x>
      <y>110</y>
      <w>398</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>3960.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2458</x>
      <y>141</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_init
1.获取宿主-pci桥的类型，确定操作函数
2.通过pci_scan_bus建立bus树， bus和设备之间的关系（pci_do_scan_bus）
	初始化设备的irq和resource（pci_setup_device），初始化bridge的资源（pci_read_bridge_bases）
	最后通过pci_scan_bridge递归的建立所有桥上的bus树和dev（包含irq和resource）
3.找到固件配置的设备中断数据，找到路径连接器的操作函数pirq_router
	最后通过pcibios_lookup_irq将BIOS建立的中断请求，设置dev.irq,并向procfs注册
4.将pci桥和设备的资源注册或者申请（conflict，通过pcibios_assign_resources）到资源树中</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2462</x>
      <y>116</y>
      <w>140</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>1380.0;10.0;10.0;250.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2249</x>
      <y>160</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_find_bios</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2252</x>
      <y>144</y>
      <w>212</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CONFIG_PCI_BIOS
pci_probe &amp; PCI_PROBE_BIOS</panel_attributes>
    <additional_attributes>2100.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2304</x>
      <y>162</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_check_direct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2312</x>
      <y>144</y>
      <w>152</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CONFIG_PCI_DIRECT
PCI_PROBE_CONF1 | PCI_PROBE_CONF2</panel_attributes>
    <additional_attributes>1500.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2276</x>
      <y>171</y>
      <w>40</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.检查pci 1型和2型设备（2型此后不再用，这里只是为了兼容）
2.1型设备检测：
	1.向CFB写1（即CF8(4字节)的最高位）
	2.将CF8（4字节）读出来存储
	3.再向CF8写0x80000000
	4.如果CF8读出来是0x80000000，并且pci_sanity_check通过
	就将之前存储的CF8恢复，并通过request_region
	最后返回pci_direct_conf1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2301</x>
      <y>165</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2274</x>
      <y>189</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_sanity_check</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2280</x>
      <y>185</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pci_direct_conf1</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2256</x>
      <y>197</y>
      <w>41</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.将dev初始化，
	dev.bus(bus.number初始化为0)
	dev.devfn（逻辑设备号）递增
2.遍历bus0上的256个设备，读取设备的PCI_CLASS_DEVICE
	是BRIDGE_HOST或者DISPLAY_VGA
	或者读取设备的PCI_VENDOR_ID是INTEL或者COMPAQ
	表示是一个pci总线
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2277</x>
      <y>192</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2300</x>
      <y>189</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_region</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2292</x>
      <y>185</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2299</x>
      <y>196</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__request_region</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2305</x>
      <y>192</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ioport_resource，0xCF8，8，"PCI conf1"</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2300</x>
      <y>206</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2304</x>
      <y>199</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请resource内存</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2314</x>
      <y>204</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>res-&gt;name = name;
res-&gt;start = start;（CF8）
res-&gt;end = start + n - 1;(CFF)
res-&gt;flags = IORESOURCE_BUSY;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2304</x>
      <y>199</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2305</x>
      <y>199</y>
      <w>48</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;460.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2344</x>
      <y>202</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2339</x>
      <y>206</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__request_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2316</x>
      <y>216</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //new本身存在问题
1.new的end&lt;start
 //new不在root范围内
2.new的start小于root的start
3.new的end大于root的end
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2324</x>
      <y>209</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
下面三种情况不能再root下申请resource
所以在__request_region中会将new释放</panel_attributes>
    <additional_attributes>200.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2338</x>
      <y>216</y>
      <w>42</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.遍历root的子树root-&gt;child
2.如果子树中遍历到了最后（!temp）或者new在temp的前面
	将new插入到子树的链表中
		new-&gt;sibling = tmp;
		*p = new;
		new-&gt;parent = root;
		return NULL;
3.如果temp.end&gt;new，表示temp的区域和new有重合
	return temp
4.如果上述条件均不满足（temp.end&lt;new）,遍历链表的下一个
	重复过程2~4
注：child：表示当前resource的子链表头
	sibling：同级的resource通这个链表链接在一起
	parent:指向当前resource的父资源（子资源空间在父资源空间之内）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2343</x>
      <y>209</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2380</x>
      <y>210</y>
      <w>35</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果conflict为NULL,则new能正确的链入
	到parent的child链表中
2.如果conflict是parent，则new存在问题，
	直接释放new
3.如果confict不是parent，并且conflict.flags
	的IORESOURCE_BUSY没置上，就以conflict为parent
	重新通过__request_resource来查看new释放在conflict
	的子链表中有重叠
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2350</x>
      <y>202</y>
      <w>43</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2322</x>
      <y>162</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_root_ops = dir
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2328</x>
      <y>144</y>
      <w>136</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1340.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2396</x>
      <y>156</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_scan_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2401</x>
      <y>144</y>
      <w>63</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>610.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2332</x>
      <y>169</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_alloc_primary_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2339</x>
      <y>159</y>
      <w>64</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2325</x>
      <y>175</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_bus_exists</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2330</x>
      <y>172</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查bus是否存在
pci_root_buses</panel_attributes>
    <additional_attributes>90.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2317</x>
      <y>181</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.遍历node链表（同级链表）
2.如果发现bus.number=nr，
	或者在该bus的children中
	发现nr的bus（利用pci_bus_exists递归）
	就找到编号为nr的bus
3.如果遍历完整个pci的bus树，没找到nr的
	bus，说明目前并不存在该bus
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2328</x>
      <y>178</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2337</x>
      <y>172</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没找到相应编号的bus</panel_attributes>
    <additional_attributes>40.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2349</x>
      <y>175</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2344</x>
      <y>180</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_alloc_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2345</x>
      <y>188</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2348</x>
      <y>183</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请bus的内存空间</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2365</x>
      <y>188</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>memset(b, 0, sizeof(*b));
INIT_LIST_HEAD(&amp;b-&gt;children);
INIT_LIST_HEAD(&amp;b-&gt;devices);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2349</x>
      <y>183</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化bus</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2366</x>
      <y>179</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_add_tail
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2349</x>
      <y>175</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将bus.node链接到
pci_root_buses的尾端</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2382</x>
      <y>178</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>b-&gt;number = b-&gt;secondary = bus;
b-&gt;resource[0] = &amp;ioport_resource;
b-&gt;resource[1] = &amp;iomem_resource;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2348</x>
      <y>175</y>
      <w>40</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化primary_bus</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2427</x>
      <y>168</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>b-&gt;sysdata = sysdata;
b-&gt;ops = ops;
 //pci桥子设备中的最大总线号
b-&gt;subordinate = pci_do_scan_bus(b);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2400</x>
      <y>159</y>
      <w>41</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;390.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2437</x>
      <y>178</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_do_scan_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2442</x>
      <y>174</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2388</x>
      <y>187</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>memset(&amp;dev0, 0, sizeof(dev0));
dev0.bus = bus;
dev0.sysdata = bus-&gt;sysdata;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2397</x>
      <y>181</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化dev0</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2418</x>
      <y>186</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_scan_slot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2424</x>
      <y>181</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将dev0.devfn设置为0~0x100
每次扫描8个设备</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2423</x>
      <y>189</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历8个功能设备</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2417</x>
      <y>192</y>
      <w>59</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.先将0号设备的header读进来（pci_read_config_byte）
	temp-&gt;hdr_type = hdr_type &amp; 0x7f
2.在通过pci_scan_device检测pci总线上否存在该设备
	并对其属性根据配置赋值
3.如果设备存在，通过pci_name_device对dev的name属性赋值
4.如果是0号设备，就检测header中的最高位是否为1，如果是0，表示是
	单功能设备（整个接口卡提供一个功能），之后的7个逻辑设备就不用遍历了
	is_multi = hdr_type &amp; 0x80;
	first_dev = dev;
	...
	if (func &amp;&amp; !is_multi)		/* not a multi-function device */
			continue;
5.将设备的global_list链入到pci_devices链表中
	将设备的bus_list链入到bus的devices中
6.通过pci_fixup_device使得当dev的ventor或者device满足pcibios_fixups
	和pci_fixups中的相应条件时，通过其hook函数做出相应的修改(这里PCI_FIXUP_HEADER
	表示将头部信息读出之后就进行修改，PCI_FIXUP_FINAL表示设置了总线地址之后进行修改)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2420</x>
      <y>222</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_scan_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2426</x>
      <y>219</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2384</x>
      <y>232</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_config_dword</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2391</x>
      <y>225</y>
      <w>37</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这个函数通过 pci_##rw##_config_##size定义
这里是调用bus.ops从PCI_VENDOR_ID读取32字节
头16字节是vendor，后16字节是device</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2401</x>
      <y>233</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.读出的ventor和device
	不能是0或者（~0），
	否则返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2407</x>
      <y>225</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2419</x>
      <y>241</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2423</x>
      <y>225</y>
      <w>12</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请dev内存</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2429</x>
      <y>240</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>memcpy(dev, temp, sizeof(*dev));
dev-&gt;vendor = l &amp; 0xffff;
dev-&gt;device = (l &gt;&gt; 16) &amp; 0xffff;
dev-&gt;dma_mask = 0xffffffff
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2425</x>
      <y>225</y>
      <w>17</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置dev</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2454</x>
      <y>242</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_setup_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2425</x>
      <y>225</y>
      <w>38</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2404</x>
      <y>252</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.dev-&gt;slot_name  bus_number:slot:func
	dev-&gt;name		PCI device vendor:device
2.dev-&gt;class被赋值为PCI_CLASS_REVISION初始地址的
	4字节的高3个字节
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2429</x>
      <y>245</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2459</x>
      <y>245</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dev-&gt;hdr_type</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2458</x>
      <y>249</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
NORMAL
class不能为BRIDGE</panel_attributes>
    <additional_attributes>100.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2446</x>
      <y>254</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2442</x>
      <y>259</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2456</x>
      <y>260</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_bases</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2460</x>
      <y>254</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
resource
ram：6，rom：PCI_ROM_ADDRESS</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2469</x>
      <y>259</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>分别从PCI_SUBSYSTEM_VENDOR_ID和
PCI_SUBSYSTEM_ID读取16字节到
dev-&gt;subsystem_vendor和
dev-&gt;subsystem_device
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2460</x>
      <y>254</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2363</x>
      <y>270</y>
      <w>33</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.读取PCI_INTERRUPT_PIN字节，如果是0，
	表示没有中断请求；如果是1~4，则表示
	设备链接在pci接口4根针的其中一个。
	PCI_INTERRUPT_LINE表示被映射到中断控制器
	的哪个引脚，这个一般是由固件设置，因为固件知道
	pci和中断控制器的硬件电路
	如果设备存在中断，
	dev-&gt;irq = irq（LINE的值）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2382</x>
      <y>262</y>
      <w>66</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>640.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2403</x>
      <y>269</y>
      <w>46</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1，遍历ram（howmany，6个）
2.取得ram对应的resource，并对其赋值
	res = &amp;dev-&gt;resource[pos];
	res-&gt;name = dev-&gt;name;
3.向寄存器PCI_BASE_ADDRESS_0 + (pos &lt;&lt; 2)
	读取ram的初始地址（l），然后向其写~0,然后再次读取，
	便是ram的大小（size），最后将初始地址l写进寄存器恢复
4.ram的（sz）大小不能是0或者（~0）
5.初始地址是（~0），则表示地址是0
6.l最低位是1，表示IO,IO的高29位表示初始地址，因为ram大小
	只能是2的整数次幂，所以sz高29位中最低位1，表示其大小
	（pci_size用于pci ram的真实大小）
	l最低位是0，表示memory map，高28位表示初始地址，sz的高28
	位中的最低位1表示其大小（pci_size）；l的第3位表示是否可预取
	（prefetchable）
	其他详情参考P1052
	根据解析，赋值res-&gt;start res-&gt;end res-&gt;flags
7.如果是memory_map,低于1M，64位，下一个寄存器表示初始地址或者
	大小的高32位，此时需要重新更新res-&gt;start res-&gt;end
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2421</x>
      <y>263</y>
      <w>43</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置ram resource</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2453</x>
      <y>270</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>dev-&gt;rom_base_reg = rom;
res = &amp;dev-&gt;resource[PCI_ROM_RESOURCE]
res-&gt;flags = (l &amp; PCI_ROM_ADDRESS_ENABLE) |
			  IORESOURCE_MEM | IORESOURCE_PREFETCH | IORESOURCE_READONLY | IORESOURCE_CACHEABLE;
res-&gt;start = l &amp; PCI_ROM_ADDRESS_MASK;
res-&gt;end = res-&gt;start + sz
res-&gt;name = dev-&gt;name
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2461</x>
      <y>263</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置rom resource</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2467</x>
      <y>249</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
BRIDGE
class要为BRIDGE
ram为2，rom：PCI_ROM_ADDRESS1</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2489</x>
      <y>254</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_bases</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2467</x>
      <y>249</y>
      <w>62</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CARDBUS
class要是BRIDGE_CARDBUS</panel_attributes>
    <additional_attributes>10.0;10.0;600.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2505</x>
      <y>257</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2508</x>
      <y>253</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2519</x>
      <y>258</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_bases</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2523</x>
      <y>253</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ram：1
rom：无</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2532</x>
      <y>257</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>分别从PCI_CB_SUBSYSTEM_VENDOR_ID和
PCI_CB_SUBSYSTEM_ID读取16字节到
dev-&gt;subsystem_vendor和
dev-&gt;subsystem_device
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2526</x>
      <y>253</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2472</x>
      <y>223</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_name_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2445</x>
      <y>219</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2461</x>
      <y>231</y>
      <w>37</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>遍历pci_vendor_list数据库，查看是否有和dev-&gt;vendor
以及dev-&gt;device相同的项，从而更新dev-&gt;name
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2477</x>
      <y>226</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2505</x>
      <y>186</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_fixup_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2443</x>
      <y>181</y>
      <w>69</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2522</x>
      <y>194</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_bridge_bases</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2512</x>
      <y>189</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2497</x>
      <y>189</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2487</x>
      <y>193</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_fixup_ghosts</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2477</x>
      <y>200</y>
      <w>38</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果逻辑设备号小于mirror（PCI_DEVFN(16,0)）
	的设备中有一个设备（devfn）与设备（devfn+mirror）
	不是完全相同，就直接返回（或者存在PCI_CLASS_BRIDGE_HOST
	的设备）；否则释放掉所有大于mirror的设备
注：不清楚resource检测的作用，感觉完全没有意义
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2487</x>
      <y>196</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2451</x>
      <y>13</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_##rw##_config_##size</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2449</x>
      <y>4</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>PCI_OP(read, word, u16 *)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2459</x>
      <y>7</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2444</x>
      <y>16</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PCI_##size##_BAD
pos不按规定的对齐</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2425</x>
      <y>22</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>PCIBIOS_BAD_REGISTER_NUMBER
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2459</x>
      <y>22</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;bus-&gt;ops-&gt;rw##_##size
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2459</x>
      <y>16</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2469</x>
      <y>25</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pci_direct_conf1</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2460</x>
      <y>32</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_conf1_read_config_word</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2460</x>
      <y>35</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到pci设备地址</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2419</x>
      <y>42</y>
      <w>47</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>outl
0x80000000 | (dev-&gt;bus-&gt;number &lt;&lt; 16) | (dev-&gt;devfn &lt;&lt; 8) | (where &amp; ~3)
0xCF8
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2470</x>
      <y>43</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inw(0xCFC + (where&amp;2))
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2471</x>
      <y>35</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读取偏移为where&amp;2的地址</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2491</x>
      <y>44</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>PCIBIOS_SUCCESSFUL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2471</x>
      <y>35</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2517</x>
      <y>201</y>
      <w>60</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.pci桥对应的设备要存在
2.bus中的resource指向dev中PCI_BRIDGE_RESOURCES
	及其之后的3个resource
3.赋值pci桥的IO窗口（4KB对齐）
	res-&gt;flags = (io_base_lo &amp; PCI_IO_RANGE_TYPE_MASK) | IORESOURCE_IO;
	res-&gt;start = base;
	res-&gt;end = limit + 0xfff;
	res-&gt;name = child-&gt;name;
4.赋值pci桥的memory map窗口（1MB对齐）
	res-&gt;flags = (mem_base_lo &amp; PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
	res-&gt;start = base;
	res-&gt;end = limit + 0xfffff;
	res-&gt;name = child-&gt;name;
5.赋值pci桥的窗口（最低4位1表示64，0表示32）
	res-&gt;flags = (mem_base_lo &amp; PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM | IORESOURCE_PREFETCH;
	res-&gt;start = base;
	res-&gt;end = limit + 0xfffff;
	res-&gt;name = child-&gt;name;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2532</x>
      <y>197</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2443</x>
      <y>181</y>
      <w>173</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历bus的devices链表中所有的device
如果设备是BRIDGE或者CARDBUS
</panel_attributes>
    <additional_attributes>10.0;10.0;1710.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2606</x>
      <y>186</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_scan_bridge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2570</x>
      <y>195</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_config_dword</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2577</x>
      <y>189</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PCI_PRIMARY_BUS</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2608</x>
      <y>189</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
buses &amp; 0xffff00
如果次总线号或者子树中的
最大总线号不为0，表示BIOS
已经被对其进行枚举</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2595</x>
      <y>195</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2583</x>
      <y>200</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>第二次遍历时（pass!=0）,直接返回
因为bios处理的pci桥设备会在第一次
遍历时处理完
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2608</x>
      <y>201</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_add_new_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2608</x>
      <y>195</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2582</x>
      <y>208</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_alloc_bus
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2589</x>
      <y>204</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2601</x>
      <y>209</y>
      <w>43</w>
      <h>22</h>
    </coordinates>
    <panel_attributes> //node加入到parent_bus的children链表中
list_add_tail(&amp;child-&gt;node, &amp;parent-&gt;children);
child-&gt;self = dev;
dev-&gt;subordinate = child;
child-&gt;parent = parent;
child-&gt;ops = parent-&gt;ops;
child-&gt;sysdata = parent-&gt;sysdata;

child-&gt;number = child-&gt;secondary = busnr;
child-&gt;primary = parent-&gt;secondary;
child-&gt;subordinate = 0xff;

child-&gt;resource[i] = &amp;dev-&gt;resource[PCI_BRIDGE_RESOURCES+i]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2616</x>
      <y>204</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2645</x>
      <y>201</y>
      <w>31</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>child-&gt;primary = buses &amp; 0xFF;
child-&gt;secondary = (buses &gt;&gt; 8) &amp; 0xFF;
child-&gt;subordinate = (buses &gt;&gt; 16) &amp; 0xFF;
child-&gt;number = child-&gt;secondary;

 //如果不是cardbus，这里采用的是深度优先算法
 //cmax是子树中最大的bus号（不论是bios遍历的，还是没遍历的）
cmax = pci_do_scan_bus(child);
 //如果时cardbus，没有桥接
cmax = child-&gt;subordinate

 //更新最大总线号
if (cmax &gt; max) max = cmax;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2608</x>
      <y>195</y>
      <w>45</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2613</x>
      <y>189</y>
      <w>80</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果bios没对pci进行配置
就次总线号和最大子树总线号为0</panel_attributes>
    <additional_attributes>10.0;10.0;780.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2677</x>
      <y>200</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>第一次遍历时（pass=0）,直接返回
第一次只处理bios处理过的pci设备
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2686</x>
      <y>194</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2701</x>
      <y>200</y>
      <w>52</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.将命令寄存器存储，然后向命令寄存器写0，向状态寄存器写全1
	pci_read_config_word(dev, PCI_COMMAND, &amp;cr);
	pci_write_config_word(dev, PCI_COMMAND, 0x0000);
	pci_write_config_word(dev, PCI_STATUS, 0xffff);
2，通过pci_add_new_bus申请child_bus（++max），其中会对主次总线号和
	子树最大总线号赋值，然后在外面进行组装，写入到PCI_PRIMARY_BUS
3.如果不是cardbus，利用pci_do_scan_bus对child进行深度有先的编号
	否则，max += 3（能插入4个cards）
4，然后更新子树的最大总线号，并将其写入寄存器PCI_SUBORDINATE_BUS中
	child-&gt;subordinate = max;
	pci_write_config_byte(dev, PCI_SUBORDINATE_BUS, max);
5.将命令寄存器恢复
	pci_write_config_word(dev, PCI_COMMAND, cr);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2690</x>
      <y>194</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2613</x>
      <y>189</y>
      <w>151</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1490.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2754</x>
      <y>198</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>child-&gt;name
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2480</x>
      <y>151</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_irq_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2461</x>
      <y>144</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2457</x>
      <y>159</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pirq_find_routing_table</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2466</x>
      <y>154</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pirq_table</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2455</x>
      <y>165</y>
      <w>27</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.搜索物理地址0xf0000~0x100000，
	routing_table起始地址是16位对齐
	所以addr+=16
2.检测结构是否符合
	rt-&gt;signature != PIRQ_SIGNATURE ||
    rt-&gt;version != PIRQ_VERSION ||
    rt-&gt;size % 16 ||
    rt-&gt;size &lt; sizeof(struct irq_routing_table)
3.如果条件符合，并且irq_routing_table所
	对应的字节的sum为0irq_routing_table
	中有checksum），返回找到的rt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2465</x>
      <y>162</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2478</x>
      <y>154</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果pirq_table没找到
并且pci_probe &amp; PCI_BIOS_IRQ_SCAN</panel_attributes>
    <additional_attributes>70.0;10.0;180.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2487</x>
      <y>160</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pirq_find_routing_table</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2496</x>
      <y>163</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2484</x>
      <y>167</y>
      <w>27</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1。通过PCIBIOS_GET_ROUTING_OPTIONS
	向bios服务pci_indirect请求，如果返回值正确
	申请irq_routing_table内存，并根据相应的
	返回值赋值
	memset(rt, 0, sizeof(struct irq_routing_table));
	rt-&gt;size = opt.size + sizeof(struct irq_routing_table);
	rt-&gt;exclusive_irqs = map;
	memcpy(rt-&gt;slots, (void *) page, opt.size);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2230</x>
      <y>169</y>
      <w>40</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.遍历0xe0000~0xffff0，查找BIOS32 Service directory，其中	length
	要存在，checksum为0，revision为0，entry要小于0x100000
	将entry转化成虚拟地址之后，赋值给bios32_indirect
2.在check_pcibios中通过bios32_service找到pci服务的entry并转
	化为虚拟地址pci_indirect，然后通过服务PCIBIOS_PCI_BIOS_PRESENT
	检查pci服务是否存在，如果存在返回pci bios服务的封装函数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2251</x>
      <y>163</y>
      <w>6</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2485</x>
      <y>154</y>
      <w>42</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果找到了pirq_table</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2519</x>
      <y>158</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2513</x>
      <y>161</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pirq_peer_trick</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2512</x>
      <y>167</y>
      <w>22</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.遍历pirq_table中所有的irq_info
	将其中存在的bus通过busmap存储
	然后通过pci_scan_bus将没建立
	的bus树建立起来，建立起来之后
	pcibios_last_bus = -1
注：之前只是扫面了0号总线上的
	pci设备，这里是将其他pci树补全
	如果树存在，pci_scan_bus会通过
	pci_bus_exists返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2518</x>
      <y>164</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2548</x>
      <y>162</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pirq_find_router</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2524</x>
      <y>158</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2537</x>
      <y>168</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_find_slot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2535</x>
      <y>165</y>
      <w>27</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据irq_router中的bus和设备号找到dev</panel_attributes>
    <additional_attributes>190.0;10.0;70.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2535</x>
      <y>174</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>遍历pci_devices中的global_list
全局链表，找到bus和逻辑设备号
相同的pirq_router_dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2542</x>
      <y>171</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2553</x>
      <y>165</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2558</x>
      <y>170</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>遍历pirq_routers数组，找到和pirq_table
相同vendor和device的项，这个项中
有操作中断路径互连器的接口
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2523</x>
      <y>158</y>
      <w>74</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2584</x>
      <y>162</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.exclusive_irqs中为1的中断输入线
	pirq_penalty[i] += 100
2.如果是APIC中断控制器，自带router
	所以pirq_table赋为NULL
注：exclusive_irqs位图中为1，表示该中断输入
	应尽量少的共用，所以将其“惩罚量”加100。在路径
	互连时，尽量不选这条中断请求线。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2629</x>
      <y>153</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_fixup_peer_bridges</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2462</x>
      <y>144</y>
      <w>178</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1760.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2618</x>
      <y>162</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.pcibios_last_bus&lt;0表示pirq_peer_trick
	已经遍历过0号总线之外的其他树
2.pcibios_last_bus不能大于0xff，
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2629</x>
      <y>156</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2647</x>
      <y>162</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>对于小于pcibios_last_bus的bus，
看其上是否有0~255号设备（查看vendor）
如果有通过pci_scan_bus建立其总线树和
设备
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2638</x>
      <y>156</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2692</x>
      <y>152</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_fixup_irqs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2462</x>
      <y>144</y>
      <w>237</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2350.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2676</x>
      <y>162</y>
      <w>27</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>遍历pci_devices链表中的所有设备，如果
dev-&gt;irq有效（这是bios已经分配好的），
则将相应中断请求线的pirq_penalty++。

注：如果pirq_penalty显示该中断请求要
分配给ISA(大于100，小于100000),但是
在已经分配给pci设备，那么将其pirq_penalty
重置
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>155</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pirq_penalty</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2731</x>
      <y>158</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_lookup_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2700</x>
      <y>155</y>
      <w>40</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历pci_devices，读取PCI_INTERRUPT_PIN
如果有中断（pin不为0），但是没连接到中断控制器的
中断请求线上（dev-&gt;irq为0）</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2709</x>
      <y>166</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pirq_get_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2713</x>
      <y>161</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2704</x>
      <y>173</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>遍历pirq_table中slot的元素（所有中断设备的信息）
如果发现bus和相应的设备号和dev相同的，返回
对应的irq_info
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2714</x>
      <y>169</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2737</x>
      <y>171</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //link表示和互连器连接的线号
pirq = info-&gt;irq[pin].link;
 //mask表示可以连接到中断控制器的哪个引脚
mask = info-&gt;irq[pin].bitmap;
mask &amp;= pcibios_irq_mask
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2737</x>
      <y>161</y>
      <w>8</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2768</x>
      <y>163</y>
      <w>41</w>
      <h>53</h>
    </coordinates>
    <panel_attributes>1.如果没分配中断请求线（!newirq）,并且
	要求分配中断号；如果发现mask中可以被
	使用，并且pirq_penalty最小的中断号
	通过request_irq申请中断号（后面会free，实际
	只是通过register_irq_proc注册procfs。
	另外这里请求空的中断处理函数，如果能成功返回，说明之后申请中断处理函数
	也可以顺利申请（没有action或者SA_SHIRQ））
	newirq = i
2.如果link的高4位为F,表示路径连接器和中断控制
	器通过硬连接，其低四位便是中断控制器的请求线号
	irq = pirq &amp; 0xf
	msg = "Hardcoded"
3.如果不是硬链接，通过pirq_router.get获取该路径连接器的
	线是否连接到中断控制器，如果!0，表示已连接
	irq = r-&gt;get
	msg = "Found";
4.如果上述2个条件均不满足，但是被分配了newirq，通过r-&gt;set
	（不能是VGA）将路径连接器和中断控制器的newirq号请求线连接
	如果成功，eisa_set_level_irq将0x4d0 + (irq &gt;&gt; 3)（port）
	读进来，并将irq &amp; 7位置上后，写进port
	msg = "Assigned";
	irq = newirq;
5.如果最后irq还是为0，表示没分配中断请求线给dev
	如果该dev只允许唯一的中断请求线newirq
	msg = "Guessed";
	irq = newirq;
	否则，直接返回0
6.遍历pci_devices中的其他设备，如果该设备连接到相同的路径
	连接器的相同通道（link相同），则为该设备分配中断控制器
	的请求线
	//这里的dev2包含dev，所以这里设置了dev.irq
	dev2-&gt;irq = irq;
	pirq_penalty[irq]++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2737</x>
      <y>160</y>
      <w>39</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
assign=0表示尚未连接中断请求线的dev
之后在说，先处理已经连接的</panel_attributes>
    <additional_attributes>10.0;20.0;370.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2845</x>
      <y>154</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_resource_survey</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2463</x>
      <y>144</y>
      <w>395</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;3930.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2813</x>
      <y>162</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_allocate_bus_resources</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2822</x>
      <y>157</y>
      <w>35</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为bios中已经分配的pci桥
resource建立树结构（conflict除外）</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2810</x>
      <y>170</y>
      <w>30</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.遍历父节点的所有子节点（父节点包含root）
	找到每个bus对应的pci桥（dev = bus-&gt;self）
2.遍历pci桥的bridge资源（要存在!r-&gt;start），
	通过pci_find_parent_resource讯在pci桥父bus
	上包含该resource的总线的parent_resource
3.通过request_resource将pci桥的resource注册
	到父bus的resource树中
4.将pci桥的resource遍历完之后，pcibios_allocate_bus_resources
	递归将其子gus上的资源注册至resource树中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2823</x>
      <y>165</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2815</x>
      <y>188</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_find_parent_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2824</x>
      <y>185</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2811</x>
      <y>194</y>
      <w>33</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.找到设备所在的bus（dev-&gt;bus）
2.bus的resource要存在
3.start存在，且dev的resource要在bus相应
	的resource范围内
4.bus的resource（r）要和dev的resource（res）
	是IO寻址还是Mem寻址要是一样的
	IORESOURCE_IO | IORESOURCE_MEM
5.如果预取的符号也是一致的（IORESOURCE_PREFETCH）
	这个bus resource就是要找的父resource
6.如果预取符号不一致，但是dev的resource可预取
	但是父bus的resource不可预取时，暂存这个resource
	如果没有更好的就将其返回。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2823</x>
      <y>191</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2848</x>
      <y>163</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_allocate_resources</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2855</x>
      <y>157</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
0</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2840</x>
      <y>171</y>
      <w>25</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.将PCI_COMMAND寄存器读出
2.遍历所有的ram resource，
	该resource不能连接到树中（r-&gt;parent为NULL）
	resource被分配总线地址（r-&gt;start不为0）	
3.已生效的resource(disable=0，
	command中相应的标志置上)在第
	一次访问时(pass=0)通过pci_find_parent_resource
	在父总线上找到父resource，然后
	通过request_resource将dev的resource
	连接到resource中；
	没生效的resource（disable=1，command
	中相应的标志没置上），将在第二次访问
	的时候将其连接到resource中；
	如果dev的resource与父resource矛盾，
	将其分配的总线地址清除
	r-&gt;end -= r-&gt;start;
	r-&gt;start = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2858</x>
      <y>166</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历pci_devices所有设备</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2844</x>
      <y>168</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ram</panel_attributes>
    <additional_attributes>150.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2858</x>
      <y>168</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
rom</panel_attributes>
    <additional_attributes>10.0;20.0;180.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2867</x>
      <y>171</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>r-&gt;flags &amp;= ~PCI_ROM_ADDRESS_ENABLE;
pci_write_config_dword(dev, dev-&gt;rom_base_reg, reg &amp; ~PCI_ROM_ADDRESS_ENABLE)
注：在第一次扫描时，将rom关闭
（在初始化时由BIOS或者设备驱动
程序使用），但是resource还是存在
再次需要时，可通过驱动程序将其打开
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2869</x>
      <y>163</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_allocate_resources</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2855</x>
      <y>157</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2894</x>
      <y>163</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_assign_resources</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2855</x>
      <y>157</y>
      <w>48</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;460.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2904</x>
      <y>166</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2893</x>
      <y>171</y>
      <w>30</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.遍历pci_devices所有设备
2.class要存在且不是PCI_CLASS_BRIDGE_HOST
ram地址空间[0，6)
3.PCI_CLASS_STORAGE_IDE设备（硬盘）的前4区间
	VGA设备的IO地址，这些地址已经被使用
	所以不需要分配
4.如果没被分配总线地址（!r-&gt;start &amp;&amp; r-&gt;end），
	通过pci_assign_resource分配总线地址
5.如果pci_probe的PCI_ASSIGN_ROMS置上
	将其bios分配的地址清除
	r-&gt;end -= r-&gt;start;
	r-&gt;start = 0;
	然后通过pci_assign_resource重新分配
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2898</x>
      <y>195</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_assign_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2906</x>
      <y>192</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2894</x>
      <y>202</y>
      <w>29</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.计算resource的size，和起始分配地址
	size = res-&gt;end - res-&gt;start + 1;
	min = (res-&gt;flags &amp; IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;
2.通过pci_assign_bus_resource申请可预取
（IORESOURCE_PREFETCH）符号相同的地址空间，
如果没有成功，并且该resource可预取
再次通过pci_assign_bus_resource分配
可预取符号不同的地址空间
（可预取的res能安排不可预取的area，但是不可预取的res不能安排可预取的area）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2905</x>
      <y>198</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2894</x>
      <y>219</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_assign_bus_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2904</x>
      <y>216</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2878</x>
      <y>226</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.resource要存在
2.type_mask规定的flag要相同
3.bus的resource要求预取时，
	dev的resource必须时可预取的
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2882</x>
      <y>222</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历bus的4个resource空间</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2904</x>
      <y>226</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>allocate_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2902</x>
      <y>222</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2897</x>
      <y>233</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2898</x>
      <y>229</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查看子树链表中间的区域
看是否能容纳该resource</panel_attributes>
    <additional_attributes>130.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2884</x>
      <y>239</y>
      <w>41</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.调整end，如果child没有，则指向bus的end
	如果有child，end指向第一个resource的start
	另外end不能大于max
2，调整start，开始指向bus的start，但是不能小于min
	并将start对size取整
3.alignf在对start或者end做调整，这里pcibios_align_resource
	中处理IORESOURCE_IO中不能申请start从0x100~0x400的地址
	（以免和接口卡地址冲突），将start调整
4.判断start到end的距离是否能容纳resource
	new-&gt;start &lt; new-&gt;end &amp;&amp; new-&gt;end - new-&gt;start + 1 &gt;= size
	如果能容纳：
	new-&gt;end = new-&gt;start + size - 1;
	return 0;
5.如果不能容纳（!this），但是已经遍历到了最后，表示该bus已经没空间
	容纳该resource，return -EBUSY
6.如果不能容纳，但是还没遍历到最后，就调整到下一个空闲空间
	new-&gt;start = this-&gt;end + 1;
	this = this-&gt;sibling;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2902</x>
      <y>236</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2916</x>
      <y>233</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__request_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2905</x>
      <y>229</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果找到了足够的空间容纳resource
就将其注册至资源树中
</panel_attributes>
    <additional_attributes>70.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2929</x>
      <y>219</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_update_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2907</x>
      <y>216</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2930</x>
      <y>226</y>
      <w>32</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>ram:
new = res-&gt;start | (res-&gt;flags &amp; PCI_REGION_FLAG_MASK);
reg = PCI_BASE_ADDRESS_0 + 4*resource;

PCI_ROM_RESOURCE:
new = res-&gt;start | (res-&gt;flags &amp; PCI_REGION_FLAG_MASK);
res-&gt;flags |= PCI_ROM_ADDRESS_ENABLE;
new |= PCI_ROM_ADDRESS_ENABLE;
reg = dev-&gt;rom_base_reg;

最后写入寄存器：
pci_write_config_dword(dev, reg, new);
然后在读取出来，检查和写进去的地址是否一致
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2939</x>
      <y>222</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2610</x>
      <y>125</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_fixup_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2598</x>
      <y>116</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历pci_devices所有设备
对pcibios_fixups和pci_fixups规定的
PCI_FIXUP_FINAL进行修复</panel_attributes>
    <additional_attributes>30.0;10.0;190.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2515</x>
      <y>1</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_find_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2516</x>
      <y>10</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_find_subsys</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2522</x>
      <y>4</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2503</x>
      <y>19</y>
      <w>40</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.从from遍历device（当from为NULL时，从pci_devices）
	如果其vendor，device，subsystem_vendor，subsystem_device
	相同，就返回dev.否则就遍历其global_list.next
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2522</x>
      <y>13</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2560</x>
      <y>0</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_find_class</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2546</x>
      <y>9</y>
      <w>40</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.从from遍历device（当from为NULL时，从pci_devices）
	如果其dev-&gt;class相同，就返回dev.否则就遍历其global_list.next
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2566</x>
      <y>3</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2602</x>
      <y>0</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_enable_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2588</x>
      <y>8</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_enable_resources</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2597</x>
      <y>3</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
资源激活</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2565</x>
      <y>16</y>
      <w>44</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.读取PCI_COMMAND
2.遍历dev[0,6)的resource，
	如果!r-&gt;start &amp;&amp; r-&gt;end，表示没被分配总线地址
	如果6个资源中有IORESOURCE_IO，则将cmd的IO enable
	如果IORESOURCE_MEM，则将cmd中的MEMORY enable
	如果ram被分配总线地址，也将PCI_COMMAND_MEMORY enable
3.如果发现cmd和old_cmd不一致，将cmd写入到PCI_COMMAND中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2588</x>
      <y>11</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2616</x>
      <y>9</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_enable_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2609</x>
      <y>3</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将路径连接器和中断控制器相连
（BIOS没设置的irq）</panel_attributes>
    <additional_attributes>30.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2610</x>
      <y>17</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.读出PCI_INTERRUPT_PIN，pin不能为0
2.pcibios_lookup_irq连接中断控制器（assign
	为1，表示将BIOS没设置的也给设置），这里在遍历dev2时
	将dev.irq置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2625</x>
      <y>12</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2970</x>
      <y>134</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2965</x>
      <y>140</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>partition_setup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2947</x>
      <y>149</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>device_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2950</x>
      <y>157</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>chr_dev_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2954</x>
      <y>143</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2953</x>
      <y>152</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2932</x>
      <y>165</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_register_chrdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2960</x>
      <y>163</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memory_devfs_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2941</x>
      <y>160</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
向字符设备注册MEM_MAJOR
name：mem
fops：memory_fops</panel_attributes>
    <additional_attributes>160.0;10.0;45.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2952</x>
      <y>160</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
向devfs注册mem的各个节点</panel_attributes>
    <additional_attributes>60.0;10.0;130.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2969</x>
      <y>166</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2959</x>
      <y>170</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>遍历list，通过devfs_register
向devfs注册节点
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>832</x>
      <y>164</y>
      <w>63</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.互斥操作，系统总线加锁：xchg，lock
2.内存路障，会自动将cache中内容写入到内存中：
	1.系统总线加锁
	2.iret，cpuid，sfence，GDTR,LDTR,IDTR等指令调用
注：mb/rmb是对lock或者sfence的封装
	wmb是空指令，因为intel保证写操作的“处理器序”，gcc不会跨这个指令优化

3.保证多个cpu的cache一致
	1.snooping机制会使如果监测到系统总线写内存，将会把内存中的数据同步到各个cpu的cache中
	2.如果更新了页表，软件会通过flush_tlb刷新tlb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>860</x>
      <y>201</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_tlb_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>865</x>
      <y>195</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>841</x>
      <y>208</y>
      <w>51</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.mm的cpu_vm_mask中计入了进程运行的cpu，将除了本cpu
	的cpu_mask提出出来（在switch_mm中）
2.如果现在运行的就是当前mm（active_mm==mm），先改变当前cpu的tlb
	1.如果是用户进程，通过__flush_tlb_one将cr3提出出来
		然后重新装入，会导致整个TLB被遗弃
	2.如果是内核线程（TLBSTATE_LAZY，在schedule中通过enter_lazy_tlb置上），
		通过leave_mm将cpu_vm_mask中当前cpu的mask清掉
注：1.__exit_mm也会调用enter_lazy_tlb使得当前cpu中tlb即使被改变也不会被更新
	2.flush_tlb_page一般是改变用户层内存映射时会调用，所以不用本cpu的内核线程
		，如果需要更新内核内存映射（vmalloc）是使用flush_tlb_all
	3.如果是进程切换，会调用switch_mm，将cpu_tlbstate中active_mm替换成将要运行的的mm
		state切换成TLBSTATE_OK。如果是内核线程切换成进程时，如果发现mm被改变（cpu_vm_mask再leave_mm
		中被清掉），会通过local_flush_tlb刷新tlb
3.再通过flush_tlb_others改变cpu_mask中cpu的tlb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>865</x>
      <y>204</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>858</x>
      <y>231</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_tlb_others</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>863</x>
      <y>227</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>844</x>
      <y>238</y>
      <w>41</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.cpumask要存在，要通知的cpu要在cpu_online_map中，不能含有本cpu
2.要通知的mm要存在
3.通过tlbstate_lock将下面这段保护。
4.将mm，地址va，cpumask赋给全局变量flush_mm，flush_va,flush_cpumask
5.通过send_IPI_mask向cpumask中的cpu发送中断
6.while等待flush_cpumask被中断处理完
7.清除flush_mm，flush_va，并释放锁
注：1.每个cpu最多只有一个在这段代码中
	2.因为while等待，在其他cpu中断处理期间（中断中没申请锁），本cpu也不会释放锁
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>863</x>
      <y>234</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>829</x>
      <y>278</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_invalidate_interrupt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>824</x>
      <y>285</y>
      <w>32</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.测试flush_cpumask中当前cpu的标志是否置上
2.如果当前运行的mm（cpu_tlbstate.active_mm）
  是要被刷新的mm，并且是进程（TLBSTATE_OK），通过
  local_flush_tlb重载cr3，更新整个tlb（FLUSH_ALL）
  或者通过__flush_tlb_one刷新单个虚拟页面
3.通过ack_APIC_irq向APIC_EOI写0，回应中断
4.将flush_cpumask中当前cpu的标志清掉
注：如果是pgd发生改变，会调用flush_tlb_mm，传参是FLUSH_ALL
	要求把所有的tlb全部废除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>838</x>
      <y>281</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>873</x>
      <y>278</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_reschedule_interrupt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>869</x>
      <y>285</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过ack_APIC_irq向APIC_EOI写0，回应中断
注：1.中断来源是其他cpu通过smp_send_reschedule发送
	2.这只是使cpu产生中断，如果当前进程need_resched
	会在中断返回时发生调度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>883</x>
      <y>281</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>858</x>
      <y>256</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>send_IPI_mask</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>863</x>
      <y>252</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>848</x>
      <y>263</y>
      <w>34</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过apic_wait_icr_idle等待APIC空闲
2.通过apic_write_around将要发送的cpu_mask
	（__prepare_ICR2准备好数据）写入ICR2寄存器
3.通过apic_write_around将发送的向量vector（通过__prepare_ICR
	准备数据），写入到ICR寄存器
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>862</x>
      <y>259</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>837</x>
      <y>272</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>867</x>
      <y>272</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1651</x>
      <y>84</y>
      <w>359</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3570.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2215</x>
      <y>92</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2182</x>
      <y>101</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_boot_cpus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2246</x>
      <y>101</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_commence</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2187</x>
      <y>95</y>
      <w>36</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
启动其他cpu</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2220</x>
      <y>95</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2214</x>
      <y>102</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_threads_ready=1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2219</x>
      <y>95</y>
      <w>3</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2178</x>
      <y>107</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_boot_cpu</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2183</x>
      <y>104</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2163</x>
      <y>115</y>
      <w>45</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.通过fork_by_hand创建其他cpu的idle进程（CLONE_PID表示公用一个pid）
2.设置cpu，idle，stack
	//cpu
	idle-&gt;processor = cpu;
	x86_cpu_to_apicid[cpu] = apicid;
	x86_apicid_to_cpu[apicid] = cpu;
	//idle
	idle-&gt;has_cpu = 1; 
	idle-&gt;thread.eip = (unsigned long) start_secondary;//idle运行的ip
	//将cpu从主cpu的task链表中删除，成为次cpu的idle_task
	del_from_runqueue(idle);
	unhash_process(idle);
	init_tasks[cpu] = idle;
	//次cpu启动的ip
	start_eip = setup_trampoline()
	//stack
	stack_start.esp = (void *) (1024 + PAGE_SIZE + (char *)idle)
3.将init_deasserted置0，将start_eip分成两部分写入物理地址0x469和0x467处用于系统的热启动
4.将发送的cpu号放在ICR2，状态和控制信息放在ICR,等待APIC_ICR_BUSY被清掉
	1..初始化完成后，将init_deasserted置1
	2.其中将start_eip发至次cpu用于启动，发送成功之后，将cpu_callout_map置上
	3.检查次cpu发送的cpu_callin_map位标志，如果收到成功返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2182</x>
      <y>110</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2147</x>
      <y>155</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_trampoline</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2152</x>
      <y>150</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2150</x>
      <y>158</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为次cpu启动地址要页对齐
连接的trampoline_data不能页对齐
所以申请内存trampoline_base中执行</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2145</x>
      <y>162</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>trampoline_data</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2133</x>
      <y>169</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.将cs和ds设置相同
2.将bx设置为1
3.加在idt，gdt，其中gdt是gdt_table的物理地址
4.通过lmsw将pe置1，进入保护模式
5.到地址1M处(startup_32)执行，__KERNEL_CS对应gdt基地址是0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2149</x>
      <y>165</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3268</x>
      <y>117</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_secondary</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3273</x>
      <y>113</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
smp_init-&gt;do_boot_cpu</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3256</x>
      <y>124</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cpu_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3262</x>
      <y>120</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为进程调度做准备</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3272</x>
      <y>124</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_callin</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3275</x>
      <y>120</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3267</x>
      <y>131</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.等待主cpu将次cpu的APIC初始化后将init_deasserted置1
2.将cpu在cpu_online_map中的标志置1
3.2s内检测主cpu是否在发送ip完成之后将cpu_callout_map标志位置上
......
n.将cpu_callin_map中标志置上，用于主cpu从do_boot_cpu中返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3278</x>
      <y>127</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3291</x>
      <y>125</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_commenced
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3276</x>
      <y>120</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
while等待被置上</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3310</x>
      <y>125</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>local_flush_tlb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3276</x>
      <y>120</y>
      <w>42</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
刷新tlb</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3325</x>
      <y>125</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cpu_idle</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3277</x>
      <y>119</y>
      <w>54</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;520.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2246</x>
      <y>109</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_commenced=1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2252</x>
      <y>104</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通知次cpu开始执行</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1415</x>
      <y>102</y>
      <w>242</w>
      <h>55</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
构建iomem_resource和ioport_resource的resource树</panel_attributes>
    <additional_attributes>10.0;10.0;2400.0;530.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1640</x>
      <y>155</y>
      <w>50</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.申请iomem_resource
	1.通过probe_roms申请rom的resource
		1.申请bios的rom resource（rom_resources[0]）
		2.如果0xC0000~0xc7fff之间有Video ROM（romsignature），申请rom_resources[1]
		注：这里0xE0000应该有问题
		3.如果0xC8000~0xE0000有resource（romsignature而且checksum不为0），申请Extension ROM（放在rom_resources[roms]）
		4.如果0xE0000有resource（romsignature），申请65535byte rom（放在rom_resources[roms]）
	2.遍历e820数组，利用alloc_bootmem_low申请resource，在iomem_resource申请，并在该resource
		下申请code_resource和data_resource
	3.在iomem_resource下申请vram_resource
2.申请ioport_resource（standard_io_resources下的所有resource）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1482</x>
      <y>98</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>parse_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1488</x>
      <y>84</y>
      <w>164</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
解析boot传来的cmd
在checksetup遍历数组__setup_start，查看名字相同的解析函数
这个数组在init.h中通过宏__setup定义</panel_attributes>
    <additional_attributes>1620.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1526</x>
      <y>104</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cpu_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1520</x>
      <y>101</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1520</x>
      <y>111</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果已经被初始化（cpu_initialized），空转，但是能相应中断
2.设置eflag
3.设置TSS(set_tss_desc),ldt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1531</x>
      <y>107</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2170</x>
      <y>95</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fork_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1650</x>
      <y>84</y>
      <w>526</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mempages的一半用于创建线程和进程的task_struct</panel_attributes>
    <additional_attributes>10.0;10.0;5240.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2186</x>
      <y>94</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1650</x>
      <y>84</y>
      <w>545</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请page_hash_table</panel_attributes>
    <additional_attributes>10.0;10.0;5430.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3020</x>
      <y>93</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cpu_idle</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1651</x>
      <y>86</y>
      <w>1377</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
进入之前current-&gt;need_resched = 1</panel_attributes>
    <additional_attributes>10.0;10.0;13750.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3311</x>
      <y>133</y>
      <w>40</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.通过init_idle设置sched_data
	sched_data-&gt;curr = current;
	sched_data-&gt;last_schedule = get_cycles();
2.设置优先级和时间片：
	current-&gt;nice = 20;
	current-&gt;counter = -100;
3.while死循环
	1.选择需要执行的idle进程（default_idle）
	2.如果不需要need_resched，才执行idle
主：主cpu会在进入cpu_idle之前置上，所以之后会执行init，
	次cpu则会进入idle，从而safe_halt，直到中断唤醒硬件
	3.如果需要need_resched，schedule
	4.醒来之后通过check_pgt_cache检查是否要释放多余的pgd，pte页面
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3330</x>
      <y>128</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2684</x>
      <y>111</y>
      <w>313</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>3110.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2679</x>
      <y>117</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2655</x>
      <y>123</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2660</x>
      <y>120</y>
      <w>27</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建sk_cachep</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2673</x>
      <y>124</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2674</x>
      <y>120</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建skbuff_head_cache</panel_attributes>
    <additional_attributes>110.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2688</x>
      <y>125</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>register_filesystem(&amp;sock_fs_type);
sock_mnt = kern_mount(&amp;sock_fs_type);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2684</x>
      <y>120</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建sockfs</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2742</x>
      <y>118</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_context_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2750</x>
      <y>111</y>
      <w>247</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2450.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2741</x>
      <y>123</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kernel_thread
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2745</x>
      <y>120</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
第二个内核线程</panel_attributes>
    <additional_attributes>60.0;20.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2741</x>
      <y>129</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>context_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2746</x>
      <y>126</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2746</x>
      <y>132</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2723</x>
      <y>135</y>
      <w>42</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过daemonize退出父进程mm，fs，files，并复用current的
	fs，files，使其变为守护线程
2.设置属性
	strcpy(curtask-&gt;comm, "keventd");
	keventd_running = 1;
	keventd_task = curtask;
3.通过siginitsetinv将blocked中的SIGCHLD清掉
	并重新设置SIGCHLD的k_sigaction
4.死循环：
	1.TASK_INTERRUPTIBLE，加入等待队列context_task_wq
	2.如果tq_context中有任务，TASK_RUNNING
	3.schedule
	4.醒来之后，执行tq_context，唤醒context_task_done
	5.如果有人发信号signal_pending，通过waitpid等待同一进程组的进程
		有人zombie或者stopped，然后通过flush_signals将信号队列中清空
		并重新recalc_sigpending
注：在schedule_task中向tq_context链表中添加routine
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3097</x>
      <y>116</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mount_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2994</x>
      <y>111</y>
      <w>110</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1080.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3083</x>
      <y>121</y>
      <w>63</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.通过devfs_make_root解析root_device_name（但是好像没用，因为dest是局部变量）
2.通过devfs_find_handle在devfs根据路径（ROOT_DEVICE_NAME），或者设备号（路径为NULL时）找到devfs中的dentry
	最后合成设备号ROOT_DEV
3.通过bdget获取bdev数据结构，通过de结构中之前的注册赋值bd_op
	bdev-&gt;bd_op = devfs_get_ops (handle)
	并通过devfs_generate_path生成在devfs中的路径
4.如果root_mountflags的MS_RDONLY没置上，以读写权限通过blkdev_get去打开设备（这里有可能更换ops）
	如果不行（EROFS），再将root_mountflags的MS_RDONLY，并以读权限通过blkdev_get打开设备
5.通过get_super去super_blocks链表中查看是否有super，如果有，获取fs_type直接去安装
	如果没有，遍历file_systems，以链表中的各个文件系统模式去读取super，获取成功直接去安装
6.如果设备存在路径（path_start&gt;=0）,通过devfs_mk_symlink创建一个root的连接指向设备
	不管有没有路径，都会通过add_vfsmnt创建mnt
7.替换current的root，pwd，因为init进程是所有进程的根，所以mnt就是所有进程的根
	set_fs_root(current-&gt;fs, vfsmnt, sb-&gt;s_root);
	set_fs_pwd(current-&gt;fs, vfsmnt, sb-&gt;s_root);
注；安装跟设备核心是有对跟设备的操作函数
	linux0.11是直接在rd_init中指定的（跟设备号是rd的主设备号）
	linux2.4.0是在init_call时跟设备在注册时安装置devfs中，然后再根据在devfs中的路径去寻找跟设备的操作函数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3103</x>
      <y>119</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3149</x>
      <y>152</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_mk_symlink</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3141</x>
      <y>159</y>
      <w>55</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.name，link不存在，返回EINVAL
2.通过search_for_entry获取要name的路径对应的de，如果不存在，返回ENOMEM，如果存在通过handle返回
3.对root的de赋值
	de-&gt;mode = S_IFLNK | S_IRUGO | S_IXUGO;
    de-&gt;info = info;
    de-&gt;show_unreg = ( (boot_options &amp; OPTION_SHOW)
		       || (flags &amp; DEVFS_FL_SHOW_UNREG) ) ? TRUE : FALSE;
    de-&gt;hide = (flags &amp; DEVFS_FL_HIDE) ? TRUE : FALSE;
4.如果de之前被link（registered），不能被重复link
5.将root（连接节点）和link（实际节点）连接
	de-&gt;registered = TRUE;
	newname = kmalloc//没内存时将其从树中删除，并释放（如果是之前就有(is_new)就不释放）
	 de-&gt;u.symlink.linkname = newname;
    memcpy (de-&gt;u.symlink.linkname, link, linklength);
    de-&gt;u.symlink.linkname[linklength] = '\0';
    de-&gt;u.symlink.length = linklength;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3130</x>
      <y>149</y>
      <w>27</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建一个root指向link</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3154</x>
      <y>155</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3189</x>
      <y>112</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_initmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3002</x>
      <y>104</y>
      <w>194</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将init段（__init_begin~__init_end）的函数指针释放</panel_attributes>
    <additional_attributes>10.0;10.0;1920.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3209</x>
      <y>107</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过open，dup打开标准输入，输出，错误（/dev/console）
2.通过execve去执行init（一般/bin/sh会成功）
注：1.linux0.11是创建一个2号进程执行shell，而linux2.4.0直接执行execve执行shell（shell进程就是init进程，execve不会返回）
	2.内核中的syscall是通过宏_syscall0()，_syscall1()，syscall2()等
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3002</x>
      <y>104</y>
      <w>219</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2170.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3425</x>
      <y>102</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_reboot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3415</x>
      <y>105</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
LINUX_REBOOT_CMD_RESTART</panel_attributes>
    <additional_attributes>160.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3406</x>
      <y>109</y>
      <w>32</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过notifier_call_chain调用reboot_notifier_list链表中
	注册的需要在reboot时执行的函数
注：通过函数register_reboot_notifier注册，优先级从高到低
2.通过machine_restart重引导
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3415</x>
      <y>121</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>machine_restart</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3420</x>
      <y>116</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3403</x>
      <y>128</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过smp_send_stop使每个cpu停止local APIC
	通过disable_IO_APIC停止外部APIC
2.如果在引导时没定义"reboot="(!reboot_thru_bios),硬启动
3.如果有定义，通过machine_real_restart重启
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3421</x>
      <y>124</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3413</x>
      <y>138</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>machine_real_restart</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3419</x>
      <y>135</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3400</x>
      <y>144</y>
      <w>40</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.通过CMOS_WRITE向8f写0，关中断和NMI
2.将cr3指向swapper_pg_dir
	1.swapper_pg_dir中系统空间部分赋值到低地址前1G空间，
	2.因为在之后会去0~4k这段地址作为指令，所以必须使其指向pte指向物理地址的0~4k
		pg0[0] = _PAGE_RW | _PAGE_PRESENT//后面分析这个好像没办法保证
	注：1.进程0一直用这个页目录，
		2.pg0的物理地址是0x00102000，在setup_arch中因为下面这句而reserve
		reserve_bootmem(HIGH_MEMORY, (PFN_PHYS(start_pfn) +
			 bootmap_size + PAGE_SIZE-1) - (HIGH_MEMORY));
			所以在paging_init-&gt;pagetable_init中为swapper_pg_dir申请系统页面时不会
			申请到pg0作为pte，所以这里对pg0进行赋值根本没办法影响到页表
3.在0x472处存reboot_mode，等待bios启动时取
注：reboot_mode在reboot_setup设置，热启动是0x1234（自检），冷启动是0（不用自检）
4.将代码real_mode_switch和code(jump_to_bios)复制到0x1000 - sizeof (real_mode_switch) - 100处
	然后设置号idt gdt，将段寄存器设置为0x10，最后通过ljmp跳到复制代码处执行（$0x0008表示是段寄存器中的第1项，基地址是0）
	注：复制代码执行：
		1.将cr0和cr3的页面映射关闭
		2.如果cr0的0x60000000置上，通过invd将高速缓存作废
		3.向cr0写0x10，进入实地址模式
		4.通过ljmp跳转到0xFFFF0(段地址是0xFFFF,偏移是0)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3419</x>
      <y>141</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>767</x>
      <y>319</y>
      <w>1</w>
      <h>0</h>
    </coordinates>
    <panel_attributes>1.父目录要是S_ISDIR
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>770</x>
      <y>319</y>
      <w>3</w>
      <h>1</h>
    </coordinates>
    <panel_attributes>1.遍历parent的子节点链表parent-&gt;u.dir.first
2.根据namelen和name滤出对应的devfs_entry
3.如果在链表中没有找到devfs_entry，返回NULL
4.如果找到了，但是不是S_ISLNK，或者是link，
	但是不要求traverse_symlink，直接返回找到的
	devfs_entry
5.如果需要根据link找到实体（traverse_symlink），
	使用search_for_entry在parent中找curr-&gt;u.symlink.linkname
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1829</x>
      <y>600</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_vma</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1832</x>
      <y>603</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据虚拟地址在进程的mm中找到响应的vma
1.过滤条件mm！=NULL
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1813</x>
      <y>610</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
首先查找cache中是否有vma</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1781</x>
      <y>615</y>
      <w>39</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vma = mm-&gt;mmap_cache
vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1830</x>
      <y>610</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没有avl树，
则在链表mm-&gt;mmap中查找</panel_attributes>
    <additional_attributes>30.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1826</x>
      <y>615</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vma = mm-&gt;mmap;
while (vma &amp;&amp; vma-&gt;vm_end &lt;= addr)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1833</x>
      <y>610</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有avl树，
则在avl树中查找</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1861</x>
      <y>614</y>
      <w>36</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>struct vm_area_struct * tree = mm-&gt;mmap_avl;
vma = NULL;
for (;;) {
	if (tree == vm_avl_empty)
		break;
	if (tree-&gt;vm_end &gt; addr) {
		vma = tree;//如果在avl树中找不到相应的虚拟地址
						//找到与其最接近的vma区域
						//注意只要找过一次左树，是有确定的目标，和其最接近
						//如果一直找右树，但是最终右树没有，则返回NULL
		if (tree-&gt;vm_start &lt;= addr)
			break;
		tree = tree-&gt;vm_avl_left;
	} else
		tree = tree-&gt;vm_avl_right;
	}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1832</x>
      <y>610</y>
      <w>81</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果通过链表或者avl找到vma
则将其存入cache中</panel_attributes>
    <additional_attributes>10.0;10.0;790.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1903</x>
      <y>614</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mm-&gt;mmap_cache = vma
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1967</x>
      <y>575</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>insert_vm_struct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1950</x>
      <y>578</y>
      <w>37</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
加了两把锁，
lock_vma_mappings(vmp)//对vma加锁
spin_lock(&amp;current-&gt;mm-&gt;page_table_lock);//对mm加锁
后面详述</panel_attributes>
    <additional_attributes>260.0;10.0;100.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1933</x>
      <y>592</y>
      <w>29</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果avl不存在
找到要插入的位置</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1959</x>
      <y>592</y>
      <w>67</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
插入到链表中（即使已经插入到了avl树中，也要插入到链表中）</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1959</x>
      <y>592</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
若avl树存在
找到插入的位置</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1966</x>
      <y>598</y>
      <w>26</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
由代码可知，
to_the_left和to_the_right
分别表示改vma在链表中的左节点和
右节点
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1962</x>
      <y>605</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>avl_insert_neighbours</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1963</x>
      <y>608</y>
      <w>23</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
#define vm_avl_key	vm_end</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1933</x>
      <y>615</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到new_vma在avl树和链表中的插入位置</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1929</x>
      <y>621</y>
      <w>30</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>for (;;) {
	struct vm_area_struct * node = *nodeplace;
	if (node == vm_avl_empty)
		break;
	*stack_ptr++ = nodeplace; stack_count++; //记录new_vma的每个父节点，和其相应的深度
	if (key &lt; node-&gt;vm_avl_key) {
		*to_the_right = node;						//new_vma在链表中的左节点
		nodeplace = &amp;node-&gt;vm_avl_left;			//如果key小于该节点的key，就继续查找该节点的左节点（树的插入）
	} else {
		*to_the_left = node;							//new_vma在链表中的右节点
		nodeplace = &amp;node-&gt;vm_avl_right;			//如果key大于该节点的key，就继续查找该节点的右节点（树的插入）
	}
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1964</x>
      <y>626</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>new_node-&gt;vm_avl_left = vm_avl_empty;
new_node-&gt;vm_avl_right = vm_avl_empty;
new_node-&gt;vm_avl_height = 1;
*nodeplace = new_node;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1957</x>
      <y>615</y>
      <w>30</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化new_vma的左右子节点为NULL，height
并插入到树中</panel_attributes>
    <additional_attributes>70.0;10.0;220.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2000</x>
      <y>625</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>avl_rebalance</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1963</x>
      <y>615</y>
      <w>45</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将avl树重新平衡</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1980</x>
      <y>635</y>
      <w>65</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>注：
1.stack中存储的节点的height虽然都不对，但是他们子节点的height都是对的
	从新插入的节点开始，其height为1，其兄弟节点的height是不可能改变的
	所以stack中的最后一项中子节点的height是对的，并且此时stack中的节点
	是平衡的，所以会通过下面的语句将stack中的节点的height更改过来，
	else {
	int height = (heightleft&lt;heightright ? heightright : heightleft) + 1;
	if (height == node-&gt;vm_avl_height)
		break;
	node-&gt;vm_avl_height = height;
}
	然后再遍历stack中的倒数第二项，此时倒数第一项的height是对的，然后其兄弟节点的
	height也是对的，再进行对比出树是否平衡，和对树中的节点height重新赋值的时候都是
	用的是自己点的height，所以依此类推，最后遍历下来如果不平衡，则平衡过后通过子节点
	计算相应节点的高度，如果平衡，则通过上述语句，改变父节点的高度，所以最后所有节点的
	高度都会变得正常
2.当左-左或者右-右是采用单旋转，当左-右或者右-左采用双旋转，查看数据与算法分析的avl树章节。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2004</x>
      <y>628</y>
      <w>4</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1968</x>
      <y>598</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到链表中的要插入位置的指针</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1959</x>
      <y>592</y>
      <w>91</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
当链表中的count&gt;=32时，建立avl树</panel_attributes>
    <additional_attributes>10.0;10.0;890.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2041</x>
      <y>605</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mm-&gt;map_count++
build_mmap_avl(mm)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2020</x>
      <y>613</y>
      <w>44</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>avl_insert
（和avl_insert_neighbours类似，只不过少了链表相应的记录）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2042</x>
      <y>608</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1820</x>
      <y>485</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_vm_area</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1800</x>
      <y>488</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
size为要申请的大小+4k的安全区的大小
addr为从VMALLOC_START开始遍历vmlist</panel_attributes>
    <additional_attributes>250.0;10.0;30.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1794</x>
      <y>496</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>size += PAGE_SIZE;
addr = VMALLOC_START;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1825</x>
      <y>488</y>
      <w>17</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历整个vmlist链表</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1821</x>
      <y>496</y>
      <w>39</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>if (size + addr &lt; (unsigned long) tmp-&gt;addr)
	break; //如果链表中间找到了能放这个块的大小就直接退出
addr = tmp-&gt;size + (unsigned long) tmp-&gt;addr;
	//如果没找到，就更新块的初始地址，并进行下一轮循环
	//如果链表循环到头了，就将最后更新的初始地址作为要放置
	//块的初始地址
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1745</x>
      <y>497</y>
      <w>43</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>area = (struct vm_struct *) kmalloc(sizeof(*area), GFP_KERNEL);
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1767</x>
      <y>488</y>
      <w>59</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请通用内存区域作为管理结构
最后需要链入到vmlist</panel_attributes>
    <additional_attributes>570.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1826</x>
      <y>488</y>
      <w>51</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新area管理结构
并链入到vmlist</panel_attributes>
    <additional_attributes>10.0;10.0;490.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1869</x>
      <y>496</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>area-&gt;flags = flags;
area-&gt;addr = (void *)addr;
area-&gt;size = size;
area-&gt;next = *p;
*p = area;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1823</x>
      <y>472</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vmalloc
在High_Mem申请内存</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1824</x>
      <y>475</y>
      <w>14</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取存储的虚拟地址</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1764</x>
      <y>484</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>size = PAGE_ALIGN(size)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1770</x>
      <y>475</y>
      <w>68</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
size对page取整</panel_attributes>
    <additional_attributes>660.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1899</x>
      <y>484</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vmalloc_area_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1835</x>
      <y>475</y>
      <w>73</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
建立页表，为获取的虚拟地址分配
实际的物理地址</panel_attributes>
    <additional_attributes>10.0;10.0;710.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1891</x>
      <y>487</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
虚拟地址的实际目录地址
从initmm中获取（内核目录）</panel_attributes>
    <additional_attributes>170.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1888</x>
      <y>493</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dir = pgd_offset_k(address)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1924</x>
      <y>498</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_area_pmd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1905</x>
      <y>487</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pgd层面
一次只能申请一个pmd的页面
其他的通过adress&lt;end的循环
下次在申请</panel_attributes>
    <additional_attributes>40.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1905</x>
      <y>498</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pmd_alloc_kernel</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1908</x>
      <y>491</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为pgd中pmd的基地址
申请页面</panel_attributes>
    <additional_attributes>120.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1914</x>
      <y>491</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在充实整个获取的pmd页面
即多次获取pte页面填充整个pmd</panel_attributes>
    <additional_attributes>60.0;10.0;150.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1907</x>
      <y>507</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pte_alloc_kernel</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1938</x>
      <y>507</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_area_pte</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1911</x>
      <y>504</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为pmd中pte的基地址
申请页面</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1928</x>
      <y>504</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在充实整个获取的pte页面
即多次获取页面填充整个pte</panel_attributes>
    <additional_attributes>40.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1929</x>
      <y>501</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
一次只能申请一个pte页面
多的通过下一次循环来申请</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1932</x>
      <y>515</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1949</x>
      <y>515</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_pte</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1936</x>
      <y>510</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1944</x>
      <y>510</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1905</x>
      <y>514</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_pmd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1909</x>
      <y>510</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1726</x>
      <y>679</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>insert_vm_struct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1709</x>
      <y>687</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_vma_prepare</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1715</x>
      <y>682</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1657</x>
      <y>698</y>
      <w>52</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.__rb_link描述的父节点与子节点之间的→对象，初始值是描述指向根节点的→
2.找到__rb_link指向对象的实体，然后根据addr遍历整个树，
	如果addr&lt;end,就更新vma，如果addr&gt;=start，则找到，直接返回vma；如果
		addr&lt;start，则将__rb_link更新为指向左节点的→，然后继续遍历树
	如果addr&gt;end，将链表中的rb_prev（记录要找节点在链表中的头一个节点）更新，
		并将__rb_link更新成指向右节点的→，并接着遍历树
3.如果存在rb_prev，则找到相应的vma实体
	将__rb_link描述的→返回
	__rb_parent记录__rb_link的父节点
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1680</x>
      <y>690</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1753</x>
      <y>687</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__vma_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1731</x>
      <y>682</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1737</x>
      <y>693</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__vma_link_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1742</x>
      <y>690</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1712</x>
      <y>701</y>
      <w>50</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.如果rb_prev存在，就将新的vma结构插到rb_prev之后
2.如果不存在，说明所有的vma都比大，那么__rb_parent则是之前链表中最小的
	mm-&gt;mmap = vma;//将链表的头节点改成要插入的vma
	if (rb_parent) //将之前的链表链入到vma中
			vma-&gt;vm_next = rb_entry(rb_parent, struct vm_area_struct, vm_rb);
		else
			vma-&gt;vm_next = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1732</x>
      <y>696</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1799</x>
      <y>691</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__vma_link_rb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1757</x>
      <y>690</y>
      <w>49</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1765</x>
      <y>701</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rb_link_node</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1770</x>
      <y>694</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1763</x>
      <y>707</y>
      <w>46</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>node-&gt;rb_parent = parent; //设置node的附件点属性
node-&gt;rb_color = RB_RED; //将红黑树中的新节点颜色设置成红色
node-&gt;rb_left = node-&gt;rb_right = NULL;

*rb_link = node; //将→指向当前的node，这里使node成为parent的子节点
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1770</x>
      <y>704</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1817</x>
      <y>700</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rb_insert_color</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1804</x>
      <y>694</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1812</x>
      <y>708</y>
      <w>62</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>1.如果插入的节点没有父节点，或者父节点的颜色是黑色（因为插入时，新节点必然是叶子节点
	所以父节点的另一个子节点必然是红色，或者没有另一个子节点），完全不用变
2.如果父节点是红色（祖父节点必然为黑色）
	2.1父节点是祖父节点的左节点
		2.1.1如果叔叔节点为红色，将父节点和叔叔节点都涂黑，将祖父节点涂红，然后将祖父节点设置成
				新的插入节点，然后重新遍历。（思想：将红节点向根节点方向移动）
		2.1.2如果叔叔节点为黑色
			2.1.2.1如果插入的节点是父节点的右节点，将父节点右旋转，转化成下一个情况（2.1.2.2）
			2.1.2.2现在插入的节点是父节点的左节点，将祖父节点涂红，父节点涂黑，并将祖父节点
					向右旋转（这样可以使到叶子节点的所有黑节点的数目不变，并将消除了两个相连的红节点）
	2.2父节点是祖父节点的右节点
		2.2.1如果叔叔节点是红色，将叔叔节点和父节点同时涂黑，将祖父节点涂红，并将祖父节点设置成新插入
				的节点,然后继续遍历
		2.2.2如果叔叔节点是黑色
			2.2.2.1如果插入的节点是父节点的左节点，将父节点左旋转，转化成情况2.2.2.2
			2.2.2.2现在插入的节点是父节点的的右节点，将父节点涂红，将祖父节点涂黑，然后左旋转
3.如果是2.1.1或者2.2.1的情况遍历到根节点，直接将根节点涂黑
注：有3个模型：
	1.子：红 父：红  祖父：黑  叔叔：红  
		这将叔叔和父节点的红色移到祖父节点然后不断遍历
	2.子：红 父：红  祖父：黑  叔叔：黑  其中子节点和父节点不在祖父节点的同一侧
		这将父节点进行旋转，使子节点和父节点在祖父节点的同一侧，转换成第3个模型
	3.子：红 父：红  祖父：黑  叔叔：黑	 其中子节点和父节点在祖父节点的同一侧
		这父节点涂黑，祖父节点涂红，再将祖父节点进行旋转，使祖父节点成为父节点的子节点，使得
		此时父节点的左右两个树的黑色节点的数量是相同的
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1818</x>
      <y>703</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这个树因为新插入的节点是红色，所以
任意节点到子节点所经历的黑色节点是相同的</panel_attributes>
    <additional_attributes>60.0;10.0;220.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1884</x>
      <y>699</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__vma_link_file</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1804</x>
      <y>694</y>
      <w>87</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;850.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1982</x>
      <y>684</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rb_erase</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1958</x>
      <y>687</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
节点的删除</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1933</x>
      <y>694</y>
      <w>56</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果要删除的节点是叶子节点，直接删除
2.如果要删除的节点只有一个子节点，那么将这个子节点替补被删除节点的位置
3.如果要删除的节点有两个子节点，那么找到要删除节点的后继节点（即要删除节点的
	右树中的最小节点），然后将这个节点替换要删除节点的位置（除了key值不变外，
	后继节点的其他属性全和要删除的节点的属性相同，比如：左右树，颜色，父节点），
	那么情况就转换成2所描述的情况
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2005</x>
      <y>697</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__rb_erase_color</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1989</x>
      <y>687</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
当删除的节点是黑色时，
不满足红黑树的特性</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1968</x>
      <y>709</y>
      <w>88</w>
      <h>48</h>
    </coordinates>
    <panel_attributes>1.如果子节点为红色，直接将子节点涂黑
2.如果子节点是黑色
	2.1子节点是父节点的左节点
		2.1.1如果父节点的右节点（兄弟节点）为红色，此时父节点一定是黑色，所以将父节点涂红，将相抵节点涂黑
			然后再将父节点左旋转（目的是将其转换成2.1.2  2.1.3  2.1.4）
		2.1.2如果兄弟节点是黑色，并且兄弟节点的两个子节点都是黑色，那么将兄弟节点涂红，并将父节点当作新的子节点
		（这样讲子节点多的黑色移到和父节点，然后讲父节点当作新的子节点进行遍历）
		2.1.3如果兄弟节点是黑色，兄弟节点的右节点是黑色，但是兄弟节点的左节点是红色，那么将兄弟节点的左节点涂黑
			兄弟节点涂红，然后再将兄弟节点右旋转（转换成2.1.4）
		2.1.4如果兄弟节点是黑色，兄弟节点额右节点是红色，兄弟节点的左节点是黑色，那么将父节点的颜色赋给兄弟节点，
			将父节点涂黑，将兄弟节点的右节点涂黑，将兄弟节点左旋转（这是让父节点在左旋转之后，左树黑节点的数量+1，右树黑节点的数目因为
			兄弟节点的右节点涂黑而保持不变）
	2.2子节点是父节点的右节点
		2.2.1如果兄弟系节点是红色，将兄弟节点涂黑，父节点涂红，然后将父节点右旋转（转换成2.2.2  2.2.3  2.2.4）
		2.2.2如果兄弟节点是黑色，兄弟节点的两个子节点都是黑色，那么将兄弟节点涂红（将兄弟节点和子节点多出来的黑色
				移到父节点）
		2.2.3如果父节点是黑色，兄弟节点的左节点是黑色，兄弟节点右节点是红色，将兄弟节点涂红，兄弟节点的右节点涂黑，
				然后将兄弟节点左旋转（转换成2.2.4）
		2.2.4如果父节点是黑色，兄弟节的左节点是红色，兄弟节点的右节点是黑色，那么将父节点的夜色赋给兄弟节点，父节点涂黑
				兄弟节点的左节点涂黑，然后将父节点右旋转
3.如果2.1.2和2.2.2遍历到根节点，那么直接将根节点涂黑	

注：有4个模型：
	1.子：黑  兄弟：红  兄弟左：黑  兄弟右：黑  父节点：黑     将父节点与兄弟节点的颜色交换，然后将父节点旋转，将模型转化成以下三种
	2.子：黑  兄弟：黑  兄弟左：黑  兄弟右：黑  父节点：unkown 将兄弟节点涂红，然后将删除结点的颜色上移
	3.子：黑  兄弟：黑  红色的兄弟子节点和兄弟节点不在同一侧  父节点：unknown 将那个不在同一侧的子节点的颜色和兄弟节点交换，然后
																						将兄弟节点旋转，转化成4
	4.子：黑  兄弟：黑  红色的兄弟子节点和兄弟节点在同一侧  父节点：unknown  将父节点和兄弟节点的颜色交换，将红色的兄弟子节点涂黑
																						然后将父节点旋转
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1995</x>
      <y>700</y>
      <w>22</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
替代原来删除节点
称呼为子节点
此时子节点除了包含自己的黑色外
还包含了删除节点的黑色
即子节点的颜色为黑+黑</panel_attributes>
    <additional_attributes>180.0;10.0;30.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1284</x>
      <y>551</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_mmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1289</x>
      <y>554</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
offset要对page对齐</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1305</x>
      <y>564</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_mmap_pgoff</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1135</x>
      <y>594</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_unmapped_area</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1142</x>
      <y>567</y>
      <w>171</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1690.0;10.0;10.0;270.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1092</x>
      <y>602</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>addr
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1097</x>
      <y>597</y>
      <w>45</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
必须以指定的地址进行mapping
这里会检查指定地址addr的有效性</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1121</x>
      <y>603</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;get_unmapped_area
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1130</x>
      <y>597</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要map的文件对
所要map的地址有要求</panel_attributes>
    <additional_attributes>130.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1151</x>
      <y>603</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arch_get_unmapped_area</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1143</x>
      <y>597</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1143</x>
      <y>612</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_vma</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1146</x>
      <y>606</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
addr = PAGE_ALIGN(addr)</panel_attributes>
    <additional_attributes>150.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1144</x>
      <y>615</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!vma || addr + len &lt;= vma-&gt;vm_start
用指定的addr没找到相应的vma区域
则用指定的addr作为新文件的map</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1140</x>
      <y>620</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>addr
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1162</x>
      <y>606</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
addr = PAGE_ALIGN(TASK_UNMAPPED_BASE)
从1G的位置开始找
看已经map的vma的两个之间是否能容纳下
需要map的区域</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1170</x>
      <y>614</y>
      <w>45</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>for (vma = find_vma(current-&gt;mm, addr); ; vma = vma-&gt;vm_next)
	if (TASK_SIZE - len &lt; addr)
			return -ENOMEM;
		if (!vma || addr + len &lt;= vma-&gt;vm_start)
			return addr;
		addr = vma-&gt;vm_end
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1184</x>
      <y>567</y>
      <w>129</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
vm_flags &amp; VM_LOCKED
如果要求将这段内存锁住
就查看是否超过了限制</panel_attributes>
    <additional_attributes>1270.0;10.0;10.0;290.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1155</x>
      <y>596</y>
      <w>52</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mm-&gt;locked_vm &lt;&lt; PAGE_SHIFT+len=current-&gt;rlim[RLIMIT_MEMLOCK].rlim_cur
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1217</x>
      <y>567</y>
      <w>96</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file不存在
虚拟内存和物理内存并不发生映射

file存在
物理的file与虚拟内存发生映射
此时需要考虑file的mode</panel_attributes>
    <additional_attributes>940.0;10.0;10.0;310.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1211</x>
      <y>598</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vm_flags
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1256</x>
      <y>567</y>
      <w>57</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为之前有MAP_FIXED的参数
在get_unmapped_area没有检测是否重合
</panel_attributes>
    <additional_attributes>550.0;10.0;10.0;310.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1236</x>
      <y>597</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1231</x>
      <y>603</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_vma_prepare</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1259</x>
      <y>601</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_munmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1248</x>
      <y>597</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
vma &amp;&amp; vma-&gt;vm_start &lt; addr + len
如果要map的虚拟地址上已经map，看是否
能解除map，如果不能要返回错误信息
</panel_attributes>
    <additional_attributes>90.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1247</x>
      <y>608</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_vma_prev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1254</x>
      <y>604</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1244</x>
      <y>611</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1265</x>
      <y>614</y>
      <w>39</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>for ( ; mpnt &amp;&amp; mpnt-&gt;vm_start &lt; addr+len; mpnt = *npp) {
	*npp = mpnt-&gt;vm_next; //保存要释放的vma的下一个节点
	//将要释放的vma链入到free指向的链表中
	mpnt-&gt;vm_next = free;
	free = mpnt;
	//将这个节点从红黑树中删除
	rb_erase(&amp;mpnt-&gt;vm_rb, &amp;mm-&gt;mm_rb);
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1265</x>
      <y>604</y>
      <w>20</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1265</x>
      <y>604</y>
      <w>51</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
free链表有要释放的vma
</panel_attributes>
    <additional_attributes>10.0;10.0;490.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1305</x>
      <y>618</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>remove_shared_vm_struct(mpnt)
mm-&gt;map_count--
extra = unmap_fixup(mm, mpnt, st, size, extra)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1506</x>
      <y>617</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_pgtables</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1265</x>
      <y>604</y>
      <w>247</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
用于释放页目录和页表</panel_attributes>
    <additional_attributes>10.0;10.0;2450.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1343</x>
      <y>619</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>zap_page_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1312</x>
      <y>612</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1312</x>
      <y>612</y>
      <w>38</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
用于释放page
</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1331</x>
      <y>628</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>zap_pmd_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1350</x>
      <y>628</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mm-&gt;rss -= freed
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1336</x>
      <y>622</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1347</x>
      <y>622</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1323</x>
      <y>636</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>zap_pte_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1329</x>
      <y>631</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1425</x>
      <y>446</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_brk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1429</x>
      <y>449</y>
      <w>13</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
brk &lt;= mm-&gt;brk</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1424</x>
      <y>457</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_munmap
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1315</x>
      <y>643</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ptep_get_and_clear</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1321</x>
      <y>639</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1305</x>
      <y>650</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>xchg(&amp;(xp)-&gt;pte_low, 0)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1315</x>
      <y>646</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将pte清空</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1333</x>
      <y>644</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_pte</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1328</x>
      <y>639</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放物理页面
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1321</x>
      <y>647</y>
      <w>19</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pte_present(pte)</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1338</x>
      <y>647</y>
      <w>68</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;660.0;220.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1398</x>
      <y>669</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>swap_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1305</x>
      <y>658</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1283</x>
      <y>662</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>!VALID_PAGE(page)) || PageReserved(page)
if (pte_dirty(pte) &amp;&amp; page-&gt;mapping)
	set_page_dirty(page);
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1318</x>
      <y>662</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_page_and_swap_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1322</x>
      <y>658</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1380</x>
      <y>617</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unmap_fixup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1265</x>
      <y>604</y>
      <w>122</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1200.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1346</x>
      <y>633</y>
      <w>32</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>area-&gt;vm_mm-&gt;total_vm -= len &gt;&gt; PAGE_SHIFT
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1361</x>
      <y>620</y>
      <w>26</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1379</x>
      <y>633</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>area-&gt;vm_ops-&gt;close(area)
fput(area-&gt;vm_file)
kmem_cache_free(vm_area_cachep, area)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1383</x>
      <y>620</y>
      <w>34</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这个vma全释放
addr == area-&gt;vm_start &amp;&amp; end == area-&gt;vm_end
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1408</x>
      <y>634</y>
      <w>38</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>area-&gt;vm_pgoff += (end - area-&gt;vm_start) &gt;&gt; PAGE_SHIFT;
area-&gt;vm_start = end;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1384</x>
      <y>620</y>
      <w>31</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放后半部分
end == area-&gt;vm_end
</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1384</x>
      <y>620</y>
      <w>71</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
中间的hole</panel_attributes>
    <additional_attributes>10.0;10.0;690.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1448</x>
      <y>632</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>mpnt，表示hole后半部的vma
area：表示hole前半部的vma
__insert_vm_struct(mm, mpnt);//先插入mpnt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1480</x>
      <y>633</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__insert_vm_struct(mm, area)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1385</x>
      <y>620</y>
      <w>104</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
area一起插入</panel_attributes>
    <additional_attributes>10.0;10.0;1020.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1505</x>
      <y>625</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>clear_page_tables</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1505</x>
      <y>632</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_one_pgd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1511</x>
      <y>620</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1511</x>
      <y>628</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1505</x>
      <y>639</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_one_pmd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1511</x>
      <y>635</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1498</x>
      <y>645</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pmd_clear</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1503</x>
      <y>642</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1515</x>
      <y>645</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pte_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1511</x>
      <y>642</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1493</x>
      <y>651</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes> set_pmd(xp, __pmd(0))
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1502</x>
      <y>648</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1516</x>
      <y>651</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pte_free_fast</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1522</x>
      <y>648</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1515</x>
      <y>657</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pte_quicklist
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1522</x>
      <y>654</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1401</x>
      <y>586</y>
      <w>54</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>filter1:vma的长度不能超过限制
mm-&gt;total_vm &lt;&lt; PAGE_SHIFT) + len
&gt; current-&gt;rlim[RLIMIT_AS].rlim_cur
filter2：如果是独享这个虚拟内存空间则要有足够的物理内存
(vm_flags &amp; (VM_SHARED | VM_WRITE)) == VM_WRITE &amp;&amp;
 !(flags &amp; MAP_NORESERVE)				 &amp;&amp;
 !vm_enough_memory(len &gt;&gt; PAGE_SHIFT)
filter3：如果没有映射文件且这个虚拟地址独享，使用vma_merge看
是否能将vma合并
vma_merge：
1.如果不存在比addr小的vma，直接看这个vma是否能和红黑树的头节点合并
2.如果存在比addr小的vma，看这个vma能否和要新建的vma合并，然后再看是否
能和之后的vma合并，如果能和之后的vma合并。如果两者都能合并，就将后面vma的
管理结构从红黑树中删除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1170</x>
      <y>433</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ioremap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1170</x>
      <y>440</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__ioremap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1175</x>
      <y>436</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1167</x>
      <y>443</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
错误性检查

</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1149</x>
      <y>447</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!size || last_addr &lt; phys_addr</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1144</x>
      <y>453</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>Null
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1161</x>
      <y>453</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>phys_to_virt(phys_addr)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>447</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
phys_addr &gt;= 0xA0000 &amp;&amp; last_addr &lt; 0x100000</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1185</x>
      <y>453</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>Null
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1166</x>
      <y>447</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
phys_addr &lt; virt_to_phys(high_memory)
!PageReserved(page)</panel_attributes>
    <additional_attributes>30.0;10.0;230.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1202</x>
      <y>452</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>offset = phys_addr &amp; ~PAGE_MASK;
phys_addr &amp;= PAGE_MASK;
size = PAGE_ALIGN(last_addr) - phys_addr;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1175</x>
      <y>443</y>
      <w>38</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1238</x>
      <y>453</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_vm_area
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1175</x>
      <y>443</y>
      <w>71</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
size, VM_IOREMAP</panel_attributes>
    <additional_attributes>10.0;10.0;690.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1255</x>
      <y>453</y>
      <w>13</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>addr = area-&gt;addr
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1174</x>
      <y>443</y>
      <w>90</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;880.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1271</x>
      <y>452</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remap_area_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1175</x>
      <y>443</y>
      <w>106</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1040.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1249</x>
      <y>460</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>dir = pgd_offset(&amp;init_mm, address)
phys_addr -= address
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1269</x>
      <y>455</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
记录物理地址和
虚拟地址的偏移量</panel_attributes>
    <additional_attributes>100.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1279</x>
      <y>460</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remap_area_pmd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1297</x>
      <y>459</y>
      <w>36</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>address = (address + PGDIR_SIZE) &amp; PGDIR_MASK;
dir++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1279</x>
      <y>455</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1279</x>
      <y>455</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1266</x>
      <y>468</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pte_alloc_kernel</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1271</x>
      <y>463</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1282</x>
      <y>468</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remap_area_pte</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1300</x>
      <y>468</y>
      <w>36</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>address = (address + PMD_SIZE) &amp; PMD_MASK;
pmd++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1286</x>
      <y>463</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1286</x>
      <y>463</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1245</x>
      <y>467</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>address &amp;= ~PGDIR_MASK;
end = address + size;
if (end &gt; PGDIR_SIZE)
	end = PGDIR_SIZE;
phys_addr -= address;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1256</x>
      <y>463</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1252</x>
      <y>479</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>address &amp;= ~PMD_MASK;
end = address + size;
if (end &gt; PMD_SIZE)
	end = PMD_SIZE;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1261</x>
      <y>471</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1274</x>
      <y>481</y>
      <w>53</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>set_pte(pte, mk_pte_phys(phys_addr, __pgprot(_PAGE_PRESENT | _PAGE_RW | 
					_PAGE_DIRTY | _PAGE_ACCESSED | flags)));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1287</x>
      <y>471</y>
      <w>6</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1330</x>
      <y>480</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>address += PAGE_SIZE;
phys_addr += PAGE_SIZE;
pte++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1287</x>
      <y>471</y>
      <w>52</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1402</x>
      <y>456</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_brk
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1406</x>
      <y>449</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
oldbrk == newbrk</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1399</x>
      <y>676</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__swap_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1404</x>
      <y>672</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1355</x>
      <y>687</y>
      <w>42</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>type = SWP_TYPE(entry)//pte记录数据的第1~7位。
							//表示交换设备的序号
							//第0位表示present，
p = &amp; swap_info[type]						
offset = SWP_OFFSET(entry)	//第8~31位表示在交换设备中的偏移
p-&gt;swap_map[offset]//记录着引用计数
if (p-&gt;prio &gt; swap_info[swap_list.next].prio)
	swap_list.next = type; //todo:暂时不清楚swap_list
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1391</x>
      <y>679</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1403</x>
      <y>679</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果swap_map[offset]没减到0
则不做任何变化
如果减到0
</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1403</x>
      <y>687</y>
      <w>30</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>if (offset &lt; p-&gt;lowest_bit)
	p-&gt;lowest_bit = offset;
if (offset &gt; p-&gt;highest_bit)
	p-&gt;highest_bit = offset;
	 //lowest_bit和highest_bit表示可供swap的范围
nr_swap_pages++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1330</x>
      <y>669</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1330</x>
      <y>665</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1346</x>
      <y>675</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__free_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1336</x>
      <y>672</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1355</x>
      <y>682</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__free_pages
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1353</x>
      <y>678</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1308</x>
      <y>665</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(PageSwapCache(page) &amp;&amp; !TryLockPage(page)
!is_page_shared(page)</panel_attributes>
    <additional_attributes>200.0;10.0;123.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1301</x>
      <y>670</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>delete_from_swap_cache_nolock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1271</x>
      <y>673</y>
      <w>42</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>400.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1265</x>
      <y>678</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_flushpage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1281</x>
      <y>678</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lru_cache_del</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1290</x>
      <y>673</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1310</x>
      <y>677</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__delete_from_swap_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1310</x>
      <y>673</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1279</x>
      <y>685</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__lru_cache_del</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1285</x>
      <y>681</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1259</x>
      <y>692</y>
      <w>28</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>if (PageActive(page)) {
	del_page_from_active_list(page);
} else if (PageInactiveDirty(page)) {
	del_page_from_inactive_dirty_list(page);
} else if (PageInactiveClean(page)) {
	del_page_from_inactive_clean_list(page);
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1271</x>
      <y>688</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1297</x>
      <y>678</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ClearPageDirty
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1303</x>
      <y>673</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1320</x>
      <y>687</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>entry.val = page-&gt;index
swap_free(entry);
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1297</x>
      <y>687</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_from_swap_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1306</x>
      <y>680</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1319</x>
      <y>680</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1288</x>
      <y>695</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>PageClearSwapCache(page);
ClearPageDirty(page);
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1297</x>
      <y>690</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1311</x>
      <y>695</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__remove_inode_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1306</x>
      <y>690</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1331</x>
      <y>677</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1311</x>
      <y>673</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1410</x>
      <y>458</y>
      <w>16</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1399</x>
      <y>464</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mm-&gt;brk = brk
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1405</x>
      <y>459</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1440</x>
      <y>457</y>
      <w>36</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rlim &lt; RLIM_INFINITY &amp;&amp; brk - mm-&gt;start_data &gt; rlim
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1482</x>
      <y>457</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_vma_intersection</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1430</x>
      <y>449</y>
      <w>30</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
错误检查</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1454</x>
      <y>451</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
是否超出限制</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1456</x>
      <y>451</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
要申请的区域已经映射</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1506</x>
      <y>457</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vm_enough_memory</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1457</x>
      <y>451</y>
      <w>60</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
是否由足够的物理内存</panel_attributes>
    <additional_attributes>10.0;10.0;580.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1529</x>
      <y>457</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_brk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1431</x>
      <y>449</y>
      <w>106</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1040.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1456</x>
      <y>468</y>
      <w>39</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locked+len &gt; current-&gt;rlim[RLIMIT_MEMLOCK].rlim_cur
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1482</x>
      <y>460</y>
      <w>55</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>530.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1500</x>
      <y>468</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_munmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1505</x>
      <y>460</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1515</x>
      <y>469</y>
      <w>49</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>mm-&gt;total_vm &lt;&lt; PAGE_SHIFT) + len &gt; current-&gt;rlim[RLIMIT_AS].rlim_cur
mm-&gt;map_count &gt; MAX_MAP_COUNT
!vm_enough_memory(len &gt;&gt; PAGE_SHIFT)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1534</x>
      <y>460</y>
      <w>3</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1566</x>
      <y>468</y>
      <w>37</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>struct vm_area_struct * vma = find_vma(mm, addr-1);
if (vma &amp;&amp; vma-&gt;vm_end == addr &amp;&amp; !vma-&gt;vm_file &amp;&amp; 
    vma-&gt;vm_flags == flags) {
	vma-&gt;vm_end = addr + len;
	goto out;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1534</x>
      <y>460</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要申请的vma和之前的vma相连并且
属性相同，则将两个vma合并</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1604</x>
      <y>469</y>
      <w>44</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
vma-&gt;vm_mm = mm;
vma-&gt;vm_start = addr;
vma-&gt;vm_end = addr + len;
vma-&gt;vm_flags = flags;
vma-&gt;vm_page_prot = protection_map[flags &amp; 0x0f];
vma-&gt;vm_ops = NULL;
vma-&gt;vm_pgoff = 0;
vma-&gt;vm_file = NULL;
vma-&gt;vm_private_data = NULL;

insert_vm_struct(mm, vma);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1534</x>
      <y>460</y>
      <w>84</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不能合并，申请新的vma</panel_attributes>
    <additional_attributes>10.0;10.0;820.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1662</x>
      <y>469</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1534</x>
      <y>460</y>
      <w>133</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1310.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1649</x>
      <y>476</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1657</x>
      <y>472</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1665</x>
      <y>472</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flags &amp; VM_LOCKED</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1652</x>
      <y>481</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mm-&gt;locked_vm += len &gt;&gt; PAGE_SHIFT;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1672</x>
      <y>475</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1682</x>
      <y>481</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>make_pages_present</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1679</x>
      <y>475</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1664</x>
      <y>490</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_vma</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1669</x>
      <y>484</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1679</x>
      <y>491</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_mm_fault</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1685</x>
      <y>484</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1683</x>
      <y>487</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1687</x>
      <y>487</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1988</x>
      <y>467</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1974</x>
      <y>470</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1971</x>
      <y>476</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.释放地址不能为空
2.释放地址要按页对齐
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1993</x>
      <y>470</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历vmlist
如果其中的vma
地址和要释放的地址相同</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1983</x>
      <y>482</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>*p = tmp-&gt;next;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1986</x>
      <y>474</y>
      <w>12</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新vmlist链表</panel_attributes>
    <additional_attributes>90.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1997</x>
      <y>481</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vmfree_area_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1994</x>
      <y>474</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
&lt;&lt;includes&gt;&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1985</x>
      <y>488</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>dir = pgd_offset_k(address)
do {
	free_area_pmd(dir, address, end - address);
	address = (address + PGDIR_SIZE) &amp; PGDIR_MASK;
	dir++;
} while (address &amp;&amp; (address &lt; end));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1998</x>
      <y>484</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放页表和页面</panel_attributes>
    <additional_attributes>70.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2017</x>
      <y>481</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kfree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1994</x>
      <y>474</y>
      <w>28</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放vma内存temp</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1309</x>
      <y>567</y>
      <w>102</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1000.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1530</x>
      <y>580</y>
      <w>75</w>
      <h>72</h>
    </coordinates>
    <panel_attributes>vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL)
vma-&gt;vm_mm = mm;
vma-&gt;vm_start = addr;
vma-&gt;vm_end = addr + len;
vma-&gt;vm_flags = vm_flags;
vma-&gt;vm_page_prot = protection_map[vm_flags &amp; 0x0f];
vma-&gt;vm_ops = NULL;
vma-&gt;vm_pgoff = pgoff;
vma-&gt;vm_file = NULL;
vma-&gt;vm_private_data = NULL;
vma-&gt;vm_raend = 0;
if (file) {//如果file存在
	error = -EINVAL;
	if (vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP))
		goto free_vma;
	if (vm_flags &amp; VM_DENYWRITE) {//只允许一个写
		error = deny_write_access(file);//加保护
		if (error)
			goto free_vma;
		correct_wcount = 1;
	}
	vma-&gt;vm_file = file;//映射文件赋值
	get_file(file);//增加文件的引用
	error = file-&gt;f_op-&gt;mmap(file, vma);//将文件映射到虚拟地址
	if (error)
		goto unmap_and_free_vma;
} else if (flags &amp; MAP_SHARED) {
	error = shmem_zero_setup(vma);//如果共享，分配
	if (error)
		goto free_vma;
}
addr = vma-&gt;vm_start;

vma_link(mm, vma, prev, rb_link, rb_parent);//红黑树更新
if (correct_wcount)
	atomic_inc(&amp;file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount);//打开写保护

out:	
	mm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT;
	if (vm_flags &amp; VM_LOCKED) {
		mm-&gt;locked_vm += len &gt;&gt; PAGE_SHIFT;
		make_pages_present(addr, addr + len);//通过模拟页面中断将file读取进来
	}
	return addr;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1310</x>
      <y>567</y>
      <w>226</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2240.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1920</x>
      <y>601</y>
      <w>42</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>pprev = &amp;mm-&gt;mmap;
while (*pprev &amp;&amp; (*pprev)-&gt;vm_start &lt;= vmp-&gt;vm_start)
	pprev = &amp;(*pprev)-&gt;vm_next; //二重指针,指向(*pprev)-&gt;vm_next
										//这样既可以记住前一个vma的vm_next的位置，
										//也可以找到下一个vma
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2016</x>
      <y>605</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vmp-&gt;vm_next = *pprev;
*pprev = vmp; 
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1981</x>
      <y>605</y>
      <w>31</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pprev = (prev ? &amp;prev-&gt;vm_next : &amp;mm-&gt;mmap)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1222</x>
      <y>614</y>
      <w>39</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>if (vma) {
	if (vma-&gt;vm_rb.rb_left) {  //null表示addr&lt;vma.start
							//!=null表示addr在vma map的范围内
		rb_prev = vma-&gt;vm_rb.rb_left;
		while (rb_prev-&gt;rb_right)
			rb_prev = rb_prev-&gt;rb_right;//如果addr在vma map的范围内
				//那么vma的左节点的最右节点，则为vma在链表中的prev节点
	}
	*pprev = NULL;
	if (rb_prev)
		*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);
	if ((rb_prev ? (*pprev)-&gt;vm_next : mm-&gt;mmap) != vma)
		BUG();
	return vma;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1695</x>
      <y>491</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>addr += PAGE_SIZE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1398</x>
      <y>843</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_page_fault</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1279</x>
      <y>875</y>
      <w>30</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__asm__("movl %%cr2,%0":"=r" (address))
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1292</x>
      <y>846</y>
      <w>115</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
存储发生页面中断的地址（cr2）到adress中
</panel_attributes>
    <additional_attributes>1130.0;10.0;10.0;290.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1305</x>
      <y>897</y>
      <w>63</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.为什么用户程序没办法访问系统空间？
	通过find_vma可知，只有在内存访问到的地址大于其最大的end_adress时，才会返回NULL
	而一个进程最大的end_address是其栈的起始地址，也就是0xBFFFFFFF处，在往上就是3G
	所在的空间，所以当访问3G以上的空间时，则find_vma则返回Null,从而进入bad_area处。
2.为什么系统规定的用户态程序可以访问系统空间呢？
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1315</x>
      <y>876</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>no_context
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1321</x>
      <y>846</y>
      <w>86</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
in_interrupt() || !mm
处于中断，或者不是当前进程的上下文</panel_attributes>
    <additional_attributes>840.0;10.0;10.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1336</x>
      <y>877</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>down</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1341</x>
      <y>846</y>
      <w>66</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
&amp;mm-&gt;mmap_sem</panel_attributes>
    <additional_attributes>640.0;10.0;10.0;310.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1336</x>
      <y>884</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__down</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1341</x>
      <y>880</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1355</x>
      <y>877</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_vma</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1360</x>
      <y>846</y>
      <w>47</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;310.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1350</x>
      <y>885</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bad_area
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1355</x>
      <y>880</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!vma</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1376</x>
      <y>846</y>
      <w>43</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果空洞的上方区域不是堆栈
(!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;310.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1370</x>
      <y>877</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bad_area
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1402</x>
      <y>846</y>
      <w>44</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果空洞的上方区域是堆栈
并且检查不是认为的故意操作address + 32 &lt; regs-&gt;esp
因为cpu提供的对栈的操作，最大的的pusha，一次性压入32字节</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;310.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1396</x>
      <y>877</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expand_stack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1365</x>
      <y>884</y>
      <w>33</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>address &amp;= PAGE_MASK;
grow = (vma-&gt;vm_start - address) &gt;&gt; PAGE_SHIFT;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1380</x>
      <y>880</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将发生页面错误的地址对页取整
并将重新分配的栈也要对页取整</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1399</x>
      <y>885</y>
      <w>57</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>(vma-&gt;vm_end - address &gt; current-&gt;rlim[RLIMIT_STACK].rlim_cur ||
 ((vma-&gt;vm_mm-&gt;total_vm + grow) &lt;&lt; PAGE_SHIFT) &gt; current-&gt;rlim[RLIMIT_AS].rlim_cur)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1392</x>
      <y>880</y>
      <w>37</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
所有栈所占的大小不能超过rlim[RLIMIT_STACK]中的规定
进程使用页面的大小不能超过rlim[RLIMIT_AS]中的规定</panel_attributes>
    <additional_attributes>80.0;10.0;280.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1458</x>
      <y>883</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>vma-&gt;vm_start = address;
vma-&gt;vm_pgoff -= grow;
vma-&gt;vm_mm-&gt;total_vm += grow;
if (vma-&gt;vm_flags &amp; VM_LOCKED)
	vma-&gt;vm_mm-&gt;locked_vm += grow;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1399</x>
      <y>880</y>
      <w>72</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
对栈的vma进行重新设置</panel_attributes>
    <additional_attributes>10.0;10.0;700.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1404</x>
      <y>846</y>
      <w>97</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;950.0;310.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1492</x>
      <y>877</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>good_area
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1483</x>
      <y>885</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>分析error_code:
1.如果是0x10，表示写操作，没页面映射
	所以和检测这个vma是否有写权限
	!(vma-&gt;vm_flags &amp; VM_WRITE)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1494</x>
      <y>880</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1554</x>
      <y>866</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_mm_fault</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1404</x>
      <y>846</y>
      <w>155</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1530.0;200.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1522</x>
      <y>869</y>
      <w>39</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
算出地址在页目录下的偏移</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1518</x>
      <y>884</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pgd = pgd_offset(mm, address);
pmd = pmd_alloc(pgd, address);
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1555</x>
      <y>869</y>
      <w>17</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
得到页表中的首地址</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1550</x>
      <y>885</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pte_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1517</x>
      <y>893</y>
      <w>42</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>address = (address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1534</x>
      <y>888</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
计算页面在页表中的偏移</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1555</x>
      <y>888</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pmd_none(*pmd)
如果页面不存在</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1561</x>
      <y>894</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getnew
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1555</x>
      <y>888</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pmd_none(*pmd)
如果页面存在，但是
相应的位没置上</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1575</x>
      <y>893</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fix
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1556</x>
      <y>888</y>
      <w>49</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果存在页表</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1586</x>
      <y>893</y>
      <w>37</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return (pte_t *)pmd_page(*pmd) + __pte_offset(address);
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1542</x>
      <y>901</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_pte_fast</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1546</x>
      <y>897</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从进程的缓冲池中获取之前用过的pte</panel_attributes>
    <additional_attributes>200.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1516</x>
      <y>908</y>
      <w>42</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>free_pte_fast（将pte加到缓冲链表中）
1.将上一个存储pte的pte_quicklist存放到将要释放的pte的第一项
2.将pte_quicklist指向将要释放的pte
3.pgtable_cache_size++

free_pte_fast（从缓冲池中换取pte）：
1.获取此时pte_quicklist，也就是要获取的pte
2.将pte_quicklist指向将要获取pte中的第一项
3.将获取到的pte中的第一项还原ret[0] = ret[1];
4.pgtable_cache_size--;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1535</x>
      <y>904</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1564</x>
      <y>897</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果缓冲池中没有
</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1570</x>
      <y>901</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_pte_slow</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1561</x>
      <y>907</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_free_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1565</x>
      <y>904</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
GFP_KERNEL，0</panel_attributes>
    <additional_attributes>110.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1560</x>
      <y>914</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1565</x>
      <y>910</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1675</x>
      <y>872</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_pte_fault</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1558</x>
      <y>869</y>
      <w>124</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
得到页表中的首地址</panel_attributes>
    <additional_attributes>10.0;10.0;1220.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1678</x>
      <y>875</y>
      <w>12</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!pte_present
</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1632</x>
      <y>888</y>
      <w>49</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pte_none</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1628</x>
      <y>898</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_no_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1704</x>
      <y>891</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_swap_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1678</x>
      <y>888</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page换入</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1609</x>
      <y>917</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vma-&gt;vm_ops-&gt;nopage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1616</x>
      <y>901</y>
      <w>21</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1605</x>
      <y>907</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_anonymous_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1610</x>
      <y>901</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!vma-&gt;vm_ops || !vma-&gt;vm_ops-&gt;nopage
如果vma没有堆内存指定相应的文件操作</panel_attributes>
    <additional_attributes>230.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1532</x>
      <y>927</y>
      <w>45</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pte_wrprotect(mk_pte(ZERO_PAGE(addr), vma-&gt;vm_page_prot))
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1553</x>
      <y>910</y>
      <w>62</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>600.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1503</x>
      <y>939</y>
      <w>60</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>ZERO_PAGE(addr)：获取0x4000(实际物理地址)empty_zero_page所在页面的mem_map结构
mk_pte(ZERO_PAGE(addr), vma-&gt;vm_page_prot)：
获取empty_zero_page在页面的实际物理地址并或（|）vma-&gt;vm_page_prot
pte_wrprotect：将地址的R/W位置0（只读）

所以这一句话是将指向empty_zero_page，并将RW位置0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1529</x>
      <y>930</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1580</x>
      <y>910</y>
      <w>35</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
write_access
如果需要写操作</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;250.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1571</x>
      <y>940</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1575</x>
      <y>934</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1584</x>
      <y>940</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>clear_user_highpage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1580</x>
      <y>934</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1603</x>
      <y>940</y>
      <w>43</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pte_mkwrite(pte_mkdirty(mk_pte(page, vma-&gt;vm_page_prot)))
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1580</x>
      <y>934</y>
      <w>43</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1648</x>
      <y>940</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_page_to_ram</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1581</x>
      <y>934</y>
      <w>75</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;730.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1667</x>
      <y>940</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_pte(page_table, entry)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1580</x>
      <y>934</y>
      <w>98</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;960.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1687</x>
      <y>940</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>update_mmu_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1581</x>
      <y>934</y>
      <w>115</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是独立的MMU模块则需要
否则，这个位空函数</panel_attributes>
    <additional_attributes>10.0;10.0;1130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1833</x>
      <y>887</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_wp_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1681</x>
      <y>875</y>
      <w>159</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
write_access
&amp;&amp;!pte_write(entry)
</panel_attributes>
    <additional_attributes>10.0;10.0;1570.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1834</x>
      <y>890</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!TryLockPage(old_page)</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1843</x>
      <y>895</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1837</x>
      <y>890</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1862</x>
      <y>894</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_cow_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1838</x>
      <y>890</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1857</x>
      <y>897</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ZERO_PAGE(address)</panel_attributes>
    <additional_attributes>100.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1852</x>
      <y>903</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>clear_user_highpage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1871</x>
      <y>902</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_user_highpage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1867</x>
      <y>897</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
else</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1874</x>
      <y>907</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_user_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1877</x>
      <y>905</y>
      <w>6</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1866</x>
      <y>913</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1870</x>
      <y>910</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CACHE_ALIAS</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1839</x>
      <y>890</y>
      <w>57</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pte_same(*page_table, pte)</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1888</x>
      <y>893</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>break_cow</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1879</x>
      <y>898</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_page_to_ram</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1895</x>
      <y>899</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_cache_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1911</x>
      <y>899</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>establish_pte</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1884</x>
      <y>896</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1893</x>
      <y>896</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1893</x>
      <y>896</y>
      <w>26</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1902</x>
      <y>906</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_pte</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1919</x>
      <y>907</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_tlb_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1906</x>
      <y>902</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1917</x>
      <y>902</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1919</x>
      <y>893</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1839</x>
      <y>890</y>
      <w>90</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
new_page = old_page
old_page</panel_attributes>
    <additional_attributes>10.0;10.0;880.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1666</x>
      <y>896</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_swap_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1675</x>
      <y>894</y>
      <w>36</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1657</x>
      <y>901</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_lock_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1663</x>
      <y>899</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1650</x>
      <y>906</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__find_lock_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1655</x>
      <y>904</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1641</x>
      <y>911</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__find_page_nolock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1647</x>
      <y>909</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1635</x>
      <y>914</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page-&gt;index == offset</panel_attributes>
    <additional_attributes>110.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1630</x>
      <y>922</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>age_page_up</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1596</x>
      <y>929</y>
      <w>47</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>if (!page-&gt;age)
	activate_page(page);--&gt;activate_page_nolock--&gt;add_page_to_active_list
page-&gt;age += PAGE_AGE_ADV
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1646</x>
      <y>930</y>
      <w>40</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>if (inactive_shortage() &gt; inactive_target / 2 &amp;&amp; free_shortage())
		wakeup_kswapd(0);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1635</x>
      <y>918</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1631</x>
      <y>925</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1638</x>
      <y>918</y>
      <w>28</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1652</x>
      <y>909</y>
      <w>17</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page-&gt;mapping
因为只有在kreclaimd将
page真正释放掉的时候，
这个mapping才会被清</panel_attributes>
    <additional_attributes>20.0;10.0;140.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1658</x>
      <y>917</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_get
return page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1709</x>
      <y>894</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!page</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1804</x>
      <y>903</y>
      <w>29</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>mm-&gt;rss++
mk_pte
swap_free(entry);
if (write_access &amp;&amp; !is_page_shared(page))
	pte = pte_mkwrite(pte_mkdirty(pte));
set_pte(page_table, pte)
update_mmu_cache(vma, address, pte)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1710</x>
      <y>894</y>
      <w>109</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1070.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1702</x>
      <y>899</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1696</x>
      <y>904</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>swapin_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1726</x>
      <y>905</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_swap_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1713</x>
      <y>899</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1678</x>
      <y>909</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>valid_swaphandles</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1683</x>
      <y>906</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
计算预读的页数</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1654</x>
      <y>922</y>
      <w>31</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>*offset = (*offset &gt;&gt; page_cluster) &lt;&lt; page_cluster
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1669</x>
      <y>912</y>
      <w>16</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1685</x>
      <y>920</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>swapdev-&gt;swap_map[toff]++;
toff++;
ret++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1682</x>
      <y>912</y>
      <w>12</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1733</x>
      <y>911</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_swap_cache_async</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1704</x>
      <y>908</y>
      <w>65</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从下面这个函数出去的page
盘上页面计数包含：进程的计数和swap_space的计数
内存内面计数包含：进程+__get_free_page的1个计数（swap_space转换成当前进程对page的引用）</panel_attributes>
    <additional_attributes>260.0;10.0;380.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1722</x>
      <y>914</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
之前已经被读入
例如，如果在read_swap_cache中
调用这个函数，可能已经被swapin_readahead
读入到swapper_space中</panel_attributes>
    <additional_attributes>230.0;10.0;70.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1723</x>
      <y>922</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_swap_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1689</x>
      <y>912</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_swap_cache_async</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1697</x>
      <y>907</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1739</x>
      <y>922</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_free_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1743</x>
      <y>914</y>
      <w>7</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1755</x>
      <y>922</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>virt_to_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1743</x>
      <y>914</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1770</x>
      <y>922</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_swap_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1744</x>
      <y>914</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在get_free_page中pending
page可能被其他进程换入到swap_space中</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1787</x>
      <y>922</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lock_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1743</x>
      <y>914</y>
      <w>52</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1803</x>
      <y>922</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_to_swap_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1743</x>
      <y>914</y>
      <w>70</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1821</x>
      <y>922</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rw_swap_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1744</x>
      <y>914</y>
      <w>88</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;860.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1821</x>
      <y>931</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rw_swap_page_base</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1828</x>
      <y>925</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter：
PageLocked
PageSwapCache
page-&gt;mapping != &amp;swapper_space</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1708</x>
      <y>922</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>swap_duplicate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1712</x>
      <y>914</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里增加盘上引用
是因为害怕盘上页面被完全释放，里面填充了其他页面
因为这里增加了盘上页面的计数，
所以如果从swap_space中找到了，则会swap_free
如果需要从盘上找到，这回保留这个count</panel_attributes>
    <additional_attributes>320.0;10.0;30.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1706</x>
      <y>913</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1697</x>
      <y>907</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放掉进程对内存页面的引用</panel_attributes>
    <additional_attributes>40.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1723</x>
      <y>913</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>swap_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1700</x>
      <y>907</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放掉valid_swaphandles对盘上页面的count</panel_attributes>
    <additional_attributes>20.0;10.0;260.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1679</x>
      <y>1040</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>alloc_pages
mm/numa.c(numa)
include/linux/mm.h(uma)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1670</x>
      <y>1045</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
numa
从pgdat_list的某个节点开始查找</panel_attributes>
    <additional_attributes>137.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1667</x>
      <y>1050</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_pages_pgdat</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1688</x>
      <y>1060</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__alloc_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1673</x>
      <y>1053</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pgdat-&gt;node_zonelists + gfp_mask
order</panel_attributes>
    <additional_attributes>40.0;10.0;190.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1694</x>
      <y>1044</y>
      <w>32</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uma
contig_page_data.node_zonelists+(gfp_mask)
order</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1608</x>
      <y>1092</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memory_pressure++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1615</x>
      <y>1063</y>
      <w>78</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>760.0;10.0;10.0;290.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1624</x>
      <y>1092</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>direct_reclaim = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1630</x>
      <y>1063</y>
      <w>65</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
order == 0 //申请页面为1个
&amp;&amp; (gfp_mask &amp; __GFP_WAIT) //等待分配完成
&amp;&amp;!(current-&gt;flags &amp; PF_MEMALLOC //不是用于管理目的</panel_attributes>
    <additional_attributes>630.0;10.0;10.0;290.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1641</x>
      <y>1093</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wakeup_kswapd
wakeup_bdflush
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1649</x>
      <y>1063</y>
      <w>46</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
当发现页面短缺时
唤醒内核线程腾出页面</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;300.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1666</x>
      <y>1063</y>
      <w>29</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
zonelist-&gt;zones
遍历三个zone区域</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;310.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1653</x>
      <y>1093</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
z-&gt;free_pages &gt;= z-&gt;pages_low</panel_attributes>
    <additional_attributes>150.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1653</x>
      <y>1097</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rmqueue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1599</x>
      <y>1105</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>area = zone-&gt;free_area + order
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1609</x>
      <y>1100</y>
      <w>51</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1622</x>
      <y>1105</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>head = &amp;area-&gt;free_list
curr = memlist_next(head)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1631</x>
      <y>1100</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1643</x>
      <y>1107</y>
      <w>52</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>page = memlist_entry(curr, struct page, list) //找到链表指针对应的page实体
memlist_del(curr) //将当前的实体从链表中删除
index = (page - mem_map) - zone-&gt;offset; //找到page在该zone中的偏移
MARK_USED(index, curr_order, area);//这里之所以用1+order是表示当前page和他
										//的伙伴共同占用的位
zone-&gt;free_pages -= 1 &lt;&lt; order//刷新zone内空闲page的数量
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1657</x>
      <y>1100</y>
      <w>9</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1657</x>
      <y>1100</y>
      <w>50</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
伙伴算法的分配：
如果当前要求的块没有，
就在大块中分割出小块
再把其他小块链到其他的free_area中</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1700</x>
      <y>1104</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expand</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1703</x>
      <y>1107</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
size = 1 &lt;&lt; high;
high &gt; low</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1699</x>
      <y>1112</y>
      <w>50</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>area--;
high--;
size &gt;&gt;= 1;
memlist_add_head(&amp;(page)-&gt;list, &amp;(area)-&gt;free_list);
										//将这块page放在下一级的free_list中
MARK_USED(index, high, area);//这里相当于释放这个page，
										//改变其在map中相应的位，从而告诉伙伴
index += size;			//将index更新为下一块在zone中的偏移
page += size;			//将page指向下一块
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1714</x>
      <y>1104</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page.count.counter=1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1657</x>
      <y>1100</y>
      <w>69</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1670</x>
      <y>1097</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up_interruptible</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1662</x>
      <y>1093</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
z-&gt;free_pages &lt; z-&gt;pages_min &amp;&amp;
waitqueue_active(&amp;kreclaimd_wait)</panel_attributes>
    <additional_attributes>50.0;10.0;170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1692</x>
      <y>1063</y>
      <w>44</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
limit的大小应该是
PAGES_HIGH&gt;PAGES_LOW&gt;PAGES_MIN</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;320.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1723</x>
      <y>1095</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__alloc_pages_limit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1723</x>
      <y>1098</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历zonelist中的三个区域
z-&gt;free_pages + z-&gt;inactive_clean_pages &gt; limit</panel_attributes>
    <additional_attributes>80.0;10.0;240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1726</x>
      <y>1101</y>
      <w>36</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
direct_reclaim &amp;&amp; z-&gt;free_pages &lt; z-&gt;pages_min + 8</panel_attributes>
    <additional_attributes>200.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1736</x>
      <y>1107</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reclaim_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1746</x>
      <y>1101</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没找到page</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1753</x>
      <y>1108</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rmqueue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1728</x>
      <y>1078</y>
      <w>51</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>wakeup_kswapd(0); //唤醒分配线程
if (gfp_mask &amp; __GFP_WAIT) {
	__set_current_state(TASK_RUNNING);
	current-&gt;policy |= SCHED_YIELD;
	schedule(); //如果线程在到时之前，一直等待，叫交出cpu权限，给其他线程使用
					//腾出来一些页面
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1693</x>
      <y>1063</y>
      <w>37</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1693</x>
      <y>1063</y>
      <w>96</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!(current-&gt;flags &amp; PF_MEMALLOC)
普通进程</panel_attributes>
    <additional_attributes>10.0;10.0;940.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1786</x>
      <y>1077</y>
      <w>29</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(order &gt; 0 &amp;&amp; (gfp_mask &amp; __GFP_WAIT)</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1758</x>
      <y>1092</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>current-&gt;flags |= PF_MEMALLOC;
page_launder(gfp_mask, 1);
current-&gt;flags &amp;= ~PF_MEMALLOC;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1771</x>
      <y>1085</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将脏的页面洗净</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1783</x>
      <y>1085</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
z-&gt;inactive_clean_pages</panel_attributes>
    <additional_attributes>40.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1785</x>
      <y>1089</y>
      <w>13</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1780</x>
      <y>1100</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reclaim_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1795</x>
      <y>1100</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__free_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1795</x>
      <y>1089</y>
      <w>8</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1809</x>
      <y>1100</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rmqueue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1795</x>
      <y>1089</y>
      <w>21</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1795</x>
      <y>1108</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__free_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1799</x>
      <y>1103</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page,0</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1800</x>
      <y>1111</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!PageReserved(page) &amp;&amp; put_page_testzero(page)
查看page是否reserved并且将counter--</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1795</x>
      <y>1117</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__free_pages_ok</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1751</x>
      <y>1124</y>
      <w>52</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>page-&gt;flags &amp;= ~((1&lt;&lt;PG_referenced) | (1&lt;&lt;PG_dirty));
page-&gt;age = PAGE_AGE_START;
mask = (~0UL) &lt;&lt; order; //0xFF..00..(order个0)
base = mem_map + zone-&gt;offset;
page_idx = page - base;//在zone中的偏移
if (page_idx &amp; ~mask)//对order对齐
	BUG();
index = page_idx &gt;&gt; (1 + order);
area = zone-&gt;free_area + order;//找到zone中free_area对应块的area
zone-&gt;free_pages -= mask;//如果mask=0xFFFF0000,则-mask=0x00010000
								//所以相当于加上2的order次方个page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1763</x>
      <y>1120</y>
      <w>38</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>360.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1802</x>
      <y>1120</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1806</x>
      <y>1124</y>
      <w>61</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>伙伴算法的释放需要注意以下几点：
1.由if (page_idx &amp; ~mask)
	BUG();
	可知，要求要释放的page_idx是对order对齐的。
	比如order是4，page_idx的低4位必须是0
2.伙伴算法中有一个重要的指示标志map，这个map中的每一
	位是当前page和他的伙伴共享的位（当前page的伙伴是通过
	buddy1 = base + (page_idx ^ -mask);找到的，还是
	上面order等于4的例子，如果page_idx的第5位是1，这个伙伴的
	第5位就是0，就是page的前一块，如果page_idx的第5位是0，这个伙伴
	的第5位就是1，是page的后一块。这是因为page和他的伙伴组成的块的起始
	page_idx需要对order对齐）
3.map中相应的位在这个页面块和他的伙伴进行分配，释放的时候都会change_bit，
	所以当page和他的伙伴的状态不一样的时候，map的这一位就是1，状态一样的时候
	（比如说都是释放或者占用状态），这一位就是0.所以在这里有一句：
	if (!test_and_change_bit(index, area-&gt;map))
		break;
	因为这里要释放page，说明page是占用状态，如果map中相应的位是0，则表示伙伴也处于
	占用状态，所以不能将两者合并成更大的块，直接break。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1807</x>
      <y>1160</y>
      <w>56</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>具体代码：
while (mask + (1 &lt;&lt; (MAX_ORDER-1))) {
	struct page *buddy1, *buddy2;
	if (area &gt;= zone-&gt;free_area + MAX_ORDER)
		BUG();
	if (!test_and_change_bit(index, area-&gt;map))//这里检测map中的1+order位
															//检测伙伴和当前page的状态是否一致
		break;	

	buddy1 = base + (page_idx ^ -mask);//如果mask=0xFFFF0000,则-mask=0x00010000
													//这里是找到当前page的伙伴
	buddy2 = base + page_idx;
	if (BAD_RANGE(zone,buddy1))
		BUG();
	if (BAD_RANGE(zone,buddy2))
		BUG();

	memlist_del(&amp;buddy1-&gt;list);//已经检测到伙伴和当前page的状态不一致，是释放状态
										//所以可以直接从当前的链表中删除
	mask &lt;&lt;= 1;
	area++;
	index &gt;&gt;= 1;
	page_idx &amp;= mask;
}
memlist_add_head(&amp;(base + page_idx)-&gt;list, &amp;area-&gt;free_list);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1834</x>
      <y>1155</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1322</x>
      <y>1047</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1334</x>
      <y>1058</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__kmem_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1331</x>
      <y>1050</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1334</x>
      <y>1067</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc_one
最终返回的是虚拟地址</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1343</x>
      <y>1061</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1315</x>
      <y>1070</y>
      <w>37</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
cachep-&gt;firstnotfull==&amp;cachep-&gt;slabs
firstnotfull：第二截slab，没完全占满的slab
slabs：整个slab的头链表，指向第一截，完全占满的slab
初始化的时候slabs是和firstnotfull地址是相等的</panel_attributes>
    <additional_attributes>290.0;10.0;70.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1315</x>
      <y>1082</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_new_slab
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1343</x>
      <y>1070</y>
      <w>22</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到firstnotfull中对应的slab</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1352</x>
      <y>1082</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc_one_tail</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1348</x>
      <y>1097</y>
      <w>41</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>slabp-&gt;inuse++ //slab中用过的对象
objp = slabp-&gt;s_mem + slabp-&gt;free*cachep-&gt;objsize
	//s_mem 第一个对象在slab中的偏移
	//free 指向最新的空闲的对象
	//objsize 一个对象的size
slabp-&gt;free=((kmem_bufctl_t *)(((slab_t*)slabp)+1))[slabp-&gt;free]
	//kmem_bufctl_t紧挨着slab管理结构，在其之后，其中存储的是
	//下一个空闲对象的序号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1361</x>
      <y>1085</y>
      <w>8</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1397</x>
      <y>1098</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>cachep-&gt;firstnotfull = slabp-&gt;list.next
list.next：将完全空闲的slab放到firstnotfull中
	//lisr.next指向的是cachep-&gt;slabs，可以在
	//kmem_cache_grow中知道
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1361</x>
      <y>1085</y>
      <w>48</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
slabp-&gt;free == BUFCTL_END</panel_attributes>
    <additional_attributes>10.0;10.0;460.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1298</x>
      <y>1091</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_grow</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1305</x>
      <y>1085</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1218</x>
      <y>1111</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_getpages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1223</x>
      <y>1094</y>
      <w>84</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>820.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1222</x>
      <y>1114</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flags |= cachep-&gt;gfpflags
cachep-&gt;gfporder</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1215</x>
      <y>1120</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_free_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1199</x>
      <y>1128</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1205</x>
      <y>1123</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1215</x>
      <y>1128</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return page.virtual
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1221</x>
      <y>1123</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1241</x>
      <y>1111</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_slabmgmt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1248</x>
      <y>1094</y>
      <w>60</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>580.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1229</x>
      <y>1114</y>
      <w>26</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
OFF_SLAB(cachep)
对于“大对象”，slab的管理
结构不在slab中，而是独立的
管理结构。需要重新分配slab管理
结构的slab
cachep-&gt;slabp_cache：指向这个slab
管理结构的cache</panel_attributes>
    <additional_attributes>190.0;10.0;60.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1228</x>
      <y>1128</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1254</x>
      <y>1122</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>slabp = objp+colour_off
 //objp是分配内存的起始地址
 //colour_off是cache定义的这个slab在块中的偏移
 //这是为了和高速缓冲行对齐
colour_off += L1_CACHE_ALIGN(cachep-&gt;num *
				sizeof(kmem_bufctl_t) + sizeof(slab_t))
				//所有对象总的大小加上slab管理结构的大小，
				//要对32字节取整
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1249</x>
      <y>1114</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果管理结构在slab中</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1288</x>
      <y>1123</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>slabp-&gt;inuse = 0;
	//正在用的对象
slabp-&gt;colouroff = colour_off;
 //slab中真正的存储区域在slab中的偏移
slabp-&gt;s_mem = objp+colour_off;
	//指向第一个对象
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1249</x>
      <y>1114</y>
      <w>47</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1270</x>
      <y>1108</y>
      <w>24</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>SET_PAGE_CACHE(page, cachep)
	//将page.list.next指向cache
SET_PAGE_SLAB(page, slabp)
	//将page.list.prev指向slab
PageSetSlab(page)
	//设置PG_slab
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1278</x>
      <y>1094</y>
      <w>30</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为slab中的每个page做相应的设置</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1296</x>
      <y>1102</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_init_objs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1305</x>
      <y>1094</y>
      <w>3</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1295</x>
      <y>1110</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>cachep-&gt;ctor(objp, cachep, ctor_flags)
	//调用constructors函数
((kmem_bufctl_t *)(((slab_t*)slabp)+1))=i+1
slab_bufctl(slabp)[i-1] = BUFCTL_END
slabp-&gt;free = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1302</x>
      <y>1105</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1318</x>
      <y>1099</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>cachep-&gt;growing--
list_add_tail(&amp;slabp-&gt;list,&amp;cachep-&gt;slabs)
	//这里和kmem_cache_alloc_one_tail中BUFCTL_END
	//的情况有联系
cachep-&gt;firstnotfull = &amp;slabp-&gt;list
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1305</x>
      <y>1094</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1487</x>
      <y>1043</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1488</x>
      <y>1052</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__kmem_cache_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1497</x>
      <y>1046</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1487</x>
      <y>1060</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_free_one</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1496</x>
      <y>1055</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1473</x>
      <y>1070</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>objnr = (objp-slabp-&gt;s_mem)/cachep-&gt;objsize;
slab_bufctl(slabp)[objnr] = slabp-&gt;free;
slabp-&gt;free = objnr;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1440</x>
      <y>1070</y>
      <w>32</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>slabp = GET_PAGE_SLAB(virt_to_page(objp))
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1447</x>
      <y>1063</y>
      <w>51</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据传入obj的指针找到page（转化成物理地址之后左移12位），
然后通过page.list.prev找到对应的slab</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1478</x>
      <y>1063</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将释放的slab加入到kmem_bufctl_t链表的头部</panel_attributes>
    <additional_attributes>180.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1497</x>
      <y>1063</y>
      <w>37</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
slabp-&gt;inuse-- == cachep-&gt;num
如果之前这个slab的对象全部用完
现在应该把他加入到firstnotfull中</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1525</x>
      <y>1070</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>moveslab_partial
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1498</x>
      <y>1077</y>
      <w>50</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果要放到firstnotfull的slab就在当前firstnotfull的前面，
	那就直接将firstnotfull指向当前要释放的slab
2.如果不是上述情况则需要将slab从当前链表中删除，插入到当前firstnotfull和f
	irstnotfull。prev之间也就是说要释放的slab还是放在firstnotfull的最前方
注：list_add_tail(&amp;slabp-&gt;list, t)这个并不是尾插，因为firstnotfull。prev
	并没有指向最后一个元素，而是firstnotfull之前slab的一个元素
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1526</x>
      <y>1073</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1555</x>
      <y>1069</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>moveslab_free
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1498</x>
      <y>1063</y>
      <w>67</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!slabp-&gt;inuse
如果当前的额slabb中没有正在用的对象</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1549</x>
      <y>1078</y>
      <w>44</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.将当前的slab放到cachep-&gt;slabs链表的最后
2.如果firstnotfull指向当前的slab，就让firstnotfull
	指向firstnotfull-&gt;prev.next(这里因为slab已经从next
	中移到了尾部，所以nexr指向的slab发生了变化，当然如果要释放的
	slab本来在最后一个，这里的结构就没发生什么变化)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1560</x>
      <y>1072</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1359</x>
      <y>1047</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1336</x>
      <y>1050</y>
      <w>43</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
滤出size大于要申请大小的通用cache
看是否用于DMA传递不同的参数
flags &amp; GFP_DMA ?csizep-&gt;cs_dmacachep : csizep-&gt;cs_cachep
, flags</panel_attributes>
    <additional_attributes>300.0;10.0;120.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>769</x>
      <y>846</y>
      <w>41</w>
      <h>116</h>
    </coordinates>
    <panel_attributes>内存
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>768</x>
      <y>956</y>
      <w>44</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.
7c00 引导扇区（bootsect）搬运到90000</panel_attributes>
    <additional_attributes>10.0;20.0;420.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>768</x>
      <y>947</y>
      <w>44</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.
90000 （int13读入setup）</panel_attributes>
    <additional_attributes>10.0;20.0;420.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>809</x>
      <y>948</y>
      <w>6</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
跳转</panel_attributes>
    <additional_attributes>10.0;100.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>768</x>
      <y>945</y>
      <w>44</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.
92000 setup</panel_attributes>
    <additional_attributes>10.0;20.0;420.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>809</x>
      <y>946</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
跳转</panel_attributes>
    <additional_attributes>10.0;30.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>769</x>
      <y>933</y>
      <w>41</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>100000(1M)

图形接口卡和BIOS


A0000
valign=center
bg=gray</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>769</x>
      <y>943</y>
      <w>41</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>基本内存
bg=pink
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>769</x>
      <y>879</y>
      <w>41</w>
      <h>54</h>
    </coordinates>
    <panel_attributes>内核
注：虽然内核实际放在内存中的0x100000,但是在
arch/i386/vmlinux.lds中. = 0xC0000000 + 0x100000;
将所有内核的地址标志都加上了0xC0000000了，所以所有内核的
逻辑地址都加上了0xC0100000(链接地址就是逻辑地址)
所以下列式子是成立的
段地址+逻辑地址=线性地址
线性地址—&gt;MMU—&gt;物理地址
MMU；如果MMU打开，当访问startup_32时，因为段地址时0，
所以线性地址时0xC0100000，所以访问的时pGD
（swapper_pg_dir）中的第769项（0x300）项，所以PT是
0x00102000中的第（0x100）项,根据Initialize page tables中
的add $0x1000,%eax可知实际访问的物理地址是（0x100000）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1070</x>
      <y>874</y>
      <w>22</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1074</x>
      <y>879</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>struct list_head list
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1074</x>
      <y>886</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unsigned long index
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1072</x>
      <y>893</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>struct zone_struct *zone
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1096</x>
      <y>868</y>
      <w>35</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>zone_struct
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1102</x>
      <y>876</y>
      <w>25</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>free_area_t free_area[MAX_ORDER];
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1108</x>
      <y>879</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>struct list_head list
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1108</x>
      <y>885</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unsigned int *map
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1086</x>
      <y>880</y>
      <w>24</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1090</x>
      <y>840</y>
      <w>37</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>pglist_data
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1097</x>
      <y>854</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>struct page *node_mem_map
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1073</x>
      <y>857</y>
      <w>27</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1096</x>
      <y>843</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>zone_t node_zones[MAX_NR_ZONES]
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1118</x>
      <y>844</y>
      <w>16</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;140.0;110.0;10.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1106</x>
      <y>897</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>struct pglist_data	*zone_pgdat;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1126</x>
      <y>862</y>
      <w>30</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;370.0;280.0;240.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1095</x>
      <y>849</y>
      <w>30</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>zonelist_t node_zonelists[NR_GFPINDEX]
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1079</x>
      <y>919</y>
      <w>35</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>vm_area_struct
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1089</x>
      <y>926</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unsigned long vm_start
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1088</x>
      <y>932</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unsigned long vm_end
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>979</x>
      <y>854</y>
      <w>66</w>
      <h>78</h>
    </coordinates>
    <panel_attributes>存储节点（pglist_data）
对于NUMA（不均匀介质存储，例如多核多cpu）
因为存储介质的不同，分为不同的存储节点
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>982</x>
      <y>866</y>
      <w>59</w>
      <h>58</h>
    </coordinates>
    <panel_attributes>zone（存储区域）
用于不同的用途
DMA/NORMAL/HIGHMEM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>984</x>
      <y>876</y>
      <w>53</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>free_area
组合成不同的块可以分成不同块大小的页面的空闲链表
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>997</x>
      <y>885</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>free_list
指向相应的空闲页面，构成链表
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>959</x>
      <y>886</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>971</x>
      <y>888</y>
      <w>29</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>959</x>
      <y>895</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>963</x>
      <y>890</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>988</x>
      <y>904</y>
      <w>43</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>struct list_head inactive_clean_list
指向已经换出到设备上，但是还没用作其他用途的page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>959</x>
      <y>905</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>959</x>
      <y>914</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>971</x>
      <y>907</y>
      <w>18</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>964</x>
      <y>909</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>954</x>
      <y>855</y>
      <w>22</w>
      <h>78</h>
    </coordinates>
    <panel_attributes>mem_map
管控所有page的数组
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>916</x>
      <y>863</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>struct list_head active_list
被正在使用的page，处于页面映射中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>958</x>
      <y>863</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>958</x>
      <y>872</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>963</x>
      <y>867</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>941</x>
      <y>865</y>
      <w>19</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>810</x>
      <y>846</y>
      <w>46</w>
      <h>116</h>
    </coordinates>
    <panel_attributes>40000000（1G）(highend_pfn/max_pfn)
halign=center
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>809</x>
      <y>886</y>
      <w>49</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.
896M(max_low_pfn / highstart_pfn)</panel_attributes>
    <additional_attributes>10.0;20.0;470.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>769</x>
      <y>919</y>
      <w>41</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>node_mem_map
bg=green
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>809</x>
      <y>915</y>
      <w>49</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.
16M</panel_attributes>
    <additional_attributes>10.0;20.0;470.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>810</x>
      <y>917</y>
      <w>46</w>
      <h>45</h>
    </coordinates>
    <panel_attributes>DMA
bg=yellow
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>810</x>
      <y>888</y>
      <w>46</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>Normal
bg=orange
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>769</x>
      <y>924</y>
      <w>41</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>内核代码区，数据区
valign=center
bg=red</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>768</x>
      <y>922</y>
      <w>44</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.
_end(链接文件中)</panel_attributes>
    <additional_attributes>10.0;20.0;420.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>810</x>
      <y>913</y>
      <w>46</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mem_map
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>810</x>
      <y>846</y>
      <w>46</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>HighMem
bg=#3c7a00
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>810</x>
      <y>851</y>
      <w>46</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>809</x>
      <y>849</y>
      <w>49</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.
ffffe000
fixed_addresses</panel_attributes>
    <additional_attributes>10.0;20.0;470.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>916</x>
      <y>877</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inactive_dirty_liststruct list_head 
已经断开了某个进程的地址映射，并且和盘上页面映射
但是还没换出到设备上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>958</x>
      <y>878</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>941</x>
      <y>879</y>
      <w>19</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1643</x>
      <y>1396</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_to_swap_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1652</x>
      <y>1399</y>
      <w>42</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检测!PageLocked(page)
PageTestandSetSwapCache(page)
page-&gt;mapping=NULL</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1678</x>
      <y>1402</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1661</x>
      <y>1407</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page-&gt;flags清PG_error PG_arch_1
置PG_uptodate
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1691</x>
      <y>1402</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
swapper_space</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1690</x>
      <y>1407</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_to_page_cache_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1677</x>
      <y>1413</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1681</x>
      <y>1410</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1672</x>
      <y>1420</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page.count.counter++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1679</x>
      <y>1416</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1692</x>
      <y>1415</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page-&gt;index =swp_entry_t.val
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1698</x>
      <y>1410</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1717</x>
      <y>1415</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_page_to_inode_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1698</x>
      <y>1410</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1710</x>
      <y>1422</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>swapper_space.nrpages++
list_add(&amp;page-&gt;list, swapper_space.clean_pages)
page-&gt;mapping = swapper_space
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1741</x>
      <y>1414</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_page_to_hash_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1698</x>
      <y>1410</y>
      <w>51</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;490.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1723</x>
      <y>1418</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1763</x>
      <y>1414</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lru_cache_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1699</x>
      <y>1410</y>
      <w>74</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1754</x>
      <y>1421</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_page_to_active_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1776</x>
      <y>1421</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>deactivate_page_nolock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1766</x>
      <y>1417</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1772</x>
      <y>1417</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1747</x>
      <y>1428</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>SetPageActive(page); \
list_add(&amp;(page)-&gt;lru, &amp;active_list); \
nr_active_pages++; \
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1757</x>
      <y>1424</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1072</x>
      <y>1281</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kswapd_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1058</x>
      <y>1287</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>swap_setup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1064</x>
      <y>1284</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1049</x>
      <y>1295</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cluster
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1045</x>
      <y>1290</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据物理页面num_physpages大小设置</panel_attributes>
    <additional_attributes>170.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1078</x>
      <y>1288</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kernel_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1077</x>
      <y>1284</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1070</x>
      <y>1296</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kswapd
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1157</x>
      <y>1296</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kreclaimd
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1065</x>
      <y>1291</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CLONE_FS | CLONE_FILES | CLONE_SIGNAL</panel_attributes>
    <additional_attributes>200.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1084</x>
      <y>1292</y>
      <w>80</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CLONE_FS | CLONE_FILES | CLONE_SIGNAL</panel_attributes>
    <additional_attributes>10.0;10.0;780.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1076</x>
      <y>1299</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
死循环</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1085</x>
      <y>1305</y>
      <w>325</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
&amp;kswapd_wait, HZ</panel_attributes>
    <additional_attributes>10.0;10.0;3230.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1402</x>
      <y>1313</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>interruptible_sleep_on_timeout</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1398</x>
      <y>1321</y>
      <w>34</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;state = TASK_INTERRUPTIBLE
current-&gt;timeout = jiffies + (HZ);schedule ();
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1414</x>
      <y>1316</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1033</x>
      <y>1305</y>
      <w>21</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>struct task_struct *tsk = current;
tsk-&gt;session = 1;
tsk-&gt;pgrp = 1;
strcpy(tsk-&gt;comm, "kswapd");
sigfillset(&amp;tsk-&gt;blocked);
kswapd_task = tsk;
tsk-&gt;flags |= PF_MEMALLOC;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1047</x>
      <y>1299</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1070</x>
      <y>1305</y>
      <w>18</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1061</x>
      <y>1313</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inactive_shortage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1084</x>
      <y>1314</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_shortage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1084</x>
      <y>1305</y>
      <w>9</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1021</x>
      <y>1326</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shortage += freepages.high;
shortage += inactive_target;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1029</x>
      <y>1316</y>
      <w>38</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
free_page和inactive的数量
低于这个限值，说明inactive短缺</panel_attributes>
    <additional_attributes>360.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1052</x>
      <y>1316</y>
      <w>16</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1041</x>
      <y>1324</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
统计空闲free_page的数量</panel_attributes>
    <additional_attributes>120.0;10.0;50.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1040</x>
      <y>1331</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nr_free_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1053</x>
      <y>1331</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nr_inactive_clean_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1049</x>
      <y>1324</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
统计inactive_clean的数量</panel_attributes>
    <additional_attributes>40.0;10.0;130.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1075</x>
      <y>1331</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nr_inactive_dirty_pages
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1052</x>
      <y>1324</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
统计inactive_dirty的数量</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1030</x>
      <y>1340</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sum += zone-&gt;free_pages
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1029</x>
      <y>1334</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
统计pgdat_list中每个区域中free_pages的数量</panel_attributes>
    <additional_attributes>170.0;10.0;120.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1054</x>
      <y>1340</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sum += zone-&gt;inactive_clean_pages
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1047</x>
      <y>1334</y>
      <w>37</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
统计pgdat_list中每个区域中inactive_clean_pages的数量</panel_attributes>
    <additional_attributes>150.0;10.0;210.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1069</x>
      <y>1317</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
统计总共nr_free_pages和inactive_clean_pages
是否低于限值</panel_attributes>
    <additional_attributes>220.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1070</x>
      <y>1322</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>freepages.high + inactive_target / 3
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1082</x>
      <y>1317</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
统计所有zone中inactive_clean_pages和free_pages
的数量低于zone-&gt;pages_min+1</panel_attributes>
    <additional_attributes>90.0;10.0;230.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1099</x>
      <y>1322</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>sum += zone-&gt;pages_min + 1;
sum -= zone-&gt;free_pages;
sum -= zone-&gt;inactive_clean_pages;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1118</x>
      <y>1314</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>waitqueue_active</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1085</x>
      <y>1305</y>
      <w>39</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1124</x>
      <y>1322</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>!list_empty(&amp;kswapd_done-&gt;task_list)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1125</x>
      <y>1317</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1189</x>
      <y>1313</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_try_to_free_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1084</x>
      <y>1305</y>
      <w>114</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
GFP_KSWAPD, wait</panel_attributes>
    <additional_attributes>10.0;10.0;1120.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1153</x>
      <y>1316</y>
      <w>47</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
free_shortage() || nr_inactive_dirty_pages &gt; nr_free_pages() +
			nr_inactive_clean_pages()</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1149</x>
      <y>1319</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_launder
（将inactive_dirty page洗净）
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>1322</y>
      <w>40</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(page_lru = inactive_dirty_list.prev) != &amp;inactive_dirty_list &amp;&amp;
				maxscan-- &gt; 0
从inactive_dirty_list尾部开始遍历</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1103</x>
      <y>1327</y>
      <w>54</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1084</x>
      <y>1338</y>
      <w>45</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>!PageInactiveDirty(page)
						//位没置，不可能发生，如果发生，则从这个链表中删除
PageTestandClearReferenced(page) || page-&gt;age &gt; 0 ||
				(!page-&gt;buffers &amp;&amp; page_count(page) &gt; 1) ||
				page_ramdisk(page)
									//1.又受到了访问，产生了缺页异常
									//2.页面的寿命没耗尽，这个和页面访问的频繁程度有关
									//3.页面没用于读写缓冲，并且count&gt;1,表示还有另外的进程使用
									//4.用于虚拟磁盘
TryLockPage(page)
					//如果被锁住，则放在链表的最开始（即最后一个遍历到，
					//但是不会在遍历，因为maxscan）

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1151</x>
      <y>1327</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PageDirty(page)</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1148</x>
      <y>1333</y>
      <w>6</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1130</x>
      <y>1340</y>
      <w>44</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>int (*writepage)(struct page *) = page-&gt;mapping-&gt;a_ops-&gt;writepage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1151</x>
      <y>1333</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
第一次遍历
加到遍历的最后面
!launder_loop</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1175</x>
      <y>1339</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>list_del(page_lru)
list_add(page_lru, &amp;inactive_dirty_list)
UnlockPage(page)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1151</x>
      <y>1333</y>
      <w>61</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
第二次遍历</panel_attributes>
    <additional_attributes>10.0;10.0;590.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1143</x>
      <y>1350</y>
      <w>40</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ClearPageDirty(page)//清除dirty位，不让第二次写到swap磁盘
page_cache_get(page)//因为要写磁盘，所以引用++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>1339</y>
      <w>58</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>560.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1184</x>
      <y>1352</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>writepage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1189</x>
      <y>1339</y>
      <w>23</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1200</x>
      <y>1353</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_release
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1206</x>
      <y>1339</y>
      <w>15</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
写完，引用计数--</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>1327</y>
      <w>95</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page-&gt;buffers
用作读写缓冲</panel_attributes>
    <additional_attributes>10.0;10.0;930.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1233</x>
      <y>1348</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>del_page_from_inactive_dirty_list(page);
page_cache_get(page);
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1241</x>
      <y>1338</y>
      <w>8</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1263</x>
      <y>1346</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>try_to_free_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1246</x>
      <y>1338</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1194</x>
      <y>1316</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
free_shortage() || inactive_shortage()
回收dentry和inode页面</panel_attributes>
    <additional_attributes>40.0;10.0;190.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1203</x>
      <y>1320</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1193</x>
      <y>1323</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shrink_dcache_memory</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1211</x>
      <y>1323</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shrink_icache_memory</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1212</x>
      <y>1320</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1378</x>
      <y>1321</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_reap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1197</x>
      <y>1316</y>
      <w>190</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
回收slab页面</panel_attributes>
    <additional_attributes>10.0;10.0;1880.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1272</x>
      <y>1322</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>refill_inactive</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1212</x>
      <y>1319</y>
      <w>67</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
refill_inactive_scan是做页面的老化，如果老化将页面加载inactive_dirty_list
swap_out:是扫描swap_cnt最大的进程，为已经老化的页面放到swapper_space中，并将
			虚拟地址和物理地址断开，将虚拟地址映射到盘上页面上
</panel_attributes>
    <additional_attributes>10.0;20.0;650.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1226</x>
      <y>1330</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_reap
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1231</x>
      <y>1325</y>
      <w>47</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1254</x>
      <y>1328</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>if (current-&gt;need_resched) {
	__set_current_state(TASK_RUNNING);
	schedule();
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1269</x>
      <y>1325</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1284</x>
      <y>1329</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>refill_inactive_scan</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1272</x>
      <y>1325</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从active_list中查找到age为0的page
将其加入到inactive_dirty_list中</panel_attributes>
    <additional_attributes>50.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1287</x>
      <y>1332</y>
      <w>43</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
maxscan-- &gt; 0 &amp;&amp; (page_lru = active_list.prev) != &amp;active_list</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1281</x>
      <y>1338</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PageTestandClearReferenced</panel_attributes>
    <additional_attributes>70.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1300</x>
      <y>1345</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page-&gt;age == 0 &amp;&amp; page_count(page) &lt;=
						(page-&gt;buffers ? 2 : 1)d</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1274</x>
      <y>1342</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1262</x>
      <y>1351</y>
      <w>30</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>age_page_up_nolock(page);//更新page的寿命
page_active = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1292</x>
      <y>1342</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1294</x>
      <y>1351</y>
      <w>18</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>age_page_down_ageonly
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1300</x>
      <y>1345</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
减少page的寿命</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1310</x>
      <y>1348</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1304</x>
      <y>1356</y>
      <w>54</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>deactivate_page_nolock{
page-&gt;age = 0;
ClearPageReferenced(page);
if (PageActive(page) &amp;&amp; page_count(page) &lt;= maxcount &amp;&amp; !page_ramdisk(page)) {
		del_page_from_active_list(page);//顺便清除active标志
		add_page_to_inactive_dirty_list(page);
}
}
page_active = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1326</x>
      <y>1348</y>
      <w>43</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1359</x>
      <y>1357</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_active = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1287</x>
      <y>1338</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没从active_list中删除
page_active || PageActive(page)</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1312</x>
      <y>1342</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_del(page_lru);
list_add(page_lru, &amp;active_list)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1276</x>
      <y>1325</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1303</x>
      <y>1329</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shrink_dcache_memory
shrink_icache_memory
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1362</x>
      <y>1330</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>swap_out</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1277</x>
      <y>1325</y>
      <w>92</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到swap_cnt最大的进程</panel_attributes>
    <additional_attributes>10.0;10.0;900.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1322</x>
      <y>1338</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>best = mm
atomic_inc(&amp;best-&gt;mm_users)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1360</x>
      <y>1332</y>
      <w>44</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1.swap_cnt的初始值是0，所以在第一次循环的时候
并没有找到最佳的进程，但是之后align设置为1，然后
将每个进程的swap_cnt初始化为rss（进程占用物理页面的数量），
2.找到最大的swap_cnt去swap_out（如果不是所有swap_cnt都为0）
3.上述过程要循环count次
</panel_attributes>
    <additional_attributes>50.0;20.0;380.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1333</x>
      <y>1333</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
; p != &amp;init_mm.mmlist; p = p-&gt;next
mm-&gt;swap_cnt
</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1364</x>
      <y>1336</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>swap_out_mm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1364</x>
      <y>1333</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1391</x>
      <y>1334</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mmput(best)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1368</x>
      <y>1342</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>swap_out_vma</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1368</x>
      <y>1339</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1380</x>
      <y>1353</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>swap_out_pgd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1376</x>
      <y>1345</y>
      <w>13</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1395</x>
      <y>1367</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>swap_out_pmd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1386</x>
      <y>1356</y>
      <w>16</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1397</x>
      <y>1373</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>try_to_swap_out</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1401</x>
      <y>1370</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1347</x>
      <y>1344</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>address = mm-&gt;swap_address
vma = find_vma(mm, address)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1357</x>
      <y>1339</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1369</x>
      <y>1338</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有swap_out，退出
否则查看vma = vma-&gt;vm_next;
释放下一个address = vma-&gt;vm_start</panel_attributes>
    <additional_attributes>10.0;20.0;270.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1388</x>
      <y>1341</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vma = vma-&gt;vm_next
address = vma-&gt;vm_start
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1412</x>
      <y>1341</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mm-&gt;swap_address = 0;
mm-&gt;swap_cnt = 0;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1370</x>
      <y>1338</y>
      <w>50</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到swapout最后的vma之后，将
swap_adress重置
</panel_attributes>
    <additional_attributes>10.0;20.0;480.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1357</x>
      <y>1349</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pgdir = pgd_offset(mm, address)
end = vma-&gt;vm_end
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1366</x>
      <y>1345</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1395</x>
      <y>1348</y>
      <w>35</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>address = (address + PGDIR_SIZE) &amp; PGDIR_MASK;
pgdir++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1376</x>
      <y>1345</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没swap_out成功
就尝试下一个dir
直到end</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1364</x>
      <y>1356</y>
      <w>25</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
swap_out一个
目录</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1359</x>
      <y>1367</y>
      <w>35</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pgd_end = (address + PGDIR_SIZE) &amp; PGDIR_MASK
end = pgd_end;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1432</x>
      <y>1365</y>
      <w>32</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>address = (address + PMD_SIZE) &amp; PMD_MASK
pmd++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1386</x>
      <y>1356</y>
      <w>66</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不成功，再去检查下一个pmd
直到这个dir完</panel_attributes>
    <additional_attributes>10.0;10.0;640.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1359</x>
      <y>1374</y>
      <w>35</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>pte = pte_offset(dir, address)//找到adress对应的pte
pmd_end = (address + PMD_SIZE) &amp; PMD_MASK;
end = pmd_end		//设置查找的结束地址
mm-&gt;swap_address = address + PAGE_SIZE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1377</x>
      <y>1370</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1426</x>
      <y>1372</y>
      <w>32</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>address += PAGE_SIZE;
pte++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1402</x>
      <y>1370</y>
      <w>31</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1376</x>
      <y>1376</y>
      <w>29</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;


</panel_attributes>
    <additional_attributes>270.0;10.0;210.0;60.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1361</x>
      <y>1385</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>pte = *page_table;
filter：
!pte_present(pte)	//不存在物理页面
page = pte_page(pte)
!VALID_PAGE(page) //页面在mem_map内
PageReserved(page) //reserved表示页面允许作为交换
mm-&gt;swap_cnt--
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1398</x>
      <y>1387</y>
      <w>36</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>if (ptep_test_and_clear_young(page_table)) {
 //在通过虚拟地址访问物理地址时，
 //_PAGE_ACCESSED会自动置上
	age_page_up(page);//增加age
	goto out_failed;
}
onlist = PageActive(page);
if (!onlist)
	age_page_down_ageonly(page);//暂时不清楚为什么
if (page-&gt;age &gt; 0)
	goto out_failed;

if (TryLockPage(page))
	goto out_failed;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1402</x>
      <y>1376</y>
      <w>22</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查最近是否访问
_PAGE_BIT_ACCESSED
</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1402</x>
      <y>1376</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放pte（pte=0）并返回原始pte</panel_attributes>
    <additional_attributes>10.0;10.0;390.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1435</x>
      <y>1387</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pte = ptep_get_and_clear(page_table);
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1462</x>
      <y>1387</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_tlb_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1402</x>
      <y>1376</y>
      <w>66</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;640.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1403</x>
      <y>1376</y>
      <w>83</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PageSwapCache</panel_attributes>
    <additional_attributes>10.0;10.0;810.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1455</x>
      <y>1387</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1444</x>
      <y>1395</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>entry.val = page-&gt;index
set_page_dirty(page)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1470</x>
      <y>1387</y>
      <w>16</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1465</x>
      <y>1395</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>swap_duplicate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1467</x>
      <y>1398</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1455</x>
      <y>1402</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>type = SWP_TYPE(entry)
p = type + swap_info
offset = SWP_OFFSET(entry)
p-&gt;swap_map[offset]++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1478</x>
      <y>1395</y>
      <w>31</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_pte(page_table, swp_entry_to_pte(entry));
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1482</x>
      <y>1387</y>
      <w>11</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1510</x>
      <y>1395</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mm-&gt;rss--
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1482</x>
      <y>1387</y>
      <w>38</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drop_pte</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1516</x>
      <y>1390</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1525</x>
      <y>1395</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>deactivate_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1517</x>
      <y>1390</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1520</x>
      <y>1402</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>deactivate_page_nolock
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1528</x>
      <y>1398</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1540</x>
      <y>1395</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1517</x>
      <y>1390</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1540</x>
      <y>1402</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__free_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1547</x>
      <y>1398</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1310</x>
      <y>1237</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kswapd_balance
2.4.16</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1305</x>
      <y>1244</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kswapd_balance_pgdat</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1315</x>
      <y>1240</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历所有的节点</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1299</x>
      <y>1249</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter：
unlikely(current-&gt;need_resched)
!zone-&gt;need_balance</panel_attributes>
    <additional_attributes>150.0;10.0;60.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1296</x>
      <y>1254</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>try_to_free_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1313</x>
      <y>1249</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1325</x>
      <y>1254</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>check_classzone_need_balance</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1313</x>
      <y>1247</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
节点的zone从后向前遍历</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1317</x>
      <y>1261</y>
      <w>37</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>如果当前zone和所有前面的前的zone没有一个满足
classzone-&gt;free_pages &gt; classzone-&gt;pages_high
当前zone就需要balance
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1334</x>
      <y>1257</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1296</x>
      <y>1261</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shrink_caches</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1302</x>
      <y>1257</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1252</x>
      <y>1269</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_reap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1257</x>
      <y>1264</y>
      <w>48</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
收割slab管理的空闲页面</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1270</x>
      <y>1269</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>refill_inactive</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1286</x>
      <y>1269</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shrink_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1277</x>
      <y>1264</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将ratio的active_list转化成inactive_list</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1287</x>
      <y>1264</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将洗净没加锁的页面加入inactive_list</panel_attributes>
    <additional_attributes>160.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1302</x>
      <y>1269</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shrink_dcache_memory</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1302</x>
      <y>1264</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1320</x>
      <y>1269</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shrink_icache_memory</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1302</x>
      <y>1264</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1265</x>
      <y>1276</y>
      <w>53</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>• 把引用过的页面从活跃队列的队尾移到该队列的队头（实现LRU 策略）；
• 把未引用过的页面从活跃队列的队尾移到非活跃队列的队头（为准备换出而排队）；
• 把脏页面安排在非活跃队列的队尾准备写到磁盘；
• 从非活跃队列的队尾恢复干净页面(写出的页面就成为干净的)。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1291</x>
      <y>1272</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1219</x>
      <y>1353</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_page_dirty(page);
page_active
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1209</x>
      <y>1339</y>
      <w>19</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
写出失败</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>1327</y>
      <w>108</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page-&gt;mapping &amp;&amp; !PageDirty(page)</panel_attributes>
    <additional_attributes>10.0;10.0;1060.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1256</x>
      <y>1337</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>del_page_from_inactive_dirty_list(page);
add_page_to_inactive_clean_list(page);
cleaned_pages++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1182</x>
      <y>1327</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_active
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1155</x>
      <y>1327</y>
      <w>29</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1403</x>
      <y>1376</y>
      <w>170</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不在SwapCache中</panel_attributes>
    <additional_attributes>10.0;10.0;700.0;50.0;1680.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1557</x>
      <y>1395</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drop_pte
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1558</x>
      <y>1388</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!pte_dirty(pte)
当pte受到写访问时，
dirty位会被硬件自动置上</panel_attributes>
    <additional_attributes>130.0;10.0;30.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1570</x>
      <y>1395</y>
      <w>35</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_page_dirty//将页面加入到mapping-&gt;dirty_pages
drop_pte
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1570</x>
      <y>1388</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page-&gt;mapping
文件映射</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1570</x>
      <y>1388</y>
      <w>47</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1610</x>
      <y>1395</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_swap_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1609</x>
      <y>1402</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_swap_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1615</x>
      <y>1398</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1580</x>
      <y>1410</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>type = swap_list.next
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1588</x>
      <y>1405</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
优先级链表</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1615</x>
      <y>1405</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
死循环</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1586</x>
      <y>1410</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1579</x>
      <y>1416</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>scan_swap_map</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1612</x>
      <y>1410</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到offset</panel_attributes>
    <additional_attributes>20.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1608</x>
      <y>1413</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
组装entry</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1609</x>
      <y>1408</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SWP_WRITEOK</panel_attributes>
    <additional_attributes>70.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1591</x>
      <y>1419</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>entry = SWP_ENTRY(type,offset)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1617</x>
      <y>1413</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果下一个交换设备的优先级和
当前设备优先级相同，</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1614</x>
      <y>1417</y>
      <w>10</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1600</x>
      <y>1424</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>swap_list.next = type
	//type为下一个交换设备号
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1625</x>
      <y>1424</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>swap_list.next = swap_list.head
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1621</x>
      <y>1417</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否则重头开始</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1638</x>
      <y>1416</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out：
return entry;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1617</x>
      <y>1413</y>
      <w>30</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1615</x>
      <y>1407</y>
      <w>46</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果下一个设备的优先级查找完
就重头查找一次</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1654</x>
      <y>1413</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>type = swap_list.head;
wrapped = 1;//下次不再重头
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1570</x>
      <y>1388</y>
      <w>86</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1.置上SwapCache
2.page.count++
3.设置page.index
4.将page加入到swap_space中，随便添加到杂凑队列中
5.置上ACTIVE，加入到active_list,如果age没有，将其加入到inactive_dirty_list</panel_attributes>
    <additional_attributes>10.0;10.0;840.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1687</x>
      <y>1394</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_page_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1570</x>
      <y>1388</y>
      <w>126</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1240.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1714</x>
      <y>1400</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>test_and_set_bit(PG_dirty, &amp;page-&gt;flags)
list_del(&amp;page-&gt;list);
list_add(&amp;page-&gt;list, &amp;mapping-&gt;dirty_pages);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1696</x>
      <y>1397</y>
      <w>31</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1376</x>
      <y>1328</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>refill_inactive_scan</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1278</x>
      <y>1325</y>
      <w>109</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1070.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1368</x>
      <y>1280</y>
      <w>51</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>page中结构说明：
lru：链接到active_list  inactive_dirty_list inactive_clean_list
mapping:在换入换出中链接到swapper_space
list：和swapper_space中的clean_pages和dirty_pages链接
count：在分配page的时候，count会置为1，如果这个page在swap_cache
		中，在add_to_swap_cache中通过get_page()使count++，所以在
		deactivate_page_nolock中在没有page_buffer的时候maxcount为2
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1182</x>
      <y>1360</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shmem_writepage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1187</x>
      <y>1355</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
shmem_aops</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1169</x>
      <y>1367</y>
      <w>36</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.如果禁止换入换出(page-&gt;mapping-&gt;host-&gt;u.shmem_i-&gt;locked=1)
	直接返回1
2.通过__get_swap_page申请换出的页面（该页面的计数是2）
	如果没申请到，返回1
3.通过shmem_swp_entry查看其写入到交换盘的情况entry
	1.如果entry.val不为0，表示将内存mapping到了交互盘上
		通过__swap_free将新申请的交互盘上的页面释放
		然后执行4
	2.如果val是0，表示没有将内存map到交互盘上，将新申请的交互盘
		页面写入inode中
		*entry = swap
		然后将page从现在的address_space，hash中删除：
		lru_cache_del(page);
		remove_inode_page(page)
		最后加入到交互盘的swapper_space，hash中
		add_to_swap_cache(page, swap);
		page_cache_release(page);
		set_page_dirty(page);
		info-&gt;swapped++;
4.解锁page，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1187</x>
      <y>1363</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1192</x>
      <y>1355</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
swap_aops</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1213</x>
      <y>1359</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>swap_writepage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1214</x>
      <y>1365</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rw_swap_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1219</x>
      <y>1362</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1209</x>
      <y>1371</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.page的locked要置上
2.page的PG_swap_cache置上
3.page的mapping是swapper_space
4.通过rw_swap_page_base将page写入盘上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1219</x>
      <y>1368</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1609</x>
      <y>1305</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__swap_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1576</x>
      <y>1317</y>
      <w>39</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>type = SWP_TYPE(entry)  //交换设备的序号
p = &amp; swap_info[type]	//该交换设备的账本
offset = SWP_OFFSET(entry) //在交换设备中的页面偏移号
p-&gt;swap_map[offset]  //页面的引用次数
if (p-&gt;prio &gt; swap_info[swap_list.next].prio)
	swap_list.next = type;
	//如果当前释放的优先级大于之前swap_list中存储的，就将
	//swap_list中的next更新位当前swap_file
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1619</x>
      <y>1317</y>
      <w>37</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>p-&gt;swap_map[offset] -= count //在账本中减去释放的引用
if (offset &lt; p-&gt;lowest_bit)	//如果offset引用减到0，重新计算
										//lowest_bit highest_bit nr_swap_pages
	p-&gt;lowest_bit = offset;
if (offset &gt; p-&gt;highest_bit)
	p-&gt;highest_bit = offset;
nr_swap_pages++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1595</x>
      <y>1308</y>
      <w>21</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1613</x>
      <y>1308</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1544</x>
      <y>1254</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kreclaimd
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1515</x>
      <y>1262</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>tsk-&gt;session = 1;
tsk-&gt;pgrp = 1;
strcpy(tsk-&gt;comm, "kreclaimd");
sigfillset(&amp;tsk-&gt;blocked);
current-&gt;flags |= PF_MEMALLOC;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1526</x>
      <y>1257</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1549</x>
      <y>1257</y>
      <w>10</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
死循环
</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1548</x>
      <y>1263</y>
      <w>9</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1543</x>
      <y>1269</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>interruptible_sleep_on</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1551</x>
      <y>1263</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历各个节点的所有zone
zone-&gt;free_pages &lt; zone-&gt;pages_low
</panel_attributes>
    <additional_attributes>50.0;10.0;190.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1558</x>
      <y>1274</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reclaim_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1576</x>
      <y>1274</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__free_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1563</x>
      <y>1270</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1569</x>
      <y>1270</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1563</x>
      <y>1277</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从后遍历zone内所有的
inactive_clean_list</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1497</x>
      <y>1281</y>
      <w>69</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!PageInactiveClean(page)</panel_attributes>
    <additional_attributes>670.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1472</x>
      <y>1286</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>list_del(page_lru);
page-&gt;zone-&gt;inactive_clean_pages--;
continue;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1523</x>
      <y>1281</y>
      <w>43</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PageTestandClearReferenced(page) || page-&gt;age &gt; 0 ||
				(!page-&gt;buffers &amp;&amp; page_count(page) &gt; 1)</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1509</x>
      <y>1290</y>
      <w>31</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>del_page_from_inactive_clean_list(page);
add_page_to_active_list(page);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1544</x>
      <y>1291</y>
      <w>31</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>del_page_from_inactive_clean_list(page);
			add_page_to_inactive_dirty_list(page);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1561</x>
      <y>1281</y>
      <w>38</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page-&gt;buffers || PageDirty(page) || TryLockPage(page)</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1563</x>
      <y>1281</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PageSwapCache</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1587</x>
      <y>1290</y>
      <w>9</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1573</x>
      <y>1296</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__delete_from_swap_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1636</x>
      <y>1293</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>found_page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1592</x>
      <y>1290</y>
      <w>52</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1527</x>
      <y>1303</y>
      <w>17</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>entry.val = page-&gt;index
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1535</x>
      <y>1299</y>
      <w>47</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1552</x>
      <y>1304</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_from_swap_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1561</x>
      <y>1299</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1580</x>
      <y>1299</y>
      <w>36</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
常规情况下：
这个swap有两个用户，一个是pte，一个是page
现在page要释放掉，所以将swap中的count--</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1549</x>
      <y>1314</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>PageClearSwapCache(page);
ClearPageDirty(page);
__remove_inode_page(page);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1557</x>
      <y>1307</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter：
mapping != &amp;swapper_space
!PageSwapCache(page) || !PageLocked(page)
</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1615</x>
      <y>1300</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>del_page_from_inactive_clean_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1626</x>
      <y>1296</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1639</x>
      <y>1296</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
此时page_count应该是1</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1647</x>
      <y>1301</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page-&gt;age = PAGE_AGE_START
memory_pressure++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1625</x>
      <y>1306</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>list_del(&amp;(page)-&gt;lru)
ClearPageInactiveClean(page)
page-&gt;zone-&gt;inactive_clean_pages--
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1625</x>
      <y>1303</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1563</x>
      <y>1281</y>
      <w>156</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page-&gt;mapping</panel_attributes>
    <additional_attributes>10.0;10.0;1540.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1696</x>
      <y>1289</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1683</x>
      <y>1295</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__remove_inode_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1719</x>
      <y>1296</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>found_page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1715</x>
      <y>1289</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3056</x>
      <y>903</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_fork</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3091</x>
      <y>900</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_clone</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3124</x>
      <y>902</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_vfork</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3093</x>
      <y>925</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_fork
主要工作：
1.文件系统相关file，pwd，root
2.mm相关，vma 页表
3.返回相关，返回值eax，返回时的系统栈 ip
	用户栈，
次要工作：
1.pid分配，hash查找pid
2.进程间的相互关系，父进程，兄弟进程
3.进程的相关参数，和父进程的信号交互（exit）
	是否只有一个能返回用户态（sem）
	时间片等
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3062</x>
      <y>906</y>
      <w>38</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SIGCHLD，regs.esp, &amp;regs, 0
SIGCHLD：低字节是子进程在exit之后向父进程发送的信号</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3097</x>
      <y>903</y>
      <w>41</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
clone_flags = regs.ebx 
newsp = regs.ecx/regs.esp（当传参为0时，选用父进程的sp）
&amp;regs,
0</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;220.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3092</x>
      <y>905</y>
      <w>45</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;




CLONE_VFORK | CLONE_VM | SIGCHLD, regs.esp, &amp;regs, 0
CLONE_VFORK | CLONE_VM：高字节是资源和特性的标志位
这里是指子进程和父进程要共用虚存空间，并且子进程释放虚存空间的
时候应该唤醒父进程</panel_attributes>
    <additional_attributes>380.0;10.0;60.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2635</x>
      <y>977</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DECLARE_MUTEX_LOCKED</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2646</x>
      <y>928</y>
      <w>456</w>
      <h>51</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>4540.0;10.0;10.0;490.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2661</x>
      <y>977</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>CLONE_PID只有0号进程可以用
这个是表示为进程创建task_struct，
但是和父进程公用pid
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2671</x>
      <y>928</y>
      <w>431</w>
      <h>51</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>4290.0;10.0;10.0;490.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2686</x>
      <y>978</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>current-&gt;vfork_sem = &amp;sem;
	//之后这个变量会因为vfork down
	//这个信号量之后陷入睡眠
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2695</x>
      <y>928</y>
      <w>407</w>
      <h>52</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>4050.0;10.0;10.0;500.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2707</x>
      <y>978</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_task_struct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2702</x>
      <y>985</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_free_pages(GFP_KERNEL,1)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2712</x>
      <y>928</y>
      <w>390</w>
      <h>52</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>3880.0;10.0;10.0;500.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2712</x>
      <y>981</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请2页的内存作为task_struct
注意：这里是2的1次方个页面</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2722</x>
      <y>978</y>
      <w>10</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>*p = *current
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2725</x>
      <y>928</y>
      <w>377</w>
      <h>52</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>3750.0;10.0;10.0;500.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2738</x>
      <y>977</y>
      <w>44</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>p-&gt;user：进程指向的用户
p-&gt;user-&gt;__count：引用用户的对象数目
p-&gt;user-&gt;processes：引用用户的进程数目
 p-&gt;rlim[RLIMIT_NPROC].rlim_cur：进程用户所规定的最大进程数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2749</x>
      <y>928</y>
      <w>353</w>
      <h>51</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
atomic_read(&amp;p-&gt;user-&gt;processes) &lt;-&gt;rlim[RLIMIT_NPROC].rlim_cur</panel_attributes>
    <additional_attributes>3510.0;10.0;10.0;490.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2785</x>
      <y>979</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nr_threads &lt; max_threads
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2794</x>
      <y>928</y>
      <w>308</w>
      <h>53</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
线程数目filter</panel_attributes>
    <additional_attributes>3060.0;10.0;10.0;510.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2807</x>
      <y>979</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_exec_domain(p-&gt;exec_domain)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2820</x>
      <y>928</y>
      <w>283</w>
      <h>53</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加动态安装模块module的计数</panel_attributes>
    <additional_attributes>2810.0;10.0;10.0;510.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2835</x>
      <y>979</y>
      <w>31</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__MOD_INC_USE_COUNT(p-&gt;binfmt-&gt;module)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2849</x>
      <y>928</y>
      <w>254</w>
      <h>53</h>
    </coordinates>
    <panel_attributes>lt=.&gt;


增加动态安装模块module（bin elf out等解释模块）的计数</panel_attributes>
    <additional_attributes>2520.0;10.0;10.0;510.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2869</x>
      <y>978</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>	p-&gt;did_exec = 0;
	p-&gt;swappable = 0;
	p-&gt;state = TASK_UNINTERRUPTIBLE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2878</x>
      <y>928</y>
      <w>225</w>
      <h>52</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>2230.0;10.0;10.0;500.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2897</x>
      <y>980</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_flags</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2900</x>
      <y>928</y>
      <w>203</w>
      <h>54</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>2010.0;10.0;10.0;520.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2837</x>
      <y>988</y>
      <w>41</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>new_flags &amp;= ~(PF_SUPERPRIV | PF_USEDFPU | PF_VFORK)
new_flags |= PF_FORKNOEXEC
if (!(clone_flags &amp; CLONE_PTRACE))
		p-&gt;ptrace = 0;
if (clone_flags &amp; CLONE_VFORK)
	new_flags |= PF_VFORK;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2855</x>
      <y>983</y>
      <w>49</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2914</x>
      <y>979</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_pid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2920</x>
      <y>928</y>
      <w>183</w>
      <h>53</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
p-&gt;pid</panel_attributes>
    <additional_attributes>1810.0;10.0;10.0;510.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2883</x>
      <y>993</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;pid
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2889</x>
      <y>982</y>
      <w>31</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flags &amp; CLONE_PID</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2901</x>
      <y>992</y>
      <w>54</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果没有大于0x8000，就lastpid++
2.如果大于0x8000，last_pid从300开始找，如果这个pid
	被进程，进程组或者session用到，将last_pid++然后，在遍历整个
	task链表，看是否有上述三者用到这个pid
3.每次查找，如果发现这个pid没被用到，就用已经用到的pid更新next_safe的
	内容，使next_safe的内容更精确（范围更小），以便下次寻找pid的时候能更快的找到

注意：next_safe是用static修饰的
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2919</x>
      <y>982</y>
      <w>7</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2929</x>
      <y>979</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>p-&gt;run_list.next = NULL;
p-&gt;run_list.prev = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2936</x>
      <y>928</y>
      <w>167</w>
      <h>53</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
run_list：就绪态队列</panel_attributes>
    <additional_attributes>1650.0;10.0;10.0;510.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2956</x>
      <y>983</y>
      <w>58</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>p-&gt;p_opptr：指向父进程（CLONE_VFORK/！CLONE_PARENT）
p-&gt;p_pptr：指向父进程（CLONE_VFORK/！CLONE_PARENT）&amp;（！PT_PTRACED）
p-&gt;p_cptr = NULL //指向最年轻的子进程
init_waitqueue_head(&amp;p-&gt;wait_chldexit)//初始化等待队列（因为没有子进程）
p-&gt;vfork_sem = NULL;
spin_lock_init(&amp;p-&gt;alloc_lock);
p-&gt;sigpending = 0;
init_sigpending(&amp;p-&gt;pending);	//初始化信号队列

p-&gt;it_real_value = p-&gt;it_virt_value = p-&gt;it_prof_value = 0;
p-&gt;it_real_incr = p-&gt;it_virt_incr = p-&gt;it_prof_incr = 0;
init_timer(&amp;p-&gt;real_timer);
p-&gt;real_timer.data = (unsigned long) p;
p-&gt;leader = 0;		/* session leadership doesn't inherit */
p-&gt;tty_old_pgrp = 0;
p-&gt;times.tms_utime = p-&gt;times.tms_stime = 0;
p-&gt;times.tms_cutime = p-&gt;times.tms_cstime = 0;//初始化时间参数
p-&gt;lock_depth = -1;		/* -1 = no lock */
p-&gt;start_time = jiffies;


halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2970</x>
      <y>928</y>
      <w>133</w>
      <h>57</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
p-&gt;pid</panel_attributes>
    <additional_attributes>1310.0;10.0;10.0;550.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3105</x>
      <y>981</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_files</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3206</x>
      <y>983</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_fs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3246</x>
      <y>981</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_sighand</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3417</x>
      <y>977</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_mm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3659</x>
      <y>983</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3100</x>
      <y>928</y>
      <w>14</w>
      <h>55</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
clone_flags</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;530.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3014</x>
      <y>999</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;oldf-&gt;count)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3021</x>
      <y>984</y>
      <w>90</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CLONE_FILES
但这个flag置上的时候
只复制指针</panel_attributes>
    <additional_attributes>880.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3052</x>
      <y>984</y>
      <w>61</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制整个实体</panel_attributes>
    <additional_attributes>590.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3033</x>
      <y>1001</y>
      <w>38</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>tsk-&gt;files = NULL
newf = kmem_cache_alloc(files_cachep, SLAB_KERNEL)
atomic_set(&amp;newf-&gt;count, 1);

newf-&gt;file_lock	    = RW_LOCK_UNLOCKED;
newf-&gt;next_fd	    = 0;
newf-&gt;max_fds	    = NR_OPEN_DEFAULT;
newf-&gt;max_fdset	    = __FD_SETSIZE;
newf-&gt;close_on_exec = &amp;newf-&gt;close_on_exec_init;
newf-&gt;open_fds	    = &amp;newf-&gt;open_fds_init;
newf-&gt;fd	    = &amp;newf-&gt;fd_array[0];

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3082</x>
      <y>984</y>
      <w>31</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果父进程的size大于__FD_SETSIZE</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3075</x>
      <y>999</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expand_fdset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3073</x>
      <y>1007</y>
      <w>38</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.不允许请求size的大小大于NR_OPEN
2.如果原本的size小于PAGE_SIZE * 8（内存占1页）
	就申请1页的内存，如果大于，就扩大1倍
3.如果申请小于1页的内存，就用kmlloc在低内存区申请内存
	如果大于1页内存就用vmalloc在high_mem申请内存
	这里的申请内存都是虚拟内存，kmollc申请的有物理内存
	vmlloc申请的是靠缺页中断去申请物理内存
4.复制files-&gt;open_fds，files-&gt;close_on_exec的内容
	到新申请的内存中（注意这里的max_fdset和nfds是32位
	对齐的）
5.更新位图扩展的个数，将新的内存区间和files-&gt;open_fds
	，files-&gt;close_on_exec交换，释放原来的内存区间。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3081</x>
      <y>1002</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3109</x>
      <y>997</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>count_open_files</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3111</x>
      <y>984</y>
      <w>6</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3115</x>
      <y>1000</y>
      <w>27</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从size/(8*sizeof(long))-1开始找
直到找到files-&gt;open_fds-&gt;fds_bits[--i]
不为0为止，
注意这里使用的是--i
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3112</x>
      <y>1011</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>i = (i+1) * 8 * sizeof(long)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3129</x>
      <y>997</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expand_fd_array</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3111</x>
      <y>984</y>
      <w>26</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
i&gt;NR_OPEN_DEFAULT</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3131</x>
      <y>1009</y>
      <w>31</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.不允许请求size的大小大于NR_OPEN
2.扩展的大小分为三个层次，256*4,1页
	之前的两倍
3.通过kmlloc或者vmlloc分配内存
4.更新files-&gt;fd，files-&gt;max_fds
5.如果之前有内容，将file的指针复制给new_fds
	将之后的内容置0，并且释放旧的old_fds
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3134</x>
      <y>1000</y>
      <w>9</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3151</x>
      <y>993</y>
      <w>32</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>memcpy（newf-&gt;open_fds-&gt;fds_bits 
memcpy（newf-&gt;close_on_exec-&gt;fds_bits
	//注意这里的open_files是32位对齐
if (f)
	get_file(f);//增加file的计数
*new_fds++ = f;//复制fd
memset(new_fds, 0, size)//将扩展的部分清0
memset(&amp;newf-&gt;open_fds-&gt;fds_bits[start], 0
memset(&amp;newf-&gt;close_on_exec-&gt;fds_bits[start], 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3112</x>
      <y>984</y>
      <w>45</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为之前newf-&gt;max_fds
和newf-&gt;max_fdset都赋值为0
所以没有复制父进程的文件</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3163</x>
      <y>988</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tsk-&gt;files = newf
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3112</x>
      <y>984</y>
      <w>58</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;560.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3100</x>
      <y>928</y>
      <w>113</w>
      <h>57</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1110.0;550.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3184</x>
      <y>993</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;current-&gt;fs-&gt;count)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3190</x>
      <y>986</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CLONE_FS</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3213</x>
      <y>993</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__copy_fs_struct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3209</x>
      <y>986</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
没置CLONE_FS</panel_attributes>
    <additional_attributes>20.0;10.0;100.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3204</x>
      <y>1000</y>
      <w>26</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>atomic_set(&amp;fs-&gt;count, 1);
fs-&gt;lock = RW_LOCK_UNLOCKED;
fs-&gt;umask = old-&gt;umask;
	//mntget和dget返回原值并增加引用计数
fs-&gt;rootmnt = mntget(old-&gt;rootmnt);
fs-&gt;root = dget(old-&gt;root);
fs-&gt;pwdmnt = mntget(old-&gt;pwdmnt);
fs-&gt;pwd = dget(old-&gt;pwd);
if (old-&gt;altroot) {
	fs-&gt;altrootmnt = mntget(old-&gt;altrootmnt);
	fs-&gt;altroot = dget(old-&gt;altroot);
} else {
	fs-&gt;altrootmnt = NULL;
	fs-&gt;altroot = NULL;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3218</x>
      <y>996</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3100</x>
      <y>928</y>
      <w>153</w>
      <h>55</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1510.0;530.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3239</x>
      <y>984</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CLONE_SIGHAND</panel_attributes>
    <additional_attributes>100.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3222</x>
      <y>989</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;current-&gt;sig-&gt;count)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3246</x>
      <y>989</y>
      <w>37</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>sig = kmem_cache_alloc(sigact_cachep, GFP_KERNEL);
tsk-&gt;sig = sig;
spin_lock_init(&amp;sig-&gt;siglock);
atomic_set(&amp;sig-&gt;count, 1);
memcpy(tsk-&gt;sig-&gt;action, current-&gt;sig-&gt;action
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3249</x>
      <y>984</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
没置
CLONE_SIGHAND</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3100</x>
      <y>928</y>
      <w>323</w>
      <h>51</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3210.0;490.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3284</x>
      <y>990</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>tsk-&gt;min_flt = tsk-&gt;maj_flt = 0;
tsk-&gt;cmin_flt = tsk-&gt;cmaj_flt = 0;
tsk-&gt;nswap = tsk-&gt;cnswap = 0;

tsk-&gt;mm = NULL;
tsk-&gt;active_mm = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3295</x>
      <y>980</y>
      <w>130</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1280.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3307</x>
      <y>994</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3313</x>
      <y>980</y>
      <w>112</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!oldmm
内核线程
不做任何复制</panel_attributes>
    <additional_attributes>1100.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3324</x>
      <y>980</y>
      <w>101</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CLONE_VM</panel_attributes>
    <additional_attributes>990.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3321</x>
      <y>994</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;oldmm-&gt;mm_users);
mm = oldmm;
goto good_mm;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3350</x>
      <y>980</y>
      <w>75</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
没置
CLONE_VM</panel_attributes>
    <additional_attributes>730.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3344</x>
      <y>996</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>allocate_mm
memcpy(mm, oldmm, sizeof(*mm))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3350</x>
      <y>991</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3369</x>
      <y>996</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mm_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3350</x>
      <y>991</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3341</x>
      <y>1003</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>atomic_set(&amp;mm-&gt;mm_users, 1);
atomic_set(&amp;mm-&gt;mm_count, 1);
init_MUTEX(&amp;mm-&gt;mmap_sem);
mm-&gt;page_table_lock = SPIN_LOCK_UNLOCKED;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3362</x>
      <y>999</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3374</x>
      <y>999</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mm-&gt;pgd </panel_attributes>
    <additional_attributes>10.0;10.0;170.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3384</x>
      <y>1004</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pgd_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3384</x>
      <y>1011</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_pgd_fast</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3389</x>
      <y>1007</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
get_pgd_fast中继承了原来的系统空间
get_pgd_slow初始化了系统空间</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3391</x>
      <y>1019</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_pgd_slow</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3362</x>
      <y>1018</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>pgd_quicklist = (unsigned long *)(*ret);
		ret[0] = 0;
		pgtable_cache_size--;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3373</x>
      <y>1014</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3381</x>
      <y>1026</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_free_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3385</x>
      <y>1022</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3388</x>
      <y>1014</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3395</x>
      <y>1026</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>memset(ret, 0  //pgd清0
memcpy(ret + USER_PTRS_PER_PGD
	//复制系统空间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3397</x>
      <y>1022</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3451</x>
      <y>991</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dup_mmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3422</x>
      <y>980</y>
      <w>36</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3408</x>
      <y>994</y>
      <w>50</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3433</x>
      <y>1002</y>
      <w>28</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果VM_DONTCOPY，不复制vma
2.kmem_cache_alloc
	*tmp = *mpnt;
	tmp-&gt;vm_flags &amp;= ~VM_LOCKED;
	tmp-&gt;vm_mm = mm;
	mm-&gt;map_count++;
	tmp-&gt;vm_next = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3435</x>
      <y>994</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制vma</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3457</x>
      <y>994</y>
      <w>19</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tmp-&gt;vm_file</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3541</x>
      <y>1004</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_page_range</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3457</x>
      <y>994</y>
      <w>93</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;910.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3509</x>
      <y>1011</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>address = vma-&gt;vm_start
end = vma-&gt;vm_end
cow = 
(vma-&gt;vm_flags &amp; (VM_SHARED | VM_MAYWRITE)) 
== VM_MAYWRITE// copy on write
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3523</x>
      <y>1007</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3545</x>
      <y>1011</y>
      <w>77</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果src_pgd为none，会切换到下一个pgd，如果下一个pgd超过了end或者限制
	直接返回
2.循环遍历整个pgd（从offset开始）如果dst_pgd为none，则通过pmd_alloc分配pmd（只分配pmd空间，并加到pgd中）
3.在循环遍历pmd（从offset开始），如果pmd为空，则切换到下一个pmd，如果超过了限制，直接返回
				如果目标pmd为空，通过pte_alloc申请pte内存，并填充到pmd中
4.遍历整个pte空间(从offset开始)，如果pte为none，则不复制，切换到下一个pte，
	如果页面在盘上，通过swap_duplicate增加盘上计数
	如果页面在内存中，copy on write置上的话，将页面设置为只读
					ptep_set_wrprotect(src_pte);
					pte = *src_pte;
		如果VM_SHARED，将pte _PAGE_DIRTY位清掉
		通过pte_mkold，将_PAGE_ACCESSED清掉
		增加pte指向page的count计数
		将设置好的pte赋值给dest_pte,然后切换到下一个pte，直到end

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3546</x>
      <y>1007</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3564</x>
      <y>1003</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tmp-&gt;vm_ops-&gt;open(tmp)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3457</x>
      <y>994</y>
      <w>117</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!retval &amp;&amp; tmp-&gt;vm_ops &amp;&amp; tmp-&gt;vm_ops-&gt;open</panel_attributes>
    <additional_attributes>10.0;10.0;1150.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3458</x>
      <y>994</y>
      <w>136</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将申请到的vma加入到mm-&gt;mmap
指向的链表中</panel_attributes>
    <additional_attributes>10.0;10.0;1340.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3611</x>
      <y>1003</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>build_mmap_avl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3458</x>
      <y>994</y>
      <w>159</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mm-&gt;map_count &gt;= AVL_MIN_MAP_COUNT
2.4.0建造平衡树</panel_attributes>
    <additional_attributes>10.0;10.0;1570.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3477</x>
      <y>990</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_add(&amp;mm-&gt;mmlist, &amp;oldmm-&gt;mmlist)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3422</x>
      <y>980</y>
      <w>67</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将新申请的mm加入到父进程mm链表的后面</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3543</x>
      <y>988</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_segments</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3423</x>
      <y>980</y>
      <w>127</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制父进程的ldt
</panel_attributes>
    <additional_attributes>10.0;10.0;1250.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3523</x>
      <y>993</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3527</x>
      <y>990</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请ldt的内存空间
可见是在high_mem</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3541</x>
      <y>993</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memcpy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3543</x>
      <y>990</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制父进程的ldt</panel_attributes>
    <additional_attributes>60.0;20.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3562</x>
      <y>994</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>new_mm-&gt;context.segments = ldt
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3549</x>
      <y>991</y>
      <w>26</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3591</x>
      <y>989</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_new_context
（i386中没有操作）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3423</x>
      <y>980</y>
      <w>173</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1710.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3606</x>
      <y>988</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>tsk-&gt;mm = mm;
tsk-&gt;active_mm = mm;
return 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3423</x>
      <y>980</y>
      <w>191</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1890.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3100</x>
      <y>928</y>
      <w>566</w>
      <h>57</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
stack_start= regs.esp（用户栈）
regs指向系统调用时的系统栈</panel_attributes>
    <additional_attributes>10.0;10.0;5640.0;550.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3603</x>
      <y>996</y>
      <w>45</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>childregs = ((struct pt_regs *) (THREAD_SIZE + (unsigned long) p)) - 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3620</x>
      <y>986</y>
      <w>46</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
子进程系统栈顶</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3650</x>
      <y>996</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>struct_cpy(childregs, regs)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3657</x>
      <y>986</y>
      <w>13</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制系统栈</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3671</x>
      <y>996</y>
      <w>31</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>childregs-&gt;eax = 0;//修改系统调用的返回值
childregs-&gt;esp = esp;//修改用户栈的地址
p-&gt;thread.esp=childregs//上下文切换时，
	//esp变成了系统栈的地址
p-&gt;thread.esp0=childregs+1 //系统栈的初始地址
	//设置了系统栈的栈顶
p-&gt;thread.eip=	ret_from_fork//上下文切换时，ip
	//被切换成ret_from_fork
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3663</x>
      <y>986</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3703</x>
      <y>997</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>savesegment(fs,p-&gt;thread.fs);
savesegment(gs,p-&gt;thread.gs)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3664</x>
      <y>986</y>
      <w>50</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
保存段寄存器
fs gs</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3725</x>
      <y>997</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>unlazy_fpu(current);
struct_cpy(&amp;p-&gt;thread.i387, &amp;current-&gt;thread.i387)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3664</x>
      <y>986</y>
      <w>73</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fpu相关</panel_attributes>
    <additional_attributes>10.0;10.0;710.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2629</x>
      <y>986</y>
      <w>34</w>
      <h>4</h>
    </coordinates>
    <panel_attributes> __DECLARE_SEMAPHORE_GENERIC(name,0)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2644</x>
      <y>980</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这个信号量的初始值是0</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2620</x>
      <y>995</y>
      <w>46</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>struct semaphore name = __SEMAPHORE_INITIALIZER(name,count)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2642</x>
      <y>989</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
定义变量
这里是局部变量</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3097</x>
      <y>928</y>
      <w>682</w>
      <h>57</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;6800.0;550.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3399</x>
      <y>1002</y>
      <w>31</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>flush_cache_mm(current-&gt;mm);
mm-&gt;locked_vm = 0;
mm-&gt;mmap = NULL;
mm-&gt;mmap_avl = NULL;
mm-&gt;mmap_cache = NULL;
mm-&gt;map_count = 0;
mm-&gt;cpu_vm_mask = 0;
mm-&gt;swap_cnt = 0;
mm-&gt;swap_address = 0;
pprev = &amp;mm-&gt;mmap;//pprev描述的是一个箭头
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3469</x>
      <y>1005</y>
      <w>39</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>get_file(file);
if (tmp-&gt;vm_flags &amp; VM_DENYWRITE)
	atomic_dec(&amp;inode-&gt;i_writecount);
	//从这里看出，每个vm_pprev_share指向（指向自己的指针）
	//即两次解引用才是自己
	//vm_next_share:mpnt-&gt;tmp-&gt;mpnt.vm_next_share
if((tmp-&gt;vm_next_share = mpnt-&gt;vm_next_share) != NULL)
	mpnt-&gt;vm_next_share-&gt;vm_pprev_share =
		&amp;tmp-&gt;vm_next_share;
mpnt-&gt;vm_next_share = tmp;
tmp-&gt;vm_pprev_share = &amp;mpnt-&gt;vm_next_share;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3586</x>
      <y>1003</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>*pprev = tmp;
pprev = &amp;tmp-&gt;vm_next
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3762</x>
      <y>983</y>
      <w>54</w>
      <h>101</h>
    </coordinates>
    <panel_attributes>p-&gt;semundo = NULL
p-&gt;parent_exec_id = p-&gt;self_exec_id
	//parent_exec_id父进程的执行域
	//self_exec_id本进程的执行域
p-&gt;swappable = 1//本进程页面可以换出
p-&gt;exit_signal = clone_flags &amp; CSIGNAL
	//exit_signal规定子进程exit时向父进程发送的信号
p-&gt;pdeath_signal = 0
	//pdeath_signal规定父进程在exit时向本进程发送的信号
p-&gt;counter = (current-&gt;counter + 1) &gt;&gt; 1;
current-&gt;counter &gt;&gt;= 1;
	//父子进程的时间片减半
if (!current-&gt;counter)
		current-&gt;need_resched = 1;//如果当前进程的时间片用完
				//则需要调度
retval = p-&gt;pid;
p-&gt;tgid = retval;
INIT_LIST_HEAD(&amp;p-&gt;thread_group);
if (clone_flags &amp; CLONE_THREAD) {
	p-&gt;tgid = current-&gt;tgid;//子进程的线程组被赋值为当前进程的进程组
	list_add(&amp;p-&gt;thread_group, &amp;current-&gt;thread_group);
	//将子进程的线程组加载当前进程的线程组链表之后
}
#define SET_LINKS(p) do { \
	(p)-&gt;next_task = &amp;init_task; \
	(p)-&gt;prev_task = init_task.prev_task; \
	init_task.prev_task-&gt;next_task = (p); \
	init_task.prev_task = (p); \//将子进程加入到task链表的最尾端
 //p_ysptr指向年轻的兄弟进程
 //p_osptr指向年长的兄弟进程
 //父进程p_cptr指向最年轻的子进程
 //p_pptr指向父进程
	(p)-&gt;p_ysptr = NULL; \
	if (((p)-&gt;p_osptr = (p)-&gt;p_pptr-&gt;p_cptr) != NULL) \
		(p)-&gt;p_osptr-&gt;p_ysptr = p; \//如果父进程p_pptr之前有最年轻的兄弟子进程p_cptr，
		//则将这个子进程年轻兄弟进程p_ysptr指向创建的进程
		//而当前进程的年长兄弟进程p_osptr指向之前最年轻的几次呢很难过
	(p)-&gt;p_pptr-&gt;p_cptr = p; //最年轻的进程指向当前创建的进程
	} while (0)
hash_pid（p）
{
	struct task_struct **htable = &amp;pidhash[pid_hashfn(p-&gt;pid)];
	//通过进程的pid找到hash值
	if((p-&gt;pidhash_next = *htable) != NULL)//将p加入到pid位hash值的杂凑队列
		(*htable)-&gt;pidhash_pprev = &amp;p-&gt;pidhash_next;//pidhash_pprev指向p.next指向下一个的箭头
	*htable = p;//更新杂凑队列头
	p-&gt;pidhash_pprev = htable;//指向自身
}
nr_threads++
if (p-&gt;ptrace &amp; PT_PTRACED)
		send_sig(SIGSTOP, p, 1);
wake_up_process(p);		/* do this last */
++total_forks;
	//因为之前如果CLONE_VM置上，导致父进程和子进程
	//共用用户空间，所以如果父进程和子进程同时返回用户空间
	//两者使用同一个用户栈，将导致严重的问题，所以如果使用了CLONE_VM
	//就必须使用CLONE_VFORK使当前进程陷入睡眠，用户空间只有子进程一个
	//享用用户栈
if ((clone_flags &amp; CLONE_VFORK) &amp;&amp; (retval &gt; 0)) 
		down(&amp;sem);//因为之前申明这个局部变量为0，现在申请（down）
				//这个信号量的时候会使当前进程陷入睡眠
return pid
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3075</x>
      <y>1271</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>load_aout_binary</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2721</x>
      <y>1312</y>
      <w>59</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.ex.a_info的低16位要是ZMAGIC OMAGIC QMAGIC NMAGIC
2.代码段和数据段重定位的长度要为0（ N_TRSIZE(ex)  N_DRSIZE(ex)）
3.执行文件的长度不能小于头信息中相加的大小（代码段 数据段，N_SYMSIZE N_TXTOFF）
 N_TXTOFF记录执行文件的入口地址
4.bss段和data段的长度和不能超过规定的current-&gt;rlim[RLIMIT_DATA].rlim_cur
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2747</x>
      <y>1274</y>
      <w>334</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>3320.0;10.0;10.0;380.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2915</x>
      <y>1307</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_old_exec
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2920</x>
      <y>1274</y>
      <w>162</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
step1:与过去告别
1.释放过去的物理内存和虚拟内存
	初始化自己的内存空间
2.释放过去的信号action
3.关闭父进程规定关闭的文件</panel_attributes>
    <additional_attributes>1600.0;10.0;10.0;330.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2772</x>
      <y>1323</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>oldsig = current-&gt;sig
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2777</x>
      <y>1310</y>
      <w>145</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1430.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2798</x>
      <y>1323</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>make_private_signals</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2805</x>
      <y>1310</y>
      <w>117</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1150.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2778</x>
      <y>1331</y>
      <w>25</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.filter：这个sig被引用大于1次
	因为如果小于1次时因为在fork的时候
	就通过copy_sighand分开了
2.申请sig内存newsig
3.将newsig.count置1
4.将action拷贝过来
注：task_struct中的sig是指信号action
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2789</x>
      <y>1326</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2864</x>
      <y>1322</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>exec_mmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2868</x>
      <y>1310</y>
      <w>54</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2821</x>
      <y>1325</y>
      <w>51</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;mm如果只有一个
user说明父进程和子进程的mm
是分开的</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2810</x>
      <y>1330</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2805</x>
      <y>1336</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_cache_mm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2818</x>
      <y>1336</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mm_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2832</x>
      <y>1336</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>exit_mmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2852</x>
      <y>1334</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_tlb_mm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2822</x>
      <y>1330</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2822</x>
      <y>1330</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2822</x>
      <y>1330</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2785</x>
      <y>1339</y>
      <w>41</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tsk-&gt;flags &amp; PF_VFORK</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2773</x>
      <y>1347</y>
      <w>21</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>tsk-&gt;flags &amp;= ~PF_VFORK;
	//在do_fork时因为这个标志将
	//父进程sleep，这里因为要将父
	//进程和子进程用户空间分开，
	//所以将父进程唤醒
up(tsk-&gt;p_opptr-&gt;vfork_sem)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2870</x>
      <y>1325</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果之前和父进程公用一个用户空间
</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2823</x>
      <y>1343</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>release_segments</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2828</x>
      <y>1339</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2799</x>
      <y>1354</y>
      <w>28</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>if (ldt) {//如果task的ldt存在
 //将task的ldt设NULL
	mm-&gt;context.segments = NULL;
	//将cpu的ldt设置成default_ldt
	//并通过lldt加载
	clear_LDT();
	//释放ldt的页表，页面以及vma的管理结构
	vfree(ldt);
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2809</x>
      <y>1346</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2834</x>
      <y>1349</y>
      <w>53</w>
      <h>44</h>
    </coordinates>
    <panel_attributes> //保存原来的vma链表
mpnt = mm-&gt;mmap;
	//释放vma链表 avl树，vma cache
mm-&gt;mmap = mm-&gt;mmap_avl = mm-&gt;mmap_cache = NULL;

while (mpnt) {
	struct vm_area_struct * next = mpnt-&gt;vm_next;
	unsigned long start = mpnt-&gt;vm_start;
	unsigned long end = mpnt-&gt;vm_end;
	unsigned long size = end - start;

	if (mpnt-&gt;vm_ops) {
		if (mpnt-&gt;vm_ops-&gt;close)
			mpnt-&gt;vm_ops-&gt;close(mpnt);
	}
	mm-&gt;map_count--;//清除对应vma的应用
	//如果vm_fil存在，当VM_DENYWRITE时
	//将i_writecount释放，释放vma在vm_next_share
	//链表中的链接关系
	remove_shared_vm_struct(mpnt);
	flush_cache_range(mm, start, end);
	zap_page_range(mm, start, size);//释放vma对应的物理页面
	if (mpnt-&gt;vm_file)
		fput(mpnt-&gt;vm_file);//释放映射文件
	kmem_cache_free(vm_area_cachep, mpnt);//释放vma管理结构对应的内存空间
	mpnt = next;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2836</x>
      <y>1339</y>
      <w>11</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2852</x>
      <y>1342</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>clear_page_tables</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2836</x>
      <y>1339</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放页表结构
注：这里没释放pgd
根据参数，这里只是释放了用户空间</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2873</x>
      <y>1336</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mm_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2869</x>
      <y>1343</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>allocate_mm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2880</x>
      <y>1343</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memset(mm, 0, sizeof(*mm))
mm_init
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2878</x>
      <y>1339</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2872</x>
      <y>1339</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2878</x>
      <y>1332</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2884</x>
      <y>1336</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>list_add(&amp;mm-&gt;mmlist, &amp;init_mm.mmlist)
current-&gt;mm = mm;
		current-&gt;active_mm = mm;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2892</x>
      <y>1332</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
加载mmlist最后</panel_attributes>
    <additional_attributes>80.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2912</x>
      <y>1337</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>activate_mm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2899</x>
      <y>1332</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mm的切换</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2913</x>
      <y>1345</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>switch_mm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2917</x>
      <y>1340</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2889</x>
      <y>1353</y>
      <w>44</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>clear_bit(cpu, &amp;prev-&gt;cpu_vm_mask)
 //注意这里的context是结构体，所以在分配mm的时候，就就分配
 //context的内存，所以在init_mm的时候将mm set为0，表示segments
 //被设置成NULL,而prev-&gt;context.segments是有ldt的（从copy_mm
 //可以看出）
if (prev-&gt;context.segments != next-&gt;context.segments)
	load_LDT(next)
set_bit(cpu, &amp;next-&gt;cpu_vm_mask)
 //重新加载pgd的地址，更换页表
asm volatile("movl %0,%%cr3": :"r" (__pa(next-&gt;pgd)))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2908</x>
      <y>1348</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2926</x>
      <y>1337</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mm_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2870</x>
      <y>1325</y>
      <w>62</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
之前因为公用一个mm
将父进程sleep，现在
通过up释放这个信号量
</panel_attributes>
    <additional_attributes>10.0;10.0;600.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2941</x>
      <y>1337</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mmput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2870</x>
      <y>1325</y>
      <w>78</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;760.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2945</x>
      <y>1340</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2936</x>
      <y>1349</y>
      <w>24</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>atomic_dec_and_test
	__asm__ __volatile__(
		//sete是当eflags中的ZF为1
		//时，置上1.ZF(zero flag)
		//表示计算结果如果为0，zf就置上
		LOCK "decl %0; sete %1"
		:"=m" (v-&gt;counter), "=qm" (c)
		:"m" (v-&gt;counter) : "memory");
	return c != 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2931</x>
      <y>1344</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
看mm_users--是否为0
mm_users是针对用户空间（current.mm）
</panel_attributes>
    <additional_attributes>180.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2948</x>
      <y>1344</y>
      <w>32</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果为0
</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2967</x>
      <y>1349</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2962</x>
      <y>1354</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_del(&amp;mm-&gt;mmlist)
spin_unlock(&amp;mmlist_lock)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2982</x>
      <y>1354</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>exit_mmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2976</x>
      <y>1349</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注：这里没释放pgd
</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2998</x>
      <y>1354</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mmdrop</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2976</x>
      <y>1349</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2999</x>
      <y>1362</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mmdrop</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3003</x>
      <y>1356</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
atomic_dec_and_test
mm_count减到0
mm_count是针对mm（current.active_mm）
例如内核线程就没有mm而有active_mm
</panel_attributes>
    <additional_attributes>10.0;20.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2988</x>
      <y>1369</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pgd_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3009</x>
      <y>1370</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_mm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2991</x>
      <y>1365</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
exit_mmap并没有释放pgd
这里将pgd释放
</panel_attributes>
    <additional_attributes>130.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3003</x>
      <y>1365</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放mm管理结构</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2956</x>
      <y>1337</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mmdrop</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2871</x>
      <y>1325</y>
      <w>93</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果current-&gt;mm为空（线程）
直接mmdrop，不用对mm_user进行操作</panel_attributes>
    <additional_attributes>10.0;10.0;910.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2890</x>
      <y>1319</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>release_old_signals</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2895</x>
      <y>1310</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2893</x>
      <y>1322</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;sig != oldsig</panel_attributes>
    <additional_attributes>50.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2894</x>
      <y>1325</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>if (atomic_dec_and_test(&amp;oldsig-&gt;count))
	kmem_cache_free(sigact_cachep, oldsig)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2909</x>
      <y>1319</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>current-&gt;sas_ss_sp =
current-&gt;sas_ss_size = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2915</x>
      <y>1310</y>
      <w>8</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2929</x>
      <y>1320</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;dumpable = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2909</x>
      <y>1310</y>
      <w>41</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;euid == current-&gt;uid &amp;&amp; current-&gt;egid == current-&gt;gid</panel_attributes>
    <additional_attributes>130.0;10.0;270.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2950</x>
      <y>1320</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;comm
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2921</x>
      <y>1310</y>
      <w>38</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
存储filename最后一个“\”之后的
字符串</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2965</x>
      <y>1320</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2921</x>
      <y>1310</y>
      <w>51</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;490.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2980</x>
      <y>1319</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2921</x>
      <y>1310</y>
      <w>65</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;630.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2958</x>
      <y>1329</y>
      <w>23</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>list_del_init(&amp;tsk-&gt;thread_group)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2958</x>
      <y>1322</y>
      <w>38</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果执行execve的是线程!list_empty(&amp;tsk-&gt;thread_group)
，那么现在需要上升到进程

</panel_attributes>
    <additional_attributes>290.0;10.0;80.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2986</x>
      <y>1329</y>
      <w>14</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>tsk-&gt;tgid = tsk-&gt;pid
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2986</x>
      <y>1322</y>
      <w>9</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2994</x>
      <y>1319</y>
      <w>16</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>current-&gt;dumpable = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2920</x>
      <y>1310</y>
      <w>82</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bprm-&gt;e_uid != current-&gt;euid || bprm-&gt;e_gid != current-&gt;egid || 
	    permission(bprm-&gt;file-&gt;f_dentry-&gt;d_inode,MAY_READ)</panel_attributes>
    <additional_attributes>10.0;10.0;800.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3012</x>
      <y>1319</y>
      <w>16</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>current-&gt;self_exec_id++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2920</x>
      <y>1310</y>
      <w>102</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>10.0;10.0;1000.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3031</x>
      <y>1319</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_signal_handlers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2921</x>
      <y>1310</y>
      <w>120</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>10.0;10.0;1180.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3024</x>
      <y>1325</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //IGN表示ignore
if (ka-&gt;sa.sa_handler != SIG_IGN)
	//设置成default
	ka-&gt;sa.sa_handler = SIG_DFL;
//全都清0
ka-&gt;sa.sa_flags = 0;
sigemptyset(&amp;ka-&gt;sa.sa_mask);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3037</x>
      <y>1321</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历所有的action

</panel_attributes>
    <additional_attributes>20.0;20.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3059</x>
      <y>1319</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_old_files</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2921</x>
      <y>1310</y>
      <w>144</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>10.0;10.0;1420.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3052</x>
      <y>1327</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>files-&gt;close_on_exec-&gt;fds_bits[j] = 0
sys_close(i)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3055</x>
      <y>1322</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
清零位图
关闭位图中指示的文件

</panel_attributes>
    <additional_attributes>110.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3003</x>
      <y>1309</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_personality</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3007</x>
      <y>1274</y>
      <w>77</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>750.0;10.0;10.0;350.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3079</x>
      <y>1311</y>
      <w>31</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>current-&gt;mm-&gt;end_code = ex.a_text +
	(current-&gt;mm-&gt;start_code = N_TXTADDR(ex));
current-&gt;mm-&gt;end_data = ex.a_data +
	(current-&gt;mm-&gt;start_data = N_DATADDR(ex));
current-&gt;mm-&gt;brk = ex.a_bss +
	(current-&gt;mm-&gt;start_brk = N_BSSADDR(ex));

current-&gt;mm-&gt;rss = 0;
current-&gt;mm-&gt;mmap = NULL;
current-&gt;flags &amp;= ~PF_FORKNOEXEC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3080</x>
      <y>1274</y>
      <w>15</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;370.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3113</x>
      <y>1319</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>compute_creds</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3081</x>
      <y>1274</y>
      <w>39</w>
      <h>47</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
计算新代码之后具有的权限
注：可以看代码注释

</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;450.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3081</x>
      <y>1274</y>
      <w>81</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
step2:加载代码段和data段</panel_attributes>
    <additional_attributes>10.0;10.0;790.0;350.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3143</x>
      <y>1308</y>
      <w>19</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
OMAGIC
不是可重入代码</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3159</x>
      <y>1308</y>
      <w>25</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查是否按页对齐
ex.a_text &amp; 0xfff || ex.a_data &amp; 0xfff
fd_offset &amp; ~PAGE_MASK
报问题要间隔5s
(jiffies-error_time2) &gt; 5*HZ
</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3131</x>
      <y>1317</y>
      <w>34</w>
      <h>15</h>
    </coordinates>
    <panel_attributes> //代码段的初始虚拟地址
text_addr = N_TXTADDR(ex)
pos = 32;
map_size = ex.a_text+ex.a_data;
 //申请代码虚拟内存
error = do_brk(text_addr &amp; PAGE_MASK, map_size);
 //读取文件到内存中
bprm-&gt;file-&gt;f_op-&gt;read(bprm-&gt;file, (char *)text_addr,
			  ex.a_text+ex.a_data, &amp;pos)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3156</x>
      <y>1317</y>
      <w>41</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!bprm-&gt;file-&gt;f_op-&gt;mmap||((fd_offset &amp; ~PAGE_MASK) != 0)
如果没有体统mmap，或者没有页对齐，申请虚拟内存，然后将
文件读到用户空间</panel_attributes>
    <additional_attributes>250.0;10.0;150.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3167</x>
      <y>1326</y>
      <w>40</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>do_brk(N_TXTADDR(ex), ex.a_text+ex.a_data);
			bprm-&gt;file-&gt;f_op-&gt;read(bprm-&gt;file,(char *)N_TXTADDR(ex),
					ex.a_text+ex.a_data, &amp;pos);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3209</x>
      <y>1328</y>
      <w>51</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>do_mmap(bprm-&gt;file, N_TXTADDR(ex), ex.a_text,
			PROT_READ | PROT_EXEC,
			MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,
			fd_offset)
do_mmap(bprm-&gt;file, N_DATADDR(ex), ex.a_data,
				PROT_READ | PROT_WRITE | PROT_EXEC,
				MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,
				fd_offset + ex.a_text)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3180</x>
      <y>1317</y>
      <w>47</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果提供mmap，并且与页对齐
直接将文件mmap用户空间</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3209</x>
      <y>1305</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_binfmt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3082</x>
      <y>1274</y>
      <w>133</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1310.0;310.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3218</x>
      <y>1312</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>*old = current-&gt;binfmt;
if (new &amp;&amp; new-&gt;module)
	//增加模块计数
	__MOD_INC_USE_COUNT(new-&gt;module);
current-&gt;binfmt = new;//更新模块
if (old &amp;&amp; old-&gt;module)
	//减少旧的模块计数
	__MOD_DEC_USE_COUNT(old-&gt;module);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3215</x>
      <y>1308</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3249</x>
      <y>1303</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_brk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3082</x>
      <y>1274</y>
      <w>174</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
step3:current-&gt;mm-&gt;start_brk//bss的起始地址
current-&gt;mm-&gt;brk//bss的结束地址</panel_attributes>
    <additional_attributes>10.0;10.0;1720.0;290.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3250</x>
      <y>1309</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_brk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3254</x>
      <y>1306</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请虚拟内存</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3292</x>
      <y>1297</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_arg_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3081</x>
      <y>1274</y>
      <w>218</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
step4:设置栈的虚拟内存
和物理内存</panel_attributes>
    <additional_attributes>10.0;10.0;2160.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3251</x>
      <y>1314</y>
      <w>41</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //栈base的虚拟地址
stack_base = STACK_TOP - MAX_ARG_PAGES*PAGE_SIZE;
 //栈指针的位置
bprm-&gt;p += stack_base;
if (bprm-&gt;loader)
	bprm-&gt;loader += stack_base;
bprm-&gt;exec += stack_base;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3263</x>
      <y>1300</y>
      <w>37</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3294</x>
      <y>1314</y>
      <w>50</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc//申请vma
mpnt-&gt;vm_mm = current-&gt;mm;
 //栈vma的vm_start是栈指针对页取整
mpnt-&gt;vm_start = PAGE_MASK &amp; (unsigned long) bprm-&gt;p;
mpnt-&gt;vm_end = STACK_TOP;//虚拟地址3G
mpnt-&gt;vm_page_prot = PAGE_COPY;
mpnt-&gt;vm_flags = VM_STACK_FLAGS;
mpnt-&gt;vm_ops = NULL;
mpnt-&gt;vm_pgoff = 0;
mpnt-&gt;vm_file = NULL;
mpnt-&gt;vm_private_data = (void *) 0;
 //插入vma
insert_vm_struct(current-&gt;mm, mpnt);
current-&gt;mm-&gt;total_vm = (mpnt-&gt;vm_end - mpnt-&gt;vm_start) &gt;&gt; PAGE_SHIFT
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3297</x>
      <y>1300</y>
      <w>18</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3356</x>
      <y>1309</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_dirty_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3328</x>
      <y>1307</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>bprm-&gt;page[i] = NULL;
 //进程占据物理页面的数量rss
current-&gt;mm-&gt;rss++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3297</x>
      <y>1300</y>
      <w>56</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bprm-&gt;page[i]!=Null
如果栈有被分配物理内存</panel_attributes>
    <additional_attributes>10.0;10.0;540.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3340</x>
      <y>1305</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3346</x>
      <y>1305</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为栈提供虚拟地址的访问页表</panel_attributes>
    <additional_attributes>50.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3343</x>
      <y>1316</y>
      <w>45</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>set_pte(pte, pte_mkdirty(pte_mkwrite(mk_pte(page, PAGE_COPY))))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3361</x>
      <y>1312</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3382</x>
      <y>1297</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_aout_tables</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3390</x>
      <y>1305</y>
      <w>49</w>
      <h>53</h>
    </coordinates>
    <panel_attributes>sp -= envc+1;//栈腾出环境变量的空间，最后一个放NULL
envp = (char **) sp;//main中的envp二重指针
sp -= argc+1;//腾出参数空间
argv = (char **) sp;//main中的argv二重指针
 //将传参放入栈中argc argv envp
put_user((unsigned long) envp,--sp);
put_user((unsigned long) argv,--sp);
put_user(argc,--sp);
 //这个是在execve中的传参地址
current-&gt;mm-&gt;arg_start = (unsigned long) p;

 //p因为put_dirty_page处于用户空间，c在系统空间
 //这里复制argv
while (argc--&gt;0) {
	char c;
	put_user(p,argv++);
	do {
		get_user(c,p++);
	} while (c);
}
put_user(NULL,argv);
current-&gt;mm-&gt;arg_end = current-&gt;mm-&gt;env_start = (unsigned long) p;
 //这里复制env
while (envc--&gt;0) {
	char c;
	put_user(p,envp++);
	do {
		get_user(c,p++);
	} while (c);
}
put_user(NULL,envp);
current-&gt;mm-&gt;env_end = (unsigned long) p;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3389</x>
      <y>1300</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3081</x>
      <y>1274</y>
      <w>309</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;mm-&gt;start_stack
step5:充实栈
</panel_attributes>
    <additional_attributes>10.0;10.0;3070.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3442</x>
      <y>1293</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3443</x>
      <y>1305</y>
      <w>37</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>__asm__("movl %0,%%fs ; movl %0,%%gs": :"r" (0));	\
set_fs(USER_DS);					\
regs-&gt;xds = __USER_DS;					\
regs-&gt;xes = __USER_DS;					\
regs-&gt;xss = __USER_DS;					\
regs-&gt;xcs = __USER_CS;					\
regs-&gt;eip = new_eip;					\
regs-&gt;esp = new_esp;					\
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3447</x>
      <y>1296</y>
      <w>16</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置段，ip esp</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3082</x>
      <y>1274</y>
      <w>367</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ex.a_entry, current-&gt;mm-&gt;start_stack
step6:设置从系统空间返回用户空间的参数设置</panel_attributes>
    <additional_attributes>10.0;10.0;3650.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3549</x>
      <y>1268</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>load_script</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3495</x>
      <y>1282</y>
      <w>47</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.错误检查，要以#！开头
	标志为shell bprm-&gt;sh_bang++
	释放文件
	allow_write_access(bprm-&gt;file);
	fput(bprm-&gt;file);
	bprm-&gt;file = NULL;
2.首先标志出头128字节的字符串在哪里结束
	2.1字符串中的第一个“\n”
	2.2将最后的所有的空格和制表符去掉
3.分析出解释器的开始字符地址i_name，即在#！遇到的第一个不是
	空格 制表符 ‘\0’的字符。然后找到制表符结束地址，即找到
	空格 制表符 ‘\0’的字符，如果是空格 制表符，就将其替换成‘\0’
	顺便找到参数的开始地址i_arg
4.从bprm.page中移除环境变量，然后分别将bprm-&gt;filename i_arg i_name
	压入bprm.page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3515</x>
      <y>1271</y>
      <w>43</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
字符串解析
参数压栈</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3551</x>
      <y>1281</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>open_exec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3556</x>
      <y>1271</y>
      <w>10</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
打开解释器</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3579</x>
      <y>1281</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>bprm-&gt;file = file
prepare_binprm
search_binary_handler
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3556</x>
      <y>1271</y>
      <w>30</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
重新组装linux_binprm
然后找到shell的执行器执行</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3042</x>
      <y>1339</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cap_intersect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3047</x>
      <y>1322</y>
      <w>73</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将两者相与
这里与的是：
 //cap_bset是第CAP_SETPCAP位为0
new_permitted：bprm-&gt;cap_permitted, cap_bset
working：bprm-&gt;cap_inheritable,current-&gt;cap_inheritable</panel_attributes>
    <additional_attributes>710.0;10.0;130.0;150.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3060</x>
      <y>1341</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cap_combine</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3065</x>
      <y>1322</y>
      <w>55</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将两者相或
这里或的是：
new_permitted：new_permitted, working</panel_attributes>
    <additional_attributes>530.0;10.0;190.0;160.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3083</x>
      <y>1322</y>
      <w>51</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bprm-&gt;e_uid != current-&gt;uid || bprm-&gt;e_gid != current-&gt;gid ||
 !cap_issubset(new_permitted, current-&gt;cap_permitted)
 这里是测试是否有超出父进程的权限，cap_issubset表示第一个是第二个的子集
 如果有</panel_attributes>
    <additional_attributes>350.0;10.0;150.0;180.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3081</x>
      <y>1339</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3075</x>
      <y>1343</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;dumpable = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3098</x>
      <y>1339</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
must_not_trace_exec(current)
|| atomic_read(&amp;current-&gt;fs-&gt;count) &gt; 1
|| atomic_read(&amp;current-&gt;files-&gt;count) &gt; 1
|| atomic_read(&amp;current-&gt;sig-&gt;count) &gt; 1
 不允许trace 共用fs files sig</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3083</x>
      <y>1345</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
！CAP_SETUID
进程不允许setuid位</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3071</x>
      <y>1351</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bprm-&gt;e_uid = current-&gt;uid;
bprm-&gt;e_gid = current-&gt;gid;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3103</x>
      <y>1345</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
！CAP_SETPCAP
进程不允许超出父进程的权限</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3101</x>
      <y>1352</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>new_permitted&amp;=current-&gt;cap_permitted
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3135</x>
      <y>1345</y>
      <w>40</w>
      <h>14</h>
    </coordinates>
    <panel_attributes> //不是init进程（pid！=1）
current-&gt;cap_permitted = new_permitted;
current-&gt;cap_effective =
		cap_intersect(new_permitted, bprm-&gt;cap_effective);
 //对于所有的进程
current-&gt;suid = current-&gt;euid = current-&gt;fsuid = bprm-&gt;e_uid;
current-&gt;sgid = current-&gt;egid = current-&gt;fsgid = bprm-&gt;e_gid;
current-&gt;keep_capabilities = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3117</x>
      <y>1322</y>
      <w>36</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
OMAGIC</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3151</x>
      <y>1136</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_execve</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3004</x>
      <y>1157</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3009</x>
      <y>1139</y>
      <w>149</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1470.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2966</x>
      <y>1165</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__getname
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2970</x>
      <y>1160</y>
      <w>40</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>380.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2938</x>
      <y>1175</y>
      <w>36</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc(names_cachep, SLAB_KERNEL)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2954</x>
      <y>1168</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2988</x>
      <y>1166</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_getname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2992</x>
      <y>1160</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2981</x>
      <y>1169</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2976</x>
      <y>1176</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>filter:
1.filename的地址不在用户空间
current-&gt;addr_limit要和KERNEL_DS相等
2.如果在filename用户空间，如果距离用户空间的长度
小于1页，则为实际长度，否则为一页的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3012</x>
      <y>1176</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>strncpy_from_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2994</x>
      <y>1169</y>
      <w>28</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3015</x>
      <y>1179</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
access_ok
对filename有读的权限</panel_attributes>
    <additional_attributes>30.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3013</x>
      <y>1184</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__do_strncpy_from_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3009</x>
      <y>1192</y>
      <w>40</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>"	testl %1,%1\n"					   \
"	jz 2f\n"					   \如果count=0，就不复制
"0:	lodsb\n"					   \否则加载esi的一个字节到al
"	stosb\n"					   \将al中的数装载到edi中
"	testb %%al,%%al\n"				   \
"	jz 1f\n"					   \如果al=0，则退出复制
"	decl %1\n"					   \count--
"	jnz 0b\n"					   \继续复制
"1:	subl %1,%0\n"		\//计算出字符的长度res=res-count
"2:\n"
: "=d"(res), "=c"(count), "=&amp;a" (__d0), "=&amp;S" (__d1),	   \
  "=&amp;D" (__d2)						   \
: "i"(-EFAULT), "0"(count), "1"(count), "3"(src), "4"(dst) \
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3021</x>
      <y>1187</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fixup和__ex_table
参考__copy_user_zeroing</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2994</x>
      <y>1169</y>
      <w>45</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3031</x>
      <y>1177</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>如果正确返回0
不正确返回错误代码
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3007</x>
      <y>1160</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
正确的话返回装有
复制过来的filename
的slab</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3006</x>
      <y>1167</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return result
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3155</x>
      <y>1139</y>
      <w>94</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1.空指针检查
2.是否超过上限（-1000）这里转换成无符号数</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3241</x>
      <y>1149</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_execve
主要工作：
1.加载可执行文件
2.复制参数到linux_binprm
3.寻找到执行模块执行</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3046</x>
      <y>1170</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>open_exec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3051</x>
      <y>1152</y>
      <w>198</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1960.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3068</x>
      <y>1171</y>
      <w>49</w>
      <h>49</h>
    </coordinates>
    <panel_attributes> //因为有一个arg[0],所以减去一个指针的长度，总共传参大侠最大为32页
bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
memset(bprm.page, 0, MAX_ARG_PAGES*sizeof(bprm.page[0])); 

bprm.file = file;
bprm.filename = filename;
bprm.sh_bang = 0;//1表示shell，0表示二进制文件
bprm.loader = 0;
bprm.exec = 0;
 //计算传参的数目
bprm.argc = count(argv, bprm.p / sizeof(void *))
			//这里的count是计算argv的数目，直到*argv为NUll
			__get_user_4:
			addl $3,%eax //eax在get_user中定义为ptr（argv）
							//和返回值的值
			movl %esp,%edx
			jc bad_get_user
			andl $0xffffe000,%edx//edx设置为task的2k页面
			cmpl addr_limit(%edx),%eax//比较装载的ptr是否超过界限
			jae bad_get_user
		3:	movl -3(%eax),%edx//这里将*argv的值赋给edx，edx在get_user
									//中定义为装载*argv的指针
			xorl %eax,%eax//将eax赋值为0，即返回值为0
			ret	
bprm.envc = count(envp, bprm.p / sizeof(void *))
	//因为在open_exec中通过deny_write_access将文件写给锁住，
	//所以如果出现错误，需要通过allow_write_access将文件写打开
	//并且通过fput（file）将文件释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3084</x>
      <y>1152</y>
      <w>165</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
linux_binprm
装有可执行程序的信息</panel_attributes>
    <additional_attributes>1630.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3172</x>
      <y>1169</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>prepare_binprm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3176</x>
      <y>1152</y>
      <w>74</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读取前128字节</panel_attributes>
    <additional_attributes>720.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3258</x>
      <y>1168</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_strings_kernel</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3248</x>
      <y>1152</y>
      <w>24</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制filename到系统空间</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3233</x>
      <y>1177</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>oldfs = get_fs()(current.addr_limit)
set_fs(KERNEL_DS)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3283</x>
      <y>1177</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_fs(oldfs)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3242</x>
      <y>1171</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3265</x>
      <y>1171</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3261</x>
      <y>1177</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_strings</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3265</x>
      <y>1171</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
赋值argv到系统空间</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3246</x>
      <y>1185</y>
      <w>52</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.循环argc，直到结束
2.通过get_user从后向前复制**argv到str，检查str不为空
	通过strnlen_user计算str的长度
		mask = -__addr_ok(s); //如果地址满足要求mask为0xFFFFFFFF,否则为0
		"	andl %0,%%ecx\n"//正确ecx为n，否则为0，
		"0:	repne; scasb\n"//将edi（s）中的字节和al比较，如果不同则ecx--,
						//然后继续，如果相同，则停止
		"	setne %%al\n"//将eflag中的zf取反赋给al
		"	subl %%ecx,%0\n"//n=n-ecx 即s的长度
		"	addl %0,%%eax\n"//eax=0+n即为s的长度为返回值
		"1:\n"
		:"=r" (n), "=D" (s), "=a" (res), "=c" (tmp)
		:"0" (n), "1" (s), "2" (0), "3" (mask)
		:"cc");
	错误性检查str的长度len不能查超过最大长度bprm-&gt;p
3.将最大长度bprm-&gt;p更新，以便检查下一个argv
4.找到这个argv在bprm-&gt;page中的位置，如果这个page没有物理内存，就申请一个
	bprm-&gt;page[i] = page，并将这一页中这个argv没用到的部分全部清0，
	并通过copy_from_user将argv复制到申请的内存中
5.然后通过下面更新局部变量，然后再次循环
	pos += bytes_to_copy;
	str += bytes_to_copy;
	len -= bytes_to_copy;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3265</x>
      <y>1180</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3278</x>
      <y>1168</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bprm.exec = bprm.p
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3302</x>
      <y>1167</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_strings</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3248</x>
      <y>1152</y>
      <w>34</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3249</x>
      <y>1152</y>
      <w>60</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制参数和环境变量到
bprm-&gt;page</panel_attributes>
    <additional_attributes>10.0;10.0;580.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3319</x>
      <y>1167</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>search_binary_handler</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3247</x>
      <y>1152</y>
      <w>83</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到执行模块
</panel_attributes>
    <additional_attributes>10.0;10.0;810.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3300</x>
      <y>1176</y>
      <w>68</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.遍历formats链表，通过函数指针fmt-&gt;load_binary加载指定的bprm（二进制文件或者解释文件）
2.如果加载成功
	if (retval &gt;= 0) {
		put_binfmt(fmt);//释放动态安装模块
		allow_write_access(bprm-&gt;file);//释放文件写
		if (bprm-&gt;file)
			fput(bprm-&gt;file);//释放文件
		bprm-&gt;file = NULL;
		current-&gt;did_exec = 1;
		return retval;//返回成功标志
	}
3.如果没成功，通过put_binfmt(fmt)释放模块。
		如果返回值不是-ENOEXEC，说明该模块可以执行这个文件，但是却出现了其他错误，直接break
		如果bprm-&gt;file不存在，即可执行文件不存在，直接退出
		否则继续遍历下一个动态安装模块
4.如果遍历完formats链表中的所有模块，都没有执行，则通过request_module请求可以执行这个文件的动态
	安装模块
5.找到模块之后再次遍历整个formats链表
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3327</x>
      <y>1170</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3080</x>
      <y>1205</y>
      <w>250</w>
      <h>68</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2480.0;10.0;1810.0;450.0;10.0;660.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3327</x>
      <y>1205</y>
      <w>227</w>
      <h>65</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1190.0;580.0;2250.0;630.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3124</x>
      <y>1172</y>
      <w>57</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>550.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3121</x>
      <y>1178</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.取出file中的inode，检查其mode
2.检查file相关的文件操作是否存在
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3147</x>
      <y>1178</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>bprm-&gt;e_uid = current-&gt;euid;
	bprm-&gt;e_gid = current-&gt;egid;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3156</x>
      <y>1172</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3136</x>
      <y>1182</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(inode)-&gt;i_sb-&gt;s_flag（超级块标志）
超级块中不存在MS_NOSUID</panel_attributes>
    <additional_attributes>200.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3124</x>
      <y>1187</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //如果inode的mode标记上了S_ISUID
bprm-&gt;e_uid = inode-&gt;i_uid;
 //如果inode的mode标记上了S_ISGID | S_IXGRP
bprm-&gt;e_gid = inode-&gt;i_gid
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3168</x>
      <y>1179</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>cap_clear(bprm-&gt;cap_inheritable);
cap_clear(bprm-&gt;cap_permitted);
cap_clear(bprm-&gt;cap_effective);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3175</x>
      <y>1172</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
普通用户得到的授权</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3179</x>
      <y>1172</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果SECUREBITS_DEFAULT中
SECURE_NOROOT位置上</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3191</x>
      <y>1178</y>
      <w>16</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bprm-&gt;e_uid == 0 || 
current-&gt;uid == 0</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3183</x>
      <y>1187</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cap_set_full(bprm-&gt;cap_inheritable);
cap_set_full(bprm-&gt;cap_permitted);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3208</x>
      <y>1188</y>
      <w>22</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>cap_set_full(bprm-&gt;cap_effective)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3205</x>
      <y>1178</y>
      <w>16</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bprm-&gt;e_uid == 0</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3212</x>
      <y>1178</y>
      <w>7</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>memset
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3179</x>
      <y>1172</y>
      <w>37</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bprm-&gt;buf,0,BINPRM_BUF_SIZE</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3220</x>
      <y>1177</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kernel_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3178</x>
      <y>1172</y>
      <w>49</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2679</x>
      <y>1466</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>1469</y>
      <w>42</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter：!current-&gt;active_mm
	in_interrupt 不能再interrupt中调度
 //如果还有bh没有执行，先去执行相应的中断，然后再schedule
	softirq_active(this_cpu) &amp; softirq_mask(this_cpu)</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2619</x>
      <y>1486</y>
      <w>26</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>sched_data = 
&amp; aligned_data[this_cpu].schedule_data
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2629</x>
      <y>1477</y>
      <w>57</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>550.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2662</x>
      <y>1477</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SCHED_RR</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2654</x>
      <y>1485</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>move_rr_last
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2657</x>
      <y>1488</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!prev-&gt;counter</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2641</x>
      <y>1492</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2628</x>
      <y>1496</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>prev-&gt;counter = 
NICE_TO_TICKS(prev-&gt;nice)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2659</x>
      <y>1497</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>move_last_runqueue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2657</x>
      <y>1492</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2647</x>
      <y>1504</y>
      <w>29</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_del(&amp;p-&gt;run_list);
list_add_tail(&amp;p-&gt;run_list, &amp;runqueue_head)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2661</x>
      <y>1500</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>1477</y>
      <w>10</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
prev-&gt;state</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>1485</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TASK_INTERRUPTIBLE</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2677</x>
      <y>1489</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
signal_pending</panel_attributes>
    <additional_attributes>70.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2671</x>
      <y>1493</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>prev-&gt;state = TASK_RUNNING
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2696</x>
      <y>1493</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>del_from_runqueue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>1489</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>1485</y>
      <w>23</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
default</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>1485</y>
      <w>38</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TASK_RUNNING</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2713</x>
      <y>1493</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>不变
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2728</x>
      <y>1493</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>prev-&gt;need_resched = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>1477</y>
      <w>53</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2749</x>
      <y>1493</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>next = idle_task(this_cpu);
	c = -1000;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2684</x>
      <y>1477</y>
      <w>77</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果runqueue_head中没有task
会默认选idle_task</panel_attributes>
    <additional_attributes>10.0;10.0;750.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2769</x>
      <y>1493</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>still_running
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2684</x>
      <y>1477</y>
      <w>95</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
prev-&gt;state == TASK_RUNNING</panel_attributes>
    <additional_attributes>10.0;10.0;930.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2758</x>
      <y>1502</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>goodness</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2774</x>
      <y>1502</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>next = prev
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2773</x>
      <y>1496</y>
      <w>9</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2762</x>
      <y>1496</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2716</x>
      <y>1505</y>
      <w>50</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SCHED_YIELD
礼让</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2710</x>
      <y>1514</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>weight=-1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2740</x>
      <y>1505</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SCHED_OTHER
(交互式应用：注重响应时间)</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2736</x>
      <y>1514</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>weight = p-&gt;counter //如果时间片用完，就直接退出
weight += 1 //p-&gt;mm == this_mm || !p-&gt;mm
				//如果是当前进程或者是内核线程
weight += 20 - p-&gt;nice
		//如果之前存在时间片，加大其时间片
		nice是19~-20，表示谦让程度

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2763</x>
      <y>1505</y>
      <w>20</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
实时性进程
SCHED_FIFO //执行时间较短
SCHED_RR //执行时间较长
</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2776</x>
      <y>1515</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>weight = 1000 + p-&gt;rt_priority
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>1477</y>
      <w>114</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1120.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2789</x>
      <y>1491</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>遍历整个runqueue_head
找到goodness最大的task
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>1477</y>
      <w>140</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
所有TASK_RUNNING的task的时间片都用完了
!c</panel_attributes>
    <additional_attributes>10.0;10.0;1380.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2810</x>
      <y>1492</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>recalculate
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2791</x>
      <y>1501</y>
      <w>39</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>p-&gt;counter = (p-&gt;counter &gt;&gt; 1) + NICE_TO_TICKS(p-&gt;nice)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2803</x>
      <y>1495</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
对所有的task重新分配时间片
然后再次找到最大的执行全的task</panel_attributes>
    <additional_attributes>150.0;10.0;70.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2829</x>
      <y>1492</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sched_data-&gt;curr = next
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>1477</y>
      <w>155</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1530.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>1477</y>
      <w>179</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
prev == next</panel_attributes>
    <additional_attributes>10.0;10.0;1770.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2852</x>
      <y>1492</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>same_process
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2856</x>
      <y>1495</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2837</x>
      <y>1499</y>
      <w>33</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>如果need_resched置上，则重新执行一边schedule
否则return
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2869</x>
      <y>1492</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kstat.context_swtch++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>1477</y>
      <w>192</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1900.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>1477</y>
      <w>219</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2170.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2889</x>
      <y>1488</y>
      <w>13</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
切换为内核线程
!mm
复用之前task的mm</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2872</x>
      <y>1498</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>next-&gt;active_mm = oldmm;
atomic_inc(&amp;oldmm-&gt;mm_count);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2899</x>
      <y>1488</y>
      <w>14</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
切换为用户进程</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2904</x>
      <y>1498</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>switch_mm
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2899</x>
      <y>1488</y>
      <w>34</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!prev-&gt;mm
要切换的task是内核线程或者是
exit的用户进程</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2921</x>
      <y>1497</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>prev-&gt;active_mm = NULL;
			mmdrop(oldmm);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2949</x>
      <y>1488</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>switch_to</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>1477</y>
      <w>274</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2720.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3019</x>
      <y>1487</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__schedule_tail</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3025</x>
      <y>1490</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2683</x>
      <y>1477</y>
      <w>343</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3410.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2941</x>
      <y>1501</y>
      <w>69</w>
      <h>63</h>
    </coordinates>
    <panel_attributes>asm volatile("pushl %%esi\n\t"					\
"pushl %%edi\n\t"					\
"pushl %%ebp\n\t"					\
"movl %%esp,%0\n\t"	/* save ESP */		\
 //这里切换了系统栈
"movl %3,%%esp\n\t"	/* restore ESP */	\
	//这里保存了pre进程再次调用时的返回地址
"movl $1f,%1\n\t"		/* save EIP */		
 //对于初次fork的进程，这里压栈的是ret_from_fork
 //对于经历过schedule的进程，这里压栈是1f
 //对于linux0.11而言，返回地址是用户空间的系统调用，因为cs：ip被赋值为用户空间
 //对于2.4.0而言，返回地址是系统空间，不管是新创建的进程（ret_from_fork）还是schedule过的进程（1f）
 //cs：ip都是指向系统空间的
"pushl %4\n\t"		/* restore EIP */	\
"jmp __switch_to\n"				\
"1:\t"						\
"popl %%ebp\n\t"					\
"popl %%edi\n\t"					\
"popl %%esi\n\t"					\
:"=m" (prev-&gt;thread.esp),"=m" (prev-&gt;thread.eip),	\
"=b" (last)					\
:"m" (next-&gt;thread.esp),"m" (next-&gt;thread.eip),	\
"a" (prev), "d" (next),				\
"b" (prev));					\

注：根据i386 ABI规则
eax ecx edx eflag在编译的时候如果调用者后期需要用，需要将其
压栈保护
esi edi ebx ebp esp会由被调用者保护，所以在被使用的时候会将这些寄存器
压栈保护
所以这些通用寄存器如果后期会用到，会在编译的时候进行保护

注：ebp被用来访问栈，首次进入一个函数中栈中：
		函数参数
		ip
esp：	上一个函数的ebp
将esp的地址复制给ebp，成为本函数访问栈空间的基址，访问传参使用ebp+（例如访问第一个参数（ebp+8））
访问本函数的占空间使用ebp-。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2954</x>
      <y>1491</y>
      <w>3</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2966</x>
      <y>1567</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>_switch_to</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2971</x>
      <y>1562</y>
      <w>36</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注：_switch_to的申明是被FASTCALL修饰过的
根据GUN的编译规则regparm(3)，是通过eax edx ecx
依次传参，其余的是通过栈传参
所以这里能将prev和next指针传递进来</panel_attributes>
    <additional_attributes>20.0;20.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2953</x>
      <y>1575</y>
      <w>36</w>
      <h>14</h>
    </coordinates>
    <panel_attributes> //保存系统堆栈的地址到TSS中，以便之后在用户空间
 //发生中断 异常的时候，能进行堆栈的切换
 //ss不用变，因为用的是同一个TSS
tss-&gt;esp0 = next-&gt;esp0
asm volatile("movl %%fs,%0":"=m" (*(int *)&amp;prev-&gt;fs));
asm volatile("movl %%gs,%0":"=m" (*(int *)&amp;prev-&gt;gs));
loadsegment(fs, next-&gt;fs);
loadsegment(gs, next-&gt;gs);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2970</x>
      <y>1570</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3998</x>
      <y>1473</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up_process </panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3992</x>
      <y>1476</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3979</x>
      <y>1482</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>p-&gt;state = TASK_RUNNING
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4004</x>
      <y>1476</y>
      <w>22</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在调度链表中
task_on_runqueue
 //调度链表是一个循环链表
p-&gt;run_list.next != NULL</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4005</x>
      <y>1486</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4004</x>
      <y>1476</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否则加入调度链表
并重新调度</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4017</x>
      <y>1489</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_to_runqueue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4023</x>
      <y>1482</y>
      <w>9</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4046</x>
      <y>1489</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reschedule_idle</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4029</x>
      <y>1482</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4007</x>
      <y>1496</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //list_add是头插
list_add(&amp;p-&gt;run_list, &amp;runqueue_head);
nr_running++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4020</x>
      <y>1492</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4033</x>
      <y>1503</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tsk = cpu_curr(this_cpu)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4037</x>
      <y>1492</y>
      <w>22</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取正在调度的task
schedule_data.curr
不用current，因为在schedule
中准备切栈的之前，已经决定出了
要调度的task</panel_attributes>
    <additional_attributes>160.0;10.0;50.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4053</x>
      <y>1492</y>
      <w>28</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
preemption_goodness
比较两个task之间的权重
如果要唤醒的task权重比
调度的task的权重大</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4070</x>
      <y>1504</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tsk-&gt;need_resched = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3438</x>
      <y>1477</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sched_setscheduler</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3466</x>
      <y>1477</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sched_setparam</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3449</x>
      <y>1493</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setscheduler</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3445</x>
      <y>1480</y>
      <w>20</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pid, policy, param</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3458</x>
      <y>1480</y>
      <w>18</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pid, -1, param</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3457</x>
      <y>1496</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter:
!param || pid &lt; 0</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3416</x>
      <y>1500</y>
      <w>45</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从用户空间复制param</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3411</x>
      <y>1509</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_from_user
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3427</x>
      <y>1509</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_process_by_pid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3435</x>
      <y>1500</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3432</x>
      <y>1512</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果pid为0，就返回current
否则</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3424</x>
      <y>1521</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_task_by_pid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3420</x>
      <y>1528</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>从pidhash中查找pid相同的task
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3427</x>
      <y>1524</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3446</x>
      <y>1510</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>policy&lt;0，
则用进程原本的policy
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3450</x>
      <y>1500</y>
      <w>10</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3467</x>
      <y>1511</y>
      <w>36</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.lp.sched_priority要在0~99
2.policy == SCHED_OTHER的时候
	lp.sched_priority == 0
3.如果切换实时策略
	policy == SCHED_FIFO || policy == SCHED_RR
	需要的current-&gt;cap_effective的CAP_SYS_NICE
	位置上
4.如果当前进程和要设置的进程的euid和uid都不相同
	同样也需要current-&gt;cap_effective的CAP_SYS_NICE
	位置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3457</x>
      <y>1500</y>
      <w>16</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3506</x>
      <y>1510</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>p-&gt;policy = policy;
p-&gt;rt_priority = lp.sched_priority;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3456</x>
      <y>1500</y>
      <w>62</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;600.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3457</x>
      <y>1500</y>
      <w>82</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
task_on_runqueue
如果在调度链表中
将task移到链表的最前端</panel_attributes>
    <additional_attributes>10.0;10.0;800.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3530</x>
      <y>1509</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>move_first_runqueue
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3549</x>
      <y>1509</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;need_resched = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3457</x>
      <y>1501</y>
      <w>101</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;990.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3574</x>
      <y>1473</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sched_yield</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3581</x>
      <y>1476</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有其他task在就绪链表中
nr_pending--</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3571</x>
      <y>1482</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>if (current-&gt;policy == SCHED_OTHER)
	current-&gt;policy |= SCHED_YIELD;
	current-&gt;need_resched = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3734</x>
      <y>1468</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_nanosleep</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3644</x>
      <y>1480</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_from_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3649</x>
      <y>1471</y>
      <w>93</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制用户空间的规定的时间rqtp</panel_attributes>
    <additional_attributes>910.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3669</x>
      <y>1471</y>
      <w>74</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>720.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3664</x>
      <y>1482</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>t.tv_nsec &gt;= 1000000000L
|| t.tv_nsec &lt; 0 
|| t.tv_sec &lt; 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3713</x>
      <y>1471</y>
      <w>32</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
t.tv_sec == 0 &amp;&amp; t.tv_nsec &lt;= 2000000L &amp;&amp;
current-&gt;policy != SCHED_OTHER
如果定义小于2ms，并且是实时进程
因为时钟中断是10ms，如果让进程睡，很可能会
错过这个时间，所以用延时

转化为us</panel_attributes>
    <additional_attributes>280.0;10.0;30.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3711</x>
      <y>1485</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udelay</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3711</x>
      <y>1492</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__udelay</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3717</x>
      <y>1488</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将延时的时间换算成loops
然后递减</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3712</x>
      <y>1501</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__const_udelay</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3716</x>
      <y>1495</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
微秒换算为秒
但是这个值太小，所以先将其左移32位，
然后再换算为秒</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3713</x>
      <y>1509</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__delay</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3717</x>
      <y>1504</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
秒换算成loops
将 秒*loops_per_jiffy*hz
loops_per_jiffy：10ms内loop的个数
hz：100，即jiffy*hz为1s</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3714</x>
      <y>1516</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__loop_delay</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3719</x>
      <y>1512</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3711</x>
      <y>1523</y>
      <w>17</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>递减loops，直到loops为0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3719</x>
      <y>1519</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3735</x>
      <y>1484</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>timespec_to_jiffies</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3740</x>
      <y>1471</y>
      <w>18</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1000000000L / HZ
表示每个jiffy需要多少ns</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3757</x>
      <y>1484</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;state = TASK_INTERRUPTIBLE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3740</x>
      <y>1471</y>
      <w>30</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3790</x>
      <y>1484</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>schedule_timeout</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3740</x>
      <y>1471</y>
      <w>60</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注意到这如果t.tv_sec || t.tv_nsec有值
最小的的expire时间为2

如果时间没到就被唤醒，返回的是expire-jiffies，否则为0</panel_attributes>
    <additional_attributes>10.0;10.0;580.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3792</x>
      <y>1487</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3758</x>
      <y>1491</y>
      <w>37</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MAX_SCHEDULE_TIMEOUT
如果是最大值，表示无限期延长
就不计时唤醒，直接schedule</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3774</x>
      <y>1491</y>
      <w>21</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
timeout &lt; 0</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3753</x>
      <y>1504</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>schedule();
goto out
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3770</x>
      <y>1505</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;state = TASK_RUNNING;
goto out;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3797</x>
      <y>1487</y>
      <w>13</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
唤醒的绝对时间</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3792</x>
      <y>1498</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expire = timeout + jiffies
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3811</x>
      <y>1499</y>
      <w>26</w>
      <h>16</h>
    </coordinates>
    <panel_attributes> //初始化timer指针
init_timer(&amp;timer);
	//定时绝对时间
timer.expires = expire;
	//时间到了之后唤醒进程，作为function
	//的传参
timer.data = (unsigned long) current;
	//时间到了之后的函数
timer.function = process_timeout
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3797</x>
      <y>1487</y>
      <w>33</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置定时时间</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3842</x>
      <y>1499</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3797</x>
      <y>1487</y>
      <w>52</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3843</x>
      <y>1506</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>internal_add_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3846</x>
      <y>1502</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
首先进行错误检查
timer不能在链表中</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3838</x>
      <y>1513</y>
      <w>56</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.jiffies是一个32位的数，linux中将这32位转化成6+6+6+6+8
2.如果偏移值小于256，则将时间戳放在tv1.vec对应的数组中
	（数组中的每个list_head都对应具体的一个时间戳）
	如果偏移值大于256，但是小于1&lt;&lt;(6+8),则将1组时间戳存放在
	tv2.vec对应的数组中（例如：0x187和0x101在这个数组中同一个
	位置的队列中），依次类推。
	当低8位的时间戳用完之后，会向高6位的数组借一位，并且通过再次通过
	internal_add_timer将这一组队列重新排布，（具体见run_timer_list
	--&gt;cascade_timers）以此类推。
3.list_add(&amp;timer-&gt;list, vec-&gt;prev)将timer加到队列的最尾端
注：1.如果设置的时间戳expires小于timer_jiffies（以及处理的时间戳+1），
	则这个时间点已经过去，就用timer就加到timer_jiffies所在的队列
	（tv1.vec + tv1.index）
	2.判断作为哪里容纳timer时间戳的条件是偏移值，但是容纳的点却是绝对值
	试想：如果timer_jiffies运行到一个位置，而来了一个256+timer_jiffies-3
	（timer_jiffies&gt;3）的时间戳，按照条件，这个应该存储到tv1.vec，但是存储的点
	却是timer_jiffies-3的位置，此时队列应该是空的（因为已经运行过）。
	3.除了tv1.vec[0]中有队列外，其他的4个数组中的第一项都是没有队列的，这一点可以由
	 判断条件得到
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3849</x>
      <y>1509</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3861</x>
      <y>1498</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3877</x>
      <y>1498</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3798</x>
      <y>1487</y>
      <w>69</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3799</x>
      <y>1487</y>
      <w>86</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果时间没到就被信号唤醒
</panel_attributes>
    <additional_attributes>10.0;10.0;840.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3739</x>
      <y>1471</y>
      <w>85</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
剩余时间转化成timespec
并复制到用户空间</panel_attributes>
    <additional_attributes>10.0;10.0;830.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3819</x>
      <y>1482</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>jiffies_to_timespec
copy_to_user
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3919</x>
      <y>1472</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_pause</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3912</x>
      <y>1483</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>current-&gt;state = TASK_INTERRUPTIBLE;
schedule();
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3924</x>
      <y>1475</y>
      <w>4</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3012</x>
      <y>1494</y>
      <w>47</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.将prev.policy中的SCHED_YIELD清除，将prev.has_cpu置0，这两部都要
	将cache同步到内存，保证数据及时更新
2.如果prev的状态还是TASK_RUNNING
	1.如果时idle_task，或者之前要SCHED_YIELD，就不需要执行，return
	2.否则通过reschedule_idle看是否在其他核上是否能重新调度prev
3.如果prev状态是其他，直接return
注：此时虽然sp，ip已经更替，但是像eax等寄存器还是prev执行时的值
	因为switch_to把prev放在了eax中，所以切换到next之后，prev还能保持
	在prev执行时的值
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3030</x>
      <y>1513</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reschedule_idle</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3035</x>
      <y>1509</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3014</x>
      <y>1520</y>
      <w>45</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.先检查p之前运行的cpu（p-&gt;processor），
	如果可以在这个cpu上执行（can_schedule，has_cpu为0：没有cpu执行;cpus_allowed位图中当前cpu置上）
	如果cpu当前运行的task（cpu_curr）是idle_task
	tsk-&gt;need_resched = 1//如果是当前cpu，系统调用返回时就会调度p
	如果这个cpu不是当前cpu，并且之前need_resched没被置上，通过smp_send_reschedule通知cpu shcedule
2.遍历所有的cpu
	1.p要能在cpu上执行（can_schedule）
	2.如果cpu当前执行的task（cpu_curr）是idle_task，选取last_schedule最小的cpu
	3.如果执行的是其他task，选取goodness相差最大的cpu
	4.如果找到了cpu（target_tsk不为NULL）,
		1.如果cpu上执行的是idle_task，就去该cpu执行
		2.如果没有idle_task:
			tsk-&gt;need_resched = 1 //本cpu只要这个置上就可以了
			smp_send_reschedule(tsk-&gt;processor)//如果在其他cupu上，要通知其他cpu进中断
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3035</x>
      <y>1516</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3149</x>
      <y>1468</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_wait4</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3128</x>
      <y>1471</y>
      <w>52</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
options &amp; ~(WNOHANG|WUNTRACED|__WNOTHREAD|__WCLONE|__WALL)
option不能有除这些之外的其他的标志置上</panel_attributes>
    <additional_attributes>280.0;10.0;230.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3135</x>
      <y>1476</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
&amp;current-&gt;wait_chldexit,&amp;wait</panel_attributes>
    <additional_attributes>160.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3132</x>
      <y>1481</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_wait_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3116</x>
      <y>1488</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait-&gt;flags = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3121</x>
      <y>1484</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3135</x>
      <y>1488</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__add_wait_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3128</x>
      <y>1484</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将current.tasklist加入到
current.wait_chldexit.tasklist的链表中</panel_attributes>
    <additional_attributes>90.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3133</x>
      <y>1494</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3137</x>
      <y>1491</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3149</x>
      <y>1476</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
扫描当前进程所有线程的子进程
从最年轻的子进程开始查找
</panel_attributes>
    <additional_attributes>20.0;10.0;190.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3154</x>
      <y>1484</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3149</x>
      <y>1490</y>
      <w>33</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>pid符合要求的子进程
1.如果pid&gt;0，找到是进程号是pid的子进程
2.pid=0，找的是和当前进程同一个进程组的子进程
3.pid&lt;-1，找的是进程组号是-pid的子进程
4.pid=-1,所有的子进程

1.__WALL，表示不管是什么子进程都wait
2.如果__WALL没置上：
	__WCLONE置上，wait exit_signal不为SIGCHLD
	__WCLONE没置上，wait exit_signal为SIGCHLD
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3183</x>
      <y>1491</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flag = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3167</x>
      <y>1484</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3166</x>
      <y>1484</y>
      <w>39</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3195</x>
      <y>1488</y>
      <w>17</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TASK_STOPPED</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3201</x>
      <y>1488</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TASK_ZOMBIE</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3180</x>
      <y>1507</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>current-&gt;times.tms_cutime += 
p-&gt;times.tms_utime + p-&gt;times.tms_cutime;
current-&gt;times.tms_cstime += 
p-&gt;times.tms_stime + p-&gt;times.tms_cstime;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3190</x>
      <y>1495</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3218</x>
      <y>1495</y>
      <w>47</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3250</x>
      <y>1502</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
p-&gt;p_opptr != p-&gt;p_pptr
生父和养父不一样</panel_attributes>
    <additional_attributes>130.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3244</x>
      <y>1507</y>
      <w>26</w>
      <h>14</h>
    </coordinates>
    <panel_attributes> //将子进程从之前养父的链表中删除
REMOVE_LINKS(p);
	//最后通知的还是生父去处理
p-&gt;p_pptr = p-&gt;p_opptr;
	//加到task序列和生父的宗族关系中
SET_LINKS(p);
	//通知新的养父去处理
do_notify_parent(p, SIGCHLD);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3301</x>
      <y>1509</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>release_task</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3261</x>
      <y>1502</y>
      <w>47</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3267</x>
      <y>1512</y>
      <w>43</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3251</x>
      <y>1523</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>atomic_dec(&amp;p-&gt;user-&gt;processes);
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3278</x>
      <y>1523</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_uid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3283</x>
      <y>1512</y>
      <w>27</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3282</x>
      <y>1526</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
up &amp;&amp; atomic_dec_and_lock(&amp;up-&gt;__count</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3267</x>
      <y>1536</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uid_hash_remove</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3287</x>
      <y>1536</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3268</x>
      <y>1531</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pprev指向（指向自己的指针）
所以对pprev解引用赋值，就是改变
上一个next中的值</panel_attributes>
    <additional_attributes>150.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3282</x>
      <y>1531</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3300</x>
      <y>1523</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unhash_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3304</x>
      <y>1512</y>
      <w>6</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3303</x>
      <y>1531</y>
      <w>18</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>nr_threads--;
	//将p从pid hash中删除
unhash_pid(p);
	//解除其宗族关系
REMOVE_LINKS(p);
	//从线程中删除
list_del(&amp;p-&gt;thread_group)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3305</x>
      <y>1526</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3319</x>
      <y>1522</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>release_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3307</x>
      <y>1512</y>
      <w>20</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mm在exit中被置成NULL</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3334</x>
      <y>1523</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>current-&gt;cmin_flt += p-&gt;min_flt + p-&gt;cmin_flt;
current-&gt;cmaj_flt += p-&gt;maj_flt + p-&gt;cmaj_flt;
current-&gt;cnswap += p-&gt;nswap + p-&gt;cnswap;
current-&gt;counter += p-&gt;counter
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3307</x>
      <y>1512</y>
      <w>33</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3369</x>
      <y>1524</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_task_struct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3307</x>
      <y>1512</y>
      <w>70</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3213</x>
      <y>1495</y>
      <w>16</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
copy rusage到ru</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3209</x>
      <y>1508</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getrusage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3222</x>
      <y>1509</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3218</x>
      <y>1495</y>
      <w>23</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
exit_code复制到stat_addr</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3235</x>
      <y>1509</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>end_wait4
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3214</x>
      <y>1495</y>
      <w>30</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制到用户空间出错了
不释放task的空间直接退出
当父进程exit时，看到子进程是TASK_ZOMBIE
就通知其新任父进程将其回收
</panel_attributes>
    <additional_attributes>50.0;10.0;240.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3045</x>
      <y>1837</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_exit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3046</x>
      <y>1848</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_exit
主要过程：
1.与do_fork相反的过程
	mm退出
	file close
	文件路径退出
	sig 退出
	thread 退出
2.解除关系
	如果是seesion的主进程，和tty解除
	如果由动态安装模块，减少计数
	父进程 子进程 进程组之间的关系
3.schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3050</x>
      <y>1840</y>
      <w>16</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(error_code&amp;0xff)&lt;&lt;8</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2838</x>
      <y>1864</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.in_interrupt（不能再irq和bh中）
	//中断服务程序不允许调用exit，因为
	//exit不能返回
2.tsk-&gt;pid不为0和1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2855</x>
      <y>1851</y>
      <w>200</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>1980.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2865</x>
      <y>1865</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tsk-&gt;flags |= PF_EXITING
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2872</x>
      <y>1851</y>
      <w>182</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1800.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2887</x>
      <y>1865</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>del_timer_sync</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2892</x>
      <y>1851</y>
      <w>163</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tsk-&gt;real_timer</panel_attributes>
    <additional_attributes>1610.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2867</x>
      <y>1868</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2886</x>
      <y>1868</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2861</x>
      <y>1872</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>detach_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2874</x>
      <y>1872</y>
      <w>26</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>timer-&gt;list.next = timer-&gt;list.prev = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2855</x>
      <y>1881</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_del</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2848</x>
      <y>1875</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果timer-&gt;list.next == NULL
timer-&gt;list
猜想：是双向链表，所以如果next没有，就没有
加入到timer的链表中</panel_attributes>
    <additional_attributes>180.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2905</x>
      <y>1865</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__exit_mm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2912</x>
      <y>1851</y>
      <w>143</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1410.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2879</x>
      <y>1877</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mm_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2883</x>
      <y>1868</y>
      <w>30</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
表示不会回到用户空间</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2910</x>
      <y>1868</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mm!=Null</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2895</x>
      <y>1874</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2881</x>
      <y>1882</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes> //退出了mm，但增加active_mm的计数
atomic_inc(&amp;mm-&gt;mm_count)
tsk-&gt;mm = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2906</x>
      <y>1882</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>enter_lazy_tlb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2912</x>
      <y>1874</y>
      <w>12</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2919</x>
      <y>1881</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mmput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2921</x>
      <y>1874</y>
      <w>41</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为增加了mm_count的计数
这里只是释放了页表和页面，并没有把mm的实体释放，
因为schedule需要active_mm，mm是再schedule中释放的</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2926</x>
      <y>1869</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sem_exit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2930</x>
      <y>1851</y>
      <w>125</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1230.0;10.0;120.0;130.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2947</x>
      <y>1863</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__exit_files</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2953</x>
      <y>1851</y>
      <w>102</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1000.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2952</x>
      <y>1866</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tsk-&gt;files!=Null</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2948</x>
      <y>1871</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2942</x>
      <y>1875</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tsk-&gt;files = NULL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2956</x>
      <y>1875</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_files_struct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2952</x>
      <y>1871</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2962</x>
      <y>1878</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
atomic_dec_and_test</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2945</x>
      <y>1883</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2939</x>
      <y>1890</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>close_files</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2960</x>
      <y>1883</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果fd和fdset做过扩展</panel_attributes>
    <additional_attributes>30.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2956</x>
      <y>1888</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
files-&gt;fd != &amp;files-&gt;fd_array[0]</panel_attributes>
    <additional_attributes>150.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2955</x>
      <y>1892</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_fd_array</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2964</x>
      <y>1888</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
files-&gt;max_fdset &gt; __FD_SETSIZE
open_fds
close_on_exec</panel_attributes>
    <additional_attributes>70.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2974</x>
      <y>1894</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_fdset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2983</x>
      <y>1887</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2962</x>
      <y>1883</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放files结构体</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2974</x>
      <y>1862</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__exit_fs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2979</x>
      <y>1865</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tsk-&gt;fs!=Null</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2970</x>
      <y>1875</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tsk-&gt;fs = NULL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2974</x>
      <y>1870</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2994</x>
      <y>1875</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__put_fs_struct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2980</x>
      <y>1870</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3002</x>
      <y>1878</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
atomic_dec_and_test</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2995</x>
      <y>1883</y>
      <w>13</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fs-&gt;root
fs-&gt;pwd
fs-&gt;altroot</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2990</x>
      <y>1893</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3011</x>
      <y>1892</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mntput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3002</x>
      <y>1883</y>
      <w>16</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fs-&gt;rootmnt
fs-&gt;pwdmnt
fs-&gt;altrootmnt</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3031</x>
      <y>1889</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3002</x>
      <y>1883</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放fs结构体</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3028</x>
      <y>1859</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>exit_sighand</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3030</x>
      <y>1862</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tsk-&gt;sig!=Null</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3012</x>
      <y>1871</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tsk-&gt;sig = NULL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3016</x>
      <y>1867</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3029</x>
      <y>1872</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3028</x>
      <y>1867</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放sigaction结构体</panel_attributes>
    <additional_attributes>40.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3050</x>
      <y>1872</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tsk-&gt;sigpending = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3068</x>
      <y>1871</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_sigqueue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3030</x>
      <y>1867</y>
      <w>45</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tsk-&gt;pending</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3030</x>
      <y>1867</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3047</x>
      <y>1882</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sigemptyset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3051</x>
      <y>1874</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
清空被pending的signal
&amp;queue-&gt;signal</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3064</x>
      <y>1882</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>q = queue-&gt;head;
 //将队列清空
queue-&gt;head = NULL;
queue-&gt;tail = &amp;queue-&gt;head;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3068</x>
      <y>1874</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3087</x>
      <y>1885</y>
      <w>27</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>kmem_cache_free(sigqueue_cachep, q);
		atomic_dec(&amp;nr_queued_signals);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3075</x>
      <y>1874</y>
      <w>26</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环释放队列中的sigqueue</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3061</x>
      <y>1859</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>exit_thread
（对i386 nothing to do）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2977</x>
      <y>1851</y>
      <w>78</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>760.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3033</x>
      <y>1851</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3052</x>
      <y>1851</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3053</x>
      <y>1851</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;leader
当前进程是session的主进程
所以session中的进程就与主控终端解除
关系，成为后台进程</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3078</x>
      <y>1859</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>disassociate_ctty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3102</x>
      <y>1859</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_exec_domain</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3052</x>
      <y>1851</y>
      <w>59</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tsk-&gt;exec_domain</panel_attributes>
    <additional_attributes>10.0;10.0;570.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3119</x>
      <y>1859</y>
      <w>33</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>__MOD_DEC_USE_COUNT(tsk-&gt;binfmt-&gt;module)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3053</x>
      <y>1851</y>
      <w>85</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;830.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3154</x>
      <y>1859</y>
      <w>15</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>tsk-&gt;exit_code = code
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3052</x>
      <y>1851</y>
      <w>109</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1070.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3175</x>
      <y>1859</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>exit_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3052</x>
      <y>1851</y>
      <w>130</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1280.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3126</x>
      <y>1868</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>forget_original_parent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3132</x>
      <y>1862</y>
      <w>51</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3100</x>
      <y>1873</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>reaper = next_thread(father);
 //如果exit的是线程，则由线程组中的
 //下一个线程接管子进程，
 //否则由init进程结接管这个进程的子进程
if (reaper == father)
	reaper = child_reaper;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3109</x>
      <y>1870</y>
      <w>27</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>250.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3131</x>
      <y>1881</y>
      <w>25</w>
      <h>13</h>
    </coordinates>
    <panel_attributes> //退出时要给父进程发送的信号
p-&gt;exit_signal = SIGCHLD;
p-&gt;self_exec_id++;
	//改变其“生父” original father
p-&gt;p_opptr = reaper;
if (p-&gt;pdeath_signal)
 send_sig(p-&gt;pdeath_signal, p, 0);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3134</x>
      <y>1871</y>
      <w>19</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历所有的task
如果是当前进程的子进程</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3165</x>
      <y>1862</y>
      <w>66</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
孤儿进程组，再同一session，但是进程组中所有进程的父进程不和子进程在同一个进程组
(t-&gt;pgrp != current-&gt;pgrp) &amp;&amp;
(t-&gt;session == current-&gt;session) &amp;&amp;
  //进程组中的其他所有进程的父进程都不在这个进程组
will_become_orphaned_pgrp(current-&gt;pgrp, current) &amp;&amp;
 //该进程组中有TASK_STOPPED的进程
has_stopped_jobs</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3160</x>
      <y>1885</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>kill_pg(current-&gt;pgrp,SIGHUP,1);
kill_pg(current-&gt;pgrp,SIGCONT,1);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3181</x>
      <y>1862</y>
      <w>33</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;exit_signal != SIGCHLD &amp;&amp;
( current-&gt;parent_exec_id != t-&gt;self_exec_id  ||
current-&gt;self_exec_id != current-&gt;parent_exec_id) 
 //不是super user
&amp;&amp; !capable(CAP_KILL)</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;280.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3197</x>
      <y>1890</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;exit_signal = SIGCHLD
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3225</x>
      <y>1886</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;state = TASK_ZOMBIE;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3181</x>
      <y>1862</y>
      <w>56</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;540.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3259</x>
      <y>1887</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_notify_parent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3181</x>
      <y>1862</y>
      <w>85</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;830.0;250.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3237</x>
      <y>1896</y>
      <w>26</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>info.si_signo = sig;
info.si_errno = 0;
info.si_pid = tsk-&gt;pid;
info.si_uid = tsk-&gt;uid;
info.si_utime = tsk-&gt;times.tms_utime;
info.si_stime = tsk-&gt;times.tms_stime;
 //这两项由task的状态和exit_code决定
info.si_code = why; 
info.si_status = status;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3240</x>
      <y>1890</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
组装siginfo</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3269</x>
      <y>1903</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>send_sig_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3291</x>
      <y>1901</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up_parent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3264</x>
      <y>1890</y>
      <w>21</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sig, &amp;info, tsk-&gt;p_pptr</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3264</x>
      <y>1890</y>
      <w>34</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tsk-&gt;p_pptr</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3182</x>
      <y>1862</y>
      <w>135</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;p_cptr != NULL)
存在子进程
循环</panel_attributes>
    <additional_attributes>10.0;10.0;1330.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3310</x>
      <y>1886</y>
      <w>44</w>
      <h>44</h>
    </coordinates>
    <panel_attributes> //移除exit进程的最年轻子进程
p = current-&gt;p_cptr;
current-&gt;p_cptr = p-&gt;p_osptr;
p-&gt;p_ysptr = NULL; //这里还是和之前最年轻的子进程连接的，
						//这里把关系解除
p-&gt;ptrace = 0;

	//将之前移除的子进程连接到forget_original_parent规定的生父中
	//并且养父也换成了生父
p-&gt;p_pptr = p-&gt;p_opptr;
p-&gt;p_osptr = p-&gt;p_pptr-&gt;p_cptr;
if (p-&gt;p_osptr)
	p-&gt;p_osptr-&gt;p_ysptr = p;
p-&gt;p_pptr-&gt;p_cptr = p;
	//如果这个子进程也退出
if (p-&gt;state == TASK_ZOMBIE)
	do_notify_parent(p, p-&gt;exit_signal);

	//因为最年轻的子进程要和父进程解除关系
	//如果变换子进程的关系使子进程原来的进程组成为了孤儿进程
if ((p-&gt;pgrp != current-&gt;pgrp) &amp;&amp;
    (p-&gt;session == current-&gt;session)) {
	int pgrp = p-&gt;pgrp;
	if (is_orphaned_pgrp(pgrp) &amp;&amp; has_stopped_jobs(pgrp)) {
		kill_pg(pgrp,SIGHUP,1);
		kill_pg(pgrp,SIGCONT,1);
	}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3221</x>
      <y>1857</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3051</x>
      <y>1851</y>
      <w>177</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1750.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3291</x>
      <y>1910</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up_interruptible</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3296</x>
      <y>1904</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
唤醒该进程内所有线程
的wait_chldexit</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3294</x>
      <y>1917</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__wake_up</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3283</x>
      <y>1913</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(x),TASK_INTERRUPTIBLE,WQ_FLAG_EXCLUSIVE</panel_attributes>
    <additional_attributes>150.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3293</x>
      <y>1924</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__wake_up_common</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3300</x>
      <y>1920</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mode=0</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2931</x>
      <y>1872</y>
      <w>3</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2903</x>
      <y>1887</y>
      <w>34</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果因为申请信号量而睡着（semsleeping有值）
	1.通过sem_lock获取sma，并上锁，并清除：
		current-&gt;semsleeping = NULL
	2.如果queue在链表中（q-&gt;prev），通过remove_from_queue
		将其从sma链表中删除
2.遍历进程注册过的undo的链表semundo，无论结果如何，都通过kfree将undo释放
	1.经过sem_lock，semid != -1(两次，lock可能睡)，sem_checkid检测
	2.遍历sma的undo链表，如果没找到就解锁，查看进程下一个
	3.如果找到了，遍历sma中所有的信号量：
		sem-&gt;semval += u-&gt;semadj[i];
		sem-&gt;sempid = current-&gt;pid;
	4.通过update_queue尝试为sma中的等待队列申请信号量
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3215</x>
      <y>1661</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>down</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3207</x>
      <y>1669</y>
      <w>27</w>
      <h>19</h>
    </coordinates>
    <panel_attributes> //lock 原子操作
LOCK "decl %0\n\t"     /* --sem-&gt;count */
"js 2f\n"
"1:\n"
".section .text.lock,\"ax\"\n"
"2:\tcall __down_failed\n\t"
"jmp 1b\n"
".previous"
:"=m" (sem-&gt;count)
:"c" (sem)
:"memory");
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3220</x>
      <y>1664</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3214</x>
      <y>1692</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__down_failed</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3219</x>
      <y>1687</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3213</x>
      <y>1700</y>
      <w>14</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>"pushl %eax\n\t"
"pushl %edx\n\t"
"pushl %ecx\n\t"
"call __down\n\t"
"popl %ecx\n\t"
"popl %edx\n\t"
"popl %eax\n\t"
"ret"
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3219</x>
      <y>1695</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3213</x>
      <y>1719</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__down</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3218</x>
      <y>1713</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3161</x>
      <y>1728</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DECLARE_WAITQUEUE(wait, tsk)
tsk-&gt;state = TASK_UNINTERRUPTIBLE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3176</x>
      <y>1722</y>
      <w>44</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>420.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3193</x>
      <y>1728</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_wait_queue_exclusive</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3202</x>
      <y>1722</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
&amp;sem-&gt;wait, &amp;wait</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3189</x>
      <y>1735</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>	wait-&gt;flags = WQ_FLAG_EXCLUSIVE;
	__add_wait_queue_tail(q, wait);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3199</x>
      <y>1731</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3215</x>
      <y>1728</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sem-&gt;sleepers++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3217</x>
      <y>1722</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3217</x>
      <y>1722</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
死循环</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3230</x>
      <y>1724</y>
      <w>67</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!atomic_add_negative(sleepers - 1, &amp;sem-&gt;count
因为在down里面减了sem-&gt;count，是负数才跳到这
如果当sleeper和sem.count的值是正值时，说明有生产者
释放了信号量
注：sem-&gt;count最小为-1，因为在down的时候虽然减了1
	但是在atomic_add_negative又加上了sleeper-1
	如果开始counter=0 down，counter=-1 sleeper-1=0 atomic_add_negative后count=-1 sem.sleeper=1
	之后counter=-1， down， counter=-2 sleeper-1=1 atomic_add_negative后count=-1 sem.sleeper=1</panel_attributes>
    <additional_attributes>60.0;20.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3220</x>
      <y>1736</y>
      <w>40</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>sem-&gt;sleepers = 0
remove_wait_queue(&amp;sem-&gt;wait, &amp;wait);
tsk-&gt;state = TASK_RUNNING;
	//唤醒队列中的第一个进程，因为是add_wait_queue_exclusive
	//设置了WQ_FLAG_EXCLUSIVE
wake_up(&amp;sem-&gt;wait);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3349</x>
      <y>1660</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>up</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3342</x>
      <y>1668</y>
      <w>27</w>
      <h>20</h>
    </coordinates>
    <panel_attributes> //lock 原子操作
"# atomic up operation\n\t"
LOCK "incl %0\n\t"     /* ++sem-&gt;count */
 //&lt;=0
"jle 2f\n"
"1:\n"
".section .text.lock,\"ax\"\n"
"2:\tcall __up_wakeup\n\t"
"jmp 1b\n"
".previous"
:"=m" (sem-&gt;count)
:"c" (sem)
:"memory"
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3354</x>
      <y>1663</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3350</x>
      <y>1691</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__up_wakeup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3355</x>
      <y>1687</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3350</x>
      <y>1698</y>
      <w>14</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>"pushl %eax\n\t"
"pushl %edx\n\t"
"pushl %ecx\n\t"
"call __up\n\t"
"popl %ecx\n\t"
"popl %edx\n\t"
"popl %eax\n\t"
"ret"
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3355</x>
      <y>1694</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3350</x>
      <y>1715</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3355</x>
      <y>1711</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3355</x>
      <y>1718</y>
      <w>55</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE,WQ_FLAG_EXCLUSIVE</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3350</x>
      <y>1722</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__wake_up</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3350</x>
      <y>1729</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__wake_up_common</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3355</x>
      <y>1725</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
0</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3234</x>
      <y>1725</y>
      <w>47</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3272</x>
      <y>1741</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>sem-&gt;sleepers = 1;	
schedule();
tsk-&gt;state = TASK_UNINTERRUPTIBLE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3325</x>
      <y>1736</y>
      <w>83</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.遍历wait_queue_head_t中的wait_queue_t
2.检查	wait_queue_t中的task是否state和mode规定的其中一个
3.遇到没置上WQ_FLAG_EXCLUSIVE，就直接唤醒。直到遇到第一个WQ_FLAG_EXCLUSIVE，如果不在irq中
	就唤醒这个task后退出；如果在irq中，就看这个task在不在同一个cpu上，如果在就直接唤醒退出，如果
	不在，就记录下这个，继续查找。如果查找过程遇到没置WQ_FLAG_EXCLUSIVE继续唤醒，遇到置上的WQ_FLAG_EXCLUSIVE
	就看是否在本cpu中，直到遍历完成，如果找不到在本cpu中的WQ_FLAG_EXCLUSIVE，唤醒记录的那个。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3356</x>
      <y>1732</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3539</x>
      <y>1660</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>local_irq_save</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3534</x>
      <y>1669</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes> //这里保存eflags，并禁止中断
"pushfl ; popl %0 ; cli":"=g" (x)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3543</x>
      <y>1663</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
local_开头的是本cpu禁止/开启中断</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3567</x>
      <y>1686</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>spin_lock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3571</x>
      <y>1689</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
_lock结尾是为了防止来自其他cpu干扰</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3559</x>
      <y>1694</y>
      <w>24</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>"\n1:\t" \
	//原子操作
"lock ; decb %0\n\t" \
	//是负数就跳到2
"js 2f\n" \
".section .text.lock,\"ax\"\n" \
"2:\t" \
"cmpb $0,%0\n\t" \
"rep;nop\n\t" \
	//&lt;=0
"jle 2b\n\t" \
"jmp 1b\n" \
".previous"
:"=m" (lock-&gt;lock) : : 
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3563</x>
      <y>1722</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>spin_unlock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3566</x>
      <y>1725</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3553</x>
      <y>1729</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //这里不用lock，因为dec 包含读 改 写三步
 //而mov只包含写1步
"movb $1,%0"
:"=m" (lock-&gt;lock)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3520</x>
      <y>1688</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_lock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3519</x>
      <y>1696</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__build_read_lock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3524</x>
      <y>1691</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3518</x>
      <y>1703</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__build_read_lock_ptr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3525</x>
      <y>1699</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3514</x>
      <y>1710</y>
      <w>24</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>LOCK "subl $1,(%0)\n\t" \
"js 2f\n" \
"1:\n" \
".section .text.lock,\"ax\"\n" \
 //const中leal是将（*（volatile *）rw）
 //的地址赋给eax，
"2:\tcall " helper "\n\t" \
"jmp 1b\n" \
".previous" \
::"a" (rw) : "memory")
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3524</x>
      <y>1706</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3522</x>
      <y>1726</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3515</x>
      <y>1731</y>
      <w>17</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>__read_lock_failed:
	lock ; incl	(%eax)
1:	cmpl	$1,(%eax)
	js	1b

	lock ; decl	(%eax)
	js	__read_lock_failed
	ret
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3478</x>
      <y>1688</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>write_lock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3477</x>
      <y>1696</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__build_write_lock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3483</x>
      <y>1691</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3474</x>
      <y>1703</y>
      <w>24</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>LOCK "subl $" RW_LOCK_BIAS_STR ",(%0)\n\t" \
"jnz 2f\n" \
"1:\n" \
".section .text.lock,\"ax\"\n" \
"2:\tcall " helper "\n\t" \
"jmp 1b\n" \
".previous" \
::"a" (rw) : "memory"
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3482</x>
      <y>1699</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3469</x>
      <y>1721</y>
      <w>33</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>__write_lock_failed:
	//这里防止加了写的锁，其他的读操作无法进行
	" LOCK "addl	$" RW_LOCK_BIAS_STR ",(%eax)
1:	cmpl	$" RW_LOCK_BIAS_STR ",(%eax)
	jne	1b

	" LOCK "subl	$" RW_LOCK_BIAS_STR ",(%eax)
	jnz	__write_lock_failed
	ret
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3484</x>
      <y>1717</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3138</x>
      <y>480</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3110</x>
      <y>483</y>
      <w>36</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3094</x>
      <y>489</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.irqflags &amp; SA_SHIRQ shared的irq得有device
2.irq id不能超过NR_IRQS
3.handler 中断服务函数不能为空
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3126</x>
      <y>490</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>action = (struct irqaction *)
			kmalloc(sizeof(struct irqaction), GFP_KERNEL);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3141</x>
      <y>483</y>
      <w>10</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请action
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3161</x>
      <y>490</y>
      <w>18</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>action-&gt;handler = handler;
action-&gt;flags = irqflags;
action-&gt;mask = 0;
action-&gt;name = devname;
action-&gt;next = NULL;
action-&gt;dev_id = dev_id;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3144</x>
      <y>483</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3185</x>
      <y>490</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3144</x>
      <y>483</y>
      <w>47</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3190</x>
      <y>493</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
irq irqaction</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3154</x>
      <y>498</y>
      <w>39</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3146</x>
      <y>506</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>desc = irq_desc + irq
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3178</x>
      <y>506</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>p = &amp;desc-&gt;action
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3186</x>
      <y>498</y>
      <w>7</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3190</x>
      <y>498</y>
      <w>17</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
shared有效性判断</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3199</x>
      <y>506</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.头节点为action空，就不是shared
2.不为空，但是头节点和新加的节点没有SA_SHIRQ
	就产生错误
3.上述情况都不成立，将p指向最后一个箭头
	且shared=1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3237</x>
      <y>506</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>*p = new
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3191</x>
      <y>498</y>
      <w>53</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将最后一个箭头指向新加的节点</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3251</x>
      <y>506</y>
      <w>49</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>desc-&gt;depth = 0;
desc-&gt;status &amp;= ~(IRQ_DISABLED | IRQ_AUTODETECT | IRQ_WAITING);
desc-&gt;handler-&gt;startup(irq);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3191</x>
      <y>498</y>
      <w>77</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!shared</panel_attributes>
    <additional_attributes>10.0;10.0;750.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3307</x>
      <y>506</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_irq_proc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3190</x>
      <y>498</y>
      <w>123</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1210.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3163</x>
      <y>507</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rand_initialize_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3168</x>
      <y>498</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
外部中断的发生时间用于产生随机数</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3149</x>
      <y>513</y>
      <w>41</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>state = kmalloc(sizeof(struct timer_rand_state), GFP_KERNEL)
memset(state, 0, sizeof(struct timer_rand_state))
irq_timer_state[irq] = state
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3164</x>
      <y>510</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3377</x>
      <y>497</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>"pushl $"#nr"-256
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3407</x>
      <y>497</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>"jmp common_interrupt"
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3383</x>
      <y>491</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
压中断号入栈（注意时负数）</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3404</x>
      <y>491</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3387</x>
      <y>483</y>
      <w>26</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>BUILD_16_IRQS(0x0)
--
1.内核产生中断：eflag cs ip
2.用户态产生中断：ss sp eflag cs ip
valign=top</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3397</x>
      <y>504</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>SAVE_ALL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3401</x>
      <y>500</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
保存现场</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3409</x>
      <y>504</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pushl $ret_from_intr
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3416</x>
      <y>500</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
函数返回地址</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3432</x>
      <y>504</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_IRQ</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3417</x>
      <y>500</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3365</x>
      <y>513</y>
      <w>48</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>irq = regs.orig_eax &amp; 0xff
desc = irq_desc + irq
kstat.irqs[cpu][irq]++
desc-&gt;handler-&gt;ack(irq)
status = desc-&gt;status &amp; ~(IRQ_REPLAY | IRQ_WAITING)
status |= IRQ_PENDING
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3400</x>
      <y>507</y>
      <w>41</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3416</x>
      <y>507</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!(status &amp; (IRQ_DISABLED | IRQ_INPROGRESS))
处于disable或inproress下就pending，暂时不执行
否则
</panel_attributes>
    <additional_attributes>230.0;10.0;90.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3420</x>
      <y>516</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>action = desc-&gt;action
status &amp;= ~IRQ_PENDING
status |= IRQ_INPROGRESS
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3442</x>
      <y>516</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>desc-&gt;status = status
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3437</x>
      <y>507</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3438</x>
      <y>507</y>
      <w>32</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
死循环处理pending的irq</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3459</x>
      <y>517</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_IRQ_event</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3475</x>
      <y>517</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>if (!(desc-&gt;status &amp; IRQ_PENDING))
	break;
desc-&gt;status &amp;= ~IRQ_PENDING;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3464</x>
      <y>512</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3466</x>
      <y>512</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3503</x>
      <y>518</y>
      <w>27</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>desc-&gt;status &amp;= ~IRQ_INPROGRESS
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3439</x>
      <y>507</y>
      <w>75</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;730.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3532</x>
      <y>518</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>desc-&gt;handler-&gt;end(irq)
if (softirq_active(cpu) &amp; softirq_mask(cpu))
	do_softirq();
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3438</x>
      <y>507</y>
      <w>106</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1040.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3397</x>
      <y>527</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>irq_enter</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3393</x>
      <y>534</y>
      <w>17</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>++local_irq_count(cpu)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3402</x>
      <y>520</y>
      <w>63</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果处于中断，
这个值不为0
</panel_attributes>
    <additional_attributes>610.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3400</x>
      <y>530</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3411</x>
      <y>528</y>
      <w>8</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>status = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3414</x>
      <y>520</y>
      <w>51</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3421</x>
      <y>528</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__sti()
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3424</x>
      <y>520</y>
      <w>41</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!(action-&gt;flags &amp; SA_INTERRUPT)
</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3432</x>
      <y>528</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>status |= action-&gt;flags;
		action-&gt;handler(irq, action-&gt;dev_id, regs);
		action = action-&gt;next;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3445</x>
      <y>520</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
依次执行中断服务函数
中断服务函数中应该检测
设备的中断状态寄存器
</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3462</x>
      <y>520</y>
      <w>26</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
status &amp; SA_SAMPLE_RANDOM</panel_attributes>
    <additional_attributes>10.0;10.0;52.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3462</x>
      <y>530</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_interrupt_randomness
引入随机性</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3485</x>
      <y>531</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__cli()
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3462</x>
      <y>520</y>
      <w>29</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3494</x>
      <y>531</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>irq_exit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3462</x>
      <y>520</y>
      <w>40</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3486</x>
      <y>538</y>
      <w>17</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>local_irq_count(cpu)--
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3493</x>
      <y>534</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3588</x>
      <y>506</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ret_from_intr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3418</x>
      <y>500</y>
      <w>179</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1770.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3560</x>
      <y>513</y>
      <w>16</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>GET_CURRENT(%ebx)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3564</x>
      <y>509</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过esp指针得到现在task_struct指针
从这里可知，task的指针是对2个页面对齐的
</panel_attributes>
    <additional_attributes>270.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3583</x>
      <y>513</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ret_with_reschedule
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3588</x>
      <y>509</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
只有在用户空间发生了中断或者异常才会发生调度
否则在系统空间发生了中断和异常是不会发生调度的
即使此时发生了timer的中断</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3617</x>
      <y>514</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>restore_all
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3591</x>
      <y>509</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3567</x>
      <y>521</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reschedule
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3582</x>
      <y>521</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>signal_return
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3599</x>
      <y>521</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>RESTORE_ALL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3572</x>
      <y>516</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
need_resched</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3587</x>
      <y>516</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sigpending</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3588</x>
      <y>516</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3579</x>
      <y>524</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3574</x>
      <y>528</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3589</x>
      <y>528</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>restore_all
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3586</x>
      <y>524</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3548</x>
      <y>524</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3543</x>
      <y>528</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3558</x>
      <y>529</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ret_from_sys_call
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3564</x>
      <y>524</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3634</x>
      <y>522</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iret
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3615</x>
      <y>522</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>addl $4,%esp;
是将push的irq号删除
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3617</x>
      <y>517</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3622</x>
      <y>517</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2646</x>
      <y>599</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_bh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2651</x>
      <y>602</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bh_task_vec+nr
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2645</x>
      <y>606</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tasklet_hi_schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2629</x>
      <y>614</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>t-&gt;next = tasklet_hi_vec[cpu].list;
tasklet_hi_vec[cpu].list = t;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2638</x>
      <y>609</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
加入到当前核的执行链表</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2656</x>
      <y>614</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__cpu_raise_softirq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2653</x>
      <y>609</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2655</x>
      <y>621</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>softirq_active(cpu) |= (1&lt;&lt;nr)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2664</x>
      <y>617</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3527</x>
      <y>527</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_softirq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3531</x>
      <y>523</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3511</x>
      <y>532</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>in_interrupt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3515</x>
      <y>529</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>170.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3483</x>
      <y>543</y>
      <w>36</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>local_irq_count(__cpu) + local_bh_count(__cpu) != 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3497</x>
      <y>535</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在中断中不能执行
当前cpu正在执行softirq的时候不能执行
</panel_attributes>
    <additional_attributes>200.0;10.0;60.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3524</x>
      <y>533</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>local_bh_disable</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3530</x>
      <y>530</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3520</x>
      <y>538</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>local_bh_count(cpu)++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3527</x>
      <y>535</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3528</x>
      <y>530</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注意软件中中断disable和enable
的位置，在softirq执行的时候打开中断
其他时候将中断关闭，因为此时在中断中
</panel_attributes>
    <additional_attributes>40.0;10.0;220.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3539</x>
      <y>538</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>local_irq_disable
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3531</x>
      <y>530</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
softirq_active(cpu)&amp;softirq_mask(cpu)
</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3539</x>
      <y>536</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
清除所有的软中断</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3524</x>
      <y>544</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>softirq_active(cpu) &amp;= ~active
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3546</x>
      <y>544</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>local_irq_enable
h = softirq_vec
mask &amp;= ~active
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3552</x>
      <y>536</y>
      <w>11</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3561</x>
      <y>536</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历active所有的标志位</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3562</x>
      <y>543</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>if (active &amp; 1)
	h-&gt;action(h);
h++;
active &gt;&gt;= 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3560</x>
      <y>536</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果找到有其他的标志位
重新继续执行</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3575</x>
      <y>545</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>retry
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3587</x>
      <y>541</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>local_irq_enable
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3531</x>
      <y>530</y>
      <w>64</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3591</x>
      <y>554</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tasklet_hi_action</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3569</x>
      <y>550</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3582</x>
      <y>563</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list = tasklet_hi_vec[cpu].list;
tasklet_hi_vec[cpu].list = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3589</x>
      <y>557</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到执行的list</panel_attributes>
    <additional_attributes>80.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3596</x>
      <y>557</y>
      <w>51</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历链表中的bh_task_vec</panel_attributes>
    <additional_attributes>10.0;10.0;490.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3634</x>
      <y>562</y>
      <w>13</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3609</x>
      <y>572</y>
      <w>31</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>clear_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state)
t-&gt;func(t-&gt;data)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3645</x>
      <y>571</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>t-&gt;next = tasklet_hi_vec[cpu].list;
tasklet_hi_vec[cpu].list = t;
__cpu_raise_softirq(cpu, HI_SOFTIRQ);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3644</x>
      <y>562</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果被锁住，再次将这个tasklet加到链表中</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3619</x>
      <y>580</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bh_action</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3624</x>
      <y>576</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3623</x>
      <y>588</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bh_base[nr]()
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3623</x>
      <y>583</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3425</x>
      <y>480</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>软中断通道：softirq_vec  通过softirq_mask 和 softirq_active
								表示cpu支持和是否激活
通道中的任务:bh_task_vec ,具体对应哪个硬件irq，
								链接到tasklet_hi_vec
								根据这个中的data找到bh_base执行
								
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3599</x>
      <y>588</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>spin_trylock(&amp;global_bh_lock)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3609</x>
      <y>583</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
保证bh函数执行的穿行化</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2640</x>
      <y>577</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>timer_interrupt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2646</x>
      <y>534</y>
      <w>800</w>
      <h>45</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>7980.0;10.0;10.0;430.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2633</x>
      <y>583</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_timer_interrupt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2639</x>
      <y>580</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2622</x>
      <y>592</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2663</x>
      <y>591</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>x86_do_profile</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2627</x>
      <y>586</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2638</x>
      <y>586</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!user_mode(regs)</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2593</x>
      <y>599</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>(*(unsigned long *)&amp;jiffies)++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2601</x>
      <y>595</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
保证操作的原子性</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2618</x>
      <y>599</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>update_process_times</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2625</x>
      <y>595</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2627</x>
      <y>595</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TIMER_BH
list_not_empty(tq_timer)
	TQUEUE_BH</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3623</x>
      <y>595</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>timer_bh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3628</x>
      <y>591</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3613</x>
      <y>601</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>update_times</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3632</x>
      <y>601</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>run_timer_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3618</x>
      <y>598</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3627</x>
      <y>598</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3609</x>
      <y>607</y>
      <w>6</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>xtime
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3611</x>
      <y>604</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新xtime</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3619</x>
      <y>608</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>calc_load</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3617</x>
      <y>604</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3767</x>
      <y>571</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kernel_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3753</x>
      <y>578</y>
      <w>47</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>"movl %%esp,%%esi\n\t"  //保存父线程栈的位置
"int $0x80\n\t"		//根据%0 和%2可知eax=__NR_clone，所以调用sys_clone
"cmpl %%esp,%%esi\n\t"	/* child or parent? *///开是否是父线程的栈
"je 1f\n\t"		/* parent - jump */
/* Load the argument into eax, and push it.  That way, it does
 * not matter whether the called function is compiled with
 * -mregparm or not.  */
"movl %4,%%eax\n\t"//如果是子线程的栈，就将传的参数arg压栈
"pushl %%eax\n\t"		
"call *%5\n\t"		/* call fn *//调用子线程的执行函数
"movl %3,%0\n\t"	/* exit *//eax=__NR_exit，调用sys_exit
"int $0x80\n"
"1:\t"
:"=&amp;a" (retval), "=&amp;S" (d0)
:"0" (__NR_clone), "i" (__NR_exit),
 "r" (arg), "r" (fn),
 "b" (flags | CLONE_VM)
: "memory");
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3772</x>
      <y>574</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2512</x>
      <y>615</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>update_one_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2519</x>
      <y>602</y>
      <w>108</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
user_tick=1 表示在用户空间发生了时钟中断
			=0 表示在系统空间发生了时钟中断
system和user_tick相反</panel_attributes>
    <additional_attributes>1060.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2460</x>
      <y>623</y>
      <w>26</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>p-&gt;per_cpu_utime[cpu] += user;
p-&gt;per_cpu_stime[cpu] += system;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2471</x>
      <y>618</y>
      <w>49</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
统计task在用户空间和系统空间的时间
虽然有一定误差，但是也只是切换的时候存在
并且两者可能互相抵消</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2492</x>
      <y>625</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_process_times</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2501</x>
      <y>618</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2456</x>
      <y>631</y>
      <w>30</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>psecs = (p-&gt;times.tms_utime += user);
psecs += (p-&gt;times.tms_stime += system)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2471</x>
      <y>628</y>
      <w>30</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
psecs统计task总的时间</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2496</x>
      <y>628</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
psecs / HZ &gt; p-&gt;rlim[RLIMIT_CPU].rlim_cur</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2487</x>
      <y>631</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!(psecs % HZ)
没秒钟发一个SIGXCPU</panel_attributes>
    <additional_attributes>100.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2491</x>
      <y>631</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
psecs / HZ &gt; p-&gt;rlim[RLIMIT_CPU].rlim_max
注：前面是rlim_cur,这里是rlim_max
</panel_attributes>
    <additional_attributes>60.0;10.0;230.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2476</x>
      <y>636</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>send_sig(SIGXCPU, p, 1)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2504</x>
      <y>635</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>send_sig(SIGKILL, p, 1)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2519</x>
      <y>623</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_it_virt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2518</x>
      <y>618</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2520</x>
      <y>626</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里是用户时间闹钟</panel_attributes>
    <additional_attributes>40.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2525</x>
      <y>632</y>
      <w>22</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>p-&gt;it_virt_value
表示对task设置的闹钟
（在用户空间的时间），这个
时间到了之后，需要向进程发
send_sig(SIGVTALRM, p, 1)

p-&gt;it_virt_incr
每次it_virt_value时间到了之后
再向it_virt_value重新加载这个时间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2536</x>
      <y>623</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_it_prof</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2519</x>
      <y>618</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2549</x>
      <y>632</y>
      <w>24</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>p-&gt;it_prof_value
表示对task设置的闹钟，这个
时间到了之后，需要向进程发
send_sig(SIGPROF, p, 1)

p-&gt;it_prof_incr
每次it_prof_value时间到了之后
再向it_prof_value重新加载这个时间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2538</x>
      <y>626</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
和virt_value相比，这里是总的时间
（用户空间和系统空间）</panel_attributes>
    <additional_attributes>50.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2581</x>
      <y>602</y>
      <w>45</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
p-&gt;pid
不是怠速进程</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2564</x>
      <y>617</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
时间片到时间后，
置上need_resched</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2561</x>
      <y>622</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>if (--p-&gt;counter &lt;= 0) {
	p-&gt;counter = 0;
	p-&gt;need_resched = 1;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2578</x>
      <y>622</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>if (p-&gt;nice &gt; 0)
	kstat.per_cpu_nice[cpu] += user_tick;
else
	kstat.per_cpu_user[cpu] += user_tick;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2582</x>
      <y>617</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2605</x>
      <y>625</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kstat.per_cpu_system[cpu] += system
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2582</x>
      <y>617</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2600</x>
      <y>616</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kstat.per_cpu_system[cpu] += system
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2602</x>
      <y>602</y>
      <w>31</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
local_bh_count(cpu) || local_irq_count(cpu) &gt; 1
如果pid=0，又在其他的中断中</panel_attributes>
    <additional_attributes>220.0;10.0;80.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3638</x>
      <y>604</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
jiffies - timer_jiffies</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3634</x>
      <y>608</y>
      <w>51</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果tv1.index是第一次为0，就将其他的4个数组的index分别置为1，
	如果是之后循环回来，通过cascade_timers向前一个6的数组借一位
	并通过internal_add_timer重新更新到tv1中（注：timer_jiffies
	相对于刚开始加入时有更新）
2.遍历tv1.index所在的队列，然后通过fn(data)去执行响应的定时函数，
	此时比没有删除timer，因为timer在等待timer的进程的栈中，需要该进程自己删。
3.更新下面的值，然后重新遍历
	++timer_jiffies; 
	tv1.index = (tv1.index + 1) &amp; TVR_MASK;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2804</x>
      <y>576</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_intr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2811</x>
      <y>534</y>
      <w>634</w>
      <h>44</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hwif_init-&gt;init_irq</panel_attributes>
    <additional_attributes>6330.0;10.0;12.0;420.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2696</x>
      <y>593</y>
      <w>30</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.检查handler = hwgroup-&gt;handler是否为NULL
2.检查hwgroup-&gt;drive是否为NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2712</x>
      <y>579</y>
      <w>100</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>980.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2734</x>
      <y>593</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drive_is_ready</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2739</x>
      <y>579</y>
      <w>73</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>710.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2721</x>
      <y>596</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;waiting_for_dma
如果是DMA</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2709</x>
      <y>602</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>HWIF(drive)-&gt;dmaproc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2733</x>
      <y>596</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不是DMA
检查是否处于busy状态</panel_attributes>
    <additional_attributes>50.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2738</x>
      <y>601</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>stat &amp; BUSY_STAT
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2751</x>
      <y>593</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hwgroup-&gt;busy = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2755</x>
      <y>579</y>
      <w>57</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果busy没置上，将其置上
之前没释放，应该是置上的</panel_attributes>
    <additional_attributes>550.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2765</x>
      <y>593</y>
      <w>21</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>hwgroup-&gt;handler = NULL
 //将timeout从timer中移除
del_timer(&amp;hwgroup-&gt;timer)
 //如果暴露中断，将中断打开
if (drive-&gt;unmask)
		ide__sti()
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2769</x>
      <y>579</y>
      <w>43</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2790</x>
      <y>596</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handler(drive)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2795</x>
      <y>579</y>
      <w>17</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2804</x>
      <y>593</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_recovery_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2809</x>
      <y>579</y>
      <w>20</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
两次操作需要有时间间隔时
hwif-&gt;last_time</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2776</x>
      <y>605</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_intr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2782</x>
      <y>599</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2705</x>
      <y>608</y>
      <w>80</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>780.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2687</x>
      <y>614</y>
      <w>41</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过GET_STAT获取硬盘的状态，并进行检查，如果数据已经读了
	但是出现错（ERR_STAT|DRQ_STAT），报错。如果数据还没收
	进来，通过ide_set_handler设置read_intr，等待下一次中断
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2732</x>
      <y>615</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>msect = drive-&gt;mult_count
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2739</x>
      <y>608</y>
      <w>45</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取硬盘缓冲区存储的扇区数
</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2761</x>
      <y>615</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_next
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2765</x>
      <y>608</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2730</x>
      <y>618</y>
      <w>37</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
计算本次bh要读的扇区</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2707</x>
      <y>623</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果判断是multi_read，本次要读的扇区数不能超过
	msect。然后更新硬盘缓冲区中剩余的扇区数
	msect -= nsect
2.如果不是multi_read,本次要读的nsect = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2749</x>
      <y>622</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>idedisk_input_data</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2753</x>
      <y>618</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读取寄存器数据到buffer</panel_attributes>
    <additional_attributes>130.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2729</x>
      <y>630</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有定义特殊的读取函数ideproc</panel_attributes>
    <additional_attributes>170.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2723</x>
      <y>634</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>HWIF(drive)-&gt;ideproc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2744</x>
      <y>630</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没有ideproc
</panel_attributes>
    <additional_attributes>30.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2740</x>
      <y>633</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;io_32bit
如果是32为读取</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2733</x>
      <y>638</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是同步读取</panel_attributes>
    <additional_attributes>80.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2721</x>
      <y>642</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过do_vlb_sync三次读取port
	IDE_NSECTOR_REG
2.通过insl读取IDE_DATA_REG
	的wcount个32位到buffer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2744</x>
      <y>644</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>insl
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2741</x>
      <y>638</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不是同步读取</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2751</x>
      <y>633</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不是32位去读
是16位</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2757</x>
      <y>638</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;slow
如果是慢读</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2753</x>
      <y>642</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>while (wcount--) {
				*ptr++ = inw_p(IDE_DATA_REG);
				*ptr++ = inw_p(IDE_DATA_REG);
			}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2762</x>
      <y>638</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注意wcount转化为16位
</panel_attributes>
    <additional_attributes>30.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2771</x>
      <y>643</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>insw
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2742</x>
      <y>627</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_input_data</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2747</x>
      <y>624</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>60.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2753</x>
      <y>625</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果定义了bswap</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2758</x>
      <y>628</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>idedisk_bswap_data
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2780</x>
      <y>623</y>
      <w>37</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.更新读取sector起始，和buffer起始，
	和剩下要去读的扇区数
	rq-&gt;sector += nsect;
	rq-&gt;buffer += nsect&lt;&lt;9;
	rq-&gt;errors = 0;
	rq-&gt;nr_sectors -= nsect
2.如果当前的bh的扇区数读完
（rq-&gt;current_nr_sectors -= nsect&lt;=0）
	通过ide_end_request（注意uptodate=1）
	调整req中的bh
3.如果req中的扇区数没读完（nr_sectors），
	并且硬盘的缓冲区中还有数据（msect），重新
	read_next
	但是如果硬盘缓冲区中没有数据，通过ide_set_handler
	重新设置read_intr，返回ide_started
4.如果整个req读完，返回ide_stopped
注：只需要单独考虑两个问题：
	1.缓冲区是否写完，如果写完，通过ide_end_request更换
	2.整个req是否执行完（硬盘的扇区是否读完），如果没读完
		继续读取，或者通过ide_set_handler设置下一个intr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2767</x>
      <y>618</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2751</x>
      <y>662</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_end_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2757</x>
      <y>655</y>
      <w>35</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在一个bh处理完之后，需要end</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2741</x>
      <y>668</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>end_that_request_first</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2742</x>
      <y>665</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果整个req没执行完，返回1
如果执行完，则返回0</panel_attributes>
    <additional_attributes>130.0;10.0;60.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2713</x>
      <y>671</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!uptodate
</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2704</x>
      <y>677</y>
      <w>22</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>如果数据没更新，提示有IO error
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2727</x>
      <y>677</y>
      <w>34</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.将req.bh指向下一个bh，并将结束的bh脱链，执行
	b_end_io
	//计算本次执行了多少个扇区
	nsect = bh-&gt;b_size &gt;&gt; 9
	req-&gt;bh = bh-&gt;b_reqnext;
	bh-&gt;b_reqnext = NULL;
	bh-&gt;b_end_io(bh, uptodate)
2.如果下一个bh不为空，更新req的起始扇区和读写的扇区总数
	以及当前bh要读写的扇区数，以及缓冲区的位置
	req-&gt;hard_sector += nsect;
	req-&gt;hard_nr_sectors -= nsect;
	req-&gt;sector = req-&gt;hard_sector;
	//如果nr_sectors没超过bh的size，将其扩大位bh的size
	req-&gt;nr_sectors = req-&gt;hard_nr_sectors
	req-&gt;current_nr_sectors = bh-&gt;b_size &gt;&gt; 9
	req-&gt;buffer = bh-&gt;b_data
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2739</x>
      <y>671</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果req.bh不为空</panel_attributes>
    <additional_attributes>80.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2754</x>
      <y>665</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果执行完整个req</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2761</x>
      <y>673</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_blkdev_randomness</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2767</x>
      <y>668</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加随机属性</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2734</x>
      <y>718</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>end_buffer_io_sync</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2736</x>
      <y>707</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bh-&gt;b_end_io
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2741</x>
      <y>703</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2741</x>
      <y>710</y>
      <w>53</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
对于file的read，在readpage中进行赋值（read因为要预读，所以采用readpage）
对于file的write，因为不是立即向磁盘写入，所以没对其赋值
但是当blance_dirty时，通过ll_rw_block写bh时，对齐进行赋值
当然如果swap，采用writepage时，也会对其进行赋值
在readpage和writepage中赋值是end_buffer_io_async
在ll_rw_block赋值是end_buffer_io_sync</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2723</x>
      <y>726</y>
      <w>16</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mark_buffer_uptodate
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2724</x>
      <y>721</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据uptodate设置bh的BH_Uptodate</panel_attributes>
    <additional_attributes>160.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2743</x>
      <y>725</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unlock_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2740</x>
      <y>721</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2728</x>
      <y>733</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>clear_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2733</x>
      <y>728</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
清除BH_Lock</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2755</x>
      <y>734</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2741</x>
      <y>728</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过waitqueue_active检查bh-&gt;b_wait等待队列
不为空，唤醒其等待队列</panel_attributes>
    <additional_attributes>100.0;10.0;200.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2781</x>
      <y>673</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_dequeue_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2776</x>
      <y>668</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2785</x>
      <y>676</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果req的电梯存在</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2776</x>
      <y>681</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2764</x>
      <y>691</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>elevator_noop_dequeue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2763</x>
      <y>684</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>req-&gt;e-&gt;dequeue_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2772</x>
      <y>687</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ELEVATOR_LINUS</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2784</x>
      <y>684</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>req-&gt;e = NULL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2785</x>
      <y>681</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2800</x>
      <y>683</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_del</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2788</x>
      <y>676</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将req从dev的队列中移除</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2801</x>
      <y>672</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hwgroup-&gt;rq = NULL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2776</x>
      <y>668</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2822</x>
      <y>672</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>end_that_request_last</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2776</x>
      <y>668</y>
      <w>54</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;520.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2818</x>
      <y>675</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
req-&gt;sem
如果信号量存在，将其释放</panel_attributes>
    <additional_attributes>130.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2816</x>
      <y>680</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>up(req-&gt;sem)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2836</x>
      <y>680</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_release_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2830</x>
      <y>675</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2815</x>
      <y>687</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>req-&gt;rq_status = RQ_INACTIVE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2824</x>
      <y>683</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2843</x>
      <y>686</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //加入到free_list，并将等待队列唤醒
list_add(&amp;req-&gt;table, req-&gt;free_list);
req-&gt;free_list = NULL;
wake_up(&amp;req-&gt;q-&gt;wait_for_request)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2844</x>
      <y>683</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
req-&gt;free_list
如果req的来源存在</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2811</x>
      <y>579</y>
      <w>17</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2821</x>
      <y>593</y>
      <w>37</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果返回ide_stopped，表示之前req执行完成
	检查hwgroup-&gt;handler为空时：
	hwgroup-&gt;busy = 0;
	ide_do_request
2.如果返回的是ide_started，req在read_next设置软件
	硬件在do_rw_disk中就已经写了要读写的扇区数到寄存器
	IDE_NSECTOR_REG
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2811</x>
      <y>605</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_dma_intr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2797</x>
      <y>599</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2807</x>
      <y>608</y>
      <w>11</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_dma_end</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2799</x>
      <y>616</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>HWIF(drive)-&gt;dmaproc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2811</x>
      <y>608</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
DRIVE_READY
并且能正常结束ide_dma_end
遍历每一个bh去end</panel_attributes>
    <additional_attributes>60.0;10.0;140.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2820</x>
      <y>615</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_end_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2838</x>
      <y>615</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_stopped
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2817</x>
      <y>608</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2893</x>
      <y>579</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>keyboard_interrupt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2898</x>
      <y>534</y>
      <w>548</w>
      <h>47</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pckbd_init_hw-&gt;kbd_request_irq</panel_attributes>
    <additional_attributes>5460.0;10.0;10.0;450.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2893</x>
      <y>586</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_kbd_event</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2898</x>
      <y>582</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
kbd_controller_lock保护</panel_attributes>
    <additional_attributes>10.0;10.0;12.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2863</x>
      <y>597</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kbd_read_status</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2868</x>
      <y>589</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读取键盘状态
KBD_STATUS_REG</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2898</x>
      <y>589</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在status=KBD_STAT_OBF
（键盘缓冲区中有数据）时
执行9999次
</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2878</x>
      <y>599</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kbd_read_input</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2881</x>
      <y>595</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在KBD_DATA_REG中读取系统扫描码</panel_attributes>
    <additional_attributes>210.0;10.0;32.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2901</x>
      <y>595</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果status没有错误信息
KBD_STAT_GTO | KBD_STAT_PERR</panel_attributes>
    <additional_attributes>10.0;10.0;12.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2886</x>
      <y>597</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
status中KBD_STAT_MOUSE_OBF置上
表示是鼠标事件</panel_attributes>
    <additional_attributes>160.0;10.0;102.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2891</x>
      <y>601</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_mouse_event</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2908</x>
      <y>601</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_keyboard_event</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2901</x>
      <y>597</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否则是键盘事件</panel_attributes>
    <additional_attributes>10.0;10.0;122.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2928</x>
      <y>601</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kbd_read_status</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2901</x>
      <y>595</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
再次读取status并循环</panel_attributes>
    <additional_attributes>10.0;10.0;312.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2878</x>
      <y>610</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_acknowledge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2884</x>
      <y>604</y>
      <w>32</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>310.0;10.0;12.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2867</x>
      <y>617</y>
      <w>31</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果reply_expected置上，表示cpu给键盘发送
	正在等待键盘回应。
	1.1当系统扫描码是KBD_REPLY_ACK表示
		键盘confirmation：
		acknowledge = 1;
		//清除标志
		reply_expected = 0
		return 0
	1.2当系统扫描码是KBD_REPLY_RESEND
		表示键盘需要cpu重新发送：
		resend = 1;
		reply_expected = 0
		return 0
2.如果不是cpu等待的扫描码，则return 1.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2879</x>
      <y>613</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;12.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2923</x>
      <y>612</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_scancode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2915</x>
      <y>604</y>
      <w>18</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
do_acknowledge确定接收
系统扫描码</panel_attributes>
    <additional_attributes>10.0;10.0;152.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3062</x>
      <y>608</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tasklet_schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2915</x>
      <y>604</y>
      <w>156</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
keyboard_tasklet</panel_attributes>
    <additional_attributes>10.0;10.0;1542.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3498</x>
      <y>462</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>softirq_vec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3487</x>
      <y>472</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>TASKLET_SOFTIRQ
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3515</x>
      <y>472</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>HI_SOFTIRQ
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3496</x>
      <y>465</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3504</x>
      <y>465</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3532</x>
      <y>479</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bh_action
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3520</x>
      <y>475</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3519</x>
      <y>488</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mark_bh</panel_attributes>
    <additional_attributes>10.0;20.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3544</x>
      <y>478</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
init_bh</panel_attributes>
    <additional_attributes>10.0;30.0;50.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3548</x>
      <y>474</y>
      <w>9</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TIMER_BH</panel_attributes>
    <additional_attributes>10.0;60.0;70.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3555</x>
      <y>473</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>timer_bh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3556</x>
      <y>480</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tqueue_bh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3556</x>
      <y>487</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>immediate_bh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3548</x>
      <y>479</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TQUEUE_BH</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3548</x>
      <y>479</y>
      <w>17</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
IMMEDIATE_BH</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3502</x>
      <y>495</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>TIMER_BH
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3517</x>
      <y>495</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>TQUEUE_BH
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3532</x>
      <y>495</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>IMMEDIATE_BH
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3508</x>
      <y>490</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;50.0;120.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3519</x>
      <y>490</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;50.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3519</x>
      <y>490</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;50.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3514</x>
      <y>485</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tasklet
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3520</x>
      <y>482</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bh_task_vec</panel_attributes>
    <additional_attributes>10.0;30.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3514</x>
      <y>479</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tasklet_hi_vec
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3526</x>
      <y>480</y>
      <w>8</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3488</x>
      <y>479</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tasklet_vec
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3486</x>
      <y>485</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>console_tasklet
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3491</x>
      <y>482</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;30.0;30.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3493</x>
      <y>475</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3526</x>
      <y>476</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;40.0;120.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3526</x>
      <y>482</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
统一</panel_attributes>
    <additional_attributes>10.0;50.0;110.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3482</x>
      <y>481</y>
      <w>8</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3532</x>
      <y>473</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kbd_bh
bg=red
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3470</x>
      <y>480</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>console_softint
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3500</x>
      <y>485</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>keyboard_tasklet
valign=center
bg=red</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3505</x>
      <y>482</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;30.0;90.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3067</x>
      <y>611</y>
      <w>3</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;12.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3056</x>
      <y>613</y>
      <w>30</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>将tasklet加在tasklet_vec[cpu].list
链表中，并且将TASKLET_SOFTIRQ
的softirq_active置上
注：如果是include &lt;linux/drivers/net&gt;
	挂入的链表路径不一样，但是同样会执行action
	（首先将tasklet挂入tq_immediate链表中，
	然后将IMMEDIATE_BH的bh挂入tasklet_hi_vec链表中
	最后置上HI_SOFTIRQ的softirq_active，执行时
	多经历了bh_action）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2929</x>
      <y>615</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
down是将系统扫描码的最高位提取并置反
反应是否按下按键</panel_attributes>
    <additional_attributes>10.0;10.0;12.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2902</x>
      <y>618</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;12.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2899</x>
      <y>624</y>
      <w>25</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.如果放开按键将up_flag为0200
	如果按下按键为0
2.电源管理，当长期没操作进入
	省电模式，键盘操作之后正常
	运行，这里为空
	pm_access
3.do_poke_blanked_console = 1
4.中断的耗时操作留在打开中断后
	在console_tasklet中执行
	tasklet_schedule(&amp;console_tasklet)
5.添加随机性
	add_keyboard_randomness(scancode | up_flag)
6.利用ttytab和kbd_table表设置前台虚
	拟终端tty和前台键盘结构kbd（如果tty-&gt;driver_data
	不存在，则tty=NULL）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2929</x>
      <y>618</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果键盘处于原始模式
（kbd-&gt;kbdmode == VC_RAW）
将系统扫描码直接加到缓冲队列中</panel_attributes>
    <additional_attributes>10.0;10.0;12.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2925</x>
      <y>628</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2929</x>
      <y>618</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将系统扫描码转化成键码</panel_attributes>
    <additional_attributes>10.0;10.0;212.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2943</x>
      <y>624</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kbd_translate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2944</x>
      <y>629</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pckbd_translate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2949</x>
      <y>627</y>
      <w>3</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;12.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2933</x>
      <y>636</y>
      <w>38</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.如果是前缀码e0/e1，将其保存在静态局部变量
	prev_scancode，然后返回0
2.如果是无效码00/ff,prev_scancode设置为0，
	并返回0
3.如果不是上述情况：
	1.如果前缀码存在，
		1.如果是e1，现在收到的是1d，前缀码将其变换成0x100；
		如果是100，收到的是0x45，表示键码是E1_PAUSE；
		如果什么都不是，将前缀码清空为0。
		注：这里实现的是一个有限状态机，prev_scancode是状态
		scancode是条件，然后通过条件得到下一个状态或者结果
		2.如果是e0，首先将前缀码清空为0；
			如果此次的扫描码是左右shift（0x2a,0x36），丢弃，返回0
			因为如果shift在某些情况作为扩充键，Linux中依靠其内部状
			态处理，丢弃shift
			如果是其他键，将scancode通过e0_keys转化为键码
		注：大部分扩充键是e0
	2.如果前缀码不存在，但是扫描码大于SC_LIM，通过high_keys
		将其转换
	3.如果小于SC_LIM，系统扫描码即为键码*keycode = scancode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2948</x>
      <y>632</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;12.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2929</x>
      <y>618</y>
      <w>52</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;502.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2971</x>
      <y>623</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
up_flag
如果释放</panel_attributes>
    <additional_attributes>80.0;10.0;12.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2957</x>
      <y>626</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>rep = 0
 //将key_down对应的键码清掉
 //如果原来是0，说明之前漏掉
 //用kbd_unexpected_up处理
test_and_clear_bit
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2975</x>
      <y>623</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是按下
将key_down对应的位置上
如果之前置上，将rep置上</panel_attributes>
    <additional_attributes>40.0;10.0;122.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2982</x>
      <y>627</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>test_and_set_bit
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2930</x>
      <y>618</y>
      <w>74</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
kbd-&gt;kbdmode == VC_MEDIUMRAW
半原始模式，将扫描码转化为键码，但是保留释放标志</panel_attributes>
    <additional_attributes>10.0;10.0;722.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2996</x>
      <y>625</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_queue(keycode + up_flag)
raw_mode = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2930</x>
      <y>618</y>
      <w>111</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
条件:
1.没有rep
2.在重复收到(rep)，并且键盘处于VC_REPEAT模式
	终端运行于“echo"模式，或者缓冲区已经被读完</panel_attributes>
    <additional_attributes>10.0;10.0;1092.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3007</x>
      <y>622</y>
      <w>34</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2984</x>
      <y>633</y>
      <w>27</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>根据shift_state，slockstate，lockstate
计算出shift_final
shift_state：每位表示辅助键Alt,Ctrl,
	Altgr,shift按下的状态
slockstate：相应的位置上表示，相应的
		辅助键一直sticky
lockstate：相应的位置上，表示将相应的
	辅助键反转
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3020</x>
      <y>622</y>
      <w>26</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据辅助键的按下的情况（shift_final）
选择将键码翻译成目标码的码表</panel_attributes>
    <additional_attributes>190.0;10.0;60.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3012</x>
      <y>633</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>key_map = key_maps[shift_final]
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3038</x>
      <y>622</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3042</x>
      <y>629</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果码表存在</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3028</x>
      <y>633</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从码表中获取
目标码及其类型</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3013</x>
      <y>639</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>keysym = key_map[keycode];
 //高8位
type = KTYP(keysym)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3043</x>
      <y>633</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;42.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3041</x>
      <y>636</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
type&gt;=0xf0</panel_attributes>
    <additional_attributes>60.0;10.0;22.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3035</x>
      <y>640</y>
      <w>23</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.type-=0xf0
2.在raw_mode下，扫描码已经
	被put_queue.但是如果是KT_SPEC
	或者KT_SHIFT类型的需要进一步
	处理
3.KT_LETTER相比KT_LATIN只是多了
	大写键（VC_CAPSLOCK）的处理，
	大写键置上时，相当于将shift取反
	然后找到key_map，从而找到实际的
	value=keysym &amp; 0xff	
4.然后根据type查找处理的函数
	key_handler[type]
5.如果type不为KT_SLOCK，将sticky
	的slockstate清掉
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3021</x>
      <y>668</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_self</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3027</x>
      <y>662</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
KT_LATIN</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3008</x>
      <y>676</y>
      <w>28</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.如果是放开（up_flag），直接返回
	//3.ctrl+'.'+'o'+'A'
2.如果diacr存在，使用handle_diacr处理
	value
	//2.Ctrl+'.'+'o'
3.如果存在dead_key_next，将其清掉
	并将value赋给diacr
4.最后通过put_queue将字符value放入队列中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3048</x>
      <y>668</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_spec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3043</x>
      <y>662</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1.CTRL+‘.’
KT_SPEC</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3045</x>
      <y>676</y>
      <w>21</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果是放开，直接返回
2.如果目标码不在KT_SPEC处理的
	范围内，直接返回
3.如果在raw_mode，不能是K_SAK
	类型
4.查询目标码的处理函数
	spec_fn_table[value]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3054</x>
      <y>671</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3052</x>
      <y>687</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
"."在ctrl_map中
对应的是fb0e</panel_attributes>
    <additional_attributes>30.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3054</x>
      <y>692</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>compose</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3054</x>
      <y>698</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dead_key_next = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3060</x>
      <y>695</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3031</x>
      <y>693</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_diacr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3022</x>
      <y>671</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3021</x>
      <y>690</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3021</x>
      <y>699</y>
      <w>30</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.遍历accent_table，看是否有和diacr相同
	base是此次value的项，如果有的话返回
	accent_table[i].result
2.如果value是空格或者和diacr相同，返回diacr
3.如果都找不到，将diacr put_queue，并
	返回value
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3035</x>
      <y>696</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3047</x>
      <y>636</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
type&lt;f0
并且不是放开也不是raw_mode</panel_attributes>
    <additional_attributes>10.0;10.0;232.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3062</x>
      <y>639</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>to_utf8</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3060</x>
      <y>646</y>
      <w>26</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果7个位可以表示，put_queue
2.如果是8~11个位表示，用两个字节
	表示为：
	110***** 10******
3.如果需要12~16位表示，用3个字节表示
	1110**** 10****** 10******
注：*代表要表示的数，从左到右是数的
	高到低位。要几个字节表示，最高位
	就有几个1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3068</x>
      <y>642</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;42.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3050</x>
      <y>629</y>
      <w>44</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果码表不存在</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3083</x>
      <y>642</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>compute_shiftstate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3097</x>
      <y>641</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kbd-&gt;slockstate = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3088</x>
      <y>635</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
有可能因为新按键
导致shift_state改变</panel_attributes>
    <additional_attributes>40.0;10.0;12.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3091</x>
      <y>635</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;122.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3088</x>
      <y>649</y>
      <w>28</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.清空shift_state，k_down
2.遍历key_down中的所有位，查询
	其键码在plain_map中对应的目标码
	如果目标码的类型是辅助键（KT_SHIFT）
	或者锁定键（KT_SLOCK）置上，
	shift_state相应的位置上，k_down的量也需要
	改变
注：K_CAPSSHIFT置上，相当于K_SHIFT
	置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3088</x>
      <y>645</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;62.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2999</x>
      <y>690</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2994</x>
      <y>694</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2975</x>
      <y>702</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2978</x>
      <y>697</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
keypress_wait</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2998</x>
      <y>697</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果前台tty存在</panel_attributes>
    <additional_attributes>20.0;10.0;80.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2995</x>
      <y>699</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flag=0
ch=value</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2986</x>
      <y>703</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty_insert_flip_char</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2970</x>
      <y>706</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果tty_flip_buffer的buffer没满
tty-&gt;flip.count &lt; TTY_FLIPBUF_SIZE</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2961</x>
      <y>711</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>tty-&gt;flip.count++;
*tty-&gt;flip.flag_buf_ptr++ = flag;
*tty-&gt;flip.char_buf_ptr++ = ch;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3002</x>
      <y>703</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>con_schedule_flip</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3005</x>
      <y>699</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2988</x>
      <y>706</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将tty的tty_flip_buffer
链接到con_task_queue的链表中</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2983</x>
      <y>713</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>queue_task</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3015</x>
      <y>712</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tasklet_schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3009</x>
      <y>706</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将console_tasklet
链接到tasklet_vec中</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3695</x>
      <y>554</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tasklet_action
(与tasklet_hi_action类似)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3569</x>
      <y>550</y>
      <w>140</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1380.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3697</x>
      <y>561</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>t-&gt;func
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3703</x>
      <y>557</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3702</x>
      <y>564</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
console_tasklet</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3696</x>
      <y>568</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>console_softint</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3682</x>
      <y>575</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>run_task_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3686</x>
      <y>571</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3676</x>
      <y>582</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.将队列头从list换成局部变量head
2.遍历链表，依次执行链表中的
	 p-&gt;routine（p-&gt;data）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3687</x>
      <y>578</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3683</x>
      <y>592</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_to_ldisc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3685</x>
      <y>587</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
initialize_tty_struct</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3668</x>
      <y>595</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TTY_DONT_FLIP
表示正在上层正在取数据
所以需要将这个任务加到tq_timer中
等到之后do_timer时在做
</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3663</x>
      <y>603</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>queue_task
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3695</x>
      <y>599</y>
      <w>35</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.tty-&gt;flip.buf_num为1，代表驱动是存储到了char_buf
	中的第二个，所以将存储目标码的buf指针分别复制到cp，
	fp。并将下一次键盘驱动存储的buf改成第一个buf
	tty-&gt;flip.buf_num = 0
	tty-&gt;flip.char_buf_ptr = tty-&gt;flip.char_buf;
	tty-&gt;flip.flag_buf_ptr = tty-&gt;flip.flag_buf
2.相反，如果键盘驱动此次存储的是第一个buf(buf_num=0)
	那么将cp，fp指向第一个buf，并对之后键盘驱动存储的
	buf转变为第二个
	tty-&gt;flip.buf_num = 1
	tty-&gt;flip.char_buf_ptr = tty-&gt;flip.char_buf + TTY_FLIPBUF_SIZE;
	tty-&gt;flip.flag_buf_ptr = tty-&gt;flip.flag_buf + TTY_FLIPBUF_SIZE
3.将键盘驱动buf中存储的count取出，
	count = tty-&gt;flip.count;
	tty-&gt;flip.count = 0
4.tty-&gt;ldisc.receive_buf
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3689</x>
      <y>595</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3705</x>
      <y>629</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;ldisc.receive_buf
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3712</x>
      <y>625</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3712</x>
      <y>632</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty_ldisc_N_TTY</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3707</x>
      <y>636</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>n_tty_receive_buf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3648</x>
      <y>639</y>
      <w>66</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!tty-&gt;read_buf
如果tty没申请缓冲队列（tty-&gt;ldisc.open）
退出</panel_attributes>
    <additional_attributes>640.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3641</x>
      <y>645</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3670</x>
      <y>639</y>
      <w>44</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty-&gt;real_raw
最原始的模式，即使是校验错误
也复制到tty的read_buf中</panel_attributes>
    <additional_attributes>420.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3656</x>
      <y>646</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.因为read_buf是回环队列，所
	以要分两段写。将cp中对应的
	字符通过memcpy复制到tty-&gt;read_buf + tty-&gt;read_head
	对应的位置。同时更新
	tty-&gt;read_head
	tty-&gt;read_cnt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3689</x>
      <y>639</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是其他模式，需要查看fp中每个
字节对应的flag（在tty_insert_flip_char
中flag都被置0）将每个字符依次复制</panel_attributes>
    <additional_attributes>230.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3683</x>
      <y>646</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TTY_NORMAL</panel_attributes>
    <additional_attributes>80.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3680</x>
      <y>650</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>n_tty_receive_char</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3676</x>
      <y>653</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty-&gt;raw
如果是普通的原始模式</panel_attributes>
    <additional_attributes>100.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3662</x>
      <y>666</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>tty-&gt;read_buf[tty-&gt;read_head] = c;
tty-&gt;read_head = (tty-&gt;read_head + 1) &amp; (N_TTY_BUF_SIZE-1);
tty-&gt;read_cnt++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3676</x>
      <y>658</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_tty_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3665</x>
      <y>661</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果read_cnt没超过界限N_TTY_BUF_SIZE</panel_attributes>
    <additional_attributes>170.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3686</x>
      <y>653</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
加工模式</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3689</x>
      <y>658</y>
      <w>34</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
stopped置上
flow_stopped没置
I_IXON &amp;&amp; I_IXANY
（输入控制流打开，并且任意字符都可以重新开始）</panel_attributes>
    <additional_attributes>200.0;10.0;130.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3696</x>
      <y>666</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_tty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3679</x>
      <y>669</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3667</x>
      <y>675</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.stopped是0，或者stopped是
	1的情况下flow_stopped是1
	直接退出
2.tty-&gt;stopped = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3700</x>
      <y>669</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 //该伪终端有连接，且是“信包”模式
tty-&gt;link &amp;&amp; tty-&gt;link-&gt;packet</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3689</x>
      <y>674</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>tty-&gt;ctrl_status &amp;= ~TIOCPKT_STOP;
tty-&gt;ctrl_status |= TIOCPKT_START;
 //唤醒link去读buf
wake_up_interruptible(&amp;tty-&gt;link-&gt;read_wait)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3721</x>
      <y>675</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;driver.start
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3700</x>
      <y>669</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3727</x>
      <y>678</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
con_init-&gt;console_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3722</x>
      <y>682</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>con_start</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3717</x>
      <y>689</y>
      <w>20</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.tty要存在
2.tty要在driver的范围内，
	并且要申请vc_data(在con_open
	中被申请)
3.清除kbd_table[num]中的VC_SCROLLOCK
	（scroll_lock mode）
4.set_leds
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3727</x>
      <y>685</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3700</x>
      <y>669</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果tty.flag中TTY_DO_WRITE_WAKEUP置上
并且函数指针存在（tty_ldisc_N_TTY中不存在）</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3734</x>
      <y>674</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;ldisc.write_wakeup
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3752</x>
      <y>674</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up_interruptible
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3699</x>
      <y>669</y>
      <w>63</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将tty的写等待队列唤醒
tty-&gt;write_wait</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3713</x>
      <y>662</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果I_ISTRIP，将最高位清0
2.I_IUCLC置上，并且L_IEXTEN
	通过tolower将大写（isupper
	查询表）将其转化成小写
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3708</x>
      <y>658</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3708</x>
      <y>658</y>
      <w>50</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty-&gt;closing==1</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3751</x>
      <y>662</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果输入控制流打开时（I_IXON），
	如果输入字符是START_CHAR，
	执行start_tty；如果是STOP_CHAR
	执行stop_tty
2.直接返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3772</x>
      <y>674</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>stop_tty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3761</x>
      <y>671</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3760</x>
      <y>681</y>
      <w>29</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.如果stopped置上，直接返回
2.tty-&gt;stopped = 1
3.如果该伪终端设备有链接，并且
	连接处于“信包”模式
	tty-&gt;ctrl_status &amp;= ~TIOCPKT_START;
	tty-&gt;ctrl_status |= TIOCPKT_STOP;
	wake_up_interruptible(&amp;tty-&gt;link-&gt;read_wait)
4.如果tty-&gt;driver.stop函数指针存在，则执行
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3777</x>
      <y>677</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3770</x>
      <y>699</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;driver.stop
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3771</x>
      <y>706</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>con_stop</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3776</x>
      <y>695</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3776</x>
      <y>702</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3768</x>
      <y>713</y>
      <w>20</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.tty要存在
2.tty要在driver的范围内，
	并且要申请vc_data(在con_open
	中被申请)
3.设置kbd_table[num]中的VC_SCROLLOCK
	（scroll_lock mode）
4.set_leds
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3776</x>
      <y>709</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3708</x>
      <y>658</y>
      <w>88</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1.如果c不是特殊字符（process_char_map）
2.或者c是特殊字符，但是要求下一个不做特殊处理（lnext）</panel_attributes>
    <additional_attributes>10.0;10.0;860.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3786</x>
      <y>660</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3781</x>
      <y>664</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>finish_erasing</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3784</x>
      <y>670</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果处于erasing：
	put_char('/', tty);
	tty-&gt;column += 2;
	tty-&gt;erasing = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3786</x>
      <y>667</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3794</x>
      <y>664</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;lnext = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3793</x>
      <y>660</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3792</x>
      <y>660</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果tty需要回写
L_ECHO</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3806</x>
      <y>662</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果tty-&gt;read_cnt
已经满了</panel_attributes>
    <additional_attributes>90.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3804</x>
      <y>669</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_char('\a', tty)
return
halign=left
bg=red</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3806</x>
      <y>662</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
当新行开始时
tty-&gt;canon_head == tty-&gt;read_head
记录当前column</panel_attributes>
    <additional_attributes>90.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3817</x>
      <y>668</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>tty-&gt;canon_column = tty-&gt;column
猜想：column和head的区别，head
	偏向buf，column偏向与显示
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3841</x>
      <y>669</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>echo_char
bg=red</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3814</x>
      <y>662</y>
      <w>34</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
回显</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3793</x>
      <y>660</y>
      <w>67</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果I_PARMRK（奇偶校验）
c='\377'
这里将c两次放入queue中
注：真实奇偶校验看n_tty_receive_parity_error</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3853</x>
      <y>669</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_tty_queue
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3793</x>
      <y>660</y>
      <w>84</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;820.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3868</x>
      <y>668</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_tty_queue
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3708</x>
      <y>658</y>
      <w>190</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
特殊字符的处理</panel_attributes>
    <additional_attributes>10.0;10.0;1880.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3888</x>
      <y>660</y>
      <w>10</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3867</x>
      <y>673</y>
      <w>33</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.如果输入字符时‘\r’
	1.I_IGNCR置上，忽略输入中的回车，直接return
	2.1不满足，I_ICRNL置上，将回车翻译成新行
		c='\n'
2.如果输入字符是新行‘\n’，并且I_INLCR置上，
	翻译成‘\r’
3.如果输出流控制打开（I_IXON），如果是字符
	START_CHAR，则start_tty
	如果是字符STOP_CHAR，则stop_tty
4.如果L_ISIG置上（收到相应字符，产生相应信号）：
	1.如果是INTR_CHAR，通过isig给进程组发SIGINT
	2.如果是QUIT_CHAR，发送SIGQUIT
	3.如果是SUSP_CHAR，发送SIGTSTP
	然后直接返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3919</x>
      <y>667</y>
      <w>37</w>
      <h>57</h>
    </coordinates>
    <panel_attributes>1.当字符是ERASE_CHAR（删掉上一个字符）
	或者KILL_CHAR（删掉到行首的所有字符）
	或者L_IEXTEN打开的时候WERASE_CHAR
	（删掉上一个单词）
	调用eraser
2.如果字符是LNEXT_CHAR（下一个字符不做特殊处理）
	并且L_IEXTEN打开
	tty-&gt;lnext = 1
	如果其中回写打开L_ECHO，finish_erasing
		如果L_ECHOCTL（控制字符也输出），输出：
			put_char('^', tty);
			put_char('\b', tty)
3.如果是将之前的字符重新打印（REPRINT_CHAR），
	并且回显（L_ECHO），自控制打开（L_IEXTEN）时，
	finish_erasing(tty);
	//打印控制字符
	echo_char(c, tty);
	//回显回车
	opost('\n', tty);
	然后从记录的行首canon_head，通过echo_char回显
	一直到read_head
4.如果是‘\n’，一定会handle_newline
		如果其中回显L_ECHO或者L_ECHONL打开，回显
		opost('\n', tty)
			如果回显打开的情况下read_cnt超过界限put_char('\a', tty)
5.如果是EOF_CHAR，将其改变位‘\0’,并handle_newline
		如果其中行首canon_head和read_head不同
		在tty-&gt;flags中设置TTY_PUSH，表示让tty尽快取
6.如果是EOL_CHAR，或者在L_IEXTEN打开的情况下，输入的是EOL2_CHAR
	一定会处理handle_newline
		如果其中回显打开L_ECHO，回显字符echo_char(c
			如果其中的read_cnt超过限制，put_char('\a', tty)
			如果行首和read_head相同，canon_column记录现在的column
		如果奇偶校验打开，并且字符是'\377'，put_tty_queue
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3895</x>
      <y>660</y>
      <w>37</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果处于加工模式
tty-&gt;icanon</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3931</x>
      <y>726</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_newline
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3936</x>
      <y>723</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3921</x>
      <y>733</y>
      <w>37</w>
      <h>24</h>
    </coordinates>
    <panel_attributes> //设置eol，在read_chan中检测
set_bit(tty-&gt;read_head, &amp;tty-&gt;read_flags);
 //将行结束字符放入队列中
put_tty_queue(c, tty);
 //重置行首
tty-&gt;canon_head = tty-&gt;read_head;
 //增加行数
tty-&gt;canon_data++;
kill_fasync(&amp;tty-&gt;fasync, SIGIO, POLL_IN);
 //唤醒等待队列，加工模式是在行缓冲之后唤醒，
 //原始模式是在minimum_to_wake之后唤醒
if (waitqueue_active(&amp;tty-&gt;read_wait))
	wake_up_interruptible(&amp;tty-&gt;read_wait);
return;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3935</x>
      <y>729</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3895</x>
      <y>660</y>
      <w>84</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是其他输入</panel_attributes>
    <additional_attributes>10.0;10.0;820.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3962</x>
      <y>666</y>
      <w>29</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.finish_erasing
2.如果需要回显L_ECHO
	当read_cnt超过限制时，put_char('\a', tty)
	如果输入时‘\n’（此时应该处于原始模式），回显opost('\n', tty)
	如果输入的是其他字符，如果是行首，canon_column记录column，并回显字符echo_char
3.如果需要奇偶校验I_PARMRK，并且是‘\377’
	将其放入tty的队列中
4.最后将字符放在tty的队列中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3711</x>
      <y>639</y>
      <w>32</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果处于原始模式tty-&gt;icanon
并且read_cnt数量超过了minimum_to_wake
唤醒等待队列</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3723</x>
      <y>648</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>kill_fasync(&amp;tty-&gt;fasync, SIGIO, POLL_IN);
if (waitqueue_active(&amp;tty-&gt;read_wait))
	wake_up_interruptible(&amp;tty-&gt;read_wait);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3711</x>
      <y>639</y>
      <w>70</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果键盘输入过快，导致tty队列中的空间
n_tty_receive_room小于门限值TTY_THRESHOLD_THROTTLE
如果检测到tty-&gt;flags中TTY_THROTTLED标志没置（还没对键盘的输入做限制）</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3773</x>
      <y>644</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;driver.throttle
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3829</x>
      <y>672</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3816</x>
      <y>678</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果L_ECHOCTL打开，回显除了‘\t’之外的
	所有控制字符（iscntrl）
	put_char('^', tty);
	put_char(c ^ 0100, tty);
	tty-&gt;column += 2;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3848</x>
      <y>679</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>opost</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3846</x>
      <y>672</y>
      <w>10</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3800</x>
      <y>677</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;driver.put_char
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3805</x>
      <y>672</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3811</x>
      <y>690</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;driver.write_room
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3819</x>
      <y>682</y>
      <w>37</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取space，并检查
如果为0，返回-1</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3812</x>
      <y>697</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>con_write_room</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3817</x>
      <y>693</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3809</x>
      <y>704</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果tty-&gt;stopped返回0
2.否则返回4096
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3817</x>
      <y>700</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3838</x>
      <y>682</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
O_OPOST
自定义的输出
注：IEXTEN是自定义的输入</panel_attributes>
    <additional_attributes>160.0;10.0;30.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3829</x>
      <y>689</y>
      <w>28</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>1.如果输入字符是'\n'，
	1.如果O_ONLRET打开，回到当前行的行首tty-&gt;column = 0
	2.如果O_ONLCR打开，tty-&gt;driver.put_char（'\r'）,回到行首tty-&gt;column = 0
	3.记录新行行首的位置，tty-&gt;canon_column = tty-&gt;column
2.如果输入字符是'\r'
	1.如果O_ONOCR打开，不允许在行首回车
		所以在tty-&gt;column为0时，直接返回0
	2.如果O_OCRNL打开，需要将回车映射为新行符'\n'
		如果在O_ONLRET打开的情况下tty-&gt;canon_column = tty-&gt;column = 0
		然后退出（注：这里在换成'\n'，却没记录canon_column，暂时不清楚原因）
	3.如果上述情况都不满足：
		tty-&gt;canon_column = tty-&gt;column = 0
		然后退出
3.如果是'\t'，首先计算距离8个字符满，还需要多少个字符(需要填充的)
	1.如果O_TABDLY中flag为XTABS，需要将其填充为空格
		tty-&gt;column += spaces
		tty-&gt;driver.write写入spaces个空格数
		然后return 0
	2.否则tty-&gt;column += spaces，然后退出
4.如果是'\b'，tty-&gt;column--后退出
5.如果是其他字符：
	1.如果O_OLCUC打开，通过toupper将其转化为大写
	2.如果不是功能控制（!iscntrl），tty-&gt;column++
	然后退出
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3865</x>
      <y>698</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;driver.put_char
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3853</x>
      <y>682</y>
      <w>20</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3865</x>
      <y>705</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>con_put_char</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3870</x>
      <y>700</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
con_init-&gt;console_driver
参考书说是tty_register_driver-&gt;tty_default_put_char
-&gt;con_write
但是它们都需要执行do_con_write</panel_attributes>
    <additional_attributes>10.0;20.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3858</x>
      <y>711</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pm_access</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3863</x>
      <y>708</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
电源管理</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3879</x>
      <y>711</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_con_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3870</x>
      <y>708</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3863</x>
      <y>714</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3858</x>
      <y>719</y>
      <w>22</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果vc_cons[i].d没被申请
	（!vc_cons_allocated）
	返回0.
注：这是在con_open中被申请的
2.如果是用户层调用（from_user）
	通过copy_from_user将数据copy
	到con_buf中，最大为CON_BUF_SIZE
	buf=con_buf
3.如果是前台console（IS_FG），
	hide_cursor
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3884</x>
      <y>714</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历buf直到tty-&gt;stopped
置上或者count等于0</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3882</x>
      <y>719</y>
      <w>19</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>1.如果utf打开：
	1.如果字符大于0x7f
		1.如果utf_count没用完，并且不是最高位（c &amp; 0xc0==0x80）
			将之前存储的utf_char左移6位，或上现在字符的低6位
			（(utf_char &lt;&lt; 6) | (c &amp; 0x3f)）
			utf_count--
			如果utf_count变为0，表示utf已经组装完成，tc = c = utf_char
			否则继续continue，进行下一个字符
		2.如果上述两种情况不满足，说明是utf的最高位
			这里是查看utf的最高位有n个1,utf_count=n-1,utf_char则被
			赋值为其他位
			如果不满足utf的规则，直接将utf=0，忽略这个字符
			设置了utf_count和utf_char之后，continue，继续遍历下一个字符
			直到utf完整之后，然后处理
	2.如果小于0x7f
		tc = c
		utf_count = 0
2.如果utf-8没打开
	通过translate将8位ASCII或者其他编码转换成unicode
	这个表是二维数组translations中的一个
3.如果tc存在，并且字符c不是控制字符,设置ok，表示字符可以显示
4.如果可以显示vc_state == ESnormal &amp;&amp; ok
	通过conv_uni_to_pc将unicode转化为字模的编号
	然后通过scr_writew写到0xa0000~0x100000
	注：对字符显示暂时不熟，之后在看
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3902</x>
      <y>719</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果调用接口来自用户空间（from_user）
	并且之前buf中的数据还没复制完，通过again
	再去复制一遍
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3884</x>
      <y>714</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
out</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3157</x>
      <y>557</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_interrupt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3162</x>
      <y>534</y>
      <w>284</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
setup_uhci</panel_attributes>
    <additional_attributes>2820.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3093</x>
      <y>563</y>
      <w>37</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.读取controller的中断状态，
	// uhci-&gt;io_addr
	status = inw(io_addr + USBSTS);
	如果status为0，直接返回；否则回写清除status
	outw(status, io_addr + USBSTS)
2.如果状态中有除USBINT和ERROR状态被置上，打印其信息
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3110</x>
      <y>560</y>
      <w>54</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3133</x>
      <y>564</y>
      <w>44</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.通过uhci_free_pending_qhs将qh从uhci-&gt;qh_remove_list
	中移除
2.遍历uhci-&gt;urb_remove_list，利用list_del将urb.urb_list
	从其链表中删除，并且通过urb-&gt;complete对urb进行最后的处理
3.通过uhci_clear_next_interrupt将其请求中断的flag（TD_CTRL_IOC）
	清除：
	uhci-&gt;skel_term_td.status &amp;= ~TD_CTRL_IOC
4.遍历uhci-&gt;urb_list链表（nested_lock），通过uhci_transfer_result将其中完成的urb
	找出，从链表中删除，并求其进行最后处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3148</x>
      <y>560</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3162</x>
      <y>581</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_transfer_result</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3151</x>
      <y>578</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3169</x>
      <y>584</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查看传输的类型
usb_pipetype(urb-&gt;pipe)</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3145</x>
      <y>587</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_CONTROL</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3138</x>
      <y>591</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_result_control</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3117</x>
      <y>598</y>
      <w>21</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.如果urbp为空，返回EINVAL
2.如果urbp对应的链表为空，
	返回EINVAL
3.如果之前检测到short packet，选择状态交互tmp = head-&gt;prev;
	直接去处理状态交互（status_phase）
注：short packet可能是因为数据交互
	的最后阶段，所以直接执行状态交互
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3121</x>
      <y>594</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>210.0;10.0;12.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3139</x>
      <y>598</y>
      <w>20</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.通过链表指针找到对应的td
2.通过uhci_status_bits检查
	td-&gt;status中返回的状态
	1.如果TD_CTRL_ACTIVE还是置上的
	说明td还没被执行，或者需要重新执行
	所以返回EINPROGRESS
	2.如果td被执行，但是status却不是0
	说明执行出错，td_error
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3142</x>
      <y>594</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
setup交互</panel_attributes>
    <additional_attributes>10.0;10.0;22.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3212</x>
      <y>596</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>td_error
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3143</x>
      <y>594</y>
      <w>76</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;742.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3204</x>
      <y>602</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过uhci_map_status解析status中的错误
	如果是EPIPE（broken pipe），通过usb_endpoint_halt
	将对应的endpoint标记为halt
	//out指方向，in=0，out=1
	dev-&gt;halted[out] |= (1 &lt;&lt; (ep))
2.返回解析出来的错误
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3216</x>
      <y>599</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3160</x>
      <y>598</y>
      <w>22</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.如果因为总线load过高，导致某个td
	长期没有执行，而利用 rh_int_timer_do
	将空闲时间的回收暂时拆除，致使fsbr_timeout置上；
	并且该数据交互要求产生中断（TD_CTRL_IOC），并已经执行完（!TD_CTRL_ACTIVE）
	说明此时的bus有空闲出来，所以利用uhci_inc_fsbr将term_td再次连接到hs_control,做usb总线时间的回收
	并将flag清掉：
	urbp-&gt;fsbr_timeout = 0;
	td-&gt;status &amp;= ~TD_CTRL_IOC;
2.查看status，如果没被执行（TD_CTRL_ACTIVE），返回EINPROGRESS
3.urb-&gt;actual_length记录所有数据交互的长度（每个数据交互的长度记录在td-&gt;status中）	
4.如果status非0，表示存在错误，td_error
5.如果此次交互的实际长度（uhci_actual_length）小于其预期的长度（uhci_expected_length）
	1.如果USB_DISABLE_SPD置上（SPD short packet detected）,表示不检测短包，返回EREMOTEIO
	2.如果该flag没置上，如果是输入交互（USB_PID_IN），通过usb_control_retrigger_status
		将此次传输重新执行（因为里面short_control_packet置上，所以只执行状态交互）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3143</x>
      <y>594</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
数据交互
除了第一个和最后一个交互外
都为数据交互</panel_attributes>
    <additional_attributes>10.0;10.0;262.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3183</x>
      <y>598</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.提取status
2.如果没被执行（TD_CTRL_ACTIVE）
	返回EINPROGRESS
3.如果status非0，表示出错，td_error
4.如果正确执行完，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3144</x>
      <y>594</y>
      <w>48</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
状态交互</panel_attributes>
    <additional_attributes>10.0;10.0;462.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3163</x>
      <y>626</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_control_retrigger_status</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3171</x>
      <y>622</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;12.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3152</x>
      <y>632</y>
      <w>36</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.urbp-&gt;short_control_packet = 1
2.通过uhci_remove_qh将释放，
	注释说是为了防止pointer overwritter，这里暂时不清楚
3.遍历传输中除了状态交互之外的其他所有交互，
	通过uhci_remove_td_from_urb将td.list从urbp的链表中删除
	通过uhci_remove_td将td从框架中移除（等时/中断传输会将td链接到对应的框架中，而不是通过qh）
	通过uhci_free_td释放td
4.再次为urbp分配qh
	urbp-&gt;qh = uhci_alloc_qh(urb-&gt;dev)
5.将剩下的状态交互通过uhci_insert_tds_in_qh插入到qh中
6.将qh通过uhci_insert_qh插入到ls_qh或者hs_qh中
7.返回EINPROGRESS
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3146</x>
      <y>654</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_remove_td</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3128</x>
      <y>660</y>
      <w>30</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.如果td的frameptr（指向执行td的框架frame,
	一般在等时传输时对这个字段赋值），prevtd/nexttd
	（在框架内的连接指针）都为空，表示td没连接到框架内，直接返回
2.如果frameptr存在，表示该td是这个框架内的第一个，
	//将第一个换成td的下一个，物理地址
	*(td-&gt;frameptr) = td-&gt;link;
	//如果td-&gt;nexttd存在，将其frameptr指向对应的框架
	td-&gt;nexttd-&gt;frameptr = td-&gt;frameptr;
	td-&gt;nexttd-&gt;prevtd = NULL;
	td-&gt;nexttd = NULL;
	td-&gt;frameptr = NULL
	如果不是框架中的第一个（frameptr不存在）
	//断开前面的链接，这里包含物理地址和虚拟地址
	td-&gt;prevtd-&gt;nexttd = td-&gt;nexttd;
	td-&gt;prevtd-&gt;link = td-&gt;link;
	//将td前后的两个td相连
	td-&gt;nexttd-&gt;prevtd = td-&gt;prevtd
	td-&gt;prevtd = td-&gt;nexttd = NULL;

	td-&gt;link = UHCI_PTR_TERM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3170</x>
      <y>629</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;12.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3139</x>
      <y>657</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;12.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3163</x>
      <y>654</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_free_td</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3160</x>
      <y>661</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.检查td.list是否在urbp链表中
2.如果td-&gt;dev存在，递减其rfecnt
3.通过kmem_cache_free释放td
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3167</x>
      <y>657</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;12.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3151</x>
      <y>651</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;12.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3165</x>
      <y>651</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;42.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3312</x>
      <y>588</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.存储查询urb的状态
	urb-&gt;status = ret
2.如果正在处理（EINPROGRESS）
	直接返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3171</x>
      <y>584</y>
      <w>151</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1490.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3171</x>
      <y>581</y>
      <w>191</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果urb已经处理完</panel_attributes>
    <additional_attributes>10.0;40.0;1890.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3332</x>
      <y>597</y>
      <w>25</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.对于控制/成块/等时传输，如果对urb
	分配了bandwidth，通过usb_release_bandwidth
	将其释放。最后通过uhci_unlink_generic
	释放urb
2.对于中断传输，如果urb-&gt;interval有，表示
	这个中断传输不释放，需要一直polling（uhci_submit_interrupt）
	所以执行完urb-&gt;complete之后，需要通过uhci_reset_interrupt
	将中断传输重新置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3345</x>
      <y>581</y>
      <w>17</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3322</x>
      <y>610</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
urb-&gt;bandwidth
（控制传输是不会申请带宽，所以不会进这里）</panel_attributes>
    <additional_attributes>180.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3328</x>
      <y>615</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_release_bandwidth</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3325</x>
      <y>621</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.释放总线带宽
	dev-&gt;bus-&gt;bandwidth_allocated -= urb-&gt;bandwidth
2.如果是等时传输：
	dev-&gt;bus-&gt;bandwidth_isoc_reqs--
	其他传输：
	dev-&gt;bus-&gt;bandwidth_int_reqs--
3.urb-&gt;bandwidth = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3335</x>
      <y>618</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3350</x>
      <y>615</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_unlink_generic</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3347</x>
      <y>610</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3127</x>
      <y>581</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_free_pending_qhs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3135</x>
      <y>578</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3107</x>
      <y>586</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.遍历uhci-&gt;qh_remove_list，将之前
	冷却的qh通过list_del脱链，并通过
	uhci_free_qh释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3121</x>
      <y>584</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3350</x>
      <y>621</y>
      <w>24</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.利用uhci_dec_fsbr检查urb之前是否
	要求回收总线的空闲时间，如果有，将
	uhci-&gt;fsbr递减，释放其引用
2.通过uhci_remove_urb_list将urb
	从起urb.list链表中删除（nested_lock保护）
3.如果存在urbp-&gt;qh，通过uhci_remove_qh断开其虚拟地址
	链接和物理地址链接，并将其链接到remove_list中冷却
	等待下一次中断将其释放
4.如果urbp-&gt;urb_queue_list不为空，说明该传输和其他传输
	进行了合并（同一设备的同一endpoint），通过uhci_delete_queued_urb
	将其从链表中删除
5.通过uhci_destroy_urb_priv释放urbp及其内部的td
6.urb-&gt;dev = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3358</x>
      <y>618</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3336</x>
      <y>646</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_delete_queued_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3344</x>
      <y>643</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3324</x>
      <y>653</y>
      <w>33</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果队列中当前传输是队列头（!urbp-&gt;queued）
	直接将下一个传输nurbp的qh插入到bulk_qh中，并标记队列头
	nurbp-&gt;queued = 0
2.如果urbp-&gt;queued为1（不是队列头），取出当前传输的前一个传输purbp
	如果nurbp不是队列头，那么将purbp最后一个td链接到nurbp的第一个td：
	ptd-&gt;link = virt_to_bus(list_entry(nurbp-&gt;list.next,
					struct uhci_td, list))
	如果nurbp是队列头，那么purbp最后一个td将是整个队列的最后一个td：
	ptd-&gt;link = UHCI_PTR_TERM
3.（1,2是处理物理链表）通过list_del将urbp从虚拟链表中删除
注：urb_queue_list没有专门的链表头
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3343</x>
      <y>649</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3365</x>
      <y>646</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_destroy_urb_priv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3362</x>
      <y>643</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3362</x>
      <y>653</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.filer:urbp/urb-&gt;dev/urb-&gt;dev-&gt;bus/urb-&gt;dev-&gt;bus-&gt;hcpriv要存在
2.遍历urbp-&gt;list，分别通过uhci_remove_td_from_urb将其从urbp链表中删除
	通过uhci_remove_td将td从框架中删除
	通过uhci_free_td释放td数据结构
3.释放urbp：
	urb-&gt;hcpriv = NULL;
	kmem_cache_free(uhci_up_cachep, urbp)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3372</x>
      <y>649</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3384</x>
      <y>617</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_reset_interrupt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3348</x>
      <y>610</y>
      <w>44</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3378</x>
      <y>624</y>
      <w>30</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.获取urbp-&gt;list链表中的td（只有一个）
2.置status和info
	td-&gt;status = (td-&gt;status &amp; 0x2F000000) | TD_CTRL_ACTIVE | TD_CTRL_IOC
	td-&gt;info的TD_TOKEN_TOGGLE位置反，并将其下一个次的标记放在dev-&gt;toggle[out]（每一位代表一个endpoint）
3.标记传输正在运行
	urb-&gt;status = -EINPROGRESS
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3390</x>
      <y>620</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3359</x>
      <y>581</y>
      <w>28</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
双缓冲优化传输</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3364</x>
      <y>594</y>
      <w>36</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果urb-&gt;next存在，查找链表中有没有不在框架内的传输
	（!= -EINPROGRESS），如果有processed=1，如果检测到
	这个链表是个环形链表is_ring置上
2.通过urb-&gt;complete最后处理urb，如果是个环形链表（!proceed &amp;&amp; is_ring）
	再次将urb通过uhci_submit_urb提交至框架
3.如果urb.next没有提交给框架，通过uhci_submit_urb将其提交，并通过
	urb-&gt;complete最后处理当前的urb
注：这里优化好像只能将urb.next提交至框架，不能在这次将之后的urb提交
	如果next提交时出错，顺延到第三个urb如果提交成功，那么会一直循环
	直到第三个urb处理完成（应该是bug）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3410</x>
      <y>622</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_api_blocking_completion</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3404</x>
      <y>614</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>urb-&gt;complete
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3412</x>
      <y>617</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
控制传输</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3392</x>
      <y>610</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3410</x>
      <y>629</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果唤醒队列urb-&gt;context-&gt;wakeup
	不为空，通过wake_up将其唤醒
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3420</x>
      <y>625</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
控制传输中是唤醒调用
usb_start_wait_urb的进程
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3169</x>
      <y>587</y>
      <w>88</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_BULK/PIPE_INTERRUPT</panel_attributes>
    <additional_attributes>10.0;10.0;860.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3244</x>
      <y>593</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_result_bulk
uhci_result_interrupt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3241</x>
      <y>596</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
过程和控制交互相似
只是少了setup交互和状态加护</panel_attributes>
    <additional_attributes>130.0;10.0;60.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3232</x>
      <y>604</y>
      <w>44</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.urbp要存在，并且将：
	urb-&gt;actual_length = 0
2.遍历urbp-&gt;list链表，获取链表中的td
	1.如果之前因为bus load较高，相应控制交互或者成块交互
		长时间没执行而timeout（fsbr_timeout），并且是当前td产生的
		中断（TD_CTRL_IOC &amp;&amp; ！TD_CTRL_ACTIVE）：
		//重新利用usb空闲总线时间
		uhci_inc_fsbr(urb-&gt;dev-&gt;bus-&gt;hcpriv, urb);
		urbp-&gt;fsbr_timeout = 0;
		td-&gt;status &amp;= ~TD_CTRL_IOC;
	2.通过uhci_status_bits解析td-&gt;status，如果TD_CTRL_ACTIVE
		置上，返回EINPROGRESS，表示td还没被执行完
	3.更新actual_length：
		urb-&gt;actual_length += uhci_actual_length(td-&gt;status)
	4.如果status非0，表示有错，转到td_error执行（和控制传输类似）
	5.如果受到的实际长度，小于预期长度
		1.将(dev)-&gt;toggle[out]（下一次应该发的TD_TOKEN_TOGGLE）
		设置为该urb中的TOGGLE置反。
		2.如果此时USB_DISABLE_SPD置上，返回EREMOTEIO，否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3267</x>
      <y>599</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>td_error
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3254</x>
      <y>596</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
和控制传输相同</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3169</x>
      <y>587</y>
      <w>133</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_ISOCHRONOUS</panel_attributes>
    <additional_attributes>10.0;10.0;1310.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3285</x>
      <y>592</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_result_isochronous</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3280</x>
      <y>600</y>
      <w>30</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.urbp要存在
2.遍历urbp-&gt;list链表中的td
	1.如果td.status中TD_CTRL_ACTIVE置上，返回EINPROGRESS
	2.记录td和urb的实际长度
		urb-&gt;iso_frame_desc[i].actual_length = actlength;
		urb-&gt;actual_length += actlength;
	3.记录td的状态：
		urb-&gt;iso_frame_desc[i].status = status;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3295</x>
      <y>595</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1088</x>
      <y>1805</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__user_walk
（返回0说明正常）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>908</x>
      <y>1843</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>913</x>
      <y>1808</y>
      <w>183</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1810.0;10.0;10.0;350.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>936</x>
      <y>1843</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>942</x>
      <y>1808</y>
      <w>154</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1520.0;10.0;10.0;350.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1129</x>
      <y>1818</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1093</x>
      <y>1808</y>
      <w>44</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1574</x>
      <y>1819</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>putname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1095</x>
      <y>1808</y>
      <w>485</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放name slab</panel_attributes>
    <additional_attributes>10.0;10.0;4830.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>909</x>
      <y>1851</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>nd-&gt;last_type = LAST_ROOT
nd-&gt;flags = flags;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>918</x>
      <y>1846</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>934</x>
      <y>1852</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>walk_init_root
（返回1说明继续查找
返回0说明不用继续）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>940</x>
      <y>1846</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果通过根目录寻址</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>950</x>
      <y>1852</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nd-&gt;mnt = mntget(current-&gt;fs-&gt;pwdmnt);
nd-&gt;dentry = dget(current-&gt;fs-&gt;pwd);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>940</x>
      <y>1846</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果通过当前目录寻址</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>912</x>
      <y>1855</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果current-&gt;fs-&gt;altroot不为空
!(nd-&gt;flags &amp; LOOKUP_NOALT)
并且规定不在altroot上寻址</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>880</x>
      <y>1867</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>nd-&gt;mnt = mntget(current-&gt;fs-&gt;altrootmnt);
nd-&gt;dentry = dget(current-&gt;fs-&gt;altroot);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>888</x>
      <y>1862</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>910</x>
      <y>1869</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__emul_lookup_dentry
（返回0说明存在问题）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>913</x>
      <y>1862</y>
      <w>8</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>931</x>
      <y>1865</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nd-&gt;mnt = mntget(current-&gt;fs-&gt;rootmnt);
nd-&gt;dentry = dget(current-&gt;fs-&gt;root);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>936</x>
      <y>1855</y>
      <w>26</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
表示在系统的根目录下开始寻址</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>894</x>
      <y>1879</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk
（返回非0说明存在问题）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>902</x>
      <y>1872</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>916</x>
      <y>1872</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果path_walk正常</panel_attributes>
    <additional_attributes>30.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>967</x>
      <y>1821</y>
      <w>171</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果‘/’之后name结束</panel_attributes>
    <additional_attributes>1690.0;10.0;10.0;380.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>963</x>
      <y>1859</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>974</x>
      <y>1860</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode = nd-&gt;dentry-&gt;d_inode
if (current-&gt;link_count)
		lookup_flags = LOOKUP_FOLLOW;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>982</x>
      <y>1821</y>
      <w>156</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1540.0;10.0;10.0;390.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1006</x>
      <y>1821</y>
      <w>132</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查看目录的权限</panel_attributes>
    <additional_attributes>1300.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1000</x>
      <y>1861</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>permission(inode, MAY_EXEC)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1023</x>
      <y>1860</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>this.name = name;
this.len = name - (const char *) this.name;
this.hash = end_name_hash(hash)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1032</x>
      <y>1821</y>
      <w>106</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1040.0;10.0;10.0;390.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1051</x>
      <y>1861</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>last_component
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1055</x>
      <y>1821</y>
      <w>83</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
最后一个节点最后一个字符是‘\0’
就是文件</panel_attributes>
    <additional_attributes>810.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1067</x>
      <y>1861</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>last_with_slashes
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1071</x>
      <y>1821</y>
      <w>68</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
最后一个节点最后一个如果是‘\’
就是目录</panel_attributes>
    <additional_attributes>660.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1090</x>
      <y>1821</y>
      <w>48</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
第一个字符如果是'.'</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1081</x>
      <y>1860</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果长度只有1个
找到当前目录
就跳出本次循环</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1079</x>
      <y>1867</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>continue
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1089</x>
      <y>1860</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
长度为2</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1090</x>
      <y>1866</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有两个'.'</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1073</x>
      <y>1878</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>follow_dotdot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1087</x>
      <y>1878</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode = nd-&gt;dentry-&gt;d_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1098</x>
      <y>1866</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果只有一个‘.’
另一个是其他字符
解析为普通文件名</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1078</x>
      <y>1872</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1090</x>
      <y>1872</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1105</x>
      <y>1873</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>break
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1089</x>
      <y>1860</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
长度如果更长
则不是特殊
解析为普通文件名</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1115</x>
      <y>1869</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>break
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1018</x>
      <y>1885</y>
      <w>60</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
nd-&gt;dentry == current-&gt;fs-&gt;root
&amp;&amp;nd-&gt;mnt == current-&gt;fs-&gt;rootmnt
如果是根目录，上层就是本目录
</panel_attributes>
    <additional_attributes>580.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1014</x>
      <y>1892</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>break
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1054</x>
      <y>1885</y>
      <w>28</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
	//mnt_root是设备的mount目录
nd-&gt;dentry != nd-&gt;mnt-&gt;mnt_root
如果不是本设备的根目录，就向上找parent</panel_attributes>
    <additional_attributes>220.0;10.0;50.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1050</x>
      <y>1897</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //nd-&gt;dentry-&gt;d_parent是目录的parent
dentry = dget(nd-&gt;dentry-&gt;d_parent);
dput(nd-&gt;dentry);
nd-&gt;dentry = dentry;
break;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1075</x>
      <y>1881</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
死循环</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1090</x>
      <y>1900</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>parent=nd-&gt;mnt-&gt;mnt_parent
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1075</x>
      <y>1885</y>
      <w>27</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
本设备的父设备
即设备安装在父设备上</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1075</x>
      <y>1885</y>
      <w>50</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
parent == nd-&gt;mnt
如果是系统根目录
不向上查找，直接退出</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1116</x>
      <y>1899</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>break;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1138</x>
      <y>1896</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>mntget(parent);
dentry=dget(nd-&gt;mnt-&gt;mnt_mountpoint);
dput(nd-&gt;dentry);
nd-&gt;dentry = dentry;
mntput(nd-&gt;mnt);
nd-&gt;mnt = parent;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1075</x>
      <y>1885</y>
      <w>69</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
运行到这里是
当前目录是当前设备的根目录
但是存在父设备，所以在父设备中查找
父设备中的安装目录和当前设备的根目录
是同一个节点，所以这里不退出，直接通过死循环
继续前面的过程查找</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1135</x>
      <y>1821</y>
      <w>26</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 nd-&gt;dentry-&gt;d_op-&gt;d_hash
 如果文件系统存在计算哈希值的函数
 就让文件系统自己计算哈希值</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1123</x>
      <y>1861</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_hash(nd-&gt;dentry, &amp;this)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1166</x>
      <y>1856</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cached_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1136</x>
      <y>1821</y>
      <w>38</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在内存中搜索当前节点对应的dentry结构
nd-&gt;dentry, &amp;this, LOOKUP_CONTINUE</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;350.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1155</x>
      <y>1866</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1160</x>
      <y>1859</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
parent，this</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1132</x>
      <y>1877</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1137</x>
      <y>1869</y>
      <w>24</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
parent hash
dentry_hashtable
将父节点加入哈希值的计算
可以有效减少hash表的链表长度
比如不同目录中有相同的目录名
但是这也只是上升了一层，因为
全路径的计算代价太大</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1167</x>
      <y>1875</y>
      <w>52</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.因为此时的hash是经过原来的hash经过变换得到的，所以需要比较原来的hash
	dentry-&gt;d_name.hash == hash
2.查看父节点是否相同dentry-&gt;d_parent = parent
3.查看名字是否相同（因为同一目录下允许有name相同的文件）
	如果文件系统提供了d_compare就通过文件系统本身的去比较
	d_compare(parent, &amp;dentry-&gt;d_name, name)
	如果没提供，就比较name的长度和名字
	dentry-&gt;d_name.len = len
	memcmp(dentry-&gt;d_name.name, str, len)
4.如果在hash表中找到了dentry就返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>1869</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果向下找到了dentry_hashtable的头
就返回NULL</panel_attributes>
    <additional_attributes>60.0;10.0;180.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1169</x>
      <y>1897</y>
      <w>41</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>memcmp：
	"repe\n\t"	////重复ecx次，每次ecx减1，直到ecx=0或者zf=0
	"cmpsb\n\t" //将esi和edi的字符比较，直到两者不相同	
					//相同时zf=1，不同时zf=0			
	"je 1f\n\t" //如果相同，res为0直接返回（cf=1）
	"sbbl %0,%0\n\t" //-cf
	"orb $1,%b0\n" //res=0xFFFFFFFF
	"1:"
	//esi=cs edi=ct __res是返回值 ecx=count
	:"=a" (__res), "=&amp;S" (d0), "=&amp;D" (d1), "=&amp;c" (d2)
	:"0" (0), "1" (cs), "2" (ct), "3" (count));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1186</x>
      <y>1892</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1171</x>
      <y>1859</y>
      <w>70</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果文件系统存在重新认证这个dentry的函数
就通过d_revalidate重新认证（例如NFS,会判断访问时间）
然后通过d_invalidate断开连接</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1235</x>
      <y>1873</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput(dentry);
			dentry = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1136</x>
      <y>1821</y>
      <w>144</w>
      <h>51</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果内存中没找到
就要到磁盘中查找</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;300.0;1420.0;490.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1271</x>
      <y>1870</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>real_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1224</x>
      <y>1873</y>
      <w>53</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;370.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1211</x>
      <y>1910</y>
      <w>23</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>down(&amp;dir-&gt;i_sem)
	//因为前面可能因为down而sleep
	//所以这里醒来之后需要查看一下
	//dentry是否在内存中
d_lookup(parent, name)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1249</x>
      <y>1873</y>
      <w>28</w>
      <h>43</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果还是没找到</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;410.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1241</x>
      <y>1913</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1235</x>
      <y>1917</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1222</x>
      <y>1920</y>
      <w>18</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请dentry结构</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1213</x>
      <y>1928</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1238</x>
      <y>1920</y>
      <w>3</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1227</x>
      <y>1931</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1223</x>
      <y>1926</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
name-&gt;len &gt; DNAME_INLINE_LEN-1
如果name的长度过长，就从通用cache中
申请内存
16字节对齐</panel_attributes>
    <additional_attributes>160.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1242</x>
      <y>1931</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>str = dentry-&gt;d_iname
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1235</x>
      <y>1926</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否则就用dentry中的name结构</panel_attributes>
    <additional_attributes>40.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1261</x>
      <y>1929</y>
      <w>38</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>memcpy(str, name-&gt;name, name-&gt;len);
str[name-&gt;len] = 0;

atomic_set(&amp;dentry-&gt;d_count, 1);
dentry-&gt;d_flags = 0;
dentry-&gt;d_inode = NULL;
dentry-&gt;d_parent = NULL;
dentry-&gt;d_sb = NULL;
dentry-&gt;d_name.name = str;
dentry-&gt;d_name.len = name-&gt;len;
dentry-&gt;d_name.hash = name-&gt;hash;
dentry-&gt;d_op = NULL;
dentry-&gt;d_fsdata = NULL;
	//如果dentry有安装在某个节点，这里是安装信息
INIT_LIST_HEAD(&amp;dentry-&gt;d_vfsmnt);
	//这个链接在hash表中
INIT_LIST_HEAD(&amp;dentry-&gt;d_hash);
	//如果没被用到，链接在unused_dentry中
INIT_LIST_HEAD(&amp;dentry-&gt;d_lru);
	//其子目录链接在下面，链表头
INIT_LIST_HEAD(&amp;dentry-&gt;d_subdirs);
	//如果一个inode有多个dentry，这个链接在inode的链表中
INIT_LIST_HEAD(&amp;dentry-&gt;d_alias);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1239</x>
      <y>1920</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化dentry</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1300</x>
      <y>1932</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>dentry-&gt;d_parent = dget(parent);
 //继承父节点的super_block
dentry-&gt;d_sb = parent-&gt;d_sb;
list_add(&amp;dentry-&gt;d_child, &amp;parent-&gt;d_subdirs);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1241</x>
      <y>1920</y>
      <w>76</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注意找到节点的dentry会放到父目录下的d_subdirs
有可能目录的显示就是通过遍历这个链表
</panel_attributes>
    <additional_attributes>10.0;10.0;740.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1305</x>
      <y>1926</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果该节点有父目录</panel_attributes>
    <additional_attributes>100.0;10.0;40.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1334</x>
      <y>1933</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>INIT_LIST_HEAD(&amp;dentry-&gt;d_child)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1313</x>
      <y>1926</y>
      <w>28</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没有</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1360</x>
      <y>1933</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry_stat.nr_dentry++;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1240</x>
      <y>1920</y>
      <w>136</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;750.0;40.0;1340.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1321</x>
      <y>1960</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1249</x>
      <y>1913</y>
      <w>145</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果分配好了dentry内存结构
就通过文件系统的函数到磁盘中查找</panel_attributes>
    <additional_attributes>10.0;10.0;1430.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1383</x>
      <y>1922</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_op-&gt;lookup
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1325</x>
      <y>1925</y>
      <w>76</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_dir_inode_operations
</panel_attributes>
    <additional_attributes>670.0;10.0;480.0;230.0;10.0;350.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1250</x>
      <y>1913</y>
      <w>163</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1610.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1402</x>
      <y>1917</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
result有error
没找到，释放dentry</panel_attributes>
    <additional_attributes>90.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1404</x>
      <y>1922</y>
      <w>9</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>dput(dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1410</x>
      <y>1917</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到了</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1414</x>
      <y>1922</y>
      <w>11</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>result = dentry;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1426</x>
      <y>1922</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>up(&amp;dir-&gt;i_sem);
		return result;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1410</x>
      <y>1917</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
退出</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1274</x>
      <y>1873</y>
      <w>45</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在之前的d_lookup中
找到了dentry，如果文件系统有要求
需要认证</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;290.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1313</x>
      <y>1902</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput(dentry);
			dentry = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1174</x>
      <y>1963</y>
      <w>154</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>1520.0;10.0;10.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1162</x>
      <y>1993</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry-&gt;d_name.len &gt; EXT2_NAME_LEN
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1197</x>
      <y>1993</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_find_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1201</x>
      <y>1963</y>
      <w>127</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将父目录的内容读取到内存中
存在bh为管理单元的缓冲区中
并找到对应（name inode）项</panel_attributes>
    <additional_attributes>1250.0;10.0;10.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1223</x>
      <y>1990</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1226</x>
      <y>1963</y>
      <w>102</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据inode号找到要找目录的inode</panel_attributes>
    <additional_attributes>1000.0;10.0;10.0;270.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1386</x>
      <y>1994</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1325</x>
      <y>1963</y>
      <w>67</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;310.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1377</x>
      <y>2002</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_instantiate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1396</x>
      <y>2001</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_rehash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1390</x>
      <y>1997</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1380</x>
      <y>1997</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1368</x>
      <y>2010</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>if (inode)
	//将dentry加入到inode的链表中
	list_add(&amp;entry-&gt;d_alias, &amp;inode-&gt;i_dentry);
 //指明dentry中的d_inode
entry-&gt;d_inode = inode;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1378</x>
      <y>2005</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1401</x>
      <y>2010</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>list = d_hash(entry-&gt;d_parent, entry-&gt;d_name.hash)
list_add(&amp;entry-&gt;d_hash, list);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1396</x>
      <y>2004</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将新申请的dentry链接到hash中</panel_attributes>
    <additional_attributes>40.0;10.0;160.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1110</x>
      <y>2015</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>*res_dir = NULL
sb = dir-&gt;i_sb
filter：namelen &gt; EXT2_NAME_LEN
memset (bh_use, 0, sizeof (bh_use))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1123</x>
      <y>1996</y>
      <w>80</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
NAMEI_RA_SIZE：预读的size</panel_attributes>
    <additional_attributes>780.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1154</x>
      <y>1996</y>
      <w>51</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过ext2_getblk填充
bh_use和bh_read
</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1136</x>
      <y>2016</y>
      <w>41</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.block是读取目录inode的第block块
2.预读的大小不能大于目录的size
	(block &lt;&lt; EXT2_BLOCK_SIZE_BITS (sb)) &gt;= dir-&gt;i_size
		break；
	这里可知，目录的i_size是以bit为单位
3.通过ext2_getblk填充预读的buffer_head bh_use
4.如果这个buffer没从磁盘读进来（bh &amp;&amp; !buffer_uptodate(bh)），
	就将bh_read[toread++] = bh
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1179</x>
      <y>2021</y>
      <w>61</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.采取流水线预读：处理0 block的时候，所有没到内存中的block
  都通过ll_rw_block读到内存中，在读到第4个block的时候，再将
  第8~12个block中没到内存中的读到内存中，以此类推。因为cpu处理buffer
  与从硬盘中读取是异步操作，这样就可以使在操作buffer的时候就可以同步的从
  硬盘中读取数据，如果这个过程合理，wait_on_buffer就可能不需要有任何的等待
2.错误处理：如果当前的size没有内容，就不处理，并将offset加上s_blocksize
	如果数据没有更新到内存中，那么直接退出，返回NULL
3.ext2的每个目录项都是和block对齐的，并且不能跨block。所以这里依次取出block
	中的目录项通过ext2_match比较name，和ext2_check_dir_entry进行检查，如果都通过
	了就将其他的bh释放，返回当前的bh。如果没找到，就遍历下一个目录项（de+de-&gt;rec_len），
	这里注意ext2的目录项是大小是不定的。
4.如果遍历完整个block没找到，就将当前的bh释放，并看block + NAMEI_RA_SIZE有没有超过
	dir的size，如果超过了，就不需要对其就行预读，否者需要通过ext2_getblk将bh读进来，
	并判断是否要预读，以便形成流水线的操作。
5.如果遍历完整个dir没找到，就返回NULL。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1198</x>
      <y>1996</y>
      <w>22</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
block指的是读取的block，
但是在bh_use中的额位置是
block % NAMEI_RA_SIZE

offset是目录项在dir中的偏移</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;250.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1237</x>
      <y>1997</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iget4</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1227</x>
      <y>1993</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
超级块
inode号</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1223</x>
      <y>2008</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1216</x>
      <y>2000</y>
      <w>39</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在hash表inode_hashtable中查找
1.是否有inode号和超级块和当前查找的inode相同的inode，
2.如果有find_actor，则通过find_actor进行比较</panel_attributes>
    <additional_attributes>260.0;10.0;120.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1256</x>
      <y>2011</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__iget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1242</x>
      <y>2000</y>
      <w>20</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在内存中找到</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1244</x>
      <y>2014</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果之前又被引用</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1240</x>
      <y>2021</y>
      <w>19</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;inode-&gt;i_count)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1260</x>
      <y>2020</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;inode-&gt;i_count)
 //如果dirty，这个链表会连在s_dirty
 //如果不是dirty，且count为0，则连在inode_unused
if !I_DIRTY
	将inode从原来的链表中删除，并且
	添加到inode_in_use中
inodes_stat.nr_unused--
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1261</x>
      <y>2014</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没被引用</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1325</x>
      <y>2014</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_new_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1242</x>
      <y>2000</y>
      <w>91</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在内存中没找到</panel_attributes>
    <additional_attributes>10.0;10.0;890.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1246</x>
      <y>2037</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1250</x>
      <y>2017</y>
      <w>84</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>820.0;10.0;350.0;150.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1263</x>
      <y>2039</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1268</x>
      <y>2017</y>
      <w>66</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为前面有spinlock
所以此时内存中可能已经存在了inode</panel_attributes>
    <additional_attributes>640.0;10.0;10.0;220.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1277</x>
      <y>2041</y>
      <w>20</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>__iget(old);//增加inode计数
 //因为内存中已经存在inode
 //所以将新申请的inode释放
 //如果inode的dirty_buffer中
 //存在成员，应该报错
destroy_inode(inode);
inode = old;
wait_on_inode(inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1287</x>
      <y>2017</y>
      <w>47</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
内存中存在inode</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;240.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1331</x>
      <y>2017</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
内存中还是不存在inode
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1316</x>
      <y>2025</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化inode</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1303</x>
      <y>2034</y>
      <w>40</w>
      <h>46</h>
    </coordinates>
    <panel_attributes>inodes_stat.nr_inodes++;
list_add(&amp;inode-&gt;i_list, &amp;inode_in_use);
list_add(&amp;inode-&gt;i_hash, head);
inode-&gt;i_sb = sb;
inode-&gt;i_dev = sb-&gt;s_dev;
inode-&gt;i_ino = ino;
inode-&gt;i_flags = 0;
atomic_set(&amp;inode-&gt;i_count, 1);
inode-&gt;i_state = I_LOCK;

 //注意clean_inode中的empty的操作
 //这些申明是static是保存在data段
 //没经初始化，是NULL,所以这里全部初始化为NULL
clean_inode
	memset(&amp;inode-&gt;u, 0, sizeof(inode-&gt;u));
	inode-&gt;i_sock = 0;
	inode-&gt;i_op = &amp;empty_iops;
	inode-&gt;i_fop = &amp;empty_fops;
	inode-&gt;i_nlink = 1;
	atomic_set(&amp;inode-&gt;i_writecount, 0);
	inode-&gt;i_size = 0;
	inode-&gt;i_generation = 0;
	memset(&amp;inode-&gt;i_dquot, 0, sizeof(inode-&gt;i_dquot));
	inode-&gt;i_pipe = NULL;
	inode-&gt;i_bdev = NULL;
	inode-&gt;i_data.a_ops = &amp;empty_aops;
	inode-&gt;i_data.host = inode;
	inode-&gt;i_mapping = &amp;inode-&gt;i_data;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1420</x>
      <y>2031</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_state &amp;= ~I_LOCK;
wake_up(&amp;inode-&gt;i_wait);
return inode;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1335</x>
      <y>2025</y>
      <w>96</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
当从硬盘中读到inode
并将进程唤醒</panel_attributes>
    <additional_attributes>10.0;10.0;940.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1378</x>
      <y>2033</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;read_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1335</x>
      <y>2025</y>
      <w>52</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
利用具体文件系统的方法
将inode读取到内存</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1395</x>
      <y>2041</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_read_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1386</x>
      <y>2036</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 ext2_sops</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1344</x>
      <y>2051</y>
      <w>66</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.检查inode号
	如果小于EXT2_FIRST_INO，但是不是EXT2_ROOT_INO EXT2_ACL_IDX_INO EXT2_ACL_DATA_INO
	如果inode号大于最大的inode---s_inodes_count
2.检查block_group( (inode-&gt;i_ino - 1) / EXT2_INODES_PER_GROUP )
`大于最大的group号s_groups_count
3.inode号被分为3段，最低的一段为offset（有些许不同，offset为其字节数）
	中间一段为group的号desc。最高的一段为group_desc
	首先在group_desc中存储的信息存在在buffer中，通过s_group_desc[group_desc]取出（不能为空）
	其次拿到inode所在组的block偏移s_group_desc[group_desc][desc].bg_inode_table
	最后将其加上inode在组内偏移的block号offset&gt;&gt;EXT2_BLOCK_SIZE_BITS
	即为inode的block号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1370</x>
      <y>2044</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1418</x>
      <y>2052</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1400</x>
      <y>2044</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1401</x>
      <y>2044</y>
      <w>46</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将offset对blocksize取余
这里的blocksize应该是2的整数次幂
offset &amp;= (EXT2_BLOCK_SIZE(inode-&gt;i_sb) - 1)</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1438</x>
      <y>2052</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>raw_inode=bh-&gt;b_data + offset
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1402</x>
      <y>2044</y>
      <w>69</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据raw_inode中的数据
对inode进行填充
包括inode-&gt;u.ext2_i.i_data</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1465</x>
      <y>2051</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>inode：
	VFS
	ext2_inode_info
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1402</x>
      <y>2044</y>
      <w>97</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将文件系统的操作方法
和VFS链接</panel_attributes>
    <additional_attributes>10.0;10.0;950.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1487</x>
      <y>2048</y>
      <w>34</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>ACL：不做处理
S_ISREG：
inode-&gt;i_op = &amp;ext2_file_inode_operations;
inode-&gt;i_fop = &amp;ext2_file_operations;
inode-&gt;i_mapping-&gt;a_ops = &amp;ext2_aops;

S_ISDIR：
inode-&gt;i_op = &amp;ext2_dir_inode_operations;
inode-&gt;i_fop = &amp;ext2_dir_operations;

S_ISLNK：
if (!inode-&gt;i_blocks)
	inode-&gt;i_op = &amp;ext2_fast_symlink_inode_operations;
else {
	inode-&gt;i_op = &amp;page_symlink_inode_operations;
	inode-&gt;i_mapping-&gt;a_ops = &amp;ext2_aops;
}

特殊文件：
init_special_inode(inode, inode-&gt;i_mode,
				   le32_to_cpu(raw_inode-&gt;i_block[0]));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1532</x>
      <y>2055</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_attr_flags
inode-&gt;i_flags
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1401</x>
      <y>2043</y>
      <w>140</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据inode-&gt;u.ext2_i.i_flag
设置</panel_attributes>
    <additional_attributes>10.0;20.0;1220.0;20.0;1380.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1273</x>
      <y>1859</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>d_mountpoint(dentry) 
&amp;&amp; __follow_down(&amp;nd-&gt;mnt, &amp;dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1137</x>
      <y>1821</y>
      <w>150</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查当前节点是否是安装节点</panel_attributes>
    <additional_attributes>10.0;10.0;970.0;280.0;1480.0;380.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1354</x>
      <y>1847</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1135</x>
      <y>1821</y>
      <w>224</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2220.0;220.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1358</x>
      <y>1850</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
最多嵌套调用8次</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1317</x>
      <y>1861</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>UPDATE_ATIME
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1323</x>
      <y>1856</y>
      <w>39</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1377</x>
      <y>1859</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry-&gt;d_inode-&gt;i_op-&gt;follow_link
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1359</x>
      <y>1856</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1364</x>
      <y>1862</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_fast_symlink_inode_operations</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1359</x>
      <y>1871</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1364</x>
      <y>1878</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1366</x>
      <y>1874</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
此时data中存储的路径名</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1370</x>
      <y>1885</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__vfs_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1373</x>
      <y>1880</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1360</x>
      <y>1888</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果符号链接到根目录</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1349</x>
      <y>1892</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放当前节点</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1343</x>
      <y>1895</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1328</x>
      <y>1902</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput(nd-&gt;dentry)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1350</x>
      <y>1902</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mntput(nd-&gt;mnt)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1332</x>
      <y>1898</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1347</x>
      <y>1898</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1367</x>
      <y>1902</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1372</x>
      <y>1888</y>
      <w>20</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查找符号链接对应的inode</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1413</x>
      <y>1897</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>name = __getname();
strcpy(name, nd-&gt;last.name);
nd-&gt;last.name = name;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1375</x>
      <y>1888</y>
      <w>49</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
看不懂，last.name为什么直接指向
原来的name，而需要新建一个
需要之后看这个的应用场景</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1376</x>
      <y>1888</y>
      <w>29</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;link_count
|| res //有错
|| nd-&gt;last_type!=LAST_NORM
这里因为有link_count,所以推出</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1396</x>
      <y>1903</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return res
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1355</x>
      <y>1842</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
follow_link
符号链接</panel_attributes>
    <additional_attributes>20.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1358</x>
      <y>1845</y>
      <w>5</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1360</x>
      <y>1845</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1374</x>
      <y>1847</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>dput(dentry)
inode = nd-&gt;dentry-&gt;d_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1356</x>
      <y>1842</y>
      <w>57</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
普通的inode</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1401</x>
      <y>1847</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>dput(nd-&gt;dentry);
nd-&gt;dentry = dentry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1489</x>
      <y>1828</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>last_component
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1443</x>
      <y>1828</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>last_with_slashes
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1424</x>
      <y>1847</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>continue
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1356</x>
      <y>1842</y>
      <w>75</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
继续循环查找</panel_attributes>
    <additional_attributes>10.0;10.0;730.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1431</x>
      <y>1836</y>
      <w>40</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1448</x>
      <y>1831</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是链接目录
要到所在的链接对象</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1483</x>
      <y>1831</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
LOOKUP_PARENT
要找的是父节点</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1476</x>
      <y>1837</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_parent
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1443</x>
      <y>1845</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>nd-&gt;last = this
nd-&gt;last_type = LAST_NORM //普通名称
nd-&gt;last_type = LAST_DOT //‘.’
nd-&gt;last_type = LAST_DOTDOT //'..'
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1455</x>
      <y>1840</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1479</x>
      <y>1845</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果是'..'，通过follow_dotdot，
	然后返回节点
2.如果是'.',直接返回
3,，如果是其他名称，继续查找inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1489</x>
      <y>1831</y>
      <w>17</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
解析最后一个名称</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1509</x>
      <y>1846</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>nd-&gt;dentry-&gt;d_op-&gt;d_hash
cached_lookup
real_lookup

d_mountpoint(dentry) 
&amp;&amp; __follow_down(&amp;nd-&gt;mnt, &amp;dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1496</x>
      <y>1831</y>
      <w>25</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
和查找中间节点的方法类似
但是注意real_lookup和cached_lookup
的flag变为了0
但是d_revalidate在ext2中没有</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1537</x>
      <y>1854</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_follow_link
（refrence）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1497</x>
      <y>1831</y>
      <w>67</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1546</x>
      <y>1845</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
只有在LOOKUP_FOLLOW
的时候采取找符号链接</panel_attributes>
    <additional_attributes>160.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1573</x>
      <y>1855</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>dput(nd-&gt;dentry);
			nd-&gt;dentry = dentry;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1551</x>
      <y>1854</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>dput(dentry)
inode = nd-&gt;dentry-&gt;d_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1541</x>
      <y>1850</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1548</x>
      <y>1850</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1561</x>
      <y>1845</y>
      <w>22</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1592</x>
      <y>1845</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>no_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1590</x>
      <y>1848</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
只有在LOOKUP_POSITIVE|LOOKUP_DIRECTORY
的时候在报错</panel_attributes>
    <additional_attributes>90.0;10.0;250.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1607</x>
      <y>1857</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_release(nd)
return err
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1497</x>
      <y>1831</y>
      <w>105</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1030.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1497</x>
      <y>1831</y>
      <w>146</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1440.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1607</x>
      <y>1841</y>
      <w>43</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
存在inode
当LOOKUP_DIRECTORY的时候，但是没有	inode-&gt;i_op-&gt;lookup
会报错</panel_attributes>
    <additional_attributes>340.0;10.0;80.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1136</x>
      <y>1821</y>
      <w>314</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3120.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1135</x>
      <y>1821</y>
      <w>362</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3600.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>978</x>
      <y>1871</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op-&gt;permission
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>984</x>
      <y>1864</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果文件系统规定了permission</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1007</x>
      <y>1873</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_permission
1.首先看超级块的权限，只读/mute等
2.其次看进程的权限
	2.1如果可执行文件的setuid位置上，可以改变进程的uid gid（参考prepare_binprm和compute_creds）
	2.2.CAP_DAC_OVERRIDE/CAP_DAC_READ_SEARCH可以将uid的权限覆盖
3.看uid的权限（即DAC）,和文件主是同一个用户？同组用户？还是其他用户

inode 的mode位：
0~8：其他用户、同组用户、文件主权限
10 11：setuid setgrd
12~15：文件类型
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1012</x>
      <y>1864</y>
      <w>19</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否则就用vfs的permission</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>868</x>
      <y>1876</y>
      <w>146</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(mask &amp; S_IWOTH) &amp;&amp; IS_RDONLY(inode) &amp;&amp;
(S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))
需要写权限||磁盘是只读安装 ||（是常规文件 || 目录 ||链接）</panel_attributes>
    <additional_attributes>1440.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>863</x>
      <y>1895</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>EROFS
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>891</x>
      <y>1876</y>
      <w>123</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(mask &amp; S_IWOTH) &amp;&amp; IS_IMMUTABLE(inode)
写 || 不可更改
IS_IMMUTABLE和用户无关</panel_attributes>
    <additional_attributes>1210.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>886</x>
      <y>1895</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>EACCES
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>872</x>
      <y>1888</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mode = inode-&gt;i_mode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>880</x>
      <y>1876</y>
      <w>133</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1310.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>905</x>
      <y>1896</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mode &gt;&gt;= 6
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>911</x>
      <y>1876</y>
      <w>104</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;fsuid == inode-&gt;i_uid
fsuid大部分和euid相同
但是在NFS中可能会不一样</panel_attributes>
    <additional_attributes>1020.0;10.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>926</x>
      <y>1876</y>
      <w>89</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>870.0;10.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>921</x>
      <y>1896</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>in_group_p</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>912</x>
      <y>1899</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode-&gt;i_gid == current-&gt;fsgid</panel_attributes>
    <additional_attributes>150.0;10.0;50.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>905</x>
      <y>1907</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>supplemental_group_member</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>907</x>
      <y>1914</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>遍历current-&gt;groups
看是否有组号一样的
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>914</x>
      <y>1910</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
一个用户可能在不同的组中</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>934</x>
      <y>1899</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mode &gt;&gt;= 3
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>929</x>
      <y>1895</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>956</x>
      <y>1876</y>
      <w>59</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
此时判断权限
(mode &amp; mask &amp; S_IRWXO) == mask) || capable(CAP_DAC_OVERRIDE)
others已经在最后三位上所以不用移
CAP_DAC_OVERRIDE：授权进程
</panel_attributes>
    <additional_attributes>570.0;10.0;10.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>950</x>
      <y>1900</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>982</x>
      <y>1899</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>979</x>
      <y>1876</y>
      <w>44</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(mask == S_IROTH) ||
 (S_ISDIR(inode-&gt;i_mode)  &amp;&amp; !(mask &amp; ~(S_IROTH | S_IXOTH))))
	if (capable(CAP_DAC_READ_SEARCH)
读||
（目录 || 没要写权限）
</panel_attributes>
    <additional_attributes>340.0;10.0;90.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>942</x>
      <y>1967</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_setuid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>931</x>
      <y>1970</y>
      <w>17</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CAP_SETUID</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>931</x>
      <y>1977</y>
      <w>12</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>936</x>
      <y>1985</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;suid = uid
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>923</x>
      <y>1977</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uid != old_ruid</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>918</x>
      <y>1984</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>885</x>
      <y>1994</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_uid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>890</x>
      <y>1987</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>855</x>
      <y>1997</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从uidhash_table对应的哈希值
处查找，直到为空，或者找到user的uid
和想找的相同，并将user.count++</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>849</x>
      <y>2003</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uid_hash_find</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>879</x>
      <y>1997</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果哈希表中没找到</panel_attributes>
    <additional_attributes>120.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>852</x>
      <y>2010</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>857</x>
      <y>2004</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uid_cachep
申请user</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>868</x>
      <y>2011</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>new-&gt;uid = uid;
atomic_set(&amp;new-&gt;__count, 1);
atomic_set(&amp;new-&gt;processes, 0);
atomic_set(&amp;new-&gt;files, 0)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>879</x>
      <y>2004</y>
      <w>5</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>896</x>
      <y>2012</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uid_hash_find</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>879</x>
      <y>2004</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为在操作哈希表的时候有spinlock
所以这里再查查哈希表中是否有对应的
user</panel_attributes>
    <additional_attributes>30.0;10.0;210.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>881</x>
      <y>2004</y>
      <w>35</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>910</x>
      <y>2010</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有将申请到的user释放</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>903</x>
      <y>2016</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>923</x>
      <y>2016</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //注意pprev指向的是（指向自己的）箭头
uid_hash_insert(new, hashent);
up = new;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>913</x>
      <y>2010</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>902</x>
      <y>1995</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>old_user = current-&gt;user;
atomic_dec(&amp;old_user-&gt;processes);
atomic_inc(&amp;new_user-&gt;processes);
current-&gt;uid = new_ruid;
current-&gt;user = new_user;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>917</x>
      <y>1987</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>939</x>
      <y>1997</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_uid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>924</x>
      <y>1987</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
old_user</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>923</x>
      <y>2000</y>
      <w>40</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
up &amp;&amp; atomic_dec_and_lock(&amp;up-&gt;__count, &amp;uidhash_lock)</panel_attributes>
    <additional_attributes>230.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>935</x>
      <y>2005</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //注意pprev的操作
uid_hash_remove
kmem_cache_free
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>954</x>
      <y>1984</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>EPERM
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>945</x>
      <y>1970</y>
      <w>19</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没有权限
设置的uid又不是
current-&gt;uid
current-&gt;suid</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>966</x>
      <y>1984</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;fsuid = current-&gt;euid = uid
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>945</x>
      <y>1970</y>
      <w>32</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>995</x>
      <y>1984</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes> //越界访问不产生dump文件
current-&gt;dumpable = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>945</x>
      <y>1970</y>
      <w>58</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
old_euid != uid</panel_attributes>
    <additional_attributes>10.0;10.0;560.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>957</x>
      <y>1914</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>capable</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>957</x>
      <y>1923</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cap_raised</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>962</x>
      <y>1917</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;cap_effective
相应的位有没有置上</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>968</x>
      <y>1923</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果置上</panel_attributes>
    <additional_attributes>10.0;20.0;100.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>978</x>
      <y>1923</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>current-&gt;flags |= PF_SUPERPRIV;
return 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>945</x>
      <y>1970</y>
      <w>82</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!issecure(SECURE_NO_SETUID_FIXUP)
SECUREBITS_DEFAULT中这一位没置上</panel_attributes>
    <additional_attributes>10.0;10.0;800.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1020</x>
      <y>1983</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cap_emulate_setxuid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1004</x>
      <y>1986</y>
      <w>26</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 {r,e,s}uid == 0 _to_ all of
 *  {r,e,s}uid != 0
 !current-&gt;keep_capabilities
 //r=uid e=euid s=suid
 </panel_attributes>
    <additional_attributes>240.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>983</x>
      <y>1994</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //keep_capabilities可以通过prctl
 	//变成1，这样在setuid的时候，就不会
 	//将permitted清空，当返回的时候
 	//相应的cap_effective也会恢复
cap_clear(current-&gt;cap_permitted);
cap_clear(current-&gt;cap_effective);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1024</x>
      <y>1986</y>
      <w>23</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
from_ euid == 0 _to_ euid != 0</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1012</x>
      <y>1999</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cap_clear(current-&gt;cap_effective)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1028</x>
      <y>1986</y>
      <w>20</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
from_ euid != 0 _to_ euid == 0</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1037</x>
      <y>1998</y>
      <w>31</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;cap_effective = current-&gt;cap_permitted
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1493</x>
      <y>2087</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_special_inode
i_rdev表示索引节点
代表的设备号
存在i_block[0]</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1501</x>
      <y>2083</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1483</x>
      <y>2090</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISCHR</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1472</x>
      <y>2095</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_fop = &amp;def_chr_fops;
inode-&gt;i_rdev = to_kdev_t(rdev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1501</x>
      <y>2090</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISBLK</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1495</x>
      <y>2095</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_fop = &amp;def_blk_fops;
inode-&gt;i_rdev = to_kdev_t(rdev);
inode-&gt;i_bdev = bdget(rdev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1501</x>
      <y>2090</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISFIFO</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1519</x>
      <y>2096</y>
      <w>20</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_fop = &amp;def_fifo_fops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1501</x>
      <y>2090</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISSOCK</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1540</x>
      <y>2096</y>
      <w>20</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_fop = &amp;bad_sock_fops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1411</x>
      <y>2064</y>
      <w>61</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_mode = le16_to_cpu(raw_inode-&gt;i_mode);
inode-&gt;i_uid = (uid_t)le16_to_cpu(raw_inode-&gt;i_uid_low);
inode-&gt;i_gid = (gid_t)le16_to_cpu(raw_inode-&gt;i_gid_low);
if(!(test_opt (inode-&gt;i_sb, NO_UID32))) {
	inode-&gt;i_uid |= le16_to_cpu(raw_inode-&gt;i_uid_high) &lt;&lt; 16;
	inode-&gt;i_gid |= le16_to_cpu(raw_inode-&gt;i_gid_high) &lt;&lt; 16;
}
inode-&gt;i_nlink = le16_to_cpu(raw_inode-&gt;i_links_count);
inode-&gt;i_size = le32_to_cpu(raw_inode-&gt;i_size);
inode-&gt;i_atime = le32_to_cpu(raw_inode-&gt;i_atime);
inode-&gt;i_ctime = le32_to_cpu(raw_inode-&gt;i_ctime);
inode-&gt;i_mtime = le32_to_cpu(raw_inode-&gt;i_mtime);
inode-&gt;u.ext2_i.i_dtime = le32_to_cpu(raw_inode-&gt;i_dtime);
inode-&gt;i_blksize = PAGE_SIZE;	/* This is the optimal IO size (for stat), not the fs block size */
inode-&gt;i_blocks = le32_to_cpu(raw_inode-&gt;i_blocks);
inode-&gt;i_version = ++event;
inode-&gt;u.ext2_i.i_flags = le32_to_cpu(raw_inode-&gt;i_flags);
inode-&gt;u.ext2_i.i_faddr = le32_to_cpu(raw_inode-&gt;i_faddr);
inode-&gt;u.ext2_i.i_frag_no = raw_inode-&gt;i_frag;
inode-&gt;u.ext2_i.i_frag_size = raw_inode-&gt;i_fsize;
inode-&gt;u.ext2_i.i_file_acl = le32_to_cpu(raw_inode-&gt;i_file_acl);
if (S_ISDIR(inode-&gt;i_mode))
	inode-&gt;u.ext2_i.i_dir_acl = le32_to_cpu(raw_inode-&gt;i_dir_acl);
else {
	inode-&gt;u.ext2_i.i_high_size = le32_to_cpu(raw_inode-&gt;i_size_high);
	inode-&gt;i_size |= ((__u64)le32_to_cpu(raw_inode-&gt;i_size_high)) &lt;&lt; 32;
}
inode-&gt;i_generation = le32_to_cpu(raw_inode-&gt;i_generation);
inode-&gt;u.ext2_i.i_block_group = block_group;
inode-&gt;u.ext2_i.i_data[block] = raw_inode-&gt;i_block[block]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1450</x>
      <y>2057</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1391</x>
      <y>1925</y>
      <w>52</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在proc_read_super中完成了连接
proc_root.proc_root_inode_operations</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1433</x>
      <y>1949</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_root_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1387</x>
      <y>1963</y>
      <w>27</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_nlink =proc_root.nlink +nr_threads
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1395</x>
      <y>1952</y>
      <w>51</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果父节点dir是proc的根节点
更新/proc的nlink</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1430</x>
      <y>1963</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1436</x>
      <y>1952</y>
      <w>10</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1393</x>
      <y>1974</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de = dir-&gt;u.generic_ip
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1399</x>
      <y>1966</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取inode对应的proc_dir_entry
proc_dir_entry被抽象成硬盘上的数据</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1414</x>
      <y>1973</y>
      <w>41</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果链表遍历完或者子节点的ino为0，退出遍历
2.如果子节点的名称长度和当前寻找的dentry的名字长度
	不相等，就查找下一个
3.如果长度相同，并且查找的dentry的名称和子节点的名称相同
	通过proc_get_inode获取节点的inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1429</x>
      <y>1966</y>
      <w>26</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历父目录de的子节点链表subdir</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1457</x>
      <y>1974</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>dentry-&gt;d_op = &amp;proc_dentry_operations;
 //将dentry加到inode的i_dentry的链表中
 //并将dentry加到hash中
d_add(dentry, inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1435</x>
      <y>1966</y>
      <w>39</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1499</x>
      <y>1961</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_pid_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1443</x>
      <y>1952</y>
      <w>67</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在dir中没找到</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1497</x>
      <y>1964</y>
      <w>18</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要查找self文件</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1488</x>
      <y>1973</y>
      <w>31</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>inode = new_inode(dir-&gt;i_sb)
inode-&gt;i_mtime = inode-&gt;i_atime = 
inode-&gt;i_ctime = CURRENT_TIME;
inode-&gt;i_ino = fake_ino(0, PROC_PID_INO);
inode-&gt;u.proc_i.file = NULL;
inode-&gt;u.proc_i.task = NULL;
inode-&gt;i_mode = S_IFLNK|S_IRWXUGO;
inode-&gt;i_uid = inode-&gt;i_gid = 0;
inode-&gt;i_size = 64;
inode-&gt;i_op = &amp;proc_self_inode_operations;
d_add(dentry, inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1524</x>
      <y>1974</y>
      <w>31</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.将name转化成pid号
2.通过find_task_by_pid在hash中找到task
3.通过get_task_struct增加task的计数
3.通过proc_pid_make_inode创建inode，并对其
	属性赋值（该task要有父进程）
4.通过free_task_struct释放task
5.赋值inode相应的属性
	inode-&gt;i_mode = S_IFDIR|S_IRUGO|S_IXUGO;
	inode-&gt;i_op = &amp;proc_base_inode_operations;
	inode-&gt;i_fop = &amp;proc_base_operations;
	inode-&gt;i_nlink = 3;
	inode-&gt;i_flags|=S_IMMUTABLE;

	dentry-&gt;d_op = &amp;pid_base_dentry_operations;
	d_add(dentry, inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1505</x>
      <y>1964</y>
      <w>29</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
name可能是数字，如果不是，返回-ENOENT</panel_attributes>
    <additional_attributes>40.0;10.0;240.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1528</x>
      <y>2003</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_pid_make_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1538</x>
      <y>1998</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要查找self文件</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1523</x>
      <y>2010</y>
      <w>31</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.通过new_inode申请inode
2.属性赋值（）
	inode-&gt;i_mtime = inode-&gt;i_atime = 
	inode-&gt;i_ctime = CURRENT_TIME;
	inode-&gt;i_ino = fake_ino(task-&gt;pid, ino);
	inode-&gt;u.proc_i.file = NULL;
	//创建的节点增加了task的计数
	inode-&gt;u.proc_i.task = task;
	get_task_struct(task);

	inode-&gt;i_uid = 0;
	inode-&gt;i_gid = 0;
	//dumpable表示进程访问出错会残生dump文件
	if (ino == PROC_PID_INO || task-&gt;dumpable) {
		inode-&gt;i_uid = task-&gt;euid;
		inode-&gt;i_gid = task-&gt;egid;
	}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1536</x>
      <y>2006</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1391</x>
      <y>1862</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_self_inode_operations
访问/proc/self时
在vfs_follow_link中去path_walk
找/proc/pid，然后再通过proc_pid_lookup配置相关的pid的
inode</panel_attributes>
    <additional_attributes>10.0;10.0;390.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1419</x>
      <y>1873</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_self_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1419</x>
      <y>1876</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
换算成字符类型</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1412</x>
      <y>1881</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tmp=current-&gt;pid
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1430</x>
      <y>1881</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1427</x>
      <y>1876</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1391</x>
      <y>1925</y>
      <w>217</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在proc_pid_lookup中完成了连接
proc_base_inode_operations</panel_attributes>
    <additional_attributes>10.0;10.0;2150.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1597</x>
      <y>1941</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_base_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1548</x>
      <y>1953</y>
      <w>35</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.遍历base_stuff，找到相同name长度和name的entry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1562</x>
      <y>1944</y>
      <w>43</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1588</x>
      <y>1953</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_pid_make_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1597</x>
      <y>1944</y>
      <w>19</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建访问节点的inode</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1617</x>
      <y>1952</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>PROC_PID_CWD：
inode-&gt;i_op = &amp;proc_pid_link_inode_operations;
inode-&gt;u.proc_i.op.proc_get_link = proc_cwd_link;
PROC_PID_MAPS:
inode-&gt;i_fop = &amp;proc_maps_operations;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1607</x>
      <y>1944</y>
      <w>16</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据访问节点的类型</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1391</x>
      <y>1862</y>
      <w>84</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;820.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1471</x>
      <y>1856</y>
      <w>70</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果找到最后，发现inode时link
比如找到了cwd的inode</panel_attributes>
    <additional_attributes>680.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1471</x>
      <y>1864</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1472</x>
      <y>1871</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_pid_follow_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1450</x>
      <y>1881</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.释放寻找过来的dentry和mnt  path_release(nd)
2.进程的fsuid==i_uid，或者CAP_DAC_OVERRIDE至少
	满足一个
3.proc_check_root检查inode指向task.fs的root
	要是current.fs.root的子目录
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1465</x>
      <y>1874</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1489</x>
      <y>1883</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;u.proc_i.op.proc_get_link
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1516</x>
      <y>1883</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nd-&gt;last_type = LAST_BIND
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1480</x>
      <y>1874</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1479</x>
      <y>1874</y>
      <w>48</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;460.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1492</x>
      <y>1892</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_cwd_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1499</x>
      <y>1886</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1491</x>
      <y>1900</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>fs = inode-&gt;u.proc_i.task-&gt;fs
*mnt = mntget(fs-&gt;pwdmnt);
*dentry = dget(fs-&gt;pwd);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1499</x>
      <y>1895</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将nd中的mnt和dentry更新</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1499</x>
      <y>2104</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1504</x>
      <y>2100</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1485</x>
      <y>2110</y>
      <w>35</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.首先通过bdfind在bdev_hashtable中查找
2.如果没找到，通过alloc_bdev在slab中申请数据结构
	并将其属性赋值
	new_bdev-&gt;bd_dev = dev;
	new_bdev-&gt;bd_op = NULL;
3.因为alloc_bdev有可能休眠，所以通过bdfind在找一遍
4.如果没找到，将其加入hash表中
	list_add(&amp;new_bdev-&gt;bd_hash, head);
5.如果找到了，将新申请的inode释放
	destroy_bdev(new_bdev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1503</x>
      <y>2107</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>569</x>
      <y>2295</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_from_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>538</x>
      <y>2304</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__constant_copy_to_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>562</x>
      <y>2304</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__generic_copy_to_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>553</x>
      <y>2298</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
__builtin_constant_p</panel_attributes>
    <additional_attributes>210.0;10.0;18.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>571</x>
      <y>2298</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里因为__copy_user_zeroing是一个宏
所以这里返回的是发生异常的剩余的字节数</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>557</x>
      <y>2307</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
access_ok
（检查是否所要复制的是否在用户空间）
</panel_attributes>
    <additional_attributes>160.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>556</x>
      <y>2312</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__copy_user_zeroing</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>538</x>
      <y>2318</y>
      <w>45</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>"0:	rep; movsl\n"					\//将esi中的内容复制到edi中，直到ecx=0
											//每次复制为4个字节
"	movl %3,%0\n"					\//令ecx=size&amp;3，
"1:	rep; movsb\n"					\//每次复制为1个字节
"2:\n"							\
".section .fixup,\"ax\"\n"				\//将链接到fixup 段
"3:	lea 0(%3,%0,4),%0\n"				\//ecx=size&amp;3+size(剩下的)*4
"4:	pushl %0\n"					\
"	pushl %%eax\n"					\
"	xorl %%eax,%%eax\n"				\
"	rep; stosb\n"					\将eax中的值填充到edi对应的地址
"	popl %%eax\n"					\
"	popl %0\n"					\
"	jmp 2b\n"					\
".previous\n"						\
".section __ex_table,\"a\"\n"				\//因为这一段虚拟内存可能并没有映射
					//所以可能会产生缺页中断，但是这里不能直接给进程分配页面，所以
					//在do_page_fault中，有着search_exception_table去寻找着此时应该
					//返回的ip地址，这一段是在链接的时候链接到__ex_table段，然后通过
					//遍历module_list中的module，再在每个段中通过二分法查找到对应发生
					//异常的位置，查找出要fix_up的ip
"	.align 4\n"					\
"	.long 0b,3b\n"					//在0地址发生异常，则跳到3出执行
"	.long 1b,4b\n"					\//在1处发生异常，则跳到4处
".previous"						\
: "=&amp;c"(size), "=&amp;D" (__d0), "=&amp;S" (__d1)		\
: "r"(size &amp; 3), "0"(size / 4), "1"(to), "2"(from)	\
: "memory");

ecx=size/4   edi=to   esi=from 

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>557</x>
      <y>2315</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>694</x>
      <y>2262</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>555</x>
      <y>2283</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_mount_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>564</x>
      <y>2265</y>
      <w>138</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
type</panel_attributes>
    <additional_attributes>1360.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>542</x>
      <y>2297</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_free_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>549</x>
      <y>2286</y>
      <w>14</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请一页内存</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>555</x>
      <y>2286</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1.data不能超过3G
2.copy的最大内存最大为1页
3.如果copy的不到一页，就将其他内存清零
</panel_attributes>
    <additional_attributes>60.0;10.0;210.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>577</x>
      <y>2283</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>582</x>
      <y>2265</y>
      <w>120</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dir_name</panel_attributes>
    <additional_attributes>1180.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>596</x>
      <y>2284</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_mount_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>600</x>
      <y>2265</y>
      <w>102</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dev_name
data</panel_attributes>
    <additional_attributes>1000.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>796</x>
      <y>2283</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>699</x>
      <y>2265</y>
      <w>106</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
之前将数据copy到系统空间，
这里真正做mount</panel_attributes>
    <additional_attributes>10.0;10.0;1040.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>583</x>
      <y>2299</y>
      <w>43</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果magic是MS_MGC_VAL，就将magic清掉
2.dir_name存在，不为空字符串，一个页面内存在结束字符0
	memchr
	if (!count)
	return NULL;
__asm__ __volatile__(
	"repne\n\t"
	"scasb\n\t" //edi++,ecx--,比较edi和eax（al）,不同继续，相同退出
	"je 1f\n\t" //如果相同，说明存在结束字符，跳到1将edi--
	"movl $1,%0\n" //如果不同，说明没结束字符，结合下一句将res=0
	"1:\tdecl %0"
	:"=D" (__res), "=&amp;c" (d0)
	:"a" (c), "0" (cs), "1" (count))
3.错误：dev_name存在但是一个页面内不存在结束字符
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>603</x>
      <y>2286</y>
      <w>199</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dir_name</panel_attributes>
    <additional_attributes>1970.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>626</x>
      <y>2301</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_remount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>634</x>
      <y>2286</y>
      <w>170</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flags &amp; MS_REMOUNT
如果需要将设备重新安装
（因为安装方式改变，eg:只读-&gt;可写）</panel_attributes>
    <additional_attributes>1680.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>654</x>
      <y>2302</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_loopback</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>660</x>
      <y>2286</y>
      <w>145</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flags &amp; MS_BIND
回接
将普通文件通过losetup回接成设备
可以将这个设备加密或者mkfs格式化
然后再将这个设备进行安装
这里只是安装过程</panel_attributes>
    <additional_attributes>1430.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>726</x>
      <y>2303</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>filter：
1.type_page不为空并且在一页内结束
2.进程capable(CAP_SYS_ADMIN)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>733</x>
      <y>2286</y>
      <w>74</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>720.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>753</x>
      <y>2310</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_fs_type</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>757</x>
      <y>2286</y>
      <w>50</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>713</x>
      <y>2315</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_filesystem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>719</x>
      <y>2312</y>
      <w>41</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历file_systems链表
找到名字相同的file_system_type</panel_attributes>
    <additional_attributes>390.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>684</x>
      <y>2321</y>
      <w>37</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>strcmp
"1:\tlodsb\n\t"//将esi指向的字节存到al中，并esi++
"scasb\n\t"//edi++，比较edi和al，
"jne 2f\n\t"
"testb %%al,%%al\n\t"//eax&amp;eax
"jne 1b\n\t"//不为0
"xorl %%eax,%%eax\n\t"//eax清零
"jmp 3f\n"
"2:\tsbbl %%eax,%%eax\n\t"//-cf
"orb $1,%%al\n"//eax|=1
"3:"
:"=a" (__res), "=&amp;S" (d0), "=&amp;D" (d1)
	     :"1" (cs),"2" (ct));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>705</x>
      <y>2318</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>727</x>
      <y>2324</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>try_inc_mod_count</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>733</x>
      <y>2313</y>
      <w>28</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果找到了
fs-&gt;owner</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>724</x>
      <y>2333</y>
      <w>8</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>res=1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>726</x>
      <y>2327</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是通过
register_filesystem
注册</panel_attributes>
    <additional_attributes>90.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>734</x>
      <y>2327</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是通过模块安装</panel_attributes>
    <additional_attributes>20.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>732</x>
      <y>2331</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mod-&gt;flags &amp; MOD_DELETED</panel_attributes>
    <additional_attributes>130.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>734</x>
      <y>2335</y>
      <w>8</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>res=0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>746</x>
      <y>2335</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__MOD_INC_USE_COUNT
res=1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>743</x>
      <y>2331</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>748</x>
      <y>2323</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>754</x>
      <y>2313</y>
      <w>12</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没找到</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>768</x>
      <y>2323</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_filesystem
try_inc_mod_count
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>755</x>
      <y>2313</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
然后再次查找，并且增加模块计数</panel_attributes>
    <additional_attributes>40.0;10.0;180.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>769</x>
      <y>2309</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>786</x>
      <y>2309</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>773</x>
      <y>2286</y>
      <w>34</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
LOOKUP_FOLLOW
|LOOKUP_POSITIVE
|LOOKUP_DIRECTORY</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>792</x>
      <y>2286</y>
      <w>15</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>803</x>
      <y>2286</y>
      <w>5</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;210.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>792</x>
      <y>2305</y>
      <w>30</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fstype-&gt;fs_flags &amp; FS_NOMOUNT
虚拟文件系统（pipe 共享内存）
不能通过mount安装</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>788</x>
      <y>2319</y>
      <w>6</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>EINVAL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>793</x>
      <y>2331</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_sb_bdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>705</x>
      <y>2334</y>
      <w>98</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>960.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>799</x>
      <y>2306</y>
      <w>27</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FS_REQUIRES_DEV
普通的文件系统
（不同设备有不同超级块）
通过DECLARE_FSTYPE_DEV申明
其他的通过DECLARE_FSTYPE申明</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;250.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>802</x>
      <y>2305</y>
      <w>38</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FS_SINGLE
文件系统只有一个超级块
（即使是不同设备）</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>830</x>
      <y>2324</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_sb_single</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>853</x>
      <y>2318</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_sb_nodev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>802</x>
      <y>2305</y>
      <w>58</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
虚拟文件系统
没有设备
用于实现相应的规程
生成超级块</panel_attributes>
    <additional_attributes>10.0;10.0;560.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>702</x>
      <y>2353</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>filter:
dev_name存在
且不为空字符串
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>717</x>
      <y>2353</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>730</x>
      <y>2353</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>722</x>
      <y>2334</y>
      <w>81</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到dev_name的inode</panel_attributes>
    <additional_attributes>790.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>735</x>
      <y>2334</y>
      <w>68</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>660.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>722</x>
      <y>2360</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode = nd.dentry-&gt;d_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>722</x>
      <y>2356</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>730</x>
      <y>2356</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>743</x>
      <y>2353</y>
      <w>47</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.要是块设备S_ISBLK(inode-&gt;i_mode)
2.inode的super_block要有dev
	IS_NODEV(inode)
3.bdev = inode-&gt;i_bdev;
4.如果dev的主次设备号是通过节点的路径名来表示
	1.devfs_get_handle_from_inode
		1.inode和inode的超级块不为空
		2.超级块的s_magic位DEVFS_SUPER_MAGIC
		3.inode号大于文件系统的第一个inode号
		4. inode-&gt;i_sb-&gt;u.generic_sbp不为空
		5.inode号在fs的最大inode号之内
		6.返回inode-&gt;i_sb-&gt;u.generic_sbp-&gt;table[inode-&gt;i_ino - FIRST_INODE]
	2.通过devfs_get_ops得到块设备的驱动函数
		1.第一步返回不为空
		2.de-&gt;registered为1
		3.是字符设备/块设备/常规文件 返回de-&gt;u.fcb.ops，否则返回NULL
	如果是通过一个平面结构（16位主设备号，16位次设备号）mknod表示，
	返回NULL
5.bdev-&gt;bd_op = bdops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>749</x>
      <y>2334</y>
      <w>54</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>800</x>
      <y>2334</y>
      <w>6</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>797</x>
      <y>2352</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>791</x>
      <y>2361</y>
      <w>41</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历super_blocks，如果s-&gt;s_dev不等于查找的设备dev
·就查找链表的下一个
2.如果等于dev，就wait_on_super查看lock，如果有lock，
就sleep，如果没lock，直接返回
3.醒来之后如果发现dev不同了，就重新再遍历一遍super_blocks
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>803</x>
      <y>2355</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>800</x>
      <y>2334</y>
      <w>53</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;180.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>835</x>
      <y>2351</y>
      <w>20</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果内存中存在super_block
</panel_attributes>
    <additional_attributes>160.0;10.0;30.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>833</x>
      <y>2361</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.sb的type要和安装时候格式化的fs_type相同
2.安装的flag和sb-&gt;s_flags要在MS_RDONLY位相同
满足上面两条条件，返回sb，否则返回错误
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>850</x>
      <y>2351</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不存在sb
</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>870</x>
      <y>2357</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FMODE_READ
如果不是只读安装
就把FMODE_WRITE置上
打开设备文件</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>867</x>
      <y>2365</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>795</x>
      <y>2376</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rdev = to_kdev_t(bdev-&gt;bd_dev)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>805</x>
      <y>2368</y>
      <w>70</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>680.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>821</x>
      <y>2376</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_blkfops</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>827</x>
      <y>2368</y>
      <w>48</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!bdev-&gt;bd_op
如果不是devfs设备
（devfs之前已经设置过bd_op）</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>826</x>
      <y>2379</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
主设备号</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>801</x>
      <y>2383</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!blkdevs[major].bdops
如果没在这里注册，有可能是可安装设备
</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>795</x>
      <y>2386</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>828</x>
      <y>2388</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdevs[major].bdops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>826</x>
      <y>2383</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果
blkdevs中存在</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>870</x>
      <y>2368</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里无论是devfs还是主次设备号
bd_op正常都执行驱动函数</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>849</x>
      <y>2377</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_empty_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>854</x>
      <y>2373</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>837</x>
      <y>2383</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>841</x>
      <y>2380</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>851</x>
      <y>2384</y>
      <w>34</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>inodes_stat.nr_inodes++;
list_add(&amp;inode-&gt;i_list, &amp;inode_in_use);
inode-&gt;i_sb = NULL;
inode-&gt;i_dev = 0;
 //atten:last_ino是static
inode-&gt;i_ino = ++last_ino;
inode-&gt;i_flags = 0;
atomic_set(&amp;inode-&gt;i_count, 1);
inode-&gt;i_state = 0;
clean_inode(inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>855</x>
      <y>2380</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>870</x>
      <y>2373</y>
      <w>23</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>886</x>
      <y>2384</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //file--dentry---inode
fake_file.f_mode = mode;
fake_file.f_flags = flags;
fake_file.f_dentry = &amp;fake_dentry;
fake_dentry.d_inode = fake_inode;
fake_inode-&gt;i_rdev = rdev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>914</x>
      <y>2385</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdev-&gt;bd_op-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>870</x>
      <y>2373</y>
      <w>53</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>870</x>
      <y>2373</y>
      <w>69</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>927</x>
      <y>2382</y>
      <w>12</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
正确返回</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>919</x>
      <y>2390</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;bdev-&gt;bd_openers)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>936</x>
      <y>2382</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
错误返回
并且bd_openers没有</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>942</x>
      <y>2390</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdev-&gt;bd_op = NULL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>960</x>
      <y>2390</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iput(fake_inode)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>936</x>
      <y>2382</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放申请的inode</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>896</x>
      <y>2363</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>check_disk_change</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>874</x>
      <y>2357</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查介质是否变动</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>916</x>
      <y>2362</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>!(flags &amp; MS_RDONLY) 
&amp;&amp; 
is_read_only(dev)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>874</x>
      <y>2357</y>
      <w>53</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不是只读安装
但是设备却设置成只读</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>914</x>
      <y>2371</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>blkdev_put(bdev, BDEV_FS)
path_release(&amp;nd)
return ERR_PTR(error) 
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>923</x>
      <y>2367</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>958</x>
      <y>2360</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>874</x>
      <y>2357</y>
      <w>91</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;890.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>936</x>
      <y>2367</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_empty_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>941</x>
      <y>2363</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>936</x>
      <y>2374</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.遍历链表super_blocks
2.如果存在s_dev为0，且
	s_lock没有锁住，则在链表
	中找到了空闲的sb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>942</x>
      <y>2370</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>942</x>
      <y>2370</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在super_blocks
中没找到空闲的sb</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>959</x>
      <y>2381</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>962</x>
      <y>2373</y>
      <w>8</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>976</x>
      <y>2387</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>nr_super_blocks++;
memset(s, 0, sizeof(struct super_block));
INIT_LIST_HEAD(&amp;s-&gt;s_dirty);
list_add (&amp;s-&gt;s_list, super_blocks.prev);
init_waitqueue_head(&amp;s-&gt;s_wait);
INIT_LIST_HEAD(&amp;s-&gt;s_files);
INIT_LIST_HEAD(&amp;s-&gt;s_mounts);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>967</x>
      <y>2373</y>
      <w>18</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请到了内存
就初始化sb</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>979</x>
      <y>2368</y>
      <w>28</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>s-&gt;s_dev = dev;//设备号
s-&gt;s_bdev = bdev;//具体的设备
s-&gt;s_flags = flags;
s-&gt;s_dirt = 0;
sema_init(&amp;s-&gt;s_vfs_rename_sem,1);
sema_init(&amp;s-&gt;s_nfsd_free_path_sem,1);
s-&gt;s_type = type;
sema_init(&amp;s-&gt;s_dquot.dqio_sem, 1);
sema_init(&amp;s-&gt;s_dquot.dqoff_sem, 1);
s-&gt;s_dquot.flags = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>963</x>
      <y>2363</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1010</x>
      <y>2372</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>type-&gt;read_super(s, data, silent)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>963</x>
      <y>2363</y>
      <w>66</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
type是从file_systems中
找到的file_system_type</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;30.0;640.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1037</x>
      <y>2373</y>
      <w>21</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>atomic_inc(&amp;bdev-&gt;bd_count)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>963</x>
      <y>2361</y>
      <w>87</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是块设备，则增加计数</panel_attributes>
    <additional_attributes>10.0;30.0;510.0;20.0;850.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1028</x>
      <y>2360</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>get_filesystem(fs_type);
path_release(&amp;nd);
return sb;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>874</x>
      <y>2357</y>
      <w>160</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到了sb</panel_attributes>
    <additional_attributes>10.0;10.0;1580.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>805</x>
      <y>2286</y>
      <w>39</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在read_super的过程中发现安装点已经被
其他的设备安装了，那么将会在已经安装的dentry上
继续安装现在的设备（管理上应该避免）</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>836</x>
      <y>2299</y>
      <w>49</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.通过d_mountpoint检测nd.dentry是否安装了其他设备
 	（检测d_vfsmnt是否为空）
2.通过follow_down查找d_vfsmnt链表，如果检查安装点
	的mnt_parent，如果与将要安装的相同，则安装点mnt和dentry
	都变成下一层的mnt和dentry，将原来的dentry和mnt释放，并返回1
3.如果mnt_parent不相同，就遍历链表的下一个，重复2步骤，如果最后没有
	返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>844</x>
      <y>2260</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfsmount
valign=center
bg=red</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>856</x>
      <y>2260</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_mountpoint
安装的节点</panel_attributes>
    <additional_attributes>10.0;30.0;190.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>875</x>
      <y>2260</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>828</x>
      <y>2263</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_root
要安装设备的根目录</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>816</x>
      <y>2258</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>super_block
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>877</x>
      <y>2263</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
d_vfsmount
安装在这个目录下的所有vfsmount
（同一个设备可以有不同的安装点，
所以到这个dentry的路径可能不同
所以这里是可以有不同的安装点指向不同的设备
因为mnt_parent不同）</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>849</x>
      <y>2263</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过mnt_clash链入</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>816</x>
      <y>2266</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>828</x>
      <y>2258</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_sb
要安装设备的超级块</panel_attributes>
    <additional_attributes>160.0;30.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>817</x>
      <y>2251</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
s_mounts
这个设备所有要安装的安装点</panel_attributes>
    <additional_attributes>60.0;70.0;130.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>828</x>
      <y>2251</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过
mnt_instances
链入</panel_attributes>
    <additional_attributes>210.0;90.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>852</x>
      <y>2248</y>
      <w>25</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_parent
安装的节点的安装点</panel_attributes>
    <additional_attributes>10.0;120.0;230.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>875</x>
      <y>2247</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfsmount
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>880</x>
      <y>2250</y>
      <w>8</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_root</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>852</x>
      <y>2245</y>
      <w>31</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_mounts
链接所有安装在这个设备上的安装点</panel_attributes>
    <additional_attributes>290.0;20.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>841</x>
      <y>2246</y>
      <w>19</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过mnt_child链入</panel_attributes>
    <additional_attributes>100.0;140.0;10.0;10.0;120.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>882</x>
      <y>2233</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfsmntlist
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>885</x>
      <y>2236</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
系统中所有安装点的链表</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>887</x>
      <y>2247</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=&lt;.&gt;
通过mnt_list链入</panel_attributes>
    <additional_attributes>10.0;20.0;160.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>856</x>
      <y>2250</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=&lt;.&gt;
通过mnt_list链入</panel_attributes>
    <additional_attributes>10.0;100.0;200.0;70.0;230.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>903</x>
      <y>2247</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfsmount
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>885</x>
      <y>2240</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=&lt;.&gt;
通过mnt_list链入</panel_attributes>
    <additional_attributes>250.0;70.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>883</x>
      <y>2250</y>
      <w>28</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt_root</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>804</x>
      <y>2286</y>
      <w>105</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1030.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>888</x>
      <y>2300</y>
      <w>49</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>filter:
1.nd.mnt &amp;&amp; nd.mnt-&gt;mnt_sb == sb
   &amp;&amp; nd.mnt-&gt;mnt_root == nd.dentry
   同一设备不能安装到同一个安装点
2.nd.dentry-&gt;d_inode
 	安装目录的inode要存在

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>804</x>
      <y>2286</y>
      <w>175</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
nd.dentry-&gt;d_inode.i_flags中S_DEAD没置上</panel_attributes>
    <additional_attributes>10.0;10.0;1730.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>969</x>
      <y>2298</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_vfsmnt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>923</x>
      <y>2301</y>
      <w>53</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请mnt,并将内存清0</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>919</x>
      <y>2315</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc
memset
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>937</x>
      <y>2315</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mnt-&gt;mnt_flags = MNT_VISIBLE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>947</x>
      <y>2301</y>
      <w>29</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
nd || dev_name</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>971</x>
      <y>2301</y>
      <w>10</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dev_name</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>963</x>
      <y>2315</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>kmalloc
strcpy(name, dev_name);
mnt-&gt;mnt_devname = name;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>986</x>
      <y>2315</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>mnt-&gt;mnt_owner = current-&gt;uid;
atomic_set(&amp;mnt-&gt;mnt_count,1);
mnt-&gt;mnt_sb = sb;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>973</x>
      <y>2301</y>
      <w>26</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>974</x>
      <y>2301</y>
      <w>44</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1012</x>
      <y>2314</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>nd &amp;&amp; 
 //dentry不是root
!IS_ROOT(nd-&gt;dentry) 
 //dentry没装入hash
&amp;&amp; d_unhashed(nd-&gt;dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1034</x>
      <y>2316</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>mnt-&gt;mnt_root = dget(root);
 //nd为空表示mount_root kern_mount
mnt-&gt;mnt_mountpoint = nd ? dget(nd-&gt;dentry) : dget(root);
mnt-&gt;mnt_parent = nd ? mntget(nd-&gt;mnt) : mnt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>974</x>
      <y>2301</y>
      <w>72</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;700.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1073</x>
      <y>2314</y>
      <w>33</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>if (nd) {
list_add(&amp;mnt-&gt;mnt_child, &amp;nd-&gt;mnt-&gt;mnt_mounts);
	list_add(&amp;mnt-&gt;mnt_clash, &amp;nd-&gt;dentry-&gt;d_vfsmnt);
} else {
	INIT_LIST_HEAD(&amp;mnt-&gt;mnt_child);
	INIT_LIST_HEAD(&amp;mnt-&gt;mnt_clash);
}
INIT_LIST_HEAD(&amp;mnt-&gt;mnt_mounts);
list_add(&amp;mnt-&gt;mnt_instances, &amp;sb-&gt;s_mounts);
list_add(&amp;mnt-&gt;mnt_list, vfsmntlist.prev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>975</x>
      <y>2301</y>
      <w>109</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1070.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>628</x>
      <y>2311</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>!old_name || !*old_name
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>635</x>
      <y>2305</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设备dev_name不为空</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>647</x>
      <y>2311</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init
path_walk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>650</x>
      <y>2305</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
寻找设备的dentry</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>659</x>
      <y>2311</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init
path_walk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>660</x>
      <y>2305</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
寻找安装目录的dentry</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>660</x>
      <y>2305</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>671</x>
      <y>2308</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.检查进程和安装目录的权限
	mount_is_safe
2.S_ISDIR(new_nd.dentry-&gt;d_inode-&gt;i_mode) !=
	      S_ISDIR(old_nd.dentry-&gt;d_inode-&gt;i_mode)
3.如果安装设备的file_system的fs_flags中FS_SINGLE
  增加file_system的计数
4.new_nd.dentry-&gt;d_inode的i_flags中S_DEAD没置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>707</x>
      <y>2308</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_vfsmnt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>662</x>
      <y>2305</y>
      <w>53</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里传参，相当于将sb再次安装到其他的安装点
理解：这里只是将格式化好的sb和root传给要安装的目录</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1085</x>
      <y>2385</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_read_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1022</x>
      <y>2375</y>
      <w>71</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_fs_type
因为只有在有sb的时候
才能有ext2_sops，所以
现在只能通过文件系统的方法
将sb读进来</panel_attributes>
    <additional_attributes>10.0;10.0;690.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1004</x>
      <y>2397</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_hardblocksize</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1009</x>
      <y>2388</y>
      <w>84</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从hardsect_size中获取
最小为BLOCK_SIZE</panel_attributes>
    <additional_attributes>820.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1019</x>
      <y>2398</y>
      <w>22</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>sb-&gt;u.ext2_sb.s_mount_opt = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1029</x>
      <y>2388</y>
      <w>64</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1042</x>
      <y>2397</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>parse_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1047</x>
      <y>2388</y>
      <w>46</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1056</x>
      <y>2397</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_blocksize</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1061</x>
      <y>2388</y>
      <w>32</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1073</x>
      <y>2388</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果blocksize大于BLOCK_SIZE</panel_attributes>
    <additional_attributes>180.0;10.0;30.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1071</x>
      <y>2397</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //超级块物理上在sb_block*BLOCK_SIZE的位置
logic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;
offset = (sb_block*BLOCK_SIZE) % blocksize;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1111</x>
      <y>2398</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1090</x>
      <y>2388</y>
      <w>30</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1090</x>
      <y>2388</y>
      <w>44</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1126</x>
      <y>2397</y>
      <w>40</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>es=(char *)bh-&gt;b_data + offset
sb-&gt;u.ext2_sb.s_es = es
sb-&gt;s_magic = le16_to_cpu(es-&gt;s_magic)
  //check
1.check magic EXT2_SUPER_MAGIC
2.le32_to_cpu(es-&gt;s_rev_level) == EXT2_GOOD_OLD_REV
 &amp;&amp;(COMPAT  ||  RO_COMPAT  || INCOMPAT)
3.INCOMPAT没有INCOMPAT_SUPP位
4.sb-&gt;s_flags不是MS_RDONLY
	但是RO_COMPAT没置

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1169</x>
      <y>2398</y>
      <w>40</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_blocksize_bits =
	le32_to_cpu(EXT2_SB(sb)-&gt;s_es-&gt;s_log_block_size) + 10;
sb-&gt;s_blocksize = 1 &lt;&lt; sb-&gt;s_blocksize_bits
 //在不等于BLOCK_SIZE，但是是1k，2k，4k的时候
1.s_blocksize要大于get_hardblocksize
2.将s_blocksize保存在logic_sb_block
3.通过bread在读一整个大小为s_blocksize的记录块
注：ext2在sb_block*BLOCK_SIZE总是是超级块
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1216</x>
      <y>2399</y>
      <w>63</w>
      <h>95</h>
    </coordinates>
    <panel_attributes>sb-&gt;u.ext2_sb.s_inode_size
sb-&gt;u.ext2_sb.s_first_ino
sb-&gt;u.ext2_sb.s_frag_size=EXT2_MIN_FRAG_SIZE &lt;&lt;
				   le32_to_cpu(es-&gt;s_log_frag_size)
sb-&gt;u.ext2_sb.s_frags_per_block
sb-&gt;s_magic
 //这个block的数量包含inode/描述结构/管理结构/超级块的block
sb-&gt;u.ext2_sb.s_blocks_per_group = le32_to_cpu(es-&gt;s_blocks_per_group);
sb-&gt;u.ext2_sb.s_frags_per_group = le32_to_cpu(es-&gt;s_frags_per_group);
sb-&gt;u.ext2_sb.s_inodes_per_group = le32_to_cpu(es-&gt;s_inodes_per_group);
sb-&gt;u.ext2_sb.s_inodes_per_block = sb-&gt;s_blocksize /
				   EXT2_INODE_SIZE(sb);
sb-&gt;u.ext2_sb.s_itb_per_group = sb-&gt;u.ext2_sb.s_inodes_per_group /
			        sb-&gt;u.ext2_sb.s_inodes_per_block;
sb-&gt;u.ext2_sb.s_desc_per_block = sb-&gt;s_blocksize /
				 sizeof (struct ext2_group_desc);
sb-&gt;u.ext2_sb.s_sbh = bh;
sb-&gt;u.ext2_sb.s_resuid
sb-&gt;u.ext2_sb.s_resgid
sb-&gt;u.ext2_sb.s_mount_state = le16_to_cpu(es-&gt;s_state);
 //log2是第一个1所在位的索引 bsfl op1 op2， 计算op1中第一个1，索引放在op2中
sb-&gt;u.ext2_sb.s_addr_per_block_bits =
	log2 (EXT2_ADDR_PER_BLOCK(sb));
sb-&gt;u.ext2_sb.s_desc_per_block_bits =
	log2 (EXT2_DESC_PER_BLOCK(sb));
	//check
1.sb-&gt;s_magic = EXT2_SUPER_MAGIC
2.sb-&gt;s_blocksize = bh-&gt;b_size
3.sb-&gt;s_blocksize = sb-&gt;u.ext2_sb.s_frag_size
4.不能有超过一个记录块记录block的数量
 sb-&gt;u.ext2_sb.s_blocks_per_group &gt; sb-&gt;s_blocksize * 8
5.sb-&gt;u.ext2_sb.s_frags_per_group &gt; sb-&gt;s_blocksize * 8
6.不能超过一个记录块记录inoe
	sb-&gt;u.ext2_sb.s_inodes_per_group &gt; sb-&gt;s_blocksize * 8

 //一个desc描述一个组，前面检查过blocksize和bh的b_size相同
sb-&gt;u.ext2_sb.s_groups_count = (le32_to_cpu(es-&gt;s_blocks_count) -
			        le32_to_cpu(es-&gt;s_first_data_block) +
			       EXT2_BLOCKS_PER_GROUP(sb) - 1) /
			       EXT2_BLOCKS_PER_GROUP(sb);
db_count = (sb-&gt;u.ext2_sb.s_groups_count + EXT2_DESC_PER_BLOCK(sb) - 1) /
	   EXT2_DESC_PER_BLOCK(sb);
sb-&gt;u.ext2_sb.s_group_desc = kmalloc (db_count * sizeof (struct buffer_head *), GFP_KERNEL);
 //填充group信息
sb-&gt;u.ext2_sb.s_group_desc[i] = bread (dev, logic_sb_block + i + 1,
					       sb-&gt;s_blocksize);
 //检查每个group的bg_block_bitmap  bg_block_bitmap   	bg_inode_table是否在合适的块
ext2_check_descriptors
 //先初始化8个bitmap和块号
sb-&gt;u.ext2_sb.s_inode_bitmap_number[i] = 0;
sb-&gt;u.ext2_sb.s_inode_bitmap[i] = NULL;
sb-&gt;u.ext2_sb.s_block_bitmap_number[i] = 0;
sb-&gt;u.ext2_sb.s_block_bitmap[i] = NULL;

sb-&gt;u.ext2_sb.s_loaded_inode_bitmaps = 0;
sb-&gt;u.ext2_sb.s_loaded_block_bitmaps = 0;
 //所有desc占的所有block总数
sb-&gt;u.ext2_sb.s_gdb_count = db_count;
sb-&gt;s_op = &amp;ext2_sops;
sb-&gt;s_root = d_alloc_root(iget(sb, EXT2_ROOT_INO));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1091</x>
      <y>2388</y>
      <w>95</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;930.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1092</x>
      <y>2388</y>
      <w>137</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1350.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1295</x>
      <y>2400</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_alloc_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1091</x>
      <y>2388</y>
      <w>213</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sb-&gt;s_root
为根目录inode建立dentry
iget(sb, EXT2_ROOT_INO)</panel_attributes>
    <additional_attributes>10.0;10.0;2110.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1280</x>
      <y>2408</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1284</x>
      <y>2403</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请并初始化dentry
{ "/", 1, 0 }</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1296</x>
      <y>2407</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>res-&gt;d_sb = root_inode-&gt;i_sb;
res-&gt;d_parent = res;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1300</x>
      <y>2403</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1322</x>
      <y>2407</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_instantiate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1300</x>
      <y>2403</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1310</x>
      <y>2414</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //dentry连接到inode中
list_add(&amp;entry-&gt;d_alias, &amp;inode-&gt;i_dentry)
entry-&gt;d_inode = inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1324</x>
      <y>2410</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1344</x>
      <y>2400</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_setup_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1340</x>
      <y>2409</y>
      <w>52</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>es-&gt;s_state = cpu_to_le16(le16_to_cpu(es-&gt;s_state) &amp; ~EXT2_VALID_FS);
if (!(__s16) le16_to_cpu(es-&gt;s_max_mnt_count))
	es-&gt;s_max_mnt_count = (__s16) cpu_to_le16(EXT2_DFL_MAX_MNT_COUNT);
es-&gt;s_mnt_count=cpu_to_le16(le16_to_cpu(es-&gt;s_mnt_count) + 1);
es-&gt;s_mtime = cpu_to_le32(CURRENT_TIME);
mark_buffer_dirty(sb-&gt;u.ext2_sb.s_sbh);
sb-&gt;s_dirt = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1349</x>
      <y>2403</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置管理信息</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1091</x>
      <y>2388</y>
      <w>261</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2590.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>811</x>
      <y>2332</y>
      <w>22</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>sb = fs_type-&gt;kern_mnt-&gt;mnt_sb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>821</x>
      <y>2327</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取init_proc_fs设置的sb</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>835</x>
      <y>2331</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_filesystem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>833</x>
      <y>2327</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加file_system计数</panel_attributes>
    <additional_attributes>50.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>853</x>
      <y>2331</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_remount_sb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>837</x>
      <y>2327</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>823</x>
      <y>2339</y>
      <w>43</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果要以MS_RDONLY安装，sb-&gt;s_dev要是read_only
	(procfs是NULL,这个检测不存在)
2.如果以MS_RDONLY安装，但是sb却不是read_only的，此时需要
	检测sb中的所有文件，查看inode是否只读，如果不是，返回-EBUSY

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>843</x>
      <y>2334</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>868</x>
      <y>2341</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;remount_fs
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>858</x>
      <y>2334</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sb-&gt;s_op-&gt;remount_fs存在</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>888</x>
      <y>2340</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_flags = 
(sb-&gt;s_flags &amp; ~MS_RMT_MASK) | 
(flags &amp; MS_RMT_MASK)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>859</x>
      <y>2334</y>
      <w>40</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果flag中MS_RMT_MASK置上，
就将sb-&gt;s_flags置上
否则将其清掉</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1435</x>
      <y>2295</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_umount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1362</x>
      <y>2316</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1367</x>
      <y>2298</y>
      <w>76</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>740.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1379</x>
      <y>2317</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1383</x>
      <y>2298</y>
      <w>60</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
LOOKUP_POSITIVE|LOOKUP_FOLLOW</panel_attributes>
    <additional_attributes>580.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1398</x>
      <y>2317</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1402</x>
      <y>2298</y>
      <w>41</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1415</x>
      <y>2317</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>putname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1419</x>
      <y>2298</y>
      <w>24</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
已经得到了nd
将name释放</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1429</x>
      <y>2315</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>filter
1.要释放的目录必须是设备的根目录
	nd.dentry != nd.mnt-&gt;mnt_root时报错
2.检查进程卸载的权限
 !capable(CAP_SYS_ADMIN)
 &amp;&amp; current-&gt;uid!=nd.mnt-&gt;mnt_owner
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1440</x>
      <y>2298</y>
      <w>6</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1459</x>
      <y>2316</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput(nd.dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1438</x>
      <y>2298</y>
      <w>29</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放文件的根目录
atomic_dec_and_lock只有counter为0的时候
返回true</panel_attributes>
    <additional_attributes>30.0;10.0;250.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1474</x>
      <y>2315</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_umount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1440</x>
      <y>2298</y>
      <w>42</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放nd.mnt</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;170.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1442</x>
      <y>2318</y>
      <w>40</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mnt == current-&gt;fs-&gt;rootmnt &amp;&amp; 
!umount_root
如果用户进程要删除进程的跟设备，那就把跟设备设置为只读</panel_attributes>
    <additional_attributes>380.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1431</x>
      <y>2329</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1427</x>
      <y>2334</y>
      <w>11</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mntput(mnt)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1441</x>
      <y>2334</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_remount_sb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1442</x>
      <y>2329</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果sb-&gt;s_flags &amp; MS_RDONLY没置上
那么将sb进行只读安装</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1479</x>
      <y>2318</y>
      <w>37</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果sb上安装在多个vfsmnt
mnt-&gt;mnt_instances.next != mnt-&gt;mnt_instances.prev</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1454</x>
      <y>2332</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
atomic_read(&amp;mnt-&gt;mnt_count) &gt; 2
nd中一次，vfsmnt自身一次
这里大于2次，说明有其他地方引用这个vfsmnt</panel_attributes>
    <additional_attributes>280.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1452</x>
      <y>2338</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //释放nd中的一次
mntput(mnt)
return -EBUSY
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1475</x>
      <y>2332</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sb-&gt;s_type-&gt;fs_flags &amp; FS_SINGLE
文件系统只有一个超级块</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1468</x>
      <y>2340</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes> //释放文件系统的引用
put_filesystem(sb-&gt;s_type)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1481</x>
      <y>2332</y>
      <w>17</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放其中一个（nd的）</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1490</x>
      <y>2340</y>
      <w>11</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mntput(mnt)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1503</x>
      <y>2339</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_vfsmnt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1481</x>
      <y>2332</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1498</x>
      <y>2346</y>
      <w>23</w>
      <h>25</h>
    </coordinates>
    <panel_attributes> //mnt脱离sb链表
list_del(&amp;mnt-&gt;mnt_instances);
 //脱离dentry链表
list_del(&amp;mnt-&gt;mnt_clash);
	//脱离mnt总的链表
list_del(&amp;mnt-&gt;mnt_list);
 //解除和parent的关系
list_del(&amp;mnt-&gt;mnt_child);
if (mnt-&gt;mnt_parent != mnt)
	mntput(mnt-&gt;mnt_parent);
dput(mnt-&gt;mnt_mountpoint);
dput(mnt-&gt;mnt_root);
if (mnt-&gt;mnt_devname)
	kfree(mnt-&gt;mnt_devname);
kfree(mnt);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1507</x>
      <y>2342</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1479</x>
      <y>2318</y>
      <w>70</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果sb上只安装在一个vfsmnt</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1523</x>
      <y>2330</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
磁盘空间分配</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1517</x>
      <y>2338</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>DQUOT_OFF(sb);
acct_auto_close(sb-&gt;s_dev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1538</x>
      <y>2339</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;umount_begin(sb)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1546</x>
      <y>2330</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
(flags&amp;MNT_FORCE) &amp;&amp; sb-&gt;s_op-&gt;umount_begin
有些设备要求拆卸之前先执行这个函数</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1566</x>
      <y>2339</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shrink_dcache_sb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1546</x>
      <y>2330</y>
      <w>29</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1555</x>
      <y>2342</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1532</x>
      <y>2346</y>
      <w>47</w>
      <h>55</h>
    </coordinates>
    <panel_attributes>1.遍历dentry_unused，如果dentry.d_sb和要卸载的sb相同
	就先通过list_del删除其当前的链接关系，再通过list_add
	将这个dentry头插到dentry_unused（注意这里因为时头插
	所以不会无限循环）
	如果sb不相同，就遍历下一个
2.再次遍历dentry_unused，将d_sb相同，d_count为0的删掉
	dentry_stat.nr_unused--;
	list_del(tmp);
	INIT_LIST_HEAD(tmp);
	prune_one_dentry：真正释放

	
		list_del_init(&amp;dentry-&gt;d_hash);
		list_del(&amp;dentry-&gt;d_child);
		dentry_iput(dentry);//释放inode
		parent = dentry-&gt;d_parent;

		
		d_free(dentry)：
			if (dentry-&gt;d_op &amp;&amp; dentry-&gt;d_op-&gt;d_release)
				dentry-&gt;d_op-&gt;d_release(dentry);
			if (dname_external(dentry)) 
				kfree(dentry-&gt;d_name.name);
			kmem_cache_free(dentry_cache, dentry); 
			dentry_stat.nr_dentry--;

			
		if (parent != dentry)
			dput(parent);
疑问：这里虽然将要删除的dentry都移到了最前面，在second pass
的时候只需要遍历一次(我感觉不repreat也是可以的？)，但是first_pass
和second_pass也是要遍历2次，为什么不在first_pass的时候将dentry删了？
这里又是spinlock，不会被打断。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1611</x>
      <y>2339</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fsync_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1479</x>
      <y>2318</y>
      <w>141</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1390.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1590</x>
      <y>2347</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1595</x>
      <y>2342</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dev,0</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1610</x>
      <y>2348</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_supers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1614</x>
      <y>2342</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1632</x>
      <y>2349</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_inodes</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1657</x>
      <y>2349</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DQUOT_SYNC</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1678</x>
      <y>2349</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1615</x>
      <y>2342</y>
      <w>69</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dev,1</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1615</x>
      <y>2342</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1615</x>
      <y>2342</y>
      <w>49</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1592</x>
      <y>2356</y>
      <w>41</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.遍历super_blocks
2，筛选出sb-&gt;s_dev不为0，dev存在 &amp;&amp; sb-&gt;s_dev == dev，
	sb-&gt;s_dirt（sb是脏的）的sb
3.筛选出之后lock_super,因为在lock的时候可能睡着，所以再次
  检测上面的条件，如果提供了write_super的函数通过
  sb-&gt;s_op-&gt;write_super(sb)，然后unlock_super.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1608</x>
      <y>2351</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1634</x>
      <y>2356</y>
      <w>41</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历super_blocks
2，筛选出sb-&gt;s_dev不为0，dev存在 &amp;&amp; sb-&gt;s_dev == dev，
	的sb
3.通过sync_list去同步sb中s_dirty管理的inode
	sync_list通过sync_one去处理s_dirty中的每一个inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1633</x>
      <y>2352</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里只是设标志，并没向磁盘写
因为sync_one中syn的传参是0</panel_attributes>
    <additional_attributes>40.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1651</x>
      <y>2369</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sync_one</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1655</x>
      <y>2365</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1639</x>
      <y>2372</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
i_state &amp; I_LOCK
如果inode正在向磁盘写</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1595</x>
      <y>2376</y>
      <w>47</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1590</x>
      <y>2382</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__iget
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1609</x>
      <y>2382</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__wait_on_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1616</x>
      <y>2376</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
等待向磁盘写完</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1580</x>
      <y>2390</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DECLARE_WAITQUEUE(wait, current)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1592</x>
      <y>2385</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申明wait
将其中的唤醒进程设置为current</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1610</x>
      <y>2390</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_wait_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1615</x>
      <y>2385</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将wait加在inode-&gt;i_wait</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1584</x>
      <y>2398</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait-&gt;flags = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1589</x>
      <y>2393</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1605</x>
      <y>2398</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__add_wait_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1609</x>
      <y>2393</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将task_list链表连接</panel_attributes>
    <additional_attributes>80.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1627</x>
      <y>2390</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>repeat：
TASK_UNINTERRUPTIBLE
if (inode-&gt;i_state &amp; I_LOCK) {
	schedule();
	goto repeat;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1616</x>
      <y>2385</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查锁</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1651</x>
      <y>2391</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_wait_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1616</x>
      <y>2385</y>
      <w>44</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1651</x>
      <y>2397</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__remove_wait_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1658</x>
      <y>2394</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将task_list解开</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1667</x>
      <y>2391</y>
      <w>14</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>TASK_RUNNING
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1616</x>
      <y>2385</y>
      <w>61</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为repeat的时候将task的状态设置成
TASK_UNINTERRUPTIBLE</panel_attributes>
    <additional_attributes>10.0;10.0;590.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1698</x>
      <y>2386</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iput
猜想：
1.如果count有计数，则放在inode_in_use中
2.如果count=0，则放在inode_unused中
3.以上两种情况都是!dirty，如果dirty
	则不管count，直接放在s_dirty中
3.i_nlink表示物理上有多少个链接，在文件
	刚创建的时候，i_nlink为1，其后创建链接
	会增加计数，如果这个链接为0，表示要在物理硬盘上
	将这个inode删除，通过clear_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1639</x>
      <y>2376</y>
      <w>66</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;640.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1676</x>
      <y>2389</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode-&gt;i_sb-&gt;s_op
如果sb规定了put_inode
先通过sb的函数处理</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1671</x>
      <y>2396</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>op-&gt;put_inode(inode)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1693</x>
      <y>2396</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>atomic_dec_and_lock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1701</x>
      <y>2389</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将wait加在inode-&gt;i_wait</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1703</x>
      <y>2389</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1710</x>
      <y>2395</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!i_nlink
猜想：没有符号链接的时候</panel_attributes>
    <additional_attributes>120.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1682</x>
      <y>2401</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1671</x>
      <y>2405</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>list_del(&amp;inode-&gt;i_hash);
INIT_LIST_HEAD(&amp;inode-&gt;i_hash);
list_del(&amp;inode-&gt;i_list);
INIT_LIST_HEAD(&amp;inode-&gt;i_list);
inode-&gt;i_state|=I_FREEING;
inodes_stat.nr_inodes--;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1703</x>
      <y>2401</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode-&gt;i_data.nrpages</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1696</x>
      <y>2406</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>truncate_inode_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1715</x>
      <y>2401</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1708</x>
      <y>2406</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果sb提供了
op-&gt;delete_inode</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1700</x>
      <y>2411</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>op-&gt;delete_inode(inode)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1720</x>
      <y>2406</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;58.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1721</x>
      <y>2411</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>clear_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1721</x>
      <y>2395</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
i_nlink不为0
有符号链接？</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1730</x>
      <y>2400</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果inode连在hash中</panel_attributes>
    <additional_attributes>100.0;10.0;48.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1730</x>
      <y>2409</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>list_del(&amp;inode-&gt;i_list);
list_add(&amp;inode-&gt;i_list,
	 &amp;inode_unused);
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1734</x>
      <y>2404</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果inode没脏
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1750</x>
      <y>2410</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inodes_stat.nr_unused++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1734</x>
      <y>2404</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;218.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1739</x>
      <y>2400</y>
      <w>42</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没连在hash中
将inode清掉</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1770</x>
      <y>2407</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>list_del(&amp;inode-&gt;i_list);
INIT_LIST_HEAD(&amp;inode-&gt;i_list);
inode-&gt;i_state|=I_FREEING;
inodes_stat.nr_inodes--;
clear_inode(inode)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1655</x>
      <y>2372</y>
      <w>108</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果inode没有在向磁盘写</panel_attributes>
    <additional_attributes>10.0;10.0;1060.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1742</x>
      <y>2375</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1724</x>
      <y>2378</y>
      <w>37</w>
      <h>18</h>
    </coordinates>
    <panel_attributes> //从s_dirty中删除，加到其他两个链表中
list_del(&amp;inode-&gt;i_list);
list_add(&amp;inode-&gt;i_list, atomic_read(&amp;inode-&gt;i_count)
					? &amp;inode_in_use
					: &amp;inode_unused);
 //将dirty标志提取
dirty = inode-&gt;i_state &amp; I_DIRTY;
 //将inode上锁，表示要想磁盘写
inode-&gt;i_state |= I_LOCK;
 //将dirty清掉
inode-&gt;i_state &amp;= ~I_DIRTY;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1765</x>
      <y>2381</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filemap_fdatasync</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1760</x>
      <y>2375</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1784</x>
      <y>2381</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>write_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1760</x>
      <y>2375</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1801</x>
      <y>2381</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filemap_fdatawait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1817</x>
      <y>2381</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_state &amp;= ~I_LOCK;
wake_up(&amp;inode-&gt;i_wait)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1760</x>
      <y>2375</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1760</x>
      <y>2375</y>
      <w>65</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;630.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1796</x>
      <y>2389</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_write_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1789</x>
      <y>2384</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1809</x>
      <y>2399</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_update_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1803</x>
      <y>2392</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1793</x>
      <y>2409</y>
      <w>46</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.检查i_ino
2.三段；group_desc  desc  offset
	每个inode都分组成为一个desc，而desc作为一个数据结构存在磁盘中
	首先通过group_desc找到存储当前inode 的desc的bh，再通过desc找到
	相应的desc结构，最后通过desc中的基础block bg_inode_table和offset
	找到inode对应的block
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1808</x>
      <y>2402</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1848</x>
      <y>2410</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1816</x>
      <y>2402</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1863</x>
      <y>2414</y>
      <w>42</w>
      <h>48</h>
    </coordinates>
    <panel_attributes>raw_inode-&gt;i_mode = cpu_to_le16(inode-&gt;i_mode);
raw_inode-&gt;i_uid_low 
raw_inode-&gt;i_gid_low
raw_inode-&gt;i_uid_high 
raw_inode-&gt;i_gid_high
raw_inode-&gt;i_links_count = cpu_to_le16(inode-&gt;i_nlink);
raw_inode-&gt;i_size = cpu_to_le32(inode-&gt;i_size);
raw_inode-&gt;i_atime = cpu_to_le32(inode-&gt;i_atime);
raw_inode-&gt;i_ctime = cpu_to_le32(inode-&gt;i_ctime);
raw_inode-&gt;i_mtime = cpu_to_le32(inode-&gt;i_mtime);
raw_inode-&gt;i_blocks = cpu_to_le32(inode-&gt;i_blocks);
raw_inode-&gt;i_dtime = cpu_to_le32(inode-&gt;u.ext2_i.i_dtime);
raw_inode-&gt;i_flags = cpu_to_le32(inode-&gt;u.ext2_i.i_flags);
raw_inode-&gt;i_faddr = cpu_to_le32(inode-&gt;u.ext2_i.i_faddr);
raw_inode-&gt;i_frag = inode-&gt;u.ext2_i.i_frag_no;
raw_inode-&gt;i_fsize = inode-&gt;u.ext2_i.i_frag_size;
raw_inode-&gt;i_file_acl = cpu_to_le32(inode-&gt;u.ext2_i.i_file_acl);
if (S_ISDIR(inode-&gt;i_mode))
	raw_inode-&gt;i_dir_acl = cpu_to_le32(inode-&gt;u.ext2_i.i_dir_acl);
else {
	raw_inode-&gt;i_size_high = cpu_to_le32(inode-&gt;i_size &gt;&gt; 32);
...
	}
raw_inode-&gt;i_generation = cpu_to_le32(inode-&gt;i_generation);
if (S_ISCHR(inode-&gt;i_mode) || S_ISBLK(inode-&gt;i_mode))
	raw_inode-&gt;i_block[0] = cpu_to_le32(kdev_t_to_nr(inode-&gt;i_rdev));
else for (block = 0; block &lt; EXT2_N_BLOCKS; block++)
	raw_inode-&gt;i_block[block] = inode-&gt;u.ext2_i.i_data[block];
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1912</x>
      <y>2411</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_buffer_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1816</x>
      <y>2402</y>
      <w>106</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;860.0;50.0;1040.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1816</x>
      <y>2401</y>
      <w>129</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
do_sync</panel_attributes>
    <additional_attributes>10.0;20.0;1110.0;30.0;1270.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1928</x>
      <y>2414</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ll_rw_block </panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1948</x>
      <y>2415</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait_on_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1933</x>
      <y>2409</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
WRITE</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1942</x>
      <y>2409</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1816</x>
      <y>2402</y>
      <w>75</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;60.0;730.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>732</x>
      <y>2657</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>513</x>
      <y>2694</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>517</x>
      <y>2660</y>
      <w>223</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filename</panel_attributes>
    <additional_attributes>2210.0;10.0;10.0;340.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>584</x>
      <y>2696</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_unused_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>588</x>
      <y>2660</y>
      <w>152</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1500.0;10.0;10.0;360.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>530</x>
      <y>2703</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_next_zero_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>539</x>
      <y>2699</y>
      <w>53</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>519</x>
      <y>2706</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 next_fd表示空置的fd最小偏移量
 (注意__put_unused_fd)
addr=open_fds
size=max_fdset
offset=next_fd</panel_attributes>
    <additional_attributes>190.0;10.0;30.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>496</x>
      <y>2712</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>492</x>
      <y>2717</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //所在的word
p=addr+(offset&gt;&gt;5)
 //在word中的偏移
bit = offset &amp; 31
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>508</x>
      <y>2719</y>
      <w>21</w>
      <h>13</h>
    </coordinates>
    <panel_attributes> //看*p中的第一个0的索引位
"bsfl %1,%0\n\t" //低到高直到1
"jne 1f\n\t"
"movl $32, %0\n"
"1:"
: "=r" (set)
: "r" (~(*p &gt;&gt; bit)))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>519</x>
      <y>2712</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果偏移不为0</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>520</x>
      <y>2715</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
set &lt; (32 - bit)
32位内找到了0</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>514</x>
      <y>2715</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>532</x>
      <y>2720</y>
      <w>14</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>return set + offset
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>520</x>
      <y>2715</y>
      <w>37</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否者推到下一个word</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>547</x>
      <y>2719</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set = 32 - bit;
		p++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>560</x>
      <y>2718</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_first_zero_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>521</x>
      <y>2712</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>538</x>
      <y>2725</y>
      <w>54</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>"movl $-1,%%eax\n\t"//0xffffffff
"xorl %%edx,%%edx\n\t"
 //edi和eax比较（ecx计数），相等继续（repe，如果是repne，就是不相等继续）
"repe; scasl\n\t" 
"je 1f\n\t"
 //这里异或，（edi-4）中为0的会置为1
"xorl -4(%%edi),%%eax\n\t"
"subl $4,%%edi\n\t"
 //找出eax中第一个1，即（edi）中第一个0
"bsfl %%eax,%%edx\n"
 //偏移量 edi=edi-ebx 如果ecx减到0，此时的偏移量大于size
"1:\tsubl %%ebx,%%edi\n\t"
 //算出字节的偏移量，左移（shr右移）
"shll $3,%%edi\n\t"
 //算出总的偏移量
"addl %%edi,%%edx"
:"=d" (res), "=&amp;c" (d0), "=&amp;D" (d1), "=&amp;a" (d2)
:"1" ((size + 31) &gt;&gt; 5), "2" (addr), "b" (addr))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>563</x>
      <y>2721</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>557</x>
      <y>2699</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fd&gt;rlim[RLIMIT_NOFILE]
如果文件打开的数量超出了进程的限制</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>554</x>
      <y>2709</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>570</x>
      <y>2712</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expand_fdset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>572</x>
      <y>2699</y>
      <w>20</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fd &gt;= files-&gt;max_fdset
扩展fd位图</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>583</x>
      <y>2713</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expand_fdset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>589</x>
      <y>2699</y>
      <w>15</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fd &gt;= files-&gt;max_fds
扩展file数组</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>599</x>
      <y>2711</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>FD_SET(fd, files-&gt;open_fds);（btsl将偏移值设置为1，将原来的值存在CF）
FD_CLR(fd, files-&gt;close_on_exec);（btrl将偏移值设置为0，将原来的值存在CF）
files-&gt;next_fd = fd + 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>590</x>
      <y>2699</y>
      <w>17</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>626</x>
      <y>2712</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>files-&gt;fd[fd] == NULL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>590</x>
      <y>2699</y>
      <w>44</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fd对应的file要NULL</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>738</x>
      <y>2669</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>737</x>
      <y>2660</y>
      <w>9</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1533</x>
      <y>2690</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fd_install</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>737</x>
      <y>2660</y>
      <w>804</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;8020.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1533</x>
      <y>2697</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>files-&gt;fd[fd] = file
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1539</x>
      <y>2693</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>737</x>
      <y>2660</y>
      <w>821</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;8190.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1551</x>
      <y>2690</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1549</x>
      <y>2697</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>putname(tmp)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1555</x>
      <y>2693</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1563</x>
      <y>2690</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out_error
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>737</x>
      <y>2660</y>
      <w>832</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;8300.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1563</x>
      <y>2696</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_unused_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1567</x>
      <y>2693</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1563</x>
      <y>2702</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__put_unused_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1568</x>
      <y>2699</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1561</x>
      <y>2708</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>FD_CLR(fd, files-&gt;open_fds);
 //从这里看出，next_fd存储的
 //最小空闲的fd的偏移量
if (fd &lt; files-&gt;next_fd)
	files-&gt;next_fd = fd;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1568</x>
      <y>2705</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>623</x>
      <y>2696</y>
      <w>34</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //当flag的低两位是11时，flag没有++，所以还是11
if ((namei_flags+1) &amp; O_ACCMODE)
		namei_flags++;
 //空白打开，增加写权限
if (namei_flags &amp; O_TRUNC)
	namei_flags |= 2;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>633</x>
      <y>2672</y>
      <w>112</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
open的权限转化成open_namei权限</panel_attributes>
    <additional_attributes>1100.0;10.0;10.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>683</x>
      <y>2704</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>open_namei</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>687</x>
      <y>2672</y>
      <w>58</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到文件的dentry</panel_attributes>
    <additional_attributes>560.0;10.0;10.0;320.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>636</x>
      <y>2707</y>
      <w>53</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!(flag &amp; O_CREAT)
找不到文件不创建文件</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>628</x>
      <y>2746</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>622</x>
      <y>2749</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_flags</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>637</x>
      <y>2749</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>652</x>
      <y>2749</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>636</x>
      <y>2746</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>636</x>
      <y>2746</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>602</x>
      <y>2755</y>
      <w>49</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.默认打开置上LOOKUP_FOLLOW (遇到link，继续向下找到真实文件)
2.O_NOFOLLOW 或者 O_CREAT|O_EXCL置上时，LOOKUP_FOLLOW取消
3.O_DIRECTORY时 LOOKUP_DIRECTORY（如果inode没有op则会报错）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>624</x>
      <y>2752</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>687</x>
      <y>2707</y>
      <w>21</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flag &amp; O_CREAT</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;370.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>666</x>
      <y>2749</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>680</x>
      <y>2749</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>path_walk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>671</x>
      <y>2743</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
LOOKUP_PARENT表示只找到父节点
但是nd.last是指向最后一个节点的</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>685</x>
      <y>2743</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>694</x>
      <y>2749</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //不能是.或者..
nd-&gt;last_type != LAST_NORM 
 //字符串最后一个字符是'\0'
 //不能是'\'
|| nd-&gt;last.name[nd-&gt;last.len]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>702</x>
      <y>2743</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为O_CREAT
所以最后一个节点不能是目录
目录要通过mkdir创建</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>724</x>
      <y>2750</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>701</x>
      <y>2743</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在dir中查找nd.last</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>654</x>
      <y>2764</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode = base-&gt;d_inode;
err = permission(inode, MAY_EXEC)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>665</x>
      <y>2753</y>
      <w>66</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>640.0;10.0;310.0;90.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>683</x>
      <y>2766</y>
      <w>15</w>
      <h>3</h>
    </coordinates>
    <panel_attributes> base-&gt;d_op-&gt;d_hash
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>689</x>
      <y>2753</y>
      <w>42</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
base-&gt;d_op &amp;&amp; base-&gt;d_op-&gt;d_hash</panel_attributes>
    <additional_attributes>400.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>699</x>
      <y>2765</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cached_lookup
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>704</x>
      <y>2753</y>
      <w>27</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在dentry_hashtable中查找</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>727</x>
      <y>2753</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!dentry
如果在hash中没找到dentry</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>713</x>
      <y>2765</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_alloc
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>717</x>
      <y>2758</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
先alloc
是因为alloc可能睡</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>727</x>
      <y>2766</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op-&gt;lookup
（reference）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>727</x>
      <y>2758</y>
      <w>9</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>727</x>
      <y>2758</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2中!dentry
表示没返回错误</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>744</x>
      <y>2763</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>if (!dentry)
	dentry = new;
else
	dput(new)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>755</x>
      <y>2745</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!dentry-&gt;d_inode
如果磁盘上没有这个文件</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>755</x>
      <y>2767</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>755</x>
      <y>2748</y>
      <w>8</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>767</x>
      <y>2755</y>
      <w>15</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //释放父目录
dput(nd-&gt;dentry);
 //更新为文件的dentry
nd-&gt;dentry = dentry;
acc_mode = 0;
flag &amp;= ~O_TRUNC;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>755</x>
      <y>2748</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>782</x>
      <y>2745</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
存在这个文件</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>800</x>
      <y>2748</y>
      <w>6</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>784</x>
      <y>2765</y>
      <w>43</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.O_CREAT|O_EXCL 如果这两个标志置上，表示文件必须得不存在
	所以这里检查O_EXCL，如果有，则报错文件存在
2.检查是否要打开的文件是否挂载设备 d_mountpoint
	如果挂载了，但是O_NOFOLLOW置上，则报错，
	如果O_NOFOLLOW没置上，则一直__follow_down到最后的文件
3.如果!dentry-&gt;d_inode，表示文件指向的最终文件不存在，
	返回错误
4.如果当前文件时符号链接（i_op-&gt;follow_link存在），去do_link

 //中间将dentry替换成寻找的文件
dput(nd-&gt;dentry);
nd-&gt;dentry = dentry;

5.dentry-&gt;d_inode &amp;&amp; S_ISDIR open不能打开目录
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>800</x>
      <y>2748</y>
      <w>94</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;480.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>890</x>
      <y>2796</y>
      <w>3</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>ok
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>800</x>
      <y>2748</y>
      <w>275</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2730.0;540.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1070</x>
      <y>2802</y>
      <w>7</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>do_link
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1053</x>
      <y>2804</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
O_NOFOLLOW</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1050</x>
      <y>2813</y>
      <w>7</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>-ELOOP
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1061</x>
      <y>2812</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>UPDATE_ATIME</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1067</x>
      <y>2804</y>
      <w>8</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1078</x>
      <y>2813</y>
      <w>25</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>dentry-&gt;d_inode-&gt;i_op-&gt;follow_link
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1067</x>
      <y>2804</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注意这里nd中的flag还是之前path_init的
LOOKUP_PARENT</panel_attributes>
    <additional_attributes>60.0;10.0;200.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1105</x>
      <y>2813</y>
      <w>9</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>dput(dentry)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1073</x>
      <y>2804</y>
      <w>36</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1073</x>
      <y>2804</y>
      <w>50</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1116</x>
      <y>2813</y>
      <w>35</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1. LAST_BIND（Procfs相关）
	dentry = nd-&gt;dentry;
	goto ok;
2.LAST_NORM ||  nd-&gt;last.name[nd-&gt;last.len]
	-EISDIR
3.counter==32
	dentry = nd-&gt;dentry;
	putname(nd-&gt;last.name);
	goto ok;
  注意：follow_link中虽然有循环的计数，
  			但是那是针对要寻找节点的，但是现在
  			要寻找的节点是 目标节点的父节点
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>778</x>
      <y>2742</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_last
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>702</x>
      <y>2741</y>
      <w>82</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;30.0;800.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1153</x>
      <y>2813</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //保存父目录
dir = nd-&gt;dentry;
dentry = lookup_hash(&amp;nd-&gt;last, nd-&gt;dentry);
 //找到了目标节点，释放其名称
putname(nd-&gt;last.name);
goto do_last;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1073</x>
      <y>2804</y>
      <w>90</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;880.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>822</x>
      <y>2806</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.!inode 不存在inode
	-ENOENT
2.S_ISLNK 如果是符号链接
	-ELOOP
3.S_ISDIR &amp;&amp; FMODE_WRITE
  -EISDIR

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>829</x>
      <y>2798</y>
      <w>64</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter
这些条件在某些情况下并没有被检查
（例如!(flag &amp; O_CREAT)）</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>609</x>
      <y>2749</y>
      <w>10</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>acc_mode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>613</x>
      <y>2707</y>
      <w>76</w>
      <h>44</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
"\000\004\002\006"[(x)&amp;O_ACCMODE]
注：1.ASCII中\ddd表示一个八进制的数
    2.这里字符串是一个指针，[]中时索引
    所以这里是将open_namei的权限转换成
    permission的权限</panel_attributes>
    <additional_attributes>740.0;10.0;190.0;130.0;10.0;420.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>845</x>
      <y>2808</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>permission</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>849</x>
      <y>2798</y>
      <w>44</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>420.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>858</x>
      <y>2806</y>
      <w>30</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.S_ISFIFO  S_ISSOCK  S_ISBLK  S_ISCHR
	flag &amp;= ~O_TRUNC
2.IS_RDONLY &amp;&amp; (flag &amp; 2)
	是readonly安装，但是要求写 报-EROFS
3.如果sb只能添加IS_APPEND
	3.1但是 FMODE_WRITE &amp;&amp; ！O_APPEND
		要写，但是不是添加
	3.2.O_TRUNC 空白打开
	报-EPERM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>870</x>
      <y>2798</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>889</x>
      <y>2807</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_lease</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>891</x>
      <y>2798</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
文件“租借”相关</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>891</x>
      <y>2798</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>919</x>
      <y>2806</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flag &amp; O_TRUNC</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>901</x>
      <y>2810</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>872</x>
      <y>2823</y>
      <w>30</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.检查inode-&gt;i_writecount是否小于0
	注：文件有可能通过mmap映射到内存中，
		这个时候进程访问内存和进程直接访问文件就
		需要互斥。所以就有了get_write_access和
		deny_write_access。当访问内存文件时，通过
		deny_write_access，将i_writecount置为负数
		如果此时另一个进程需要访问inode文件，需要通过
		get_write_access检查i_writecount是否小于0，
		如果小于0，则返回-ETXTBSY
2.增加inode-&gt;i_writecount的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>897</x>
      <y>2814</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_write_access</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>886</x>
      <y>2817</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>928</x>
      <y>2813</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_verify_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>919</x>
      <y>2810</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>922</x>
      <y>2816</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查强制锁</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>915</x>
      <y>2820</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>MANDATORY_LOCK</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>903</x>
      <y>2828</y>
      <w>48</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.检查sb中的s_flags是否有MS_MANDLOCK
2.并且inode中i_mode的S_ISGID置上，但是S_IXGRP没置
	注：1.强制锁指的是操作系统在进程访问文件时，主动加锁（fcntl）
			协调锁是进程在调用的过程中自己主动加锁
			（进程通过一次系统调用实现读或写的时候，对于进程本身是“原子”的
			因为进程在内核中不会因为时间而发生进程的切换，但是在对一个文件做
			多次的读写操作时，这个过程就不可能是“原子的”）
		2.一般S_ISGID置上，就是为了以这个group的权限去执行文件，但是如果
			S_IXGRP没设置，这个对于这个实例是没有意义的，所以Unix就用这个标志
			来确定是否要给inode加强制锁
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>923</x>
      <y>2823</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>948</x>
      <y>2822</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_mandatory_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>938</x>
      <y>2816</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>952</x>
      <y>2829</y>
      <w>36</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>遍历inode-&gt;i_flock，如果fl-&gt;fl_flags
的FL_POSIX置上，但是fl_owner却不是
current-&gt;files，说明这个inode被其他进程锁上
所以返回-EAGAIN。遍历完，没有被自己以外的其
他进程锁上，就返回0.
注：1.每当进程对文件的一个区间加锁时，就会在
		链表中增加一个 file_lock结构，该结构中
		fl_start和fl_end确定这个区间
	2.FL_POSIX（ fcntl）支持对区间加锁，可以是强制锁，
		也可以是协调锁因为前面有MANDATORY_LOCK的检测，
	  所以这里是强制锁，
	  FL_FLOCK（ fcntl）是协调锁，只支持对整个文件加锁
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>958</x>
      <y>2825</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>965</x>
      <y>2815</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DQUOT_INIT</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>919</x>
      <y>2810</y>
      <w>53</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>962</x>
      <y>2820</y>
      <w>21</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_sb-&gt;dq_op-&gt;initialize
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>970</x>
      <y>2818</y>
      <w>4</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1002</x>
      <y>2816</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_truncate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>919</x>
      <y>2810</y>
      <w>90</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;880.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>999</x>
      <y>2829</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>attr-&gt;ia_ctime = now
attr-&gt;ia_atime
attr-&gt;ia_mtime
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1012</x>
      <y>2837</y>
      <w>16</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op-&gt;setattr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1030</x>
      <y>2836</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_change_ok</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1059</x>
      <y>2836</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_setattr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1008</x>
      <y>2825</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1018</x>
      <y>2825</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1020</x>
      <y>2827</y>
      <w>16</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode-&gt;i_op-&gt;setattr</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1032</x>
      <y>2827</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2没有setattr</panel_attributes>
    <additional_attributes>20.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1035</x>
      <y>2830</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1039</x>
      <y>2830</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>997</x>
      <y>2843</y>
      <w>37</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.ia_valid中ATTR_FORCE 置上，权限检查ok
2.ATTR_UID置上时
	fsuid要和inode-&gt;i_uid相等，并且如果attr-&gt;ia_uid和
	i_uid不相等，CAP_CHOWN就得置上
3.ATTR_GID置上时，以下三种情况要满足一个：
	1.attr-&gt;ia_gid在fsgid中，
	2.ia_gid等于i_gid
	3.CAP_CHOWN置上
4.ATTR_MODE置上时
	1.fsuid不等于inode-&gt;i_uid时，CAP_FOWNER得置上
	2.ia_gid（ATTR_GID）或者i_gid不在fsgid中时，
		CAP_FSETID得置上。
5.ATTR_MTIME_SET | ATTR_ATIME_SET有一个置上时：
	如果fsuid不等于i_uid，CAP_FOWNER得置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1017</x>
      <y>2839</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1037</x>
      <y>2844</y>
      <w>22</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.ATTR_UID时：
	inode-&gt;i_uid = attr-&gt;ia_uid
2.ATTR_GID时：
	inode-&gt;i_gid = attr-&gt;ia_gid
3.ATTR_SIZE时：
	vmtruncate(inode, attr-&gt;ia_size)
4.ATTR_ATIME时：
	inode-&gt;i_atime = attr-&gt;ia_atime
5.ATTR_MTIME时：
	inode-&gt;i_mtime = attr-&gt;ia_mtime
6.ATTR_CTIME时：
	inode-&gt;i_ctime = attr-&gt;ia_ctime
7.ATTR_MODE时：
	inode-&gt;i_mode = attr-&gt;ia_mode
	如果inode-&gt;i_gid不在fsgid中，但是CAP_FSETID没置上时：
		inode-&gt;i_mode &amp;= ~S_ISGID
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1046</x>
      <y>2839</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>975</x>
      <y>2824</y>
      <w>31</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>newattrs.ia_size = length;
newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>990</x>
      <y>2819</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1013</x>
      <y>2822</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>notify_change</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1006</x>
      <y>2819</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1065</x>
      <y>2839</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1075</x>
      <y>2842</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_inode_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1079</x>
      <y>2845</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
没I_DIRTY
I_DIRTY是指I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES
全置上</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1074</x>
      <y>2851</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__mark_inode_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1061</x>
      <y>2858</y>
      <w>16</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_state |= flags
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1067</x>
      <y>2854</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
此时flag传的是I_DIRTY</panel_attributes>
    <additional_attributes>130.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1073</x>
      <y>2854</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode在hash中时
从inode_in_use或者inode_unused中删除
添加到s_dirty中</panel_attributes>
    <additional_attributes>70.0;10.0;200.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1085</x>
      <y>2859</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_del(&amp;inode-&gt;i_list);
list_add(&amp;inode-&gt;i_list, &amp;sb-&gt;s_dirty);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1080</x>
      <y>2830</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setattr_mask</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1098</x>
      <y>2830</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_dir_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1018</x>
      <y>2825</y>
      <w>69</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1018</x>
      <y>2825</y>
      <w>89</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;870.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>921</x>
      <y>2806</y>
      <w>123</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
flag中O_TRUNC没置上
但是FMODE_WRITE置上</panel_attributes>
    <additional_attributes>10.0;10.0;1210.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1036</x>
      <y>2810</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DQUOT_INIT</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1023</x>
      <y>2814</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_write_access</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>919</x>
      <y>2810</y>
      <w>112</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>742</x>
      <y>2672</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请file与dentry关联</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>771</x>
      <y>2679</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dentry_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>743</x>
      <y>2689</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_empty_filp</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>747</x>
      <y>2682</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>723</x>
      <y>2697</y>
      <w>41</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.如果files_stat.nr_free_files大于NR_RESERVED_FILES
	1.从free_list中申请一个file
		f = list_entry(free_list.next, struct file, f_list);
		list_del(&amp;f-&gt;f_list);
		files_stat.nr_free_files--;
	2.对file进行初始化
		memset(f, 0, sizeof(*f));
		atomic_set(&amp;f-&gt;f_count,1);
		f-&gt;f_version = ++event;
		f-&gt;f_uid = current-&gt;fsuid;
		f-&gt;f_gid = current-&gt;fsgid;
		//暂时加到anon_list链表中
		list_add(&amp;f-&gt;f_list, &amp;anon_list);
2.剩余file的数量小于要reserve的，并且之歌数量不为0，uid为0
	也做1.1和1.2
3.如果上述两个条件都不满足
	1.如果files_stat.nr_files &lt; files_stat.max_files
		就向filp_cachep申请file（kmem_cache_alloc），并
		增加计数（files_stat.nr_files++），然后通过1.2进行初始化
	2.否则返回NULL（静态变量old_max做到只提示一次）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>739</x>
      <y>2692</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>766</x>
      <y>2697</y>
      <w>26</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>f-&gt;f_flags = flags;
 //flags转换成file的read/write标志
f-&gt;f_mode = (flags+1) &amp; O_ACCMODE;
inode = dentry-&gt;d_inode;
if (f-&gt;f_mode &amp; FMODE_WRITE)
	get_write_access
f-&gt;f_dentry = dentry;
f-&gt;f_vfsmnt = mnt;
f-&gt;f_pos = 0;
f-&gt;f_reada = 0;
 //如果(fops) &amp;&amp; (fops)-&gt;owner存在
 //增加owner的计数，返回inode-&gt;i_fop
f-&gt;f_op = fops_get(inode-&gt;i_fop);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>776</x>
      <y>2682</y>
      <w>4</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>776</x>
      <y>2682</y>
      <w>30</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inode-&gt;i_sb存在
将f_list添加到
inode-&gt;i_sb-&gt;s_files中</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>797</x>
      <y>2697</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file_move</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>794</x>
      <y>2704</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>list_del(&amp;file-&gt;f_list);
list_add(&amp;file-&gt;f_list, list);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>802</x>
      <y>2700</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>776</x>
      <y>2682</y>
      <w>51</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
f-&gt;f_op-&gt;open
附加操作</panel_attributes>
    <additional_attributes>10.0;10.0;490.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>819</x>
      <y>2697</y>
      <w>11</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>f-&gt;f_op-&gt;open
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>812</x>
      <y>2707</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_open_file</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>817</x>
      <y>2699</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>793</x>
      <y>2713</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>当f_flags中O_LARGEFILE没置上时
 inode-&gt;i_size不能大于2G
 (如果O_LARGEFILE置上，高32位在
	i_high_size中，其低32位为ext2_inode
	中的i_size，两者合起来为i_size是64位整数)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>806</x>
      <y>2710</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>846</x>
      <y>2691</y>
      <w>35</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>f-&gt;f_flags &amp;= 
~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>776</x>
      <y>2682</y>
      <w>83</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将打开时用的flag给清掉</panel_attributes>
    <additional_attributes>10.0;10.0;810.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>700</x>
      <y>2775</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //umask置1的位表示该进程对组没有响应的权限
mode &amp;= S_IALLUGO &amp; ~current-&gt;fs-&gt;umask;
mode |= S_IFREG;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>739</x>
      <y>2776</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>may_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>719</x>
      <y>2782</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.child-&gt;d_inode不能存在
2.i_flags中S_DEAD不能置上，
	S_DEAD表示inode被删除，但是count不为0
3.检查父节点的MAY_WRITE | MAY_EXEC权限
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>755</x>
      <y>2776</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_op-&gt;create
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>756</x>
      <y>2786</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>760</x>
      <y>2779</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_dir_inode_operations</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>713</x>
      <y>2770</y>
      <w>50</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>743</x>
      <y>2770</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>760</x>
      <y>2770</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>736</x>
      <y>2779</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>698</x>
      <y>2796</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_new_inode
1.内存中申请管理结构new_inode
2.在磁盘上寻找inode
	1.找到对应的group
	2.在group的位图中找到对应空闲inode号
	3.对group的硬盘信息更新
3.根据硬件和进程信息初始化内存inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>703</x>
      <y>2789</y>
      <w>60</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>580.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>497</x>
      <y>2819</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>filter
1.!dir || !dir-&gt;i_nlink
	父节点不能为空，存在和这个inode相关的目录项
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>515</x>
      <y>2799</y>
      <w>189</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1870.0;10.0;10.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>530</x>
      <y>2820</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>new_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>535</x>
      <y>2799</y>
      <w>170</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sb</panel_attributes>
    <additional_attributes>1680.0;10.0;10.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>514</x>
      <y>2828</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_empty_inode
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>520</x>
      <y>2823</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>529</x>
      <y>2829</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_sb = sb;
inode-&gt;i_dev = sb-&gt;s_dev;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>534</x>
      <y>2823</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>566</x>
      <y>2815</y>
      <w>35</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISDIR</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>548</x>
      <y>2828</y>
      <w>58</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.每个组平均inode的数量
avefreei = le32_to_cpu(es-&gt;s_free_inodes_count) /
			sb-&gt;u.ext2_sb.s_groups_count;
2.inode属于哪个group
i = dir-&gt;u.ext2_i.i_block_group;
3.（被注释）从i开始遍历所有的group，找到bg_used_dirs_count(目录的数量)*256
	低于bg_free_inodes_count（空闲inode数量）的group
注：1.遍历方式，遍历的次数（bg_free_inodes_count）和遍历的起始点（i）分开
	2.ext2_get_group_desc
		sb-&gt;u.ext2_sb.s_group_desc[group_desc].b_data+desc
		bh存储s_group_desc[group_desc]这个管理结构
4.如果没有找到相应的group，再次遍历所有的group，找到空闲inode数量（s_groups_count）
	大于avefreei的inode数量（这个条件使遍历少了一些），找到最大的bg_free_blocks_count
	的group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>598</x>
      <y>2815</y>
      <w>17</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不是目录文件</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>598</x>
      <y>2799</y>
      <w>107</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
文件最好和父目录放在同一个group
但是子目录可以不放在同一个group</panel_attributes>
    <additional_attributes>1050.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>607</x>
      <y>2831</y>
      <w>45</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.获取当前dir所在的group
2，如果当前group存在空闲inode（bg_free_inodes_count不为0）
	就选取当前的group
3.如果当前group不存在空闲inode，以j &lt;&lt;= 1的方式，遍历所有的group
	找到有空闲inode的group
4.如果还没找到就通过线性查找所有的group，找到空闲inode的group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>659</x>
      <y>2811</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>load_inode_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>662</x>
      <y>2799</y>
      <w>46</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>653</x>
      <y>2819</y>
      <w>52</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.要load的group要小于s_groups_count
2.一般将最近使用的group放在0号位
	所以利用程序执行的局部性，如果0号位就
	检测到了要加载的group，直接返回
3.如果设备对应的group总数（s_groups_count）
	小于加载数组的大小（EXT2_MAX_GROUP_LOADED）
	那么每个group都存在数组对应的group号下面
	如果在block_group号下没找到，就通过read_inode_bitmap
	读取group的位图
4.如果group的总数大于数组的大小，将已经加载到数组中的
	位图（s_loaded_inode_bitmaps）向后移一位，将0号空闲出来
	（注：如果数组包含当前group，就移当前group之前的位，如果不包含
	就将所有的s_loaded_inode_bitmaps向后移一位）。再看是否包含要查找的group，
	如果不包含就通过read_inode_bitmap将位图读入数组（s_loaded_inode_bitmaps
	如果小于EXT2_MAX_GROUP_LOADED，在再次加载的时候，应该++）
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>665</x>
      <y>2814</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>665</x>
      <y>2846</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_inode_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>673</x>
      <y>2843</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>640</x>
      <y>2854</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_get_group_desc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>646</x>
      <y>2849</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>614</x>
      <y>2857</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>604</x>
      <y>2865</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_group&lt;s_groups_count
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>636</x>
      <y>2857</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
计算group对应的bh
和在bh中的偏移</panel_attributes>
    <additional_attributes>120.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>627</x>
      <y>2864</y>
      <w>39</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>group_desc = block_group / EXT2_DESC_PER_BLOCK(sb);
desc = block_group % EXT2_DESC_PER_BLOCK(sb);
s_group_desc[group_desc]不为空
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>668</x>
      <y>2864</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.bh存储管理结构s_group_desc[group_desc]
2.返回磁盘中的真实数据的内存偏移
	s_group_desc[group_desc]-&gt;b_data+desc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>647</x>
      <y>2857</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>675</x>
      <y>2855</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>674</x>
      <y>2849</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读取位图的inode
位图的inode号通过管理结构desc存储</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>689</x>
      <y>2855</y>
      <w>43</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>sb-&gt;u.ext2_sb.s_inode_bitmap_number[bitmap_nr] = block_group;
sb-&gt;u.ext2_sb.s_inode_bitmap[bitmap_nr] = bh;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>674</x>
      <y>2849</y>
      <w>40</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>691</x>
      <y>2799</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_find_first_zero_bit
（find_first_zero_bit）
&lt;EXT2_INODES_PER_GROUP</panel_attributes>
    <additional_attributes>150.0;10.0;60.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>686</x>
      <y>2806</y>
      <w>13</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>682</x>
      <y>2814</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_set_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>697</x>
      <y>2814</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_buffer_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>696</x>
      <y>2806</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>696</x>
      <y>2806</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MS_SYNCHRONOUS
如果同步就写超级块</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>713</x>
      <y>2813</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>ll_rw_block (WRITE, 1, &amp;bh);
wait_on_buffer (bh);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>705</x>
      <y>2799</y>
      <w>46</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
计算inode号</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>738</x>
      <y>2813</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //i是group号
 //j是在group中的偏移索引
 //所以+1
j += i * EXT2_INODES_PER_GROUP(sb) + 1
 EXT2_FIRST_INO&lt;j&lt;s_inodes_count
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>770</x>
      <y>2808</y>
      <w>50</w>
      <h>88</h>
    </coordinates>
    <panel_attributes> //更新group中空闲inode数量
gdp-&gt;bg_free_inodes_count =
	cpu_to_le16(le16_to_cpu(gdp-&gt;bg_free_inodes_count) - 1);
 //如果是目录，更新group中目录的数量
if (S_ISDIR(mode))
	gdp-&gt;bg_used_dirs_count =
		cpu_to_le16(le16_to_cpu(gdp-&gt;bg_used_dirs_count) + 1);
 //标记group的管理结构dirty
mark_buffer_dirty(bh2);
 //更新设备空闲inode数量
es-&gt;s_free_inodes_count =
	cpu_to_le32(le32_to_cpu(es-&gt;s_free_inodes_count) - 1);
mark_buffer_dirty(sb-&gt;u.ext2_sb.s_sbh);
sb-&gt;s_dirt = 1;
inode-&gt;i_mode = mode;
 //注意inode的mode是fsuid，所以如果进程通过执行isuid文件改变相应的uid
 //其创建出来的文件也是改变之后的uid
inode-&gt;i_uid = current-&gt;fsuid;
 //sb在安装时GRPID置上，或者dir的S_ISGID置上
 //该目录下的i_gid都是目录的gid
 //否则就是进程的fsgid
if (test_opt (sb, GRPID))
	inode-&gt;i_gid = dir-&gt;i_gid;
else if (dir-&gt;i_mode &amp; S_ISGID) {
	inode-&gt;i_gid = dir-&gt;i_gid;
	if (S_ISDIR(mode))
		mode |= S_ISGID;
} else
	inode-&gt;i_gid = current-&gt;fsgid;

inode-&gt;i_ino = j;
inode-&gt;i_blksize = PAGE_SIZE;	
inode-&gt;i_blocks = 0;
inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = CURRENT_TIME;
inode-&gt;u.ext2_i.i_new_inode = 1;
inode-&gt;u.ext2_i.i_flags = dir-&gt;u.ext2_i.i_flags;
if (S_ISLNK(mode))
	inode-&gt;u.ext2_i.i_flags &amp;= ~(EXT2_IMMUTABLE_FL | EXT2_APPEND_FL);
inode-&gt;u.ext2_i.i_faddr = 0;
inode-&gt;u.ext2_i.i_frag_no = 0;
inode-&gt;u.ext2_i.i_frag_size = 0;
inode-&gt;u.ext2_i.i_file_acl = 0;
inode-&gt;u.ext2_i.i_dir_acl = 0;
inode-&gt;u.ext2_i.i_dtime = 0;
inode-&gt;u.ext2_i.i_block_group = i;
if (inode-&gt;u.ext2_i.i_flags &amp; EXT2_SYNC_FL)
	inode-&gt;i_flags |= S_SYNC;
 //如果文件没有sb就存放在anon_hash_chain
 //如果有sb就存放在inode_hashtable + hash(inode-&gt;i_sb, inode-&gt;i_ino)中
 //注：list_add是头插
insert_inode_hash(inode);
inode-&gt;i_generation = event++;
mark_inode_dirty(inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>705</x>
      <y>2799</y>
      <w>81</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;790.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>742</x>
      <y>2795</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op = &amp;ext2_file_inode_operations;
inode-&gt;i_fop = &amp;ext2_file_operations;
inode-&gt;i_mapping-&gt;a_ops = &amp;ext2_aops;
inode-&gt;i_mode = mode;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>756</x>
      <y>2789</y>
      <w>6</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>774</x>
      <y>2796</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>mark_inode_dirty
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>759</x>
      <y>2789</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>803</x>
      <y>2796</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>ext2_add_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>759</x>
      <y>2789</y>
      <w>53</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在目录中添加目录项</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>827</x>
      <y>2796</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>d_instantiate
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>758</x>
      <y>2789</y>
      <w>79</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将inode和dir的管理结构关联</panel_attributes>
    <additional_attributes>10.0;10.0;770.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>478</x>
      <y>2617</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file.f_op
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>505</x>
      <y>2617</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_fop
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>490</x>
      <y>2617</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dentry_open</panel_attributes>
    <additional_attributes>10.0;20.0;150.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>536</x>
      <y>2617</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de-&gt;proc_fops
ext2_file_operations
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>516</x>
      <y>2617</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_read_inode
proc_get_inode
ext2_create
文件系统中给inode的操作函数赋值</panel_attributes>
    <additional_attributes>20.0;20.0;200.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>548</x>
      <y>2617</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_register
proc_register
proc_root</panel_attributes>
    <additional_attributes>10.0;20.0;220.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>570</x>
      <y>2617</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_file_operations
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>504</x>
      <y>2627</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>535</x>
      <y>2628</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de-&gt;proc_iops
ext2_file_inode_operations
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>515</x>
      <y>2627</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_read_inode
proc_get_inode
ext2_create
文件系统中给inode的操作函数赋值</panel_attributes>
    <additional_attributes>20.0;20.0;200.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>565</x>
      <y>2628</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_dir_inode_operations
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>547</x>
      <y>2628</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_register
proc_register
proc_root</panel_attributes>
    <additional_attributes>10.0;20.0;180.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>825</x>
      <y>2699</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISCHR
def_chr_fops</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>836</x>
      <y>2706</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>chrdev_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>828</x>
      <y>2714</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_chrfops</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>833</x>
      <y>2709</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filp-&gt;f_op</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>870</x>
      <y>2711</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>841</x>
      <y>2709</y>
      <w>37</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>824</x>
      <y>2720</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fops_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>829</x>
      <y>2717</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>793</x>
      <y>2728</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.查看chrdevs[major].fops是否存在
2.如果存在，且对应的owner module存在
	增加module的计数，并返回fops，如果不存在
	owner，直接返回fops
3、如果不存在，直接返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>810</x>
      <y>2723</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>828</x>
      <y>2727</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果能找到major的fops，并且是终端设备
	（major是TTY_MAJOR或者TTYAUX_MAJOR）
2.如果需要need_serial，通过fops_put将找到的
	fops释放，之后利用内核提供的module
	need_serial(get_tty_driver)：
	遍历tty_drivers，看其中是否有一个driver，其
	和device相同的 major，并且minor要在dirver
	的minor_start~ minor_start + p-&gt;num之间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>828</x>
      <y>2723</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>863</x>
      <y>2728</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //请求char-major-x  module
sprintf(name, "char-major-%d", major);
request_module(name);
 //获取fops
ret = fops_get(chrdevs[major].fops);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>828</x>
      <y>2723</y>
      <w>47</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果fops为NULL</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1350</x>
      <y>2723</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>825</x>
      <y>2699</y>
      <w>531</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_fops</panel_attributes>
    <additional_attributes>10.0;10.0;5290.0;240.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1333</x>
      <y>2726</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据inode获得虚拟设备devfs_entrylt</panel_attributes>
    <additional_attributes>210.0;10.0;18.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1323</x>
      <y>2731</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_devfs_entry_from_vfs_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1340</x>
      <y>2736</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果是S_ISDIR，goto out
2.de-&gt;registered为false， -ENODEV
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1350</x>
      <y>2726</y>
      <w>6</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1366</x>
      <y>2736</y>
      <w>55</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.file-&gt;private_data = de-&gt;info
2.S_ISBLK：
	file-&gt;f_op = &amp;def_blk_fops
	//如果df-&gt;ops存在
	inode-&gt;i_bdev-&gt;bd_op = df-&gt;ops
	其他：
	file-&gt;f_op=df-&gt;ops
3.如果file-&gt;f_op存在，且桥接的fop要求open（file-&gt;f_op-&gt;open）
	(*file-&gt;f_op-&gt;open) (inode, file)
4.如果file-&gt;f_op不存在
	如果是S_ISCHR，通过chrdev_open从chrdevs获取fops，并且
	执行桥接的filp-&gt;f_op-&gt;open
	如果是其他设备，返回-ENODEV
5.如果df已经打开（df-&gt;open为true），返回
6.如果df没打开，df-&gt;open = TRUE
7，如果要求自动owner（df-&gt;auto_owner）
	de-&gt;inode.mode = (de-&gt;inode.mode &amp; ~S_IALLUGO) |(de-&gt;mode &amp; S_IRWXUGO);
	de-&gt;inode.uid = current-&gt;euid;
	de-&gt;inode.gid = current-&gt;egid;
	inode-&gt;i_mode = de-&gt;inode.mode;
	inode-&gt;i_uid = de-&gt;inode.uid;
	inode-&gt;i_gid = de-&gt;inode.gid;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1353</x>
      <y>2726</y>
      <w>34</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1425</x>
      <y>2735</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfsd_notify_one</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1353</x>
      <y>2726</y>
      <w>80</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
df-&gt;aopen_notify</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;80.0;780.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>826</x>
      <y>2699</y>
      <w>627</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISBLK
def_blk_fops</panel_attributes>
    <additional_attributes>10.0;10.0;6250.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1446</x>
      <y>2723</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1419</x>
      <y>2730</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdev = inode-&gt;i_bdev
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1424</x>
      <y>2726</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1448</x>
      <y>2726</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bdev-&gt;bd_op不存在</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1442</x>
      <y>2731</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_blkfops</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1431</x>
      <y>2739</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.major不能为0，并且要小于MAX_BLKDEV
2.如果blkdevs[major].bdops不存在，通过
	request_module安装module
3.返回blkdevs[major].bdops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1443</x>
      <y>2734</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1450</x>
      <y>2726</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1460</x>
      <y>2733</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果没找到了bd_op，返回ENXIO
2.如果找到了，并且bdev-&gt;bd_op-&gt;open存在，
	通过这个函数对file的op进行桥接
3.如果正确返回，atomic_inc(&amp;bdev-&gt;bd_openers)
	如果没有，且没有bd_openers：
	bdev-&gt;bd_op = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1467</x>
      <y>2747</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bdev-&gt;bd_op-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1473</x>
      <y>2743</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1474</x>
      <y>2750</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_fops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1469</x>
      <y>2754</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1443</x>
      <y>2759</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_info_ptr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1447</x>
      <y>2757</y>
      <w>29</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1425</x>
      <y>2766</y>
      <w>28</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.通过major在ide_hwifs（接口）找到对应的类型
	hwif-&gt;present &amp;&amp; major == hwif-&gt;major
2.通过minor在hwif-&gt;drives中找到特定种类的
	设备（ide_drive_t）
3.如果drive-&gt;present置上，返回设备
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1440</x>
      <y>2762</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1473</x>
      <y>2757</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;driver == NULL
如果设备中没有相应的操作</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1466</x>
      <y>2759</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>80.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1461</x>
      <y>2762</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_driver_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1454</x>
      <y>2767</y>
      <w>28</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果之前有ide interface检测到
	直接将ide_modules链表中module-&gt;init
	然后在revalidate_drives
2.如果没有ide interface检测到
	通过ide_probe_module检测module
	然后在初始化ide_modules链表中的module
	并执行revalidate_drives
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1461</x>
      <y>2765</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1451</x>
      <y>2781</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_probe_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1456</x>
      <y>2778</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1443</x>
      <y>2784</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!ide_probe
请求安装ide-probe-mod</panel_attributes>
    <additional_attributes>120.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1440</x>
      <y>2788</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1453</x>
      <y>2789</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_probe-&gt;init
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1453</x>
      <y>2784</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_probe存在</panel_attributes>
    <additional_attributes>20.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1470</x>
      <y>2788</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>revalidate_drives</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1454</x>
      <y>2784</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1476</x>
      <y>2778</y>
      <w>4</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1453</x>
      <y>2791</y>
      <w>41</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历所有ide interface的设备（注意这里都是实体，没有指针）
查看drive-&gt;revalidate是否置上，如果置上并且没被初始化
（!initializing）</panel_attributes>
    <additional_attributes>230.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1463</x>
      <y>2797</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_revalidate_disk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1484</x>
      <y>2763</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1473</x>
      <y>2760</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果时具体的设备被拆除
根据drive-&gt;media安装</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1498</x>
      <y>2763</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>while (drive-&gt;busy)
	sleep_on(&amp;drive-&gt;wqueue);
drive-&gt;usage++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1473</x>
      <y>2757</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1523</x>
      <y>2764</y>
      <w>15</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>DRIVER(drive)-&gt;open
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1473</x>
      <y>2758</y>
      <w>57</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;driver != NULL</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1530</x>
      <y>2766</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
idedisk_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1524</x>
      <y>2771</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>idedisk_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1523</x>
      <y>2778</y>
      <w>18</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>MOD_INC_USE_COUNT
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1530</x>
      <y>2774</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>857</x>
      <y>2716</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memory_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>861</x>
      <y>2713</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
memory_fops</panel_attributes>
    <additional_attributes>160.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>850</x>
      <y>2718</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MINOR=3</panel_attributes>
    <additional_attributes>150.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>844</x>
      <y>2721</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op = &amp;null_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>864</x>
      <y>2719</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果filp-&gt;f_op-&gt;open
不为空，继续桥接</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>874</x>
      <y>2722</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>941</x>
      <y>2719</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty_open
1.识别设备号
2.通过设备号，找到tty_driver，并通过driver找到tty
3.tty链路层ldisc.open
4.tty.driver.open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>877</x>
      <y>2714</y>
      <w>70</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty_fops</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>892</x>
      <y>2725</y>
      <w>47</w>
      <h>44</h>
    </coordinates>
    <panel_attributes>1.存储noctty(表示进程如果没有代开tty，第一次打开tty
	会将打开的tty作为进程的tty，但是如果这个标志置上，
	则不会成为进程的tty)
	noctty = filp-&gt;f_flags &amp; O_NOCTTY
2.如果是/dev/tty，需要检查current-&gt;tty，如果存在
	获取设备号
	device = current-&gt;tty-&gt;device
	 filp-&gt;f_flags |= O_NONBLOCK
3.如果是/dev/tty0，获取前台console（fg_console），因为
	fg_console是从0开始计数，tty*是从1开始计数，所以：
	device = MKDEV(TTY_MAJOR, fg_console + 1);
	noctty = 1;
4.如果是/dev/console，查找console_drivers链表中device
	存在的console，并获取设备号：
	device = c-&gt;device(c);
	filp-&gt;f_flags |= O_NONBLOCK; /* Don't let /dev/console block */
	noctty = 1
5.如果是/dev/ptmx,扫描伪终端主设备数组ptm_driver，根据driver组装
	device = MKDEV(driver-&gt;major, minor)
	然后试图init_dev，如果正确返回，ptmx_found
注：/dev/tty0，(4,0)系统当前虚拟终端，由键盘和显示器组成,
					可以通过CONFIG_VT开关
	/dev/tty,(5,0)当前进程使用的终端，可以是tty0，可以是URAT
					或者其他终端设备
	/dev/comsole，（5,1）系统当前使用的控制台，默认是tty0，也可以是URAT
	/dev/ptmx，是伪终端设备的总入口，在打开时临时分配设备号，参考P1190
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>911</x>
      <y>2722</y>
      <w>39</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>947</x>
      <y>2722</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>956</x>
      <y>2725</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ptmx_found
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>940</x>
      <y>2732</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>set_bit(TTY_PTY_LOCK, &amp;tty-&gt;flags)
 //算出伪终端设备在driver终端的偏移量
minor -= driver-&gt;minor_start
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>950</x>
      <y>2728</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>968</x>
      <y>2733</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devpts_pty_new</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>960</x>
      <y>2728</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为slave创建inode</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>942</x>
      <y>2742</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //获取devpts的sb
sb = devpts_mnt-&gt;mnt_sb
sbi = SBI(sb)
 //如果inode存在，则直接返回
if ( sbi-&gt;inodes[number] )
		return
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>950</x>
      <y>2736</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>963</x>
      <y>2741</y>
      <w>37</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>inode = new_inode(sb)
inode-&gt;i_ino = number+2;
inode-&gt;i_blocks = 0;
inode-&gt;i_blksize = 1024;
inode-&gt;i_uid = sbi-&gt;setuid ? sbi-&gt;uid : current-&gt;fsuid;
inode-&gt;i_gid = sbi-&gt;setgid ? sbi-&gt;gid : current-&gt;fsgid;
inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = CURRENT_TIME;
init_special_inode(inode, S_IFCHR|sbi-&gt;mode, kdev_t_to_nr(device))
 //因为new_inode可能睡，所以需要再次检查
if ( sbi-&gt;inodes[number] ) {
		iput(inode);
		return;
}
sbi-&gt;inodes[number] = inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>972</x>
      <y>2736</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>998</x>
      <y>2734</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty_register_devfs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>960</x>
      <y>2728</y>
      <w>44</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为slave注册devfs</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1003</x>
      <y>2737</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1001</x>
      <y>2739</y>
      <w>22</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>tty.driver = *driver;
tty.device = MKDEV (driver-&gt;major, minor)

mode默认：mode = S_IFCHR | S_IRUSR | S_IWUSR
/dev/tty，/dev/ptmx加上：mode |= S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH

major=2（静态分配的伪终端主设备）flags |= DEVFS_FL_AUTO_OWNER
动态分配的伪终端主设备：flags |= DEVFS_FL_CURRENT_OWNER

devfs_register（name:tty-&gt;driver.name，idx + tty-&gt;driver.name_base嵌入到name中）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1036</x>
      <y>2729</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>946</x>
      <y>2722</y>
      <w>96</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;940.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1023</x>
      <y>2735</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_tty_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1024</x>
      <y>2742</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>遍历tty_drivers找到：
tty_driver.major = major
tty_driver.minor_start&lt;minor &lt; tty_driver.minor_start+tty_driver.num
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1028</x>
      <y>2732</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1029</x>
      <y>2738</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1041</x>
      <y>2735</y>
      <w>38</w>
      <h>44</h>
    </coordinates>
    <panel_attributes>1.算出device在driver中偏移量
	idx = MINOR(device) - driver-&gt;minor_start
2.如果driver-&gt;table[idx]中的tty存在，就找到了，fast_track
3.如果没找到：
	1.通过alloc_tty_struct申请tty，然后通过initialize_tty_struct
		初始化，并初始化driver和device
		tty-&gt;device = device;
		tty-&gt;driver = *driver
	2.如果driver-&gt;termios[idx]不存在，通过kmalloc在cache中申请，
		并初始化为driver-&gt;init_termios
	3.如果driver-&gt;termios_locked[idx]不存在，通过kmalloc在cache中申请
		并初始化为0
	4.如果是伪终端设备（TTY_DRIVER_TYPE_PTY），通过alloc_tty_struct
		为另一设备申请tty，并通过initialize_tty_struct初始化，并设置device和driver
		o_tty-&gt;device = (kdev_t) MKDEV(driver-&gt;other-&gt;major,
					driver-&gt;other-&gt;minor_start + idx);
		o_tty-&gt;driver = *driver-&gt;other
		如果另一设备的termios不存在，通过kmalloc申请，并初始化为driver-&gt;other-&gt;init_termios
		如果另一设备的termios_locked不存在，通过kmalloc申请，并初始化为0
		driver-&gt;other-&gt;table[idx] = o_tty
		o_tty-&gt;termios = *o_tp_loc;
		o_tty-&gt;termios_locked = *o_ltp_loc
		(*driver-&gt;other-&gt;refcount)++
		如果是主设备（PTY_TYPE_MASTER），从设备：o_tty-&gt;count++
		建立起主从设备的联系：
		tty-&gt;link   = o_tty;
		o_tty-&gt;link = tty
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1042</x>
      <y>2732</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1044</x>
      <y>2780</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_tty_struct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1030</x>
      <y>2786</y>
      <w>40</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果PAGE_SIZE大于8k,则通过kmalloc在cache中申请
2.如果小于等于8k，通过get_zeroed_page从伙伴系统中申请
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1049</x>
      <y>2783</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1068</x>
      <y>2780</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>initialize_tty_struct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1075</x>
      <y>2785</y>
      <w>28</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>memset(tty, 0, sizeof(struct tty_struct));
tty-&gt;magic = TTY_MAGIC;
 //分配链路层ldiscs
tty-&gt;ldisc = ldiscs[N_TTY];
tty-&gt;pgrp = -1; 
 //用于存储传递过来的目标码
tty-&gt;flip.char_buf_ptr = tty-&gt;flip.char_buf;
tty-&gt;flip.flag_buf_ptr = tty-&gt;flip.flag_buf;
tty-&gt;flip.tqueue.routine = flush_to_ldisc;
tty-&gt;flip.tqueue.data = tty;
init_MUTEX(&amp;tty-&gt;flip.pty_sem);
init_waitqueue_head(&amp;tty-&gt;write_wait);
init_waitqueue_head(&amp;tty-&gt;read_wait);
tty-&gt;tq_hangup.routine = do_tty_hangup;
tty-&gt;tq_hangup.data = tty;
sema_init(&amp;tty-&gt;atomic_read, 1);
sema_init(&amp;tty-&gt;atomic_write, 1);
spin_lock_init(&amp;tty-&gt;read_lock);
INIT_LIST_HEAD(&amp;tty-&gt;tty_files);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1077</x>
      <y>2783</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1049</x>
      <y>2778</y>
      <w>6</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1071</x>
      <y>2778</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1081</x>
      <y>2736</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>driver-&gt;table[idx] = tty
tty-&gt;termios = *tp_loc;
tty-&gt;termios_locked = *ltp_loc;
(*driver-&gt;refcount)++;
tty-&gt;count++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1042</x>
      <y>2732</y>
      <w>51</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
处理新申请的tty，tp_loc，ltp_loc</panel_attributes>
    <additional_attributes>10.0;10.0;490.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1110</x>
      <y>2736</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;ldisc.open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1042</x>
      <y>2732</y>
      <w>76</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty_ldisc_N_TTY</panel_attributes>
    <additional_attributes>10.0;10.0;740.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1110</x>
      <y>2743</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>n_tty_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1114</x>
      <y>2739</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1094</x>
      <y>2746</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!tty-&gt;read_buf
如果!tty-&gt;read_buf不存在</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1089</x>
      <y>2750</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_buf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1083</x>
      <y>2757</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1，如果在in_interrupt中，采用GFP_ATOMIC
	申请内存，否则使用GFP_KERNEL申请
	这个允许等待和同步
2.如果N_TTY_BUF_SIZE和PAGE_SIZE
	不相等，则通过kmalloc在cache中
	申请，并清0；否则通过get_zeroed_page
	在buddy中申请
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1093</x>
      <y>2753</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1108</x>
      <y>2752</y>
      <w>24</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>memset(tty-&gt;read_buf, 0, N_TTY_BUF_SIZE);
reset_buffer_flags(tty);
tty-&gt;column = 0;
n_tty_set_termios(tty, 0);
tty-&gt;minimum_to_wake = 1;
tty-&gt;closing = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1116</x>
      <y>2746</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1108</x>
      <y>2765</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reset_buffer_flags</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1112</x>
      <y>2762</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1086</x>
      <y>2772</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>tty-&gt;read_head = tty-&gt;read_tail = tty-&gt;read_cnt = 0
tty-&gt;canon_head = tty-&gt;canon_data = tty-&gt;erasing = 0
memset(&amp;tty-&gt;read_flags, 0, sizeof tty-&gt;read_flags)
 //tty.count不为0，tty-&gt;flags的TTY_THROTTLED置上时
 //执行tty-&gt;driver.unthrottle
check_unthrottle
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1101</x>
      <y>2768</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1131</x>
      <y>2766</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>n_tty_set_termios</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1121</x>
      <y>2762</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置tty.process_char_map</panel_attributes>
    <additional_attributes>20.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1127</x>
      <y>2736</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>o_tty-&gt;ldisc.open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1042</x>
      <y>2732</y>
      <w>94</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果o_tty和o_tty-&gt;ldisc.open存在</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1148</x>
      <y>2736</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fast_track
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1043</x>
      <y>2732</y>
      <w>112</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在driver-&gt;table[idx]中有</panel_attributes>
    <additional_attributes>10.0;10.0;1100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1137</x>
      <y>2744</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.测试tty-&gt;flags中TTY_CLOSING置上
	报错
2.如果是伪终端的主设备（如果此时tty.count
	存在，报错),将从设备tty-&gt;link-&gt;count++
3.更新tty
	tty-&gt;count++;
	tty-&gt;driver = *driver
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1146</x>
      <y>2739</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>946</x>
      <y>2722</y>
      <w>241</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2390.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1178</x>
      <y>2731</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_dev_done
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1164</x>
      <y>2739</y>
      <w>25</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>filp-&gt;private_data = tty
 //将file.list链接到tty-&gt;tty_files链表中
file_move
 //tty的count包括tty_files中的file的数量
 //+1（如果是伪终端从设备的或，加上主设备的）
check_tty_count
 //如果是伪终端主设备
noctty = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>2734</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1190</x>
      <y>2739</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;driver.open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1182</x>
      <y>2734</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1194</x>
      <y>2742</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
con_init-&gt;console_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1163</x>
      <y>2751</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
currcons是minor的偏移量</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1157</x>
      <y>2759</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vc_allocate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1149</x>
      <y>2762</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1145</x>
      <y>2766</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>偏移量不能大于
虚拟终端的数量
否则返回-ENXIO
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1158</x>
      <y>2762</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果vc_cons[currcons].d存在
返回0，如果不存在</panel_attributes>
    <additional_attributes>60.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1146</x>
      <y>2767</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1127</x>
      <y>2775</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.检查偏移量
2.检查进程的CAP_SYS_RESOURCE
	权限
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1155</x>
      <y>2776</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1158</x>
      <y>2767</y>
      <w>16</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请vc_data +vt_struct
的内存</panel_attributes>
    <additional_attributes>120.0;10.0;30.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1169</x>
      <y>2774</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //指向vc_data
vc_cons[currcons].d
 //指向vt_struct
vt_cons[currcons]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1170</x>
      <y>2767</y>
      <w>7</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1184</x>
      <y>2774</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>visual_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1170</x>
      <y>2767</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化 vc_cons[currcons].d
中的变量</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1173</x>
      <y>2759</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>vt_cons[currcons]-&gt;vc_num = currcons;
tty-&gt;driver_data = vt_cons[currcons]
 //如果下面两项同时为0时
tty-&gt;winsize.ws_row = video_num_lines;
tty-&gt;winsize.ws_col = video_num_columns
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1190</x>
      <y>2748</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>con_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1183</x>
      <y>2751</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1206</x>
      <y>2759</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vcs_make_devfs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1191</x>
      <y>2751</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty-&gt;count == 1时
创建虚拟终端的buffer及属性的设备文件</panel_attributes>
    <additional_attributes>50.0;10.0;200.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1199</x>
      <y>2769</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_unregister</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1218</x>
      <y>2769</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_register
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1204</x>
      <y>2765</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1211</x>
      <y>2765</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1211</x>
      <y>2762</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
（7，1~63）buffer
（7，129~191）attribute
devfs_handle是vcs_init中初始化为/dev/vcc</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1228</x>
      <y>2740</y>
      <w>43</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.filp-&gt;f_flags = saved_flags
2.如果之前没错，测试现在如果不是特权用户
	访问TTY_EXCLUSIVE的tty，报EBUSY
3.如果之前有错，释放dev（release_dev）
	只有在是ERESTARTSYS错并且没有signal
	待处理时，会调度之后，然后再次通过filp-&gt;f_op = &amp;tty_fops
	重新open
	否则直接return
4.如果noctty没置上，并且时当前session的主进程（current-&gt;leader）
	且这个进程没有tty，tty.session不存在：
	current-&gt;tty = tty
	current-&gt;tty_old_pgrp = 0;
	tty-&gt;session = current-&gt;session;
	tty-&gt;pgrp = current-&gt;pgrp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1183</x>
      <y>2734</y>
      <w>69</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>877</x>
      <y>2714</y>
      <w>425</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_init-&gt;usb_major_init-&gt;usb_fops
如果在devfs中注册了，直接执行driver中的open</panel_attributes>
    <additional_attributes>10.0;10.0;4230.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1293</x>
      <y>2725</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1284</x>
      <y>2733</y>
      <w>32</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.获取usb_driver(usb_minors[minor/16]),并通过
	fops_get获取driver中的fops
2.如果fops存在，将其赋值：
	file-&gt;f_op = new_fops
	如果其中的open接口存在，执行
	file-&gt;f_op-&gt;open
3.如果执行出错，将fops还原：
	file-&gt;f_op = fops_get(old_fops)
4.释放旧的fops，注意这里不管出没出错，都应该释放掉
	这是释放之前的old_fops
	fops_put(old_fops)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1299</x>
      <y>2728</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1290</x>
      <y>2755</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1295</x>
      <y>2751</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1295</x>
      <y>2758</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_scanner_init-&gt;usb_register(scanner_driver)
-&gt;usb_scanner_fops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1290</x>
      <y>2762</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>open_scanner</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1281</x>
      <y>2769</y>
      <w>29</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.算出scanner在p_scn_table中的位置：
	scn_minor=MINOR((X)-&gt;i_rdev) - SCN_BASE_MNR
2.获取scn_usb_data(要存在，否则返回ENODEV)
	scn = p_scn_table[scn_minor]
	dev = scn-&gt;scn_dev
3.filter:
	1.dev要存在
	2.scanner要被初始化（scn-&gt;present）
	3.scanner没被打开（!scn-&gt;isopen）
4.init_waitqueue_head(&amp;scn-&gt;rd_wait_q)
	scn-&gt;isopen = 1
	file-&gt;private_data = scn
	MOD_INC_USE_COUNT
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1295</x>
      <y>2765</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>826</x>
      <y>2699</y>
      <w>714</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISFIFO
def_fifo_fops</panel_attributes>
    <additional_attributes>10.0;10.0;7120.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1532</x>
      <y>2723</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fifo_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1495</x>
      <y>2731</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过PIPE_SEM保护整个过程
2.如果没有申请inode-&gt;i_pipe，通过
	pipe_new申请fifo页面和pipe_inode_info
3.filp-&gt;f_version = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1504</x>
      <y>2726</y>
      <w>36</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1521</x>
      <y>2733</y>
      <w>36</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.桥接fops：
	filp-&gt;f_op = &amp;read_fifo_fops;
2.增加读端计数：
	//注：这里在pipe_new中被设置成1
	PIPE_RCOUNTER(*inode)++;
3.PIPE_READERS++，如果之前是0，通过
	wake_up_partner唤醒等待队列PIPE_WAIT
4.如果之前没有PIPE_WRITERS：
	1.如果要求O_NONBLOCK：
	filp-&gt;f_version = PIPE_WCOUNTER(*inode)
	并返回0
	2.如果要求block，通过wait_for_partner等待（pipe_wait）
		PIPE_RCOUNTER变化，如果醒来发现是信号唤醒，唤醒等待
		队列，并返回ERESTARTSYS
	注：如果此时reader和writer都没有，将整个pipe释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1538</x>
      <y>2726</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filp-&gt;f_mode</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1531</x>
      <y>2729</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1
只读</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1538</x>
      <y>2729</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
２
只写</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1559</x>
      <y>2733</y>
      <w>39</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果要求O_NONBLOCK，但是没有PIPE_READERS
	直接返回ENXIO
2.桥接fops：
	filp-&gt;f_op = &amp;write_fifo_fops
3.增加写端计数：
	PIPE_WCOUNTER(*inode)++
4.PIPE_WRITERS(*inode)++，如果之前没有writer
	通过唤醒PIPE_WAIT
5.如果没有reader，通过wait_for_partner等待PIPE_RCOUNTER
	计数不同。如果醒来之后，发现是信号唤醒，释放PIPE_WRITERS
	如果减至0，唤醒等待队列。
注：在５的时候肯定是要求ｂｌｏｃｋ的
	如果最后ｒｅａｄｅｒ和ｗｒｉｔｅｒ都没有，释放ｐｉｐｅ
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1538</x>
      <y>2729</y>
      <w>68</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
３
可读可写</panel_attributes>
    <additional_attributes>10.0;10.0;660.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1599</x>
      <y>2733</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>１.PIPE_READERS(*inode)++;
	PIPE_WRITERS(*inode)++;
	PIPE_RCOUNTER(*inode)++;
	PIPE_WCOUNTER(*inode)++;
２.如果之前没有ｒｅａｄｅｒ或者ｗｒｉｔｅｒ
	尝试通过wake_up_partner唤醒等待队列
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1703</x>
      <y>2652</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_close</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1648</x>
      <y>2663</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.fd不能大于max_fds
2，files-&gt;fd[fd]不能为空
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1656</x>
      <y>2655</y>
      <w>55</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>530.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1673</x>
      <y>2663</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>files-&gt;fd[fd] = NULL;
 //当进程通过execv时，close_on_exec
 //指示要关闭的文件
FD_CLR(fd, files-&gt;close_on_exec);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1683</x>
      <y>2655</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1703</x>
      <y>2664</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__put_unused_fd
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1708</x>
      <y>2655</y>
      <w>5</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1725</x>
      <y>2665</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp_close</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1708</x>
      <y>2655</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1695</x>
      <y>2668</y>
      <w>37</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1689</x>
      <y>2675</y>
      <w>15</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.file.f_count不为0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1713</x>
      <y>2668</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果文件系统想在文件关闭之前
将文件写入到设备中
（filp-&gt;f_op-&gt;flush存在）</panel_attributes>
    <additional_attributes>170.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1711</x>
      <y>2675</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;flush
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1729</x>
      <y>2675</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fcntl_dirnotify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1746</x>
      <y>2675</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_remove_posix</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1730</x>
      <y>2668</y>
      <w>9</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TODO:</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1730</x>
      <y>2668</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1767</x>
      <y>2675</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1730</x>
      <y>2668</y>
      <w>44</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1752</x>
      <y>2678</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历inode-&gt;i_flock链表
将该进程（owner）对该文件上的
所有POSIX锁都清掉
TODO:</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1747</x>
      <y>2686</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_unlock_delete</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1764</x>
      <y>2684</y>
      <w>33</w>
      <h>37</h>
    </coordinates>
    <panel_attributes> //递减file的引用计数
if (atomic_dec_and_test(&amp;file-&gt;f_count)) {
	//如果此时file引用减到0
	//移除协调锁 TODO:
	locks_remove_flock(file);
  //对应ext2_release_file ，将预分配的数据块释放
	if (file-&gt;f_op &amp;&amp; file-&gt;f_op-&gt;release)
		file-&gt;f_op-&gt;release(inode, file);
	//递减模块的动态安装计数
	fops_put(file-&gt;f_op);
	file-&gt;f_dentry = NULL;
	file-&gt;f_vfsmnt = NULL;
	//在dentry_open中get_write_access
	if (file-&gt;f_mode &amp; FMODE_WRITE)
		put_write_access(inode);
	dput(dentry);
	if (mnt)
		mntput(mnt)
	//从sb的s_files中移到free_list中
	list_del(&amp;file-&gt;f_list);
	list_add(&amp;file-&gt;f_list, &amp;free_list);
	files_stat.nr_free_files++;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1774</x>
      <y>2678</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1789</x>
      <y>2724</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;release
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1777</x>
      <y>2720</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1768</x>
      <y>2731</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_read_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1775</x>
      <y>2727</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
read_pipe_fops
</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1789</x>
      <y>2731</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_write_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1791</x>
      <y>2727</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
write_pipe_fops
</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1780</x>
      <y>2738</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1773</x>
      <y>2734</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
第二个参数是读权限
第三个参数是写权限</panel_attributes>
    <additional_attributes>20.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1786</x>
      <y>2734</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1774</x>
      <y>2746</y>
      <w>34</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.通过信号量inode.sem对整个过程进行保护
2.递减PIPE_READERS和PIPE_WRITERS的计数
3.如果readers和writers都为0：
	//释放fifo缓存，释放i_pipe
	inode-&gt;i_pipe = NULL;
	free_page((unsigned long) info-&gt;base);
	kfree(info);
4.如果不是都为0，通过wake_up_interruptible唤醒
	i_pipe的等待队列
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1785</x>
      <y>2741</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1800</x>
      <y>2727</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
socket_file_ops
</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1828</x>
      <y>2731</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_close</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1834</x>
      <y>2734</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1822</x>
      <y>2738</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.file的inode要存在
2.通过sock_fasync撤销（第三个参数为0）file在sock上的异步等待
3.通过sock_release将sock释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1820</x>
      <y>2748</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_fasync</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1826</x>
      <y>2744</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1809</x>
      <y>2754</y>
      <w>34</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.如果是插入异步监听（on），通过kmalloc申请一个fasync_struct
2.通过socki_lookup找到sock（本file的sock）
3.遍历sock.fasync_list链表
	1.查看其中是否有和当前file相同的fasync_struct
	2.如果是插入异步监听（on）
		1.如果3.1中查到有和当前file相同的fasync_struct：
			fa-&gt;fa_fd=fd;
			kfree(fna)//释放1申请的fasync_struct
		2.如果没有相同的fasync_struct，将其赋值后，头插至sock-&gt;fasync_list
	3.如果是撤销异步监听
		1.如果找到了fasync_struct，将其从链表中删除：
			*prev=fa-&gt;fa_next;
			kfree(fa)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1825</x>
      <y>2751</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1856</x>
      <y>2749</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1838</x>
      <y>2744</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1847</x>
      <y>2755</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过sock-&gt;ops-&gt;release将sock释放
2.如果fasync_list不为空，打印报错信息
 （fasync_list在有链接时会在unix_release_sock中sk_wake_async遍历唤醒）
3.sockets_in_use.counter--
4.如果sock没有file，通过iput将sock对应的inode释放
5.sock-&gt;file=NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1862</x>
      <y>2752</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1857</x>
      <y>2773</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1857</x>
      <y>2767</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;release
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1862</x>
      <y>2764</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1862</x>
      <y>2770</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops/unix_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1852</x>
      <y>2780</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果sock没分配sk，直接返回0
2.如果有分配：
	sock-&gt;sk = NULL
3.通过unix_release_sock释放sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1862</x>
      <y>2776</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1856</x>
      <y>2791</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_release_sock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1862</x>
      <y>2787</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1840</x>
      <y>2798</y>
      <w>56</w>
      <h>62</h>
    </coordinates>
    <panel_attributes>1.通过unix_remove_socket将sk从hash表中删除
	//通过af_unix.lock保护整个过程
2.通过sock_orphan使sk关系断开：
	sk-&gt;dead = 1;
	sk-&gt;socket = NULL;
	sk-&gt;sleep = NULL;
注；整个过程被callback_lock保护，所以如果单独读dead，可以对callback_lock上读锁
	但是在读dead时，还有读shutdown等变量，所以大多数时用的是af_unix.loc
3.置shutdown，分别将sk的dentry，mnt，state取出来，然后将sk的这三个属性清除
	sk-&gt;shutdown = SHUTDOWN_MASK;
	dentry = sk-&gt;protinfo.af_unix.dentry;
	sk-&gt;protinfo.af_unix.dentry=NULL;
	mnt = sk-&gt;protinfo.af_unix.mnt;
	sk-&gt;protinfo.af_unix.mnt=NULL;
	state = sk-&gt;state;
	sk-&gt;state = TCP_CLOSE;
	//释放af_unix.lock锁
4.通过wake_up_interruptible_all唤醒peer_wait等待队列
注：1.peer_wait只有在无连接发送的时候receive_queue超出限制时，会使用这个队列
	2.sleep在有链接发送时，senbuf满了之后会用；或者在接收时（不管有链接还是无连接）
		receive_queue中没有skb会用
	3.最重要，在有链接connect时，会将sleep队列指向peer_wait
5.通过unix_peer获取与sk连接的skpair，如果skpair存在时：
	1.如果是有链接（SOCK_STREAM），
		skpair-&gt;shutdown=SHUTDOWN_MASK
		skpair-&gt;err = ECONNRESET //receive_queue不为空，或者调用者要求（参数是1）
		skpair-&gt;state_change(skpair)//通知skpair状态改变
		sk_wake_async(skpair,1,POLL_HUP)//唤醒skpair对应sock的异步队列
	2.不管是有链接还是无连接：
		sock_put(skpair)
		unix_peer(sk) = NULL
6.通过skb_dequeue从sk.receive_queue
	1.如果现在释放的sk处于TCP_LISTEN状态（3中存储的）所以skb存储的是client端connect报文，
		递归调用unix_release_sock释放skb中对应的子serve_sock，注意调用参数是1，会强行将sk.err置上
	2.通过kfree_skb释放skb(不仅包含skb空间，包含sendbuf，发送方sk计数，发送方sk.cb中的fp数组，以及数组中的file)
7.释放dentry，mnt以及自己的sk（sock_put(sk)）
8.如果有还没被接收的file（unix_tot_inflight），通过unix_gc查看sk的hash表中是否有没被用户引用，但是被内核引用（inflight）
	的file（比如a将自己的sock_file授权给b，b也将自己的sock_file授权给a，但是a和b都没接收就close，因为在授权时，内核skb会递增
	对file的引用，导致两个进程都释放了file，但是file因为被skb引用没办法释放，而进程却没办法自己主动释放，所以只能由内核释放）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1862</x>
      <y>2794</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1841</x>
      <y>2870</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_def_wakeup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1841</x>
      <y>2863</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skpair-&gt;state_change
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1848</x>
      <y>2859</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1846</x>
      <y>2866</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1833</x>
      <y>2877</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果sk-&gt;sleep不为空，通过wake_up_interruptible_all
	唤醒这个等待队列
注；callback_lock保护
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1846</x>
      <y>2873</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1871</x>
      <y>2862</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_gc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1872</x>
      <y>2859</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1860</x>
      <y>2869</y>
      <w>49</w>
      <h>47</h>
    </coordinates>
    <panel_attributes>1.申请静态信号量unix_gc_sem，down_trylock保证只能有
	一个进程处理
 //unix_table_lock保护hash表操作
2.遍历unix_socket_table表中所有bind的sk
	af_unix.gc_tree=GC_ORPHAN //之后用于栈的链表
3.再次遍历unix_socket_table表中所有bind的sk，查找其中sock_file的计数超过sk的inflight计数
	的sk（因为只有大于才是有用户引用而不全是内核引用），通过maybe_unmark_and_push将其压栈（注意
	栈中的sk是不应该被处理的sk）
4.通过empty_stack检查栈gc_current是否为空
	1.通过pop_stack将sk弹出
	//receive_queue.lock保护skb移出队列
	2.通过skb_peek查看队列中第一个skb
	3.如果队列中有skb，遍历链表中的所有skb（注意这里的skb被没有从链表中移除）
		1.如果skb.cb中有fp，遍历其fp数组。通过unix_get_socket查看这个file是否对应sk，如果对应
			那么这个sk也被用户引用（因为这个skb一旦被接收，就会被用户引用，到时候用户自己释放），所以通过
			maybe_unmark_and_push将这个file对应的sk压栈
		2.如果sk的状态是TCP_LISTEN，说明这个skb是client的控制报文，skb.sk指向的子serve_sk（这个也会被父serve_sk接收）
			所以也会通过maybe_unmark_and_push将这个sk压栈
	4.通过sock_put将sk释放（因为maybe_unmark_and_push中增加了对sk的计数，但是pop_stack中却没有减少）
注：1.在这期间系统过maybe_unmark_and_push加入栈中的sk也会随着!empty_stack被遍历到，所以所以不是GC_ORPHAN
	的sk都会经历pop_stack，sock_put，最终栈的状态也会是empty_stack
	2.在栈中的sk不会重复压栈，因为maybe_unmark_and_push在开始就检查了GC_ORPHAN
5.通过skb_queue_head_init初始化链表hitlist
6.遍历unix_socket_table表中所有bind的sk，
	1.如果是GC_ORPHAN，并且其skb.cb.fp存在，将receive_queue中的所有skb放到hitlist
		__skb_unlink(skb, skb-&gt;list);
		__skb_queue_tail(&amp;hitlist,skb);
	2.最后将所有sk的状态都置为GC_ORPHAN
7.通过__skb_dequeue将hitlist中所有的skb移出队列，并通过kfree_skb将其释放
	（不仅包含skb空间，包含sendbuf，发送方sk计数，发送方sk.cb中的fp数组，以及数组中的file)）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1877</x>
      <y>2865</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1860</x>
      <y>2920</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>maybe_unmark_and_push</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1869</x>
      <y>2915</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1851</x>
      <y>2926</y>
      <w>32</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果不是GC_ORPHAN，直接退出（因为已经在栈中了）
2.通过sock_hold递增sk的计数
3.sk压栈
	x-&gt;protinfo.af_unix.gc_tree = gc_current
	gc_current = x
注：这里要注意栈的链表指针和标志GC_ORPHAN的指针是同一个
	所以只要sk在栈中，就不是GC_ORPHAN
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1867</x>
      <y>2923</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1893</x>
      <y>2920</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pop_stack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1891</x>
      <y>2915</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1887</x>
      <y>2927</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>p=gc_current;
gc_current = p-&gt;protinfo.af_unix.gc_tree;
return p;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1898</x>
      <y>2923</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>514</x>
      <y>3135</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>349</x>
      <y>3164</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>356</x>
      <y>3138</y>
      <w>165</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1630.0;10.0;10.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>329</x>
      <y>3171</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fcheck</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>334</x>
      <y>3167</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>333</x>
      <y>3174</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fd &lt; files-&gt;max_fds</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>327</x>
      <y>3179</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file = files-&gt;fd[fd]
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>353</x>
      <y>3167</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>355</x>
      <y>3172</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_file</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>355</x>
      <y>3179</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file.count++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>361</x>
      <y>3175</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>468</x>
      <y>3138</y>
      <w>53</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file不为空
FMODE_WRITE</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>444</x>
      <y>3149</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里只是验证访问的区域是否被锁上
并没有上锁，locks_mandatory_area
中只是临时上锁检验一下</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>438</x>
      <y>3158</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_verify_area</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>432</x>
      <y>3161</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 //上了锁
inode-&gt;i_flock &amp;&amp; 
 //该inode上强制锁
MANDATORY_LOCK(inode)</panel_attributes>
    <additional_attributes>120.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>432</x>
      <y>3168</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_mandatory_area</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>362</x>
      <y>3185</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_alloc_lock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>367</x>
      <y>3171</y>
      <w>75</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
account指示是否检查current-&gt;locks超过限制</panel_attributes>
    <additional_attributes>730.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>347</x>
      <y>3192</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>356</x>
      <y>3188</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>368</x>
      <y>3193</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;locks++
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>365</x>
      <y>3188</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>383</x>
      <y>3186</y>
      <w>44</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>new_fl-&gt;fl_owner = current-&gt;files;
new_fl-&gt;fl_pid = current-&gt;pid;
new_fl-&gt;fl_file = filp;
new_fl-&gt;fl_flags = FL_POSIX | FL_ACCESS;
new_fl-&gt;fl_type = 
(read_write == FLOCK_VERIFY_WRITE) ? F_WRLCK : F_RDLCK;
new_fl-&gt;fl_start = offset; //file-&gt;f_pos
new_fl-&gt;fl_end = offset + count - 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>394</x>
      <y>3171</y>
      <w>48</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>439</x>
      <y>3171</y>
      <w>39</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历inode-&gt;i_flock链表
如果FL_POSIX置上
遍历的posix锁的start小于申请锁的end
（如果大于，直接返回正确，说明锁进行了排序）</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>440</x>
      <y>3182</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>433</x>
      <y>3189</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>posix_locks_conflict</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>440</x>
      <y>3192</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>428</x>
      <y>3196</y>
      <w>35</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.申请的锁没打开posix锁的，直接返回正确（0）
2，是同一个进程加的锁，直接返回正确（0）
	//是同一个files
	fl1-&gt;fl_owner == fl2-&gt;fl_owner
	//是同一个pid
	&amp;&amp; fl1-&gt;fl_pid   == fl2-&gt;fl_pid
3.检查申请的lock（sys_fl），和存在的lock（caller_fl）
	是否有重叠
	(fl1-&gt;fl_end &gt;= fl2-&gt;fl_start) &amp;&amp;
	(fl2-&gt;fl_end &gt;= fl1-&gt;fl_start)
4.如果有重叠，如果存在的lock是读锁（F_RDLCK），
	申请的lock是写锁，则错误（1）
	如果申请的是写锁，则错误（1）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>448</x>
      <y>3182</y>
      <w>34</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果存在冲突</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>466</x>
      <y>3193</y>
      <w>64</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果file是O_NONBLOCK（不能阻断的），返回-EAGAIN
2.查看如果加上申请的锁，是否会形成死锁，如果死锁，返回-EDEADLK
	posix_locks_deadlock
		1.查看申请的锁和阻塞锁是否属于同一个进程（AA）,如果是的话，就是死锁
		2.等待锁序列blocked_list中是否有和阻塞锁是同一个进程的，如果有，说明
		阻塞锁所在的进程被pending（注释说等待序列blocked_list中同一个进程，正在等待
		的锁只有一个，是因为进程只要有一个锁在等待序列中，进程就pending）
		3.在等待序列中的锁的fl_next字段，指向的是这个所等待的锁（见locks_block_on）（
		不在这个等待序列中的fl_next字段是连在inode-&gt;i_flock链表中的），
		4.如果找到等待序列中的锁和block的锁属于同一进程，说明该进程被另一个进程的锁block，具体对应
		的锁是fl-&gt;fl_next，如果这个锁和要申请的锁属于同一个进程，那么就发生死锁（AB BA）。
		5.如果不是同一个进程，重复2，3，4，查看是否有没有AB BA的死锁
3.	如果不会死锁，通过locks_block_on对进程加锁
4.如果醒来之后，发现强制锁被清了之后，直接退出，否者重新查看该锁是否存在冲突
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>487</x>
      <y>3220</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_block_on</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>494</x>
      <y>3216</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>446</x>
      <y>3227</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_insert_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>483</x>
      <y>3228</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>interruptible_sleep_on_locked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>558</x>
      <y>3227</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_delete_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>454</x>
      <y>3223</y>
      <w>41</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>493</x>
      <y>3223</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>493</x>
      <y>3223</y>
      <w>74</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>419</x>
      <y>3235</y>
      <w>34</w>
      <h>13</h>
    </coordinates>
    <panel_attributes> //加在blocker的链表中，链表中的实体被blocker阻塞
list_add_tail(&amp;waiter-&gt;fl_block,
			&amp;blocker-&gt;fl_block);
 //注意这里fl_next指向的是阻塞自己的实体
waiter-&gt;fl_next = blocker;
 //加载在等待序列中
list_add(&amp;waiter-&gt;fl_link, &amp;blocked_list);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>430</x>
      <y>3230</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>455</x>
      <y>3240</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>current-&gt;state = TASK_INTERRUPTIBLE;
 //加到等待锁的唤醒队列中
add_wait_queue(fl_wait, &amp;wait);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>466</x>
      <y>3231</y>
      <w>30</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>494</x>
      <y>3231</y>
      <w>6</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>491</x>
      <y>3237</y>
      <w>9</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
timeout=0</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>494</x>
      <y>3237</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
时间到了之后自己被timer唤醒</panel_attributes>
    <additional_attributes>40.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>485</x>
      <y>3243</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>502</x>
      <y>3242</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>schedule_timeout</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>494</x>
      <y>3231</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
有不是block的信号将其唤醒时
报错ERESTARTSYS</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>520</x>
      <y>3241</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>signal_pending</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>537</x>
      <y>3241</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_wait_queue(fl_wait, &amp;wait);
current-&gt;state = TASK_RUNNING;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>494</x>
      <y>3231</y>
      <w>55</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;530.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>565</x>
      <y>3236</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>list_del(&amp;waiter-&gt;fl_block);
INIT_LIST_HEAD(&amp;waiter-&gt;fl_block);
list_del(&amp;waiter-&gt;fl_link);
INIT_LIST_HEAD(&amp;waiter-&gt;fl_link);
waiter-&gt;fl_next = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>565</x>
      <y>3230</y>
      <w>9</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>639</x>
      <y>3152</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;write
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>468</x>
      <y>3149</y>
      <w>179</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1770.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>652</x>
      <y>3159</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_file_write
1.计算pos，算出在inode的逻辑block
2.根据逻辑block和adress_space看是否存在内存（page）（__grab_cache_page）
3.如果没有内存就要分配page和bh（create_empty_buffers）
4.如果是分配的bh，需要由逻辑block推导出实际block（ext2_get_block）
5.如果实际block不存在，需要create（ext2_find_goal 找到实际block
	ext2_alloc_branch 使索引chain完整
	）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>645</x>
      <y>3155</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_file_operations</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>536</x>
      <y>3162</y>
      <w>125</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file-&gt;f_error
如果之前有错，直接返回</panel_attributes>
    <additional_attributes>1230.0;10.0;10.0;290.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>531</x>
      <y>3191</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_error=0
goto out
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>551</x>
      <y>3162</y>
      <w>110</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
O_APPEND</panel_attributes>
    <additional_attributes>1080.0;10.0;10.0;300.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>544</x>
      <y>3192</y>
      <w>15</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>pos = inode-&gt;i_size
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>562</x>
      <y>3162</y>
      <w>100</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
current-&gt;rlim[RLIMIT_FSIZE].rlim_cur
 != RLIM_INFINITY</panel_attributes>
    <additional_attributes>980.0;10.0;10.0;280.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>560</x>
      <y>3190</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果现在文件的位置pos已经超过了limit
	send_sig(SIGXFSZ, current, 0);
	goto out;
2.如果要添加的内容超过了limit
	send_sig(SIGXFSZ, current, 0);
 //pos如果不是append，就是file-&gt;f_pos
	count = limit - pos;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>606</x>
      <y>3162</y>
      <w>56</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
count
如果此次写操作有效</panel_attributes>
    <additional_attributes>540.0;10.0;10.0;270.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>596</x>
      <y>3188</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>591</x>
      <y>3195</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>remove_suid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>551</x>
      <y>3205</y>
      <w>45</w>
      <h>7</h>
    </coordinates>
    <panel_attributes> //如果S_IXGRP置上，就将S_ISGID置上，S_ISUID一直置
mode = (inode-&gt;i_mode &amp; S_IXGRP)*(S_ISGID/S_IXGRP) | S_ISUID;
	//这里是查看inode中的S_ISGID和S_ISUID权限
mode &amp;= inode-&gt;i_mode;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>579</x>
      <y>3198</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>588</x>
      <y>3198</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果inode有S_ISGID和S_ISUID权限，
但是进程却不具备setuid的特权
mode &amp;&amp; !capable(CAP_FSETID)</panel_attributes>
    <additional_attributes>80.0;10.0;170.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>601</x>
      <y>3206</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //清除inode的setuid特权
inode-&gt;i_mode &amp;= ~mode;
mark_inode_dirty(inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>606</x>
      <y>3188</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>604</x>
      <y>3195</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_ctime = inode-&gt;i_mtime = CURRENT_TIME;
mark_inode_dirty_sync(inode)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>659</x>
      <y>3162</y>
      <w>21</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环写入数据字节数count</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>647</x>
      <y>3177</y>
      <w>19</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>642</x>
      <y>3196</y>
      <w>27</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>offset = (pos &amp; (PAGE_CACHE_SIZE -1));
index = pos &gt;&gt; PAGE_CACHE_SHIFT;
 //现在一页内写入数据
bytes = PAGE_CACHE_SIZE - offset;
 //写入的长度最大不能超过count
if (bytes &gt; count) {
	bytes = count;
	deactivate = 0;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>678</x>
      <y>3197</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__grab_cache_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>663</x>
      <y>3177</y>
      <w>23</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>670</x>
      <y>3206</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>674</x>
      <y>3200</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>646</x>
      <y>3214</y>
      <w>32</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_hash_table+_page_hashfn(mapping,index)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>664</x>
      <y>3209</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>691</x>
      <y>3205</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__find_lock_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>686</x>
      <y>3200</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>679</x>
      <y>3213</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__find_page_nolock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>685</x>
      <y>3208</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>658</x>
      <y>3220</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.遍历hash，过滤出mapping相同，index相同的page
2.增加引用page的寿命，如果page短缺，将激活kswapd进程
age_page_up(page);
if (inactive_shortage() &gt; inactive_target / 2 &amp;&amp; free_shortage())
		wakeup_kswapd(0);
注：page-&gt;index被抽象为在硬盘的偏移，普通的page被抽象为在
	交换设备中的偏移inode的buffer被抽象为在inode中的偏移
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>673</x>
      <y>3216</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>693</x>
      <y>3215</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>693</x>
      <y>3208</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在hash中找到page</panel_attributes>
    <additional_attributes>60.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>694</x>
      <y>3210</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加page.count的计数</panel_attributes>
    <additional_attributes>90.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>708</x>
      <y>3215</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lock_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>702</x>
      <y>3210</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>700</x>
      <y>3222</y>
      <w>40</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.TryLockPage，这里调用test_and_set_bit，
	会将page锁上，并通过sbbl检查之前的位，如果是0
	则返回0，否则返回-1
2.如果不为0，__lock_page
	1.增加局部变量wait（current），并将其加入到page-&gt;wait
	2.利用page提供的硬盘的page-&gt;mapping，将page同步到硬盘
	3.将task设置为TASK_UNINTERRUPTIBLE
	4.如果此时page还是锁着的，将tq_disk链表中存储的routine
		执行一遍（run_task_queue），然后调度schedule
	5.醒来之后继续TryLockPage
	6.如果锁上之后：
		tsk-&gt;state = TASK_RUNNING;
		remove_wait_queue(&amp;page-&gt;wait, &amp;wait)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>713</x>
      <y>3218</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>726</x>
      <y>3216</y>
      <w>10</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>return page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>702</x>
      <y>3210</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page-&gt;mapping
如果醒来之后还在hash</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>742</x>
      <y>3216</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>UnlockPage(page);
page_cache_release(page);
goto repeat;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>701</x>
      <y>3210</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不在hash中，则释放这个page，重新查找</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>699</x>
      <y>3208</y>
      <w>75</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在hash中没找到page</panel_attributes>
    <additional_attributes>10.0;10.0;730.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>766</x>
      <y>3215</y>
      <w>39</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.如果caller提供了cached_page,就使用caller提供的（或者
	在下面add_to_page_cache_unique为1时，cache中的页面）
	否者通过page_cache_alloc申请一个页面
2.调用add_to_page_cache_unique
	1.__find_page_nolock查找是否在page
	2.如果在hash中没找到，利用__add_to_page_cache加入
		到hash和inode的链表中
	__add_to_page_cache
		//清掉flag
		flags = page-&gt;flags &amp; ~((1 &lt;&lt; PG_uptodate) | (1 &lt;&lt; PG_error) | (1 &lt;&lt; PG_dirty) | (1 &lt;&lt; PG_referenced) | (1 &lt;&lt; PG_arch_1));
		//置上lock
		page-&gt;flags = flags | (1 &lt;&lt; PG_locked);
		//增加计数和在inode中的偏移
		page_cache_get(page);
		page-&gt;index = offset;
		//将page加在inode的clean page中，并将page的mapping映射到inode上
		add_page_to_inode_queue
			*head = &amp;mapping-&gt;clean_pages;
			mapping-&gt;nrpages++;
			list_add(&amp;page-&gt;list, head);
			page-&gt;mapping = mapping;
		//将page添加到hash中
		add_page_to_hash_queue
		//添加到active_list中
		lru_cache_add（加入到active_list）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>663</x>
      <y>3177</y>
      <w>71</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;690.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>726</x>
      <y>3196</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page要locked
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>777</x>
      <y>3196</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;prepare_write
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>664</x>
      <y>3177</y>
      <w>126</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1240.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>802</x>
      <y>3205</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_prepare_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>788</x>
      <y>3199</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_aops</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>832</x>
      <y>3214</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_prepare_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>809</x>
      <y>3208</y>
      <w>32</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_get_block</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>807</x>
      <y>3223</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode = 
page-&gt;mapping-&gt;host
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>812</x>
      <y>3217</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
page对应的inode</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>838</x>
      <y>3223</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__block_prepare_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>839</x>
      <y>3217</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>808</x>
      <y>3231</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blocksize = 
inode-&gt;i_sb-&gt;s_blocksize
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>815</x>
      <y>3226</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>831</x>
      <y>3232</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_empty_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>835</x>
      <y>3226</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果这个页面没有分配bh
!page-&gt;buffers</panel_attributes>
    <additional_attributes>120.0;10.0;40.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>811</x>
      <y>3239</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>815</x>
      <y>3235</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>816</x>
      <y>3242</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从PAGE_SIZE开始，每个
bh管理blocksize的长度
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>800</x>
      <y>3247</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>787</x>
      <y>3254</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_unused_buffer_head</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>761</x>
      <y>3257</y>
      <w>36</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果unused_list有足够的bh
nr_unused_buffer_heads &gt; NR_RESERVED</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>746</x>
      <y>3266</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>bh = unused_list;
unused_list = bh-&gt;b_next_free;
nr_unused_buffer_heads--;
return bh
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>790</x>
      <y>3257</y>
      <w>16</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没有足够的bh</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>771</x>
      <y>3267</y>
      <w>38</w>
      <h>14</h>
    </coordinates>
    <panel_attributes> //注释说SLAB_BUFFER不会因为申请不到内存将
 //page换出，产生更多的bh，但是从2.4.0中我暂时
 //没看到相关的代码，但是在3.4.2中__zone_watermark_ok
 //中的ALLOC_HIGH可能让page更容易从reserve的page中
 //申请到
kmem_cache_alloc(bh_cachep, SLAB_BUFFER)
memset(bh, 0, sizeof(*bh));
init_waitqueue_head(&amp;bh-&gt;b_wait)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>795</x>
      <y>3257</y>
      <w>22</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果想内存没有申请到page
并且async置上，就像reserve的
unused_list中继续申请</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>811</x>
      <y>3269</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>bh = unused_list;
unused_list = bh-&gt;b_next_free;
nr_unused_buffer_heads--;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>816</x>
      <y>3247</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果申请到bh</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>832</x>
      <y>3255</y>
      <w>29</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>bh-&gt;b_dev = B_FREE;
 //将申请的bh加到head链表中
bh-&gt;b_this_page = head;
head = bh;

bh-&gt;b_state = 0;
bh-&gt;b_next_free = NULL;
bh-&gt;b_pprev = NULL;
atomic_set(&amp;bh-&gt;b_count, 0);
bh-&gt;b_size = size;

set_bh_page(bh, page, offset);
	bh-&gt;b_page = page
	if PageHighMem
		bh-&gt;b_data = (char *)(0 + offset);
	else
		bh-&gt;b_data = page_address(page) + offset;

bh-&gt;b_list = BUF_CLEAN;
bh-&gt;b_end_io = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>816</x>
      <y>3242</y>
      <w>59</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果中间没有申请到bh</panel_attributes>
    <additional_attributes>10.0;10.0;570.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>867</x>
      <y>3252</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>no_grow
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>864</x>
      <y>3261</y>
      <w>31</w>
      <h>23</h>
    </coordinates>
    <panel_attributes> //释放申请的bh
bh = head;
head = head-&gt;b_this_page;
__put_unused_buffer_head(bh);
wake_up(&amp;buffer_wait)

if (!async)
	return NULL;

run_task_queue(&amp;tq_disk);
 //这里是通过宏建wait的queue，然后schedule，
 //等待唤醒后，检查condition
wait_event(buffer_wait,
			nr_unused_buffer_heads &gt;= MAX_BUF_PER_PAGE)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>872</x>
      <y>3255</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>838</x>
      <y>3235</y>
      <w>65</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;630.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>897</x>
      <y>3242</y>
      <w>20</w>
      <h>25</h>
    </coordinates>
    <panel_attributes> //遍历返回的head链表，
 //将bh进行填充
do {
	bh-&gt;b_dev = dev;
	bh-&gt;b_blocknr = 0;
	bh-&gt;b_end_io = NULL;
	tail = bh;
	bh = bh-&gt;b_this_page;
} while (bh);

 //page对应的bh形成循环链表
tail-&gt;b_this_page = head;
 //page指向bh的链表
page-&gt;buffers = head;
page_cache_get(page);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>857</x>
      <y>3230</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>bbits = inode-&gt;i_sb-&gt;s_blocksize_bits;
 //要写区域的逻辑block偏移
block = page-&gt;index &lt;&lt; (PAGE_CACHE_SHIFT 
					- bbits)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>846</x>
      <y>3226</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>846</x>
      <y>3226</y>
      <w>88</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历page-&gt;buffers链表</panel_attributes>
    <additional_attributes>10.0;10.0;860.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>918</x>
      <y>3239</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.block_end = block_start+blocksize;
2.filter：from~to要和bh所在的区间有重合
	//bh还没到要操作的区间（继续下一个bh）
	block_end &lt;= from
	//bh已经超过了要操作的区间（退出循环）
	block_start &gt;= to
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>927</x>
      <y>3230</y>
      <w>7</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>930</x>
      <y>3230</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!buffer_mapped
bh.b_state的Mapped没置上
BH_Mapped:表示bh和实际block映射起来了</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>963</x>
      <y>3242</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_block
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>958</x>
      <y>3235</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>969</x>
      <y>3245</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;35.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>983</x>
      <y>3248</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_get_block
注：ext2_get_block包括寻找chain，补全chain，而获取实际的block号给bh
getblk是根据dev和实际block号找到bh（包括创建bh及其内存）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>930</x>
      <y>3230</y>
      <w>154</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果page的PG_uptodate置上
bh的BH_Uptodate肯定会置上
Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;1520.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1076</x>
      <y>3234</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_bit(BH_Uptodate, &amp;bh-&gt;b_state);
continue;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>931</x>
      <y>3229</y>
      <w>184</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 //磁盘上的内容没有更新到内存
!buffer_uptodate(bh) &amp;&amp;
 //bh中有一段内存不在操作的区域
 //注：前面有filter，所以bh必定是有一部分
 //是要操作的区域，所以这里只是一部分没落在
 //要操作的区域
(block_start &lt; from || block_end &gt; to)</panel_attributes>
    <additional_attributes>10.0;20.0;1820.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1103</x>
      <y>3232</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>ll_rw_block(READ, 1, &amp;bh);
 //wait_bh指向wait，wait是
 //包含两个（包含两个的原因是：
 //不全在操作范围的bh最多只有
 //两个，前面一个，后面一个）
 //函数指针的数组，
*wait_bh++=bh;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>846</x>
      <y>3226</y>
      <w>292</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2900.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1133</x>
      <y>3231</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //等待要读的bh全部读完
while(wait_bh &gt; wait) {
	wait_on_buffer(*--wait_bh);
	if (!buffer_uptodate(*wait_bh))
		goto out;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>919</x>
      <y>3260</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_block_to_path</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>926</x>
      <y>3251</y>
      <w>64</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>897</x>
      <y>3269</y>
      <w>59</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果小于EXT2_NDIR_BLOCKS（12），属于直接索引（逻辑block就是索引号）
2.如果上述条件不满足，但是小于EXT2_ADDR_PER_BLOCK（一个block可以存放
	多少个block号），属于间接索引， 	首层索引为EXT2_IND_BLOCK（12），第二层
	索引为i_block -= direct_blocks
3.如果小于double_blocks（ptrs_bits * 2个bit），属于二层索引，首层索引号为
	EXT2_DIND_BLOCK（13），第二层索引号为i_block &gt;&gt; ptrs_bits，第三层索引号
	为i_block &amp; (ptrs - 1)
4.如果小于ptrs_bits * 3（因为ptrs有一个ptrs_bits），首层索引为EXT2_TIND_BLOCK（14）
	第二程索引为i_block &gt;&gt; (ptrs_bits * 2)，第三层索引为(i_block &gt;&gt; ptrs_bits) &amp; (ptrs - 1)
	第四层索引为i_block &amp; (ptrs - 1)
注：在这里if..elseif..中是先执行i_block -= ，然后在进行判断，所以这里已经将前面判断的值给减掉了
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>921</x>
      <y>3263</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>972</x>
      <y>3260</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_get_branch</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>973</x>
      <y>3251</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果正常找到block，返回NULL
有其他异常，则返回当前的chain</panel_attributes>
    <additional_attributes>160.0;10.0;50.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>958</x>
      <y>3269</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_chain</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>957</x>
      <y>3277</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.p指向bh+offset
2.k记录下一个的实际block号
3.bh指向实际block号所在的buffer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>963</x>
      <y>3263</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>964</x>
      <y>3272</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>975</x>
      <y>3263</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历depth（索引层次）次，
寻找逻辑block对应的实际block号</panel_attributes>
    <additional_attributes>40.0;10.0;180.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>979</x>
      <y>3273</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>982</x>
      <y>3269</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>990</x>
      <y>3273</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>verify_chain</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>992</x>
      <y>3269</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>982</x>
      <y>3280</y>
      <w>41</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.遍历暂存的chain数组，验证读进来的block号有没有被修改
	from-&gt;key == *from-&gt;p
注：注意p是指针，指向的是bh中的一个block号，k是之前从这个
	这个地址中拿来放在chain数组中，在bread时，有可能休眠，
	其他进程有可能将这段给删了，导致之前存的key和现在去的*p
	不一致，所以在这里为了功能安全，需要加以验证
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>994</x>
      <y>3276</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1003</x>
      <y>3273</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_chain</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>992</x>
      <y>3269</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将读入的数据存储在chain中</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>989</x>
      <y>3251</y>
      <w>25</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果找到了实际的block
!partial</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1017</x>
      <y>3265</y>
      <w>36</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>bh_result-&gt;b_dev = inode-&gt;i_dev;
 //物理block号
bh_result-&gt;b_blocknr = le32_to_cpu(chain[depth-1].key);
bh_result-&gt;b_state |= (1UL &lt;&lt; BH_Mapped);
 //这里将partial赋值为最后一个chain
partial = chain+depth-1
goto cleanup
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1005</x>
      <y>3258</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>got_it
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1012</x>
      <y>3261</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1054</x>
      <y>3258</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cleanup
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>989</x>
      <y>3251</y>
      <w>73</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将暂存在chain中的bh释放

如果没找到实际block号，但是
没有要求创建，或者要求创建，但是
出现了EIO,即没有将磁盘中的内容通过
bread读到buffer中，会执行clean_up，并返回err</panel_attributes>
    <additional_attributes>10.0;10.0;710.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1055</x>
      <y>3266</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>while (partial &gt; chain) {
	brelse(partial-&gt;bh);
	partial--;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1060</x>
      <y>3261</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>989</x>
      <y>3251</y>
      <w>118</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
没有找到相应的block
err ！= -EAGAIN
err ！= -EIO
partial！=NULL
create!=0</panel_attributes>
    <additional_attributes>10.0;10.0;1160.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1081</x>
      <y>3257</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里是找到一个物理block
用于与这个逻辑block映射
原则：尽量文件的物理block全部放在一起
	并且连续</panel_attributes>
    <additional_attributes>240.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1077</x>
      <y>3265</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_find_goal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1043</x>
      <y>3278</y>
      <w>53</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>1.如果要分配的逻辑block只比预期要分配的逻辑block大1，
	将预期分配的逻辑block和物理block都加1.（这样使预期分配的
	逻辑block和要分配的逻辑block相等，直接使用i_next_alloc_goal
	而不通过ext2_find_near去寻找实际要分配的block）
	inode-&gt;u.ext2_i.i_next_alloc_block++;
	inode-&gt;u.ext2_i.i_next_alloc_goal++;
2.通过verify_chain验证要分配block的路径的有效性（没有其他进程对这条
	映射链有更改）
3.如果要分配的逻辑block和预期分配的逻辑block（i_next_alloc_block）
	相等，要分配的实际block就为预期分配的实际block（i_next_alloc_goal）
4.如果不相等（或者之前这个inode没有进入过ext2_find_goal，此时
	i_next_alloc_goal为0）就通过ext2_find_near寻找实际block供分配
	
	ext2_find_near
		1.寻找到当前key为0所在的block
		2.在这个block中遍历key为0之前的内存，如果发现内存中的实际block不为0，
			那之后就从这个设备block向前找到这个空闲的block
		3.在这个block中遍历key为0之前的内存，发现key都为0，那么这个间接映射可能是
			inode申请的最后一个block，所以以这个间接映射所在的block为起始点开始寻找
			（ind-&gt;bh-&gt;b_blocknr）
		4.如果不是间接映射的block，就以inode所在的第一个group所在的第一个data_blcok
			开始寻找实际的block（s_first_data_block）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1070</x>
      <y>3268</y>
      <w>14</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1091</x>
      <y>3268</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>left = (chain + depth) - partial
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1103</x>
      <y>3257</y>
      <w>22</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
剩下的没有被映射的间接索引</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1134</x>
      <y>3268</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_alloc_branch</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1104</x>
      <y>3257</y>
      <w>38</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到相应的block
填充好chain
</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1121</x>
      <y>3278</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_alloc_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1123</x>
      <y>3271</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更具goal找到实际的设备block
</panel_attributes>
    <additional_attributes>170.0;10.0;30.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1335</x>
      <y>3279</y>
      <w>47</w>
      <h>43</h>
    </coordinates>
    <panel_attributes>1.将找到的block（parent）放在断裂的chain中（branch）
	branch[0].key = cpu_to_le32(parent)
2.如果找到了block，将所有的没有映射的chain进行填充
	1.找到下一个映射的block（ext2_alloc_block）
	2.填充chain
		1.branch[n].key = cpu_to_le32(nr)
		2.获取parent的bh，并memset（没有获取最后一个bh，因为最后一个bh是作为参数传给
			ext2_get_block）
			bh = getblk(inode-&gt;i_dev, parent, blocksize);
			if (!buffer_uptodate(bh))
				wait_on_buffer(bh);
			memset(bh-&gt;b_data, 0, blocksize);
			branch[n].bh = bh
		3.branch[n].p = (u32*) bh-&gt;b_data + offsets[n];
		4.将key写到内存（注branch[0]的p出没写，也就是和chain还没连起来）
			*branch[n].p = branch[n].key;
			mark_buffer_uptodate(bh, 1);
			mark_buffer_dirty_inode(bh, inode);
		5.如果需要同步写入，就请求写
			if (IS_SYNC(inode) || inode-&gt;u.ext2_i.i_osync) {
				ll_rw_block (WRITE, 1, &amp;bh);
				wait_on_buffer (bh);
			}
3.如果ext2_alloc_block每次都能找到设备block，最后都是n==num,返回0
4.如果ext2_alloc_block出错，就释放bh（bforget(branch[i].bh)）和
	block（ext2_free_blocks），并返回error
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1139</x>
      <y>3271</y>
      <w>204</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2020.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1105</x>
      <y>3281</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果inode的i_prealloc_count不为0
并且goal最多比i_prealloc_block大1</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1097</x>
      <y>3291</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>result = inode-&gt;u.ext2_i.i_prealloc_block++;
inode-&gt;u.ext2_i.i_prealloc_count--;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1125</x>
      <y>3281</y>
      <w>16</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不满足左边的条件</panel_attributes>
    <additional_attributes>20.0;10.0;130.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1126</x>
      <y>3292</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_discard_prealloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1132</x>
      <y>3288</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1099</x>
      <y>3300</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode-&gt;u.ext2_i.i_prealloc_count = 0;
inode-&gt;u.ext2_i.i_prealloc_block = 0;
ext2_free_blocks
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1116</x>
      <y>3295</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1164</x>
      <y>3293</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_new_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1137</x>
      <y>3288</y>
      <w>38</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是S_ISREG，需要填充i_prealloc_count
和i_prealloc_block。否则不用填充</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1103</x>
      <y>3307</y>
      <w>36</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果超级块的空闲block数量小于reserve的数量
	即需要sb的s_resuid在fsuid中，或者sb的s_resgid
	所在的组为超级用户，或者在fsgid所在的组，或者进程有
	CAP_SYS_RESOURCE权限
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1118</x>
      <y>3296</y>
      <w>53</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1140</x>
      <y>3309</y>
      <w>29</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>goal = le32_to_cpu(es-&gt;s_first_data_block)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1146</x>
      <y>3296</y>
      <w>29</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果超出了sb规定的block范围
goal &lt; le32_to_cpu(es-&gt;s_first_data_block) ||
goal &gt;= le32_to_cpu(es-&gt;s_blocks_count)</panel_attributes>
    <additional_attributes>230.0;10.0;50.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1171</x>
      <y>3309</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_get_group_desc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>3296</y>
      <w>14</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取desc</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1187</x>
      <y>3309</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>load_block_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>3296</y>
      <w>29</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
i为所在的block_group
j为在group中的序号

返回在s_block_bitmap_number或者
s_block_bitmap的位置</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1157</x>
      <y>3317</y>
      <w>48</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.代码运行的局部性：
	如果加载过block_bitmap（s_loaded_block_bitmaps &gt; 0）
	首先查看0处是否为要查找的block_group
2.如果磁盘的所有group都不超过最大的缓存数
	（s_groups_count &lt;=EXT2_MAX_GROUP_LOADED）
	此时block_group为其数组的索引，所以查看
	sb-&gt;u.ext2_sb.s_block_bitmap_number[block_group] == block_group &amp;&amp;
 	sb-&gt;u.ext2_sb.s_block_bitmap[block_group]
3.通过__load_block_bitmap将新加的block_group加载进来
	1.要加载的block_group不能大于s_groups_count
	2.当磁盘的group总量小于加载的内存数量（s_groups_count
											&lt;= EXT2_MAX_GROUP_LOADED）
		read_block_bitmap
	3.遍历s_loaded_block_bitmaps，看是block_group的位图是否存在于内存中
		如果存在将block_group在s_block_bitmap_number和s_block_bitmap
		中的位置移到第0位；
		如果不在，腾出一个内存单元（s_loaded_block_bitmaps++或者brelse）
		并通过read_block_bitmap读到第0位
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1182</x>
      <y>3312</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1170</x>
      <y>3351</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_block_bitmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1177</x>
      <y>3347</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1152</x>
      <y>3358</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1155</x>
      <y>3354</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1167</x>
      <y>3358</y>
      <w>42</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;u.ext2_sb.s_block_bitmap_number[bitmap_nr] = block_group;
sb-&gt;u.ext2_sb.s_block_bitmap[bitmap_nr] = bh;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1177</x>
      <y>3354</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1201</x>
      <y>3305</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_test_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>3296</y>
      <w>43</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
测试第i组的第j个block
是否被占用</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1203</x>
      <y>3312</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>got_block
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1207</x>
      <y>3308</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果为0表示没有被占用</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1169</x>
      <y>3296</y>
      <w>76</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果ext2_test_bit不为0</panel_attributes>
    <additional_attributes>10.0;10.0;740.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1223</x>
      <y>3306</y>
      <w>53</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.如果j不为0，通过ext2_find_next_zero_bit寻找位图中为0的索引
	end_goal为其搜索的结束地址（64位对齐）
2.如果还没找到，从end_goal继续查找，直到查找到EXT2_BLOCKS_PER_GROUP
	memscan
	__asm__("repnz; scasb //edi++,ecx--，如果edi！=eax或者ecx&gt;0则继续
		jnz 1f
		dec %%edi //将addr恢复到原来相等的地址
	1:		"
		: "=D" (addr), "=c" (size)
		: "0" (addr), "1" (size), "a" (c));
	如果发现连续8位都为0，search_back去向之前查找!ext2_test_bit (j - 1, bh-&gt;b_data)
	将j更新为最小的空闲block，然后got_block
3.如果在本group没有找到，遍历之后的group，只要其中的bg_free_blocks_count&gt;0，
	就加载其block_bitmap
	先连续查看是否有连续8bit的空闲block（memscan(bh-&gt;b_data, 
				0, EXT2_BLOCKS_PER_GROUP(sb) &gt;&gt; 3)）
	如果没有，通过ext2_find_first_zero_bit查找空闲的block
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>3296</y>
      <w>130</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1280.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1292</x>
      <y>3304</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>got_block
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1279</x>
      <y>3312</y>
      <w>48</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.计算获得的实际block号（group号，s_first_data_block都加进去）
2.获得的block号，不能是本group的block位图区（s_first_data_block）
	也不能是inode位图区（bg_inode_bitmap），也不能在inode所在的block
	区（e32_to_cpu(gdp-&gt;bg_inode_table),
		      sb-&gt;u.ext2_sb.s_itb_per_group）
3.将group中相应的block位图置上（ext2_set_bit），mark_buffer_dirty
4.获取的block号不能大于磁盘最大的block号（s_blocks_count）
5.gdp-&gt;bg_free_blocks_count--，并将其标记为dirty（mark_buffer_dirty）
6.s_free_blocks_count--，将超级块标记为dirty
	mark_buffer_dirty(sb-&gt;u.ext2_sb.s_sbh);
	sb-&gt;s_dirt = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1297</x>
      <y>3307</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1354</x>
      <y>3325</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getblk
1.lru_list,如果正在被使用会被加入到iru_list和hash中
	此时b_count不为0，且b_blocknr存在
2.free_list，如果进程释放掉这个bh，b_count为0，不在
	hash表中，但是b_blocknr存在（page能再次利用）
3.unused_list，这个是bh所指向的page被释放，此时b_count为0，
	不在hash表中，且b_blocknr=-1（要申请page才能利用）
注：1.从这里暂时没看出unused_list和free_list的不同，但是在try_to_free_buffer
中有当b_dev不存在时，将bh从free_list移除，然后放到unused_list中释放
2.这里的touch_buffer是增加page寿命，使其不会被老化换出
3.这里block的传参，是设备上的block号，并不是文件的逻辑block号</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1359</x>
      <y>3321</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1306</x>
      <y>3336</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_hash_table</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1313</x>
      <y>3328</y>
      <w>49</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1297</x>
      <y>3342</y>
      <w>28</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.遍历hash_table（dev和block作为杂凑值）
	中的b_next
2.查看下面字段
bh-&gt;b_blocknr == block	&amp;&amp;
bh-&gt;b_size    == size	&amp;&amp;
bh-&gt;b_dev     == dev
3.增加bh-&gt;b_count计数
4.goto out
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1312</x>
      <y>3339</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1357</x>
      <y>3328</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从free_list对应的size中查找
如果有空闲的bh</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1333</x>
      <y>3337</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__remove_from_free_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1341</x>
      <y>3333</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1328</x>
      <y>3344</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果free_list中只有bh一个（b_next_free指向自己）
	 free_list[index].list = NULL;
2.如果不止一个，将bh从free链表中删除，如果free_list
	指向的是bh，就将free_list指向bh-&gt;b_next_free
3.将bh链表置空
	bh-&gt;b_next_free = bh-&gt;b_prev_free = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1340</x>
      <y>3340</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1357</x>
      <y>3333</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1368</x>
      <y>3337</y>
      <w>31</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>atomic_set(&amp;bh-&gt;b_count, 1)
init_buffer
	bh-&gt;b_list = BUF_CLEAN;
	bh-&gt;b_end_io = handler;（这里是NULL）
	bh-&gt;b_private = private;（这里是NULL）
bh-&gt;b_dev = dev;
bh-&gt;b_blocknr = block;
bh-&gt;b_state = 1 &lt;&lt; BH_Mapped;
__insert_into_queues
out:
touch_buffer  (SetPageReferenced(bh-&gt;b_page))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1351</x>
      <y>3358</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__insert_into_queues</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1358</x>
      <y>3355</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1336</x>
      <y>3366</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__hash_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1353</x>
      <y>3365</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__insert_into_lru_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1341</x>
      <y>3361</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将bh头插至hash中
并将hash指向bh
注：b_pprev指向箭头</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1359</x>
      <y>3361</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1342</x>
      <y>3377</y>
      <w>38</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果lru_list为空，首先将其初始化，使后面的接口操作统一
	*bhp = bh;
	bh-&gt;b_prev_free = bh;
2.将bh尾插至lru链表的最后
	bh-&gt;b_next_free = *bhp;
	bh-&gt;b_prev_free = (*bhp)-&gt;b_prev_free;
	(*bhp)-&gt;b_prev_free-&gt;b_next_free = bh;
	(*bhp)-&gt;b_prev_free = bh;
	nr_buffers_type[blist]++;
	size_buffers_type[blist] += bh-&gt;b_size;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1355</x>
      <y>3368</y>
      <w>15</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里是循环链表
没有pprev</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1442</x>
      <y>3337</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>refill_freelist</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1359</x>
      <y>3328</y>
      <w>92</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果从hash或者free_list中都没找到
</panel_attributes>
    <additional_attributes>10.0;10.0;900.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1412</x>
      <y>3343</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>balance_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1417</x>
      <y>3340</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1406</x>
      <y>3351</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>balance_dirty_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1410</x>
      <y>3346</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1368</x>
      <y>3366</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.计算所有空闲页的数量（free_pages inactive_clean_pages
	inactive_dirty_pages）
2.最小为freepages.high + inactive_target（考虑到kswapd会将
	空闲页恢复到这个数量）
3.然后还要算上nr_active_pages &gt;&gt; 4（应该是考虑到页的换出）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1398</x>
      <y>3354</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1390</x>
      <y>3359</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nr_free_buffer_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1372</x>
      <y>3362</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1410</x>
      <y>3366</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果BUF_DIRTY的数量大于hard_dirty_limit的数量，需要同步
	的将页面进行同步到硬盘
2.如果BUF_DIRTY的数量大于soft_dirty_limit的数量，或者nr_inactive_dirty_pages
	的页面过多，会异步将页面写入硬盘
3.否则不进行flush操作
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1412</x>
      <y>3354</y>
      <w>13</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1435</x>
      <y>3351</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wakeup_bdflush</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1418</x>
      <y>3346</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果需要flush</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1424</x>
      <y>3356</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1429</x>
      <y>3353</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>100.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1453</x>
      <y>3357</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_dirty_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1440</x>
      <y>3354</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果需要同步的flush</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1452</x>
      <y>3365</y>
      <w>49</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.遍历lru_list[BUF_DIRTY]，这里用的是nr_buffers_type，是因为
	__refile_buffer可能使这个链表没有遍历完全，或者成为死循环
2.!buffer_dirty，如果dirty没置上，就将其移到相应的lru链表中
3.buffer_locked，bh正在想硬盘写，不用管，继续下一个
4.check_flushtime置上时，check有没有超时（bh-&gt;b_flushtime）
	没置上时，检查写入到硬盘的dirty_page是否超过bdf_prm.b_un.ndirty
	（最大写入硬盘的dirty_page数）
5.如果上述filter成立，ll_rw_block(WRITE, 1, &amp;bh)
6.如果在wake_up_process中need_resched置上，直接让当前进程进行调度
	schedule
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1460</x>
      <y>3360</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1442</x>
      <y>3340</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果页面短缺
free_shortage</panel_attributes>
    <additional_attributes>60.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1440</x>
      <y>3344</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_launder</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1487</x>
      <y>3344</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>grow_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1447</x>
      <y>3340</y>
      <w>49</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1467</x>
      <y>3353</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.以block为单位（512）
2.不能大于PAGE_SIZE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1473</x>
      <y>3347</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1489</x>
      <y>3353</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1492</x>
      <y>3347</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1505</x>
      <y>3353</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1492</x>
      <y>3347</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1523</x>
      <y>3353</y>
      <w>30</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>tmp-&gt;b_this_page = bh;
free_list[isize].list = bh;
page-&gt;buffers = bh;
page-&gt;flags &amp;= ~(1 &lt;&lt; PG_referenced);
 //加到lru链表中，因为是新申请的page
 //age为0，所以可能加入到inactive_dirty_list中
lru_cache_add(page);
atomic_inc(&amp;buffermem_pages)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1493</x>
      <y>3347</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将bh链表依次插入到free_list中
其next_free的顺序是之前bh链表的顺序
</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1416</x>
      <y>3265</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_splice_branch</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1104</x>
      <y>3257</y>
      <w>320</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;3180.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1383</x>
      <y>3274</y>
      <w>31</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.验证之前没有断裂的索引链表（chain~where-1）
2.验证索引链表在where出断裂（*where-&gt;p）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1396</x>
      <y>3268</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1393</x>
      <y>3283</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>change
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1383</x>
      <y>3291</y>
      <w>36</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.bforget(where[i].bh)
2.ext2_free_blocks(inode, le32_to_cpu(where[i].key), 1)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1399</x>
      <y>3278</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果情况出现了变化</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1400</x>
      <y>3286</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1417</x>
      <y>3275</y>
      <w>44</w>
      <h>15</h>
    </coordinates>
    <panel_attributes> //将所有链表断裂处连接起来
*where-&gt;p = where-&gt;key;
 //下一个待分配的逻辑block
inode-&gt;u.ext2_i.i_next_alloc_block = block;
 //下一个待分配的实际block
inode-&gt;u.ext2_i.i_next_alloc_goal = le32_to_cpu(where[num-1].key);
 //更新inode的block的数量
inode-&gt;i_blocks += num * inode-&gt;i_sb-&gt;s_blocksize/512;
inode-&gt;i_ctime = CURRENT_TIME
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1422</x>
      <y>3268</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1421</x>
      <y>3268</y>
      <w>57</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
where-&gt;bh存在
如果需要同步，则向发送写请求，并等待
if (IS_SYNC(inode) || inode-&gt;u.ext2_i.i_osync) {
	ll_rw_block (WRITE, 1, &amp;where-&gt;bh);
	wait_on_buffer(where-&gt;bh);
}</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1467</x>
      <y>3276</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_buffer_dirty_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1462</x>
      <y>3284</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_buffer_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1481</x>
      <y>3284</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>buffer_insert_inode_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1476</x>
      <y>3279</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1491</x>
      <y>3287</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1487</x>
      <y>3293</y>
      <w>52</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果bh.b_inode指向对应的inode，将bh.b_inode_buffers从inode的链表中删除
2.bh-&gt;b_inode = inode
3.list_add(&amp;bh-&gt;b_inode_buffers, &amp;inode-&gt;i_dirty_buffers)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1465</x>
      <y>3279</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1466</x>
      <y>3287</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
atomic_set_buffer_dirty
set bh dirty
如果之前不是dirty</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1461</x>
      <y>3292</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1455</x>
      <y>3296</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__mark_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1426</x>
      <y>3304</y>
      <w>36</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.bh-&gt;b_flushtime = jiffies + bdf_prm.b_un.age_buffer
2.refile_buffer （__refile_buffer）
	1.查看bh.b_state处于一个什么状态，从而判断其应该处于一个lru链表中
	2，比较其应该在的链表和其现在所在的链表（bh-&gt;b_list），如果不相同，
		将其从现在的lru链表中删除，加在应该处的lru链表中
		__remove_from_lru_list(bh, bh-&gt;b_list);
		bh-&gt;b_list = dispose;
		__insert_into_lru_list(bh, dispose)
	3.如果应该处于BUF_CLEAN中，就将其从inode中删除
		bh-&gt;b_inode = NULL;
		list_del(&amp;bh-&gt;b_inode_buffers)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1445</x>
      <y>3299</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1470</x>
      <y>3296</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>balance_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1465</x>
      <y>3292</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
看是否将dirty_buffer向
硬盘中写</panel_attributes>
    <additional_attributes>30.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1421</x>
      <y>3268</y>
      <w>118</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1160.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1518</x>
      <y>3274</y>
      <w>28</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果需要同步
IS_SYNC(inode) || inode-&gt;u.ext2_i.i_osync</panel_attributes>
    <additional_attributes>190.0;10.0;80.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1518</x>
      <y>3281</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_sync_inode
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1543</x>
      <y>3281</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mark_inode_dirty
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1536</x>
      <y>3274</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不需要同步</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1473</x>
      <y>3263</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bh_result-&gt;b_state |= (1UL &lt;&lt; BH_New)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1104</x>
      <y>3257</y>
      <w>384</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;3820.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>958</x>
      <y>3235</y>
      <w>36</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
buffer_new
BH_New:表示这个实际block是被创建的</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>987</x>
      <y>3237</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查hash表中有没有和其指向同一个dev和block
的bh，如果有，将这个bh写入磁盘并释放</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>977</x>
      <y>3242</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unmap_underlying_metadata</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>997</x>
      <y>3244</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>set_bit(BH_Uptodate, &amp;bh-&gt;b_state);
continue;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>991</x>
      <y>3237</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1025</x>
      <y>3242</y>
      <w>25</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>if (block_end &gt; to)
	memset(kaddr+to, 0, block_end-to);
if (block_start &lt; from)
	memset(kaddr+block_start, 0, from-block_start);
continue
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>990</x>
      <y>3237</y>
      <w>47</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为是新创建的，把不写的区域清0</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>810</x>
      <y>3195</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>kaddr = page_address(page);
status = copy_from_user(kaddr+offset, buf, bytes);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>663</x>
      <y>3177</y>
      <w>167</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制内容到缓存</panel_attributes>
    <additional_attributes>10.0;10.0;1650.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>862</x>
      <y>3181</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;commit_write
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>663</x>
      <y>3177</y>
      <w>209</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2070.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>871</x>
      <y>3184</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_aops</panel_attributes>
    <additional_attributes>20.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>869</x>
      <y>3187</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_commit_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>851</x>
      <y>3194</y>
      <w>34</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //address_space是inode和page的关联
inode = 
page-&gt;mapping-&gt;host
 //写完最后的位置
pos = ((loff_t)page-&gt;index &lt;&lt; PAGE_CACHE_SHIFT) 
		+ to
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>857</x>
      <y>3190</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>892</x>
      <y>3192</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__block_commit_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>878</x>
      <y>3190</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>900</x>
      <y>3195</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历page-&gt;buffers链表</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>859</x>
      <y>3199</y>
      <w>45</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果这个bh不在要写的范围
block_end &lt;= from || block_start &gt;= to
并且不和硬盘一致
!buffer_uptodate</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>854</x>
      <y>3211</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>partial = 1;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>891</x>
      <y>3199</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果bh在这次写的范围内
（即使部分也是的，因为__block_prepare_write
已经将那部分读了上来）</panel_attributes>
    <additional_attributes>110.0;10.0;190.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>906</x>
      <y>3207</y>
      <w>25</w>
      <h>19</h>
    </coordinates>
    <panel_attributes> //设置bh和硬盘一致
set_bit(BH_Uptodate, &amp;bh-&gt;b_state);
 //bh置dirty
if (!atomic_set_buffer_dirty(bh)) {
 //如果之前没置dirty
 //更新bh的lru链表
	__mark_dirty(bh);
	//将bh加入到inode链表中
	buffer_insert_inode_queue(bh, inode);
	need_balance_dirty = 1;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>900</x>
      <y>3195</y>
      <w>42</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
need_balance_dirty置上
根据空闲page的数量，决定是否唤醒bdflush</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>935</x>
      <y>3205</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>balance_dirty</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>901</x>
      <y>3195</y>
      <w>63</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
partial没置上
这个page中所有缓存都和硬盘一致</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>956</x>
      <y>3204</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>SetPageUptodate(page)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>962</x>
      <y>3184</y>
      <w>17</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>written ? written : status
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>931</x>
      <y>3182</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>944</x>
      <y>3183</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_osync_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>896</x>
      <y>3182</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>written += status;
count -= status;
pos += status;
buf += status;
if (deactivate)
	deactivate_page(page);
page_cache_release(page);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>662</x>
      <y>3177</y>
      <w>242</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1510.0;10.0;2400.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>661</x>
      <y>3162</y>
      <w>278</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在__grab_cache_page中
有cached_page，将其释放</panel_attributes>
    <additional_attributes>10.0;10.0;2070.0;130.0;2760.0;200.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>661</x>
      <y>3162</y>
      <w>291</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
没有错误，并要求同步，将其同步到硬盘
(status &gt;= 0) &amp;&amp; (file-&gt;f_flags &amp; O_SYNC)</panel_attributes>
    <additional_attributes>10.0;10.0;1290.0;60.0;2890.0;210.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>662</x>
      <y>3162</y>
      <w>310</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果写过，就返回写的字节数
如果没写过，就返回错误码</panel_attributes>
    <additional_attributes>10.0;10.0;2180.0;50.0;3080.0;220.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>917</x>
      <y>3183</y>
      <w>9</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>*ppos = pos;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>660</x>
      <y>3162</y>
      <w>263</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里更改了file-&gt;f_pos</panel_attributes>
    <additional_attributes>10.0;10.0;1670.0;140.0;2610.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>700</x>
      <y>3149</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_dir_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>517</x>
      <y>3138</y>
      <w>192</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有写buffer</panel_attributes>
    <additional_attributes>10.0;10.0;1900.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1426</x>
      <y>3154</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>518</x>
      <y>3138</y>
      <w>915</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放file</panel_attributes>
    <additional_attributes>10.0;10.0;9130.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1417</x>
      <y>3160</y>
      <w>33</w>
      <h>38</h>
    </coordinates>
    <panel_attributes> //递减file的count
if (atomic_dec_and_test(&amp;file-&gt;f_count)) {
 //如果f_count减到0
 //遍历inode-&gt;i_flock，删除这个file对应的FL_FLOCK|FL_LEASE锁
	locks_remove_flock(file);
	if (file-&gt;f_op &amp;&amp; file-&gt;f_op-&gt;release)
		file-&gt;f_op-&gt;release(inode, file);
	//释放module
	fops_put(file-&gt;f_op);
	file-&gt;f_dentry = NULL;
	file-&gt;f_vfsmnt = NULL;
	//释放write_access
	if (file-&gt;f_mode &amp; FMODE_WRITE)
		put_write_access(inode);
	//释放dentry mnt
	dput(dentry);
	if (mnt)
		mntput(mnt);
	//将file从anon_list加到free_list
	list_del(&amp;file-&gt;f_list);
	list_add(&amp;file-&gt;f_list, &amp;free_list);
	files_stat.nr_free_files++;
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1431</x>
      <y>3157</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>15.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>669</x>
      <y>3075</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;write
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>670</x>
      <y>3083</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>674</x>
      <y>3078</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
def_blk_fops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>641</x>
      <y>3096</y>
      <w>37</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.dev不能是只读，is_read_only通过检查ro_bits相应的位
2.设置blocksize，blocksize_bits，block，offset，size
（参考block_read）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>654</x>
      <y>3086</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>690</x>
      <y>3092</y>
      <w>53</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.当起始block大于size时，返回ENOSPC
2.确定此次要写的大小chars（初始化为blocksize - offset，但是不能大于count）
3.通过getblk获取设备的bh，如果bh没更新（!buffer_uptodate）：
	1.如果是整块写（chars == blocksize），不需要将bh读进内存，只要wait_on_buffer
	2.如果不是整块写，需要将block读进来。如果f_reada 和read_ahead都为0，就不考虑预读
	否则预读规定块大小的一半，并根据size和bhlist的大小，重新更新blocks。
	将要读的bh通过getblk填充到bhlist中，然后通过ll_rw_block读取
	之后将预读的block释放（ brelse(bhlist[i])，此时因为lock，不会真正的释放），然后等待
	bh更新（ wait_on_buffer(bh)）
4.更新起始block（block++），更新ppos，更新写进的字节数written，更新要写的字节数count
	然后通过copy_from_user将用户空间的数据写入到bh中，更新用户空间的指针buf
5.mark_buffer_uptodate(bh, 1);
	mark_buffer_dirty(bh);
6.如果要求将数据同步写入磁盘（O_SYNC），将bh放到bufferlist中；当bufferlist满了，或者整个
	写操作完成之后，通过ll_rw_block将数据写入到磁盘
7.每写一个block的数据，通过balance_dirty在必要时将bh做同步
8.写操作完成之后，将filp-&gt;f_reada = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>675</x>
      <y>3086</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环在dev中读取count</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>647</x>
      <y>3155</y>
      <w>372</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
write_pipe_fops</panel_attributes>
    <additional_attributes>10.0;10.0;3700.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1011</x>
      <y>3169</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_write</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>980</x>
      <y>3177</y>
      <w>27</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.不能lseek，所以ppos = &amp;filp-&gt;f_pos
	否则返回ESPIPE
2.如果进程要写的数据字节count=0，
	直接返回0
3.通过down_interruptible申请信号量inode.i_sem
	对整个过程进行保护
4.要有PIPE_READERS，否则跳到sigpipe
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>994</x>
      <y>3172</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1114</x>
      <y>3176</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sigpipe
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1105</x>
      <y>3182</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果有写数据到fifo（written），释放信号量，
	然后返回写的字节数
2.如果没写数据（!written），向当前的进程发送
	信号SIGPIPE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1119</x>
      <y>3179</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1017</x>
      <y>3172</y>
      <w>104</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1020.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1009</x>
      <y>3177</y>
      <w>33</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.如果要写的count小于PIPE_BUF：
	1.如果是异步（O_NONBLOCK），在没有
		足够空间放下count字节数据，直接返回EAGAIN
	2.如果是同步，在没有足够空间放下couont数据
		时，睡眠直到有足够的空间能存放下count字节
		//睡着前先递增waiting_writers计数
		PIPE_WAITING_WRITERS(*inode)++;
		pipe_wait(inode);
		PIPE_WAITING_WRITERS(*inode)--;
		//如果有信号唤醒，或者没有reader，返回ERESTARTSYS
		ret = -ERESTARTSYS;
		if (signal_pending(current))
			goto out;

		if (!PIPE_READERS(*inode))
			goto sigpipe;
	3.如果有足够空间放下count字节数据，直接循环写
2.如果要写的count大于PIPE_BUF：
	1.只要有一个字节的空闲fifo，就可以写数据
	2.如果没有任何空闲空间能写，异步时返回EAGAIN，
		同步时等待睡眠，直到有空闲fifo
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1017</x>
      <y>3172</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1043</x>
      <y>3177</y>
      <w>29</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.如果有空闲的fifo（space = PIPE_FREE(*inode)!=0）
	1.本段要写的数据是 进程要写的数据count,fifo中空闲
		空间space，以及写指针到fifo尾端的空间chars的最小值
	2.通过copy_from_user将用户空间要写的数据复制到fifo中
	3.更新变量：
	 //已经写的字节数
		written += chars;
		PIPE_LEN(*inode) += chars;
		count -= chars;
		buf += chars;
		//这个宏是计算fifo空闲空间
		//因为pipe_len被计算，所以这个宏会被重新计算
		space = PIPE_FREE(*inode);
	4.通过continue，继续复制count数据
2.如果没有空闲的空间：
	1.如果是异步（O_NONBLOCK），break退出当前循环
	2.如果是同步，同样睡眠等待，醒来检查signal，pipe_readers
	注意这里do...while条件是!PIPE_FREE，和前面的PIPE_FREE(*inode) &lt; free
	不同，所以没采用pipe_read的结构

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1016</x>
      <y>3172</y>
      <w>44</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环写count字节数据</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1073</x>
      <y>3177</y>
      <w>30</w>
      <h>20</h>
    </coordinates>
    <panel_attributes> //唤醒等待队列
wake_up_interruptible(PIPE_WAIT(*inode))新
 //更新inode
inode-&gt;i_ctime = inode-&gt;i_mtime = CURRENT_TIME;
mark_inode_dirty(inode);
 //进程没写完，没有前面的步骤
 //释放信号量
up(PIPE_SEM(*inode));
 //返回写的字节数
if (written)
	ret = written;
return ret;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1017</x>
      <y>3172</y>
      <w>71</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果进程要写的数据被写完</panel_attributes>
    <additional_attributes>10.0;10.0;690.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>576</x>
      <y>3488</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>537</x>
      <y>3501</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>542</x>
      <y>3491</y>
      <w>43</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>557</x>
      <y>3501</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locks_verify_area
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>582</x>
      <y>3491</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file存在
f_mode &amp; FMODE_READ</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>562</x>
      <y>3496</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FLOCK_VERIFY_READ
验证这块区域是否加锁使其不可读</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>581</x>
      <y>3503</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;read
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>583</x>
      <y>3496</y>
      <w>6</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>605</x>
      <y>3503</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_dir_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>630</x>
      <y>3503</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fput
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>583</x>
      <y>3496</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>584</x>
      <y>3496</y>
      <w>53</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>472</x>
      <y>3506</y>
      <w>118</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_file_operations</panel_attributes>
    <additional_attributes>1160.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>467</x>
      <y>3518</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_file_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>444</x>
      <y>3525</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>access_ok</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>449</x>
      <y>3521</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
VERIFY_WRITE</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>432</x>
      <y>3532</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__range_ok</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>438</x>
      <y>3528</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>410</x>
      <y>3539</y>
      <w>35</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>"addl %3,%1 ;
 //flag=flag-cf，cf为1表示最高位产生了进位或者借位
sbbl %0,%0; 
 //current-&gt;addr_limit.seg-addr，然后检查cf
cmpl %1,%4; sbbl $0,%0" \
:"=&amp;r" (flag), "=r" (sum) \
:"1" (addr),"g" ((int)(size)),"g" (current-&gt;addr_limit.seg)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>425</x>
      <y>3535</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>453</x>
      <y>3532</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>desc.written = 0;
desc.count = count;
desc.buf = buf;
desc.error = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>459</x>
      <y>3521</y>
      <w>16</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>474</x>
      <y>3535</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_generic_file_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>472</x>
      <y>3521</y>
      <w>12</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>472</x>
      <y>3521</y>
      <w>38</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
desc.written
检查是否想用户空间写了
读上来的数据，否则返回错误</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>501</x>
      <y>3533</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>desc.error
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>447</x>
      <y>3548</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_max_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>455</x>
      <y>3538</y>
      <w>29</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>416</x>
      <y>3555</y>
      <w>40</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果没有设备号，或者此类设备没有规定预读的长度
	（(!inode-&gt;i_dev || !max_readahead[MAJOR(inode-&gt;i_dev)）
	则为MAX_READAHEAD
2.否则，就取规定的
max_readahead[MAJOR(inode-&gt;i_dev)][MINOR(inode-&gt;i_dev)]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>436</x>
      <y>3551</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>470</x>
      <y>3538</y>
      <w>14</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>452</x>
      <y>3549</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果超出了预读窗口
 //f_raend为预读的最后一页，f_rawin为窗口的长度
 //窗口为f_raend-f_rawin ~ f_raend
index &gt; filp-&gt;f_raend || 
index + filp-&gt;f_rawin &lt; filp-&gt;f_raend</panel_attributes>
    <additional_attributes>190.0;10.0;130.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>457</x>
      <y>3556</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>reada_ok = 0;
filp-&gt;f_raend = 0;
filp-&gt;f_ralen = 0;
filp-&gt;f_ramax = 0;
filp-&gt;f_rawin = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>470</x>
      <y>3549</y>
      <w>19</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果现在读取的内容在
之前预读的范围内</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>470</x>
      <y>3559</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>reada_ok = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>481</x>
      <y>3538</y>
      <w>15</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>481</x>
      <y>3549</y>
      <w>41</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果读取file最前半页的内容
不进行预读
 //第0页
!index &amp;&amp; 
 //第0页的前半页
offset + desc-&gt;count &lt;= (PAGE_CACHE_SIZE &gt;&gt; 1)</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>477</x>
      <y>3563</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_ramax = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>493</x>
      <y>3549</y>
      <w>8</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>494</x>
      <y>3561</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.随机读（reada_ok=0），f_ramax为正在读取的长度+1
	((offset + desc-&gt;count) &gt;&gt; PAGE_CACHE_SHIFT) + 1
2.如果是顺序读（reada_ok=1），f_ramax最小为max（need，MIN_READAHEAD）
3.不管何种情况，f_ramax最大为get_max_readahead
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>481</x>
      <y>3538</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环读取内容</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>504</x>
      <y>3546</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>499</x>
      <y>3550</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果读取的长度超出了i_size，退出循环
2.如果是inode的最后一个页面，但是超出了
	i_size &amp; ~PAGE_CACHE_MASK，也超过了inode
	的长度，退出循环
3.更新读取的长度 nr = nr - offset，
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>509</x>
      <y>3546</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从hash表中通过index找page</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>532</x>
      <y>3552</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>page_hash(mapping, index)
__find_page_nolock
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>509</x>
      <y>3546</y>
      <w>56</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;540.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>554</x>
      <y>3550</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在hash表中
找到来了page</panel_attributes>
    <additional_attributes>90.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>552</x>
      <y>3555</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>found_page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>629</x>
      <y>3556</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>no_cached_page
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>562</x>
      <y>3550</y>
      <w>73</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在hash表中
没有找到page</panel_attributes>
    <additional_attributes>10.0;10.0;710.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>541</x>
      <y>3558</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加page计数</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>535</x>
      <y>3563</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_get
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>544</x>
      <y>3562</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果page和硬盘一致
</panel_attributes>
    <additional_attributes>90.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>442</x>
      <y>3576</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_file_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>552</x>
      <y>3558</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
Page_Uptodate
注：在do_generic_file_read只检查了
	page的uptodate，所以说如果不在读的范围内
	只要在相同的page中，也要将buffer读上来</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>552</x>
      <y>3562</y>
      <w>56</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不一致</panel_attributes>
    <additional_attributes>10.0;10.0;540.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>601</x>
      <y>3565</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_not_up_to_date
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>553</x>
      <y>3571</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_ok
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>449</x>
      <y>3566</y>
      <w>102</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1000.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>548</x>
      <y>3566</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>545</x>
      <y>3574</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>538</x>
      <y>3577</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file_read_actor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>520</x>
      <y>3584</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__copy_to_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>527</x>
      <y>3580</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将读到的数据复制到用户空间</panel_attributes>
    <additional_attributes>160.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>541</x>
      <y>3584</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>desc-&gt;count = count - size;
desc-&gt;written += size;
desc-&gt;buf += size;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>543</x>
      <y>3580</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新参数
size：nr</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>560</x>
      <y>3578</y>
      <w>27</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>offset += nr;
 //递增页index
index += offset &gt;&gt; PAGE_CACHE_SHIFT;
 //算出页内偏移，开始是offset，后期是0
offset &amp;= ~PAGE_CACHE_MASK;
 //释放页
page_cache_release(page);
 //count，如果还要读，继续循环
if (nr &amp;&amp; desc-&gt;count)
	continue;
 //否则退出
break;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>556</x>
      <y>3574</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>585</x>
      <y>3573</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_file_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>592</x>
      <y>3568</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>609</x>
      <y>3568</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>594</x>
      <y>3571</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
有可能是写一个新的
页，导致其没置上，
如果进过之前一些时间导致
page和磁盘一致</panel_attributes>
    <additional_attributes>160.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>592</x>
      <y>3578</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_ok
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>609</x>
      <y>3571</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果还不一致</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>600</x>
      <y>3581</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lock_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>604</x>
      <y>3576</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>608</x>
      <y>3576</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!page-&gt;mapping
如果醒来发现从hash表中
取消</panel_attributes>
    <additional_attributes>110.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>612</x>
      <y>3582</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>UnlockPage(page);
page_cache_release(page);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>618</x>
      <y>3576</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为lock_page可能导致进程睡眠
（generic_file_write将页locked）
所以醒来要检查是否和磁盘一致
Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>644</x>
      <y>3582</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>UnlockPage(page);
goto page_ok;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>617</x>
      <y>3576</y>
      <w>55</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果还不一致，只能锁住page从硬盘中读取</panel_attributes>
    <additional_attributes>10.0;10.0;530.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>664</x>
      <y>3580</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>readpage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>628</x>
      <y>3590</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;readpage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>636</x>
      <y>3583</y>
      <w>34</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>667</x>
      <y>3583</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>649</x>
      <y>3591</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_ok
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>652</x>
      <y>3587</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果和磁盘一致了</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>662</x>
      <y>3587</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不一致
（因为异步读取，还没传上来）</panel_attributes>
    <additional_attributes>70.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>663</x>
      <y>3590</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>655</x>
      <y>3595</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_file_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>674</x>
      <y>3595</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait_on_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>675</x>
      <y>3590</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
等待</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>688</x>
      <y>3595</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_ok
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>675</x>
      <y>3590</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

Page_Uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>690</x>
      <y>3592</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
一致</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>699</x>
      <y>3595</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>error = -EIO
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>694</x>
      <y>3592</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>634</x>
      <y>3559</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
和__find_lock_page找不到时类似
如果找到page了</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>630</x>
      <y>3564</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>readpage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>481</x>
      <y>3538</y>
      <w>136</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1340.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>600</x>
      <y>3541</y>
      <w>32</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //更新f_pos
*ppos =  index &lt;&lt; PAGE_CACHE_SHIFT) + offset;
filp-&gt;f_reada = 1;
 //释放掉cached_page
if (cached_page)
	page_cache_free(cached_page);
UPDATE_ATIME(inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>629</x>
      <y>3598</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_readpage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>637</x>
      <y>3593</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_aops</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>628</x>
      <y>3606</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_read_full_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>635</x>
      <y>3601</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_get_block</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>570</x>
      <y>3616</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page要lock
（PageLocked）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>573</x>
      <y>3609</y>
      <w>65</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>630.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>591</x>
      <y>3609</y>
      <w>47</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!page-&gt;buffers</panel_attributes>
    <additional_attributes>450.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>584</x>
      <y>3616</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_empty_buffers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>613</x>
      <y>3609</y>
      <w>25</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历page-&gt;buffers链表</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>609</x>
      <y>3616</y>
      <w>40</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果buffer_uptodate，不用考虑
2.如果没有映射设备的block，并且没有超出inode.i_size，
	通过get_block（ext2_get_block）去获取设备block
	注意这里的create为0
3.如果超出了inode.i_size,
	将bh对应的内存设置为0
4.因为get_block可能使buffer_uptodate，所以再次检查
	注：ext2可能没有在get_block读，可能其他文件系统有读
5.如果get_block正确返回，或者！buffer_uptodate，记录没有
	uptodate的bh到arr,数目为nr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>636</x>
      <y>3609</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!nr
page中所有的bh都uptodate</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>654</x>
      <y>3617</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>SetPageUptodate(page);
UnlockPage(page);
return 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>636</x>
      <y>3609</y>
      <w>57</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果nr存在
遍历arr</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>681</x>
      <y>3616</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lock_buffer(bh);
bh-&gt;b_end_io = end_buffer_io_async;
atomic_inc(&amp;bh-&gt;b_count);
submit_bh(READ, arr[i])
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>293</x>
      <y>3591</y>
      <w>82</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.页面locked（PageLocked），此时页面正在和磁盘交互，不管是读还是写，当这个locked清除的时候，页面必然uptodate
	如果之前有预读（f_ralen存在），且当前页面在预读窗口内（raend-f_rawin ~ raend），此时因为磁盘繁忙，并且有预读窗口
	所以暂时不用预读
	如果之前没有预读（!f_ralen）,或者当前页面超出了预读窗口，将本次要读的长度预读到内存中
2.页面没锁
	如果首页在窗口中（reada_ok不为0），不是随机读的条件1（f_ramax不为0），并且在ahead窗口中，此时需要预读；预读的长度
	为f_ramax + 1，并且将之前的ahead窗口改变为现在的current窗口（filp-&gt;f_rawin = filp-&gt;f_ralen），ahead窗口
	将会在之后被设置

注：
1.预读窗口分为current（raend-f_rawin ~ raend-f_ralen）窗口和ahead（raend-f_ralen ~ raend）窗口，其中f_ralen
	指上次预读的长度，f_rawin指的是上次和上上次一起读的长度
2.随机读的条件：
	条件1.读的是最前半页
	条件2：此次读的首页不在整个预读窗口中
	条件1不成立的时候，绝对不会预读；但是条件2不成立的时候，会预读本次要读的数据到内存中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>350</x>
      <y>3579</y>
      <w>100</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>980.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>421</x>
      <y>3579</y>
      <w>40</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
执行需要预读的页面，
超过预读的量，或者超过inode.i_size,或者预读出错，就退出</panel_attributes>
    <additional_attributes>270.0;10.0;120.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>425</x>
      <y>3590</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>447</x>
      <y>3579</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有预读页面（ahead不为0）</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>456</x>
      <y>3585</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果进行了窗口的切换
reada_ok==2</panel_attributes>
    <additional_attributes>130.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>450</x>
      <y>3591</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>run_task_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>468</x>
      <y>3585</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>466</x>
      <y>3590</y>
      <w>25</w>
      <h>18</h>
    </coordinates>
    <panel_attributes> //更新ahead窗口
filp-&gt;f_ralen += ahead;
	//更新整个预读窗口
filp-&gt;f_rawin += filp-&gt;f_ralen;
filp-&gt;f_raend = raend + ahead + 1;
 //预读页面*2
filp-&gt;f_ramax += filp-&gt;f_ramax;

if (filp-&gt;f_ramax &gt; max_readahead)
	filp-&gt;f_ramax = max_readahead;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>492</x>
      <y>3587</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drop_behind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>447</x>
      <y>3579</y>
      <w>54</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放窗口之前的page</panel_attributes>
    <additional_attributes>10.0;10.0;520.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>509</x>
      <y>3587</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>profile_readahead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>447</x>
      <y>3579</y>
      <w>69</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>494</x>
      <y>3594</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果首页到index的长度大于窗口的长度（f_rawin），
	只释放f_rawin的页面，否则一直释放到首页
2.在hash表中找到page，并释放deactivate_page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>499</x>
      <y>3590</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>381</x>
      <y>3603</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>page_hash
__find_page_nolock
return 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>386</x>
      <y>3593</y>
      <w>49</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从hash中查找page</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>433</x>
      <y>3593</y>
      <w>16</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果在hash中没找到</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>398</x>
      <y>3607</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>403</x>
      <y>3602</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>416</x>
      <y>3608</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>456</x>
      <y>3609</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>432</x>
      <y>3609</y>
      <w>20</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mapping-&gt;a_ops-&gt;readpage
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>422</x>
      <y>3602</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>433</x>
      <y>3602</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>433</x>
      <y>3602</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>587</x>
      <y>3506</y>
      <w>94</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_file_operations</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>674</x>
      <y>3519</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_file_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>621</x>
      <y>3534</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dp=inode-&gt;u.generic_ip
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>627</x>
      <y>3522</y>
      <w>54</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取inode对应的硬盘文件（被抽象）</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>655</x>
      <y>3534</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_free_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>660</x>
      <y>3522</y>
      <w>22</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
分配内存</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>679</x>
      <y>3522</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>669</x>
      <y>3531</y>
      <w>37</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读取大小</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>653</x>
      <y>3540</y>
      <w>29</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>count = MIN(PROC_BLOCK_SIZE, nbytes)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>683</x>
      <y>3542</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes> dp-&gt;get_info
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>702</x>
      <y>3531</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
eof指示是否结束</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>688</x>
      <y>3536</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
之前的版本</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>702</x>
      <y>3543</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dp-&gt;read_proc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>702</x>
      <y>3536</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
新版本
返回此次读的长度</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>686</x>
      <y>3553</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>loadavg_read_proc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>707</x>
      <y>3546</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在proc_misc_init中初始化create_proc_read_entry</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>652</x>
      <y>3564</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sprintf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>659</x>
      <y>3556</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
avenrun记录这cup的负荷
nr_running, nr_threads, last_pid
分别是处于运行态的进程数量
线程的数量
最大的pid号</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>686</x>
      <y>3563</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_calc_metrics</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>692</x>
      <y>3556</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
len表示文件现在存在的数据长度</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>679</x>
      <y>3572</y>
      <w>23</w>
      <h>16</h>
    </coordinates>
    <panel_attributes> //这个条件到了文件末尾
if (len &lt;= off+count) *eof = 1;
 //offset的地址
*start = page + off;
 //此次应该读的长度，如果大于了
 //count或者小于0就更新
len -= off;
if (len&gt;count) len = count;
if (len&lt;0) len = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>688</x>
      <y>3566</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>737</x>
      <y>3540</y>
      <w>25</w>
      <h>14</h>
    </coordinates>
    <panel_attributes> //文件偏移量更新
*ppos += start &lt; page ? (long)start : n
 //剩下需要读的字节数
nbytes -= n;
 //用户空间的指针更新
buf += n;
 //完成的字节数更新
retval += n;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>722</x>
      <y>3543</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_to_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>703</x>
      <y>3531</y>
      <w>26</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>703</x>
      <y>3531</y>
      <w>44</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>734</x>
      <y>3555</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>meminfo_read_proc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>693</x>
      <y>3550</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>707</x>
      <y>3550</y>
      <w>35</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>717</x>
      <y>3563</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>si_meminfo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>735</x>
      <y>3564</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>si_swapinfo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>722</x>
      <y>3558</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>738</x>
      <y>3558</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>705</x>
      <y>3572</y>
      <w>33</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>val-&gt;totalram = totalram_pages;
val-&gt;sharedram = 0;
val-&gt;freeram = nr_free_pages();
val-&gt;bufferram = atomic_read(&amp;buffermem_pages);
val-&gt;totalhigh = totalhigh_pages;
val-&gt;freehigh = nr_free_highpages();
val-&gt;mem_unit = PAGE_SIZE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>720</x>
      <y>3566</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>739</x>
      <y>3572</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>val-&gt;freeswap = freeswap;
val-&gt;totalswap = totalswap;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>729</x>
      <y>3567</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
记录交换设备上空闲的page（swap_map如果为0）
注意switch没有break</panel_attributes>
    <additional_attributes>120.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>751</x>
      <y>3565</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sprintf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>738</x>
      <y>3558</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>771</x>
      <y>3566</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_calc_metrics</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>738</x>
      <y>3558</y>
      <w>42</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>792</x>
      <y>3529</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pid_maps_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>587</x>
      <y>3506</y>
      <w>218</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果读/proc/self/maps
proc_maps_operations</panel_attributes>
    <additional_attributes>10.0;10.0;2160.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>771</x>
      <y>3540</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>inode = file-&gt;f_dentry-&gt;d_inode
task = inode-&gt;u.proc_i.task
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>781</x>
      <y>3532</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>787</x>
      <y>3549</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.一个vma，用MAPS_LINE_SHIFT个字符表示
2.lineno表示偏移的vma
	column表示在vma中的偏移
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>799</x>
      <y>3544</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
解释</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>821</x>
      <y>3549</y>
      <w>45</w>
      <h>43</h>
    </coordinates>
    <panel_attributes>1.首先遍历mm-&gt;mmap，lineno个vma，找到偏移的vma
2.map-&gt;vm_start, map-&gt;vm_end之后的5个字符
	查看第4条（cp初始地址和str相同）
	*cp++ = flags &amp; VM_READ ? 'r' : '-';
	*cp++ = flags &amp; VM_WRITE ? 'w' : '-';
	*cp++ = flags &amp; VM_EXEC ? 'x' : '-';
	*cp++ = flags &amp; VM_MAYSHARE ? 's' : 'p';
	*cp++ = 0;
3.如果该vma映射了file，那么通过d_path将file的绝对地址存在
	buffer中（这个file向前索引最大到当前进程的root，如果删除
	路径后面会接上/(deleted)）
4.通过sprintf复制 map-&gt;vm_start, map-&gt;vm_end, str, map-&gt;vm_pgoff
	等信息到buffer中（maxlen没用完的，用空格填充）
5.如果vma中的偏移column已经大过了此次vma中的总长度len
6.copy_to_user复制len-column到用户空间
7.更新读的指针，
	destptr += i;
	count   -= i;
	column  += i;
	//更新到下一个vma
	if (column &gt;= len) {
		column = 0; /* next time: next line at column 0 */
		lineno++;
	}
8.循环结束后，更新偏移量
	*ppos = (lineno &lt;&lt; MAPS_LINE_SHIFT) + column
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>793</x>
      <y>3541</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_pid_read_maps</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>800</x>
      <y>3532</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
返回复制的长度</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>765</x>
      <y>3552</y>
      <w>18</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>buffer = __get_free_page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>773</x>
      <y>3544</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>800</x>
      <y>3544</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>586</x>
      <y>3506</y>
      <w>333</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
def_blk_fops</panel_attributes>
    <additional_attributes>10.0;10.0;3310.0;280.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>911</x>
      <y>3534</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>block_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>869</x>
      <y>3544</y>
      <w>52</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>blocksize：设备上的块大小（默认是BLOCK_SIZE，查询blksize_size）
blocksize_bits：blocksize所占的位
size：设备的大小（默认INT_MAX 查询blk_size，为单位）
offset：文件内的偏移
left：要读的字节数（1.offset不能大于size;2.不能超过INT_MAX；3.不能超过进程要读的字节数count）
block:起始块的索引（offset &gt;&gt; blocksize_bits）
 //属性发生变化
offset:在块内的偏移
size：设备结束块的索引
blocks：要读的block数，
（初始值：(left + offset + blocksize - 1) &gt;&gt; blocksize_bits
预读调整：read_ahead[MAJOR(dev)] / (blocksize &gt;&gt; 9)，如果小于这个值，blocks就调整为这个值
			由此可知read_ahead存储预读的块的数量（块的大小是512字节）
size调整：不能大于size - block这个剩余的大小
）
bhb：指向这个循环最后一个从设备读到内核的bh
bhe：指向这个循环最后一个从内核写到用户的bh
buflist：相当于一个FIFO,bhb是写指针（将设备的数据写到内核）bhe是读指针（将内核的数据读到用户）
	这两个指针初始化为buflist
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>889</x>
      <y>3537</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>922</x>
      <y>3544</y>
      <w>58</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.首先将要读取的block添加到队列buflist中，这里file的逻辑block和设备的block相同
	*bhb = getblk(dev, block++, blocksize)
	如果!buffer_uptodate，将bh添加到数组bhreq中
	在以下三种情况退出wile循环：
	1.第一个读进来的bh已经uptodate（uptodate！=0）
	2.队列buflist已经被装满（bhb == bhe）
	3.要读的blocks读完了（blocks==0）
2.如果数组中装有未更新的bh（bhrequest!=0）,通过ll_rw_block读取数组bhreq
	中bhrequest个bh
3.进入第二层do..while
	1.通过wait_on_buffer等待bh更新，当醒来时bh应该已经更新，如果没更新，将left赋值为0
		退出整个read过程
	2.更新读进来的字节数chars，如果left没讲block占满，则为chars = left；否者就是
		chars = blocksize - offset
		并进一步更新偏移量ppos，剩余读取量left，读取两read
	3.利用copy_to_user将数据从内核copy到用户空间，并更新buf += chars
	4.offset = 0；++bhe（到最后就回到最开始）
	5.当剩余读取量left&lt;=0，或者队列buflist读完（bhe == bhb），或者要操作的bh还没更新（buffer_locked(*bhe)）
		退出第二层do...while。
		注：当第一个条件满足时退出读操作；当第二个条件满足，并且blocks读完了，退出读操作，但是blocks没读完时，继续
		通过第一层do..while填充队列buflist；当第三个条件满足时，在第一层do..while中填充队列buflist
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>916</x>
      <y>3537</y>
      <w>26</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
第一层do..while</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>586</x>
      <y>3506</y>
      <w>467</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty_fops</panel_attributes>
    <additional_attributes>10.0;10.0;4650.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1046</x>
      <y>3519</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>997</x>
      <y>3522</y>
      <w>58</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>560.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>973</x>
      <y>3532</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.只能顺序读，所以ppos = &amp;file-&gt;f_pos
2.通过file-&gt;private_data获取tty
3.通过tty_paranoia_check检查tty是否为NULL
·magic是否为TTY_MAGIC
4.检查tty是否为空，或者tty-&gt;flags是否有TTY_IO_ERROR
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1026</x>
      <y>3535</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;ldisc.read
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1030</x>
      <y>3522</y>
      <w>26</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty-&gt;ldisc.read存在</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1069</x>
      <y>3535</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_atime = CURRENT_TIME
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1052</x>
      <y>3522</y>
      <w>28</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1031</x>
      <y>3538</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty_ldisc_N_TTY</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1025</x>
      <y>3543</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_chan</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>988</x>
      <y>3546</y>
      <w>45</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>984</x>
      <y>3551</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.tty-&gt;read_buf要存在
2.如果不是当前虚拟终端或者控制台，只是进程的tty
（TODO:暂时不是很清楚）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1029</x>
      <y>3546</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
！tty-&gt;icanon
原始模式
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1019</x>
      <y>3551</y>
      <w>38</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>从termios-&gt;c_cc中获取控制信息
time = (HZ / 10) * TIME_CHAR(tty);
minimum = MIN_CHAR(tty)
1.如果time和minimum都存在，minimum_to_wake=1，因为每次收到需要重置时间
2.如果minum存在，但是time没有，minimum_to_wake取较小的那个（等待队列为空
	就是minimum、如果等待队列不为空，就取小的那个）
3.如果没有mininum，则tty-&gt;minimum_to_wake = minimum = 1
	如果有time，将timeout的时间设置成time，否则默认为0
注：minimum_to_wake：当键入多少字符时应该唤醒tty-&gt;read_wait
	minimum：如果buffer中有minimum的字符在，即使没到nr也不会阻塞	
	timeout：进程如果没有字符，进入休眠。如果此时，进程收到了minimum_to_wake
		会醒来；或者timeout时间到了之后，醒来，如果字符有字符会继续读到buffer
		然后继续睡
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1058</x>
      <y>3552</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果是不阻塞file-&gt;f_flags &amp; O_NONBLOCK
	使用down_trylock，如果没锁住就退出
2.如果不是，就采用down_interruptible
	如果没锁住就睡眠
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1030</x>
      <y>3546</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty-&gt;atomic_read
</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1080</x>
      <y>3552</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.首先通过add_wait_queue将
	其加入等待队列tty-&gt;read_wait
2.set_bit(TTY_DONT_FLIP, &amp;tty-&gt;flags)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1031</x>
      <y>3546</y>
      <w>58</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;560.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1030</x>
      <y>3546</y>
      <w>88</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读数据
</panel_attributes>
    <additional_attributes>10.0;10.0;860.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1100</x>
      <y>3550</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tty-&gt;packet（信包模式）
&amp;&amp;tty-&gt;link-&gt;ctrl_status（有数据）</panel_attributes>
    <additional_attributes>160.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1100</x>
      <y>3555</y>
      <w>17</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果之前读有其他数据（b != buf），退出整个读
2.否则将ctrl_status的数据放入到buffer，并退出
	cs = tty-&gt;link-&gt;ctrl_status;
	tty-&gt;link-&gt;ctrl_status = 0;
	put_user(cs, b++);
	nr--;
	break;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1112</x>
      <y>3550</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TASK_INTERRUPTIBLE</panel_attributes>
    <additional_attributes>40.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1119</x>
      <y>3554</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_current_state
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1136</x>
      <y>3554</y>
      <w>17</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果之前读有其他数据（b != buf），退出整个读
2.否则将ctrl_status的数据放入到buffer，并退出
	cs = tty-&gt;link-&gt;ctrl_status;
	tty-&gt;link-&gt;ctrl_status = 0;
	put_user(cs, b++);
	nr--;
	break;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1115</x>
      <y>3550</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1155</x>
      <y>3554</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tty-&gt;minimum_to_wake
	= (minimum - (b - buf))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1115</x>
      <y>3550</y>
      <w>48</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据已经写到buffer的数据
更新minimum_to_wake</panel_attributes>
    <additional_attributes>10.0;10.0;460.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1115</x>
      <y>3550</y>
      <w>63</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1173</x>
      <y>3553</y>
      <w>29</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.通过input_available_p检查buffer是否有
	数据（有数据返回1，没有返回0）
2.如果没有数据：
	1.tty-&gt;flags的TTY_OTHER_CLOSED，退出
	报错EIO
	2.tty_hung_up_p检查file的fops是否为hung_up_tty_fops
		（可以等等），直接退出
	3.如果timeout时间为0，直接退出
	4.如果file-&gt;f_flags &amp; O_NONBLOCK，报
		EAGAIN，退出
	5.如果当前进程signal_pending，报ERESTARTSYS
		退出
	6.否则清除TTY_DONT_FLIP，然后以timeout时间
	为限schedule_timeout，醒来之后将TTY_DONT_FLIP
	置上，然后重新循环
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1179</x>
      <y>3582</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>input_available_p</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1183</x>
      <y>3578</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1173</x>
      <y>3589</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果是加工模式（tty-&gt;icanon），并且
	缓冲行有数据（canon_data），返回1
2.如果处于原始模式，read_cnt超过规定
	数量，返回1
3.否者返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1184</x>
      <y>3585</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1203</x>
      <y>3553</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>put_user(TIOCPKT_DATA, b++);
nr--;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1115</x>
      <y>3550</y>
      <w>95</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果packet mode
并且之前没读过(b == buf)</panel_attributes>
    <additional_attributes>10.0;10.0;930.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1226</x>
      <y>3553</y>
      <w>41</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.如果是加工模式（tty-&gt;icanon），就循环读取，直到
	读完nr或者将整个缓冲行读完（tty-&gt;read_cnt）
	1.1.read_flags中记载着该位置上的字符是不是缓冲行终结字符（\n）
	1.2.将buffer队列中的数据取出tty-&gt;read_buf[tty-&gt;read_tail]
	1.3.更新读端tty-&gt;read_tail，更新tty-&gt;read_cnt--
	1.4.如果是缓冲行最后一个字符是'\0'，就不用复制到用户空间
		否者：
		put_user(c, b++);
		nr--;
	1.5.如果缓冲行结束（eol），就退出此次复制
2.通过copy_from_read_buf将缓冲队列中的数据复制到用户空间
	（这里buffer是一个回环队列，而copy_from_read_buf
	中copy_to_user地址只能朝一个方向生长，所以这里复制了两次）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1114</x>
      <y>3550</y>
      <w>124</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1220.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1241</x>
      <y>3579</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_from_read_buf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1247</x>
      <y>3575</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1230</x>
      <y>3586</y>
      <w>34</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.从要读的数据nr，buffer中存在的数据量tty-&gt;read_cnt
	以及tail到buffer尾端的长度（N_TTY_BUF_SIZE - tty-&gt;read_tail，
	这里是让tail之前的数据，在另一个copy_from_read_buf
	中执行）选取一个最小值
2.通过copy_to_user将缓冲队列中的数据（tty-&gt;read_buf）
	复制到用户空间
3.更新缓冲队列，用户空间buffer和nr
	tty-&gt;read_tail = (tty-&gt;read_tail + n) &amp; (N_TTY_BUF_SIZE-1);
	tty-&gt;read_cnt -= n
	*b += n;
	*nr -= n;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1247</x>
      <y>3582</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1271</x>
      <y>3553</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过n_tty_chars_in_buffer检查缓冲队列中的数据
	是否低于TTY_THRESHOLD_UNTHROTTLE。如果低于
	通过check_unthrottle将阀门打开
注;当键盘输入过快时，应用程序来不及将数据读入缓冲区
	驱动（中断)会将阀门关闭，现在低于门限，需要将其
	打开
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1272</x>
      <y>3567</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>n_tty_chars_in_buffer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1277</x>
      <y>3563</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1268</x>
      <y>3574</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果处于原始模式(!tty-&gt;icanon)，
	缓冲队列中的字符数是tty-&gt;read_cnt
2.如果处于加工模式，并且缓冲行
	有数据（tty-&gt;canon_data），字符
	数是tail~head的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1278</x>
      <y>3570</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1293</x>
      <y>3567</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>check_unthrottle</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1292</x>
      <y>3563</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1294</x>
      <y>3574</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>检查TTY_THROTTLED是否置上，
如果置上，使用tty-&gt;driver.unthrottle
将阀门打开
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1299</x>
      <y>3570</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1114</x>
      <y>3550</y>
      <w>171</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1690.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1303</x>
      <y>3553</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果读入字符数量超过了minimum，则退出
2.如果继续读的话，更新timeout为time
注;nr决定了此次读的上限，minimum是下限，
	加工模式具体读多少取决于缓冲行
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1115</x>
      <y>3550</y>
      <w>197</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1950.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1337</x>
      <y>3550</y>
      <w>25</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>clear_bit(TTY_DONT_FLIP
remove_wait_queue(&amp;tty-&gt;read_wait
 //如果等待队列tty-&gt;read_wait中没有
 //等待的进程，更新minimum_to_wake
tty-&gt;minimum_to_wake = minimum

current-&gt;state = TASK_RUNNING
 //如果读到数据（b - buf），返回b - buf
 //如果nr存在（表示进程已经来读过）
 clear_bit(TTY_PUSH
 //如果没读到数据，且TTY_PUSH，就
 //返回重新读
注：TTY_PUSH是底层驱动读到EOF将
	其置成1，表示进程需尽快读走
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1031</x>
      <y>3546</y>
      <w>313</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>589</x>
      <y>3506</y>
      <w>804</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_scanner_fops</panel_attributes>
    <additional_attributes>10.0;10.0;8020.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1386</x>
      <y>3529</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_scanner</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1388</x>
      <y>3532</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1372</x>
      <y>3536</y>
      <w>39</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.更新时间：
	file-&gt;f_dentry-&gt;d_inode-&gt;i_atime = CURRENT_TIME
2.循环从usb设备中读取count个数据
	1.检查进程如果有signal_pending，返回EINTR
	2.依次读的量不能大于IBUF_SIZE，并通过usb_bulk_msg去usb设备中读
	3.如果结果是timeout，并且没有任何数据读进来。这样的情形最多有RD_EXPIRE
	次，每次通过interruptible_sleep_on_timeout让进程睡眠RD_NAK_TIMEOUT
	时间；
	如果是其他错误（除了USB_ST_DATAUNDERRUN），返回EIO
	4.如果读到了数据（partial），最多将其前24字节打印出来
	5.如果读到了数据（partial），通过copy_to_user将数据copy到用户空间,并更新：
	//预期读this_read,实际读partial
	count -= this_read; /* Compensate for short reads */
	bytes_read += partial; /* Keep tally of what actually was read */
	buffer += partial;
	如果没读到数据，直接返回bytes_read
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1388</x>
      <y>3568</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_bulk_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1390</x>
      <y>3562</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_rcvbulkpipe
endpoint是bulk_in_ep</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1367</x>
      <y>3575</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_alloc_urb
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1371</x>
      <y>3571</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1382</x>
      <y>3575</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>urb-&gt;dev=usb_dev;\
urb-&gt;pipe=pipe;\
urb-&gt;transfer_buffer=data;\
urb-&gt;transfer_buffer_length=len;\
urb-&gt;complete=usb_api_blocking_completion;\
urb-&gt;context=0;\
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1392</x>
      <y>3571</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FILL_BULK_URB</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1408</x>
      <y>3575</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_start_wait_urb
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1394</x>
      <y>3571</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1437</x>
      <y>3523</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_read</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>591</x>
      <y>3506</y>
      <w>853</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
read_fifo_fops</panel_attributes>
    <additional_attributes>10.0;10.0;8510.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1414</x>
      <y>3530</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.因为pipe不能lseek，所以ppos
	指针必须是&amp;filp-&gt;f_pos
	如果不是，返回ESPIPE
2.如果要读的数据是count，返回0
3.通过inode.sem对整个过程保护
	（down_interruptible）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1422</x>
      <y>3526</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1441</x>
      <y>3526</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果fifo中没有数据
PIPE_EMPTY（inode.i_size=0）</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1435</x>
      <y>3530</y>
      <w>28</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果没有PIPE_WRITERS，直接返回0
2.如果f_flags &amp; O_NONBLOCK，返回EAGAIN
3.循环：
	增加WAITING_READERS的计数，然后通过pipe_wait
	睡眠。
	如果醒来之后，减少WAITING_READERS的计数
	1.如果是因为信号被唤醒（signal_pending），返回ERESTARTSYS
	2.如果是因为有数据被唤醒（!PIPE_EMPTY），退出循环
	3.如果是因为没PIPE_WRITERS被唤醒，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1442</x>
      <y>3549</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_wait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1447</x>
      <y>3545</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1447</x>
      <y>3552</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1444</x>
      <y>3526</y>
      <w>42</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
到这是因为有数据可读</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1470</x>
      <y>3530</y>
      <w>27</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.循环读取数据，直到进程要求读取的数据读取完（count&lt;=0）
	或者fifo中的数据读取完（PIPE_LEN=0）
2.一次读取的数据是count，PIPE_LEN以及PIPE_MAX_RCHUNK（
	start到fifo尾端的长度）的最小值
3.通过copy_to_user将fifo中的数据复制到用户空间
4.更新数据：
	//read是已读的所有数据长度
	read += chars;
	//start是读端的起始位置
	PIPE_START(*inode) += chars;
	PIPE_START(*inode) &amp;= (PIPE_SIZE - 1);
	PIPE_LEN(*inode) -= chars;
	count -= chars;
	buf += chars;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1445</x>
      <y>3526</y>
      <w>63</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_LEN=0
fifo中的数据全部读完
减少下次分两段读的可能性</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1500</x>
      <y>3529</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>PIPE_START(*inode) = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1445</x>
      <y>3526</y>
      <w>85</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;830.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1523</x>
      <y>3529</y>
      <w>30</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果进程要读的数据并没有被读完（count！=0）
	并且pipe中有等待的写端（WAITING_WRITERS）
	并且file被设置成block（!(f_flags &amp; O_NONBLOCK)）
	将等待队列中的唤醒，并跳到do_more_read去等待：
	wake_up_interruptible_sync(PIPE_WAIT(*inode));
	goto do_more_read;
2.如果上述条件并不满足，直接通过wake_up_interruptible唤醒
	等待队列，并返回已读的数据字节数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1432</x>
      <y>3555</y>
      <w>31</w>
      <h>19</h>
    </coordinates>
    <panel_attributes> //申明wait，并将其挂入等待队列
DECLARE_WAITQUEUE(wait, current);
current-&gt;state = TASK_INTERRUPTIBLE;
add_wait_queue(PIPE_WAIT(*inode), &amp;wait);
 //释放信号量，并调度
up(PIPE_SEM(*inode));
schedule();
 //移除wait，并申请信号量
remove_wait_queue(PIPE_WAIT(*inode), &amp;wait);
current-&gt;state = TASK_RUNNING;
down(PIPE_SEM(*inode));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>922</x>
      <y>3601</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.check bh.size和正确的block size是否一致
2.如果要求写，通过is_read_only查看dev是否
	只读

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>954</x>
      <y>3598</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>951</x>
      <y>3603</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过test_and_set_bit
	检查并设置BH_Lock
2.bh-&gt;b_end_io = 
			end_buffer_io_sync
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>960</x>
      <y>3598</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
rw</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>969</x>
      <y>3602</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
WRITE</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>967</x>
      <y>3606</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过atomic_set_buffer_clean
	检查并清除BH_Dirty
	如果没有置上，通过b_end_io
	结束这个bh请求
2.如果dirty置上了，通过__mark_buffer_clean
	改变bh在lru数组中的位置
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>972</x>
      <y>3602</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
READA
READ</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>988</x>
      <y>3607</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.检查bh是否uptodate，如果
	更新了，通过b_end_io结束
	bh请求
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>960</x>
      <y>3598</y>
      <w>70</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果bh请求没被end_io</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1021</x>
      <y>3607</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>submit_bh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>970</x>
      <y>3617</y>
      <w>32</w>
      <h>13</h>
    </coordinates>
    <panel_attributes> //lock要置上
test_bit(BH_Lock

set_bit(BH_Req
bh-&gt;b_rdev = bh-&gt;b_dev;
 //扇区的大小是512字节
bh-&gt;b_rsector = bh-&gt;b_blocknr * (bh-&gt;b_size&gt;&gt;9);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>980</x>
      <y>3610</y>
      <w>49</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1028</x>
      <y>3615</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_make_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1027</x>
      <y>3610</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1028</x>
      <y>3610</y>
      <w>42</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1063</x>
      <y>3615</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>WRITE:
kstat.pgpgout++
default:
kstat.pgpgin++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1006</x>
      <y>3618</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1003</x>
      <y>3621</y>
      <w>29</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.b_end_io要存在
2.通过blk_size计算出dev的扇区数maxsector
	通过bh-&gt;b_size计算出一个bh包含多少个扇区
	如果要写的扇区数count&gt;maxsector
	或者从sector写count个扇区后超过maxsector
	bh-&gt;b_state &amp;= (1 &lt;&lt; BH_Lock) | (1 &lt;&lt; BH_Mapped)
	bh-&gt;b_end_io(bh, 0)
halign=left
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1016</x>
      <y>3618</y>
      <w>51</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过do..while循环向终极设备发送请求
例如对RAID设备，因为RAID设备是对底层硬盘的抽象
所以通过make_request_fn向RAID设备发送请求时，
RAID设备会向第一块硬盘写，然后返回1，通过do..while
再次发送请求，RAID会向第二块硬盘发送写请求，并返回0，终止make_request
注：RAID参考南京大学蒋炎岩老师的视频</panel_attributes>
    <additional_attributes>220.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1039</x>
      <y>3621</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1033</x>
      <y>3624</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blk_get_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1033</x>
      <y>3630</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__blk_get_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1038</x>
      <y>3627</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1029</x>
      <y>3633</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1013</x>
      <y>3637</y>
      <w>37</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果blk_dev[MAJOR(dev)].queue存在，返回queue
2.否者返回blk_dev[MAJOR(dev)].request_queue
注：首次通过queue找到dev的队列，之后就可以直接通过
	request_queue找到
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1043</x>
      <y>3621</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1020</x>
      <y>3648</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_get_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1052</x>
      <y>3625</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;make_request_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1026</x>
      <y>3643</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hwif_init：
blk_dev[hwif-&gt;major].data = hwif;
blk_dev[hwif-&gt;major].queue = ide_get_queue;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1011</x>
      <y>3654</y>
      <w>28</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>hwif-&gt;drives[DEVICE_NR(dev) &amp; 1].queue
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1025</x>
      <y>3651</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1050</x>
      <y>3627</y>
      <w>44</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hwif_init-&gt;init_irq-&gt;ide_init_queue-&gt;blk_init_queue-&gt;__make_request</panel_attributes>
    <additional_attributes>100.0;20.0;330.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1076</x>
      <y>3630</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__make_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1051</x>
      <y>3638</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果是预读（READA）：
	rw_ahead = 1;
	rw = READ
2.通过buffer_mapped检测bh是否
	映射到磁盘

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1053</x>
      <y>3633</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1075</x>
      <y>3640</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_bounce</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1080</x>
      <y>3633</y>
      <w>5</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1081</x>
      <y>3643</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
DMA寻址范围是32位，不能寻址超过4G
需要将低内存区域对其做一个镜像
注：__GFP_HIGH和__GFP_HIGHMEM不一样</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1059</x>
      <y>3646</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1048</x>
      <y>3650</y>
      <w>21</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>!PageHighMem，不做任何处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1073</x>
      <y>3646</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bh_cachep中申请bh</panel_attributes>
    <additional_attributes>90.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1071</x>
      <y>3650</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1086</x>
      <y>3650</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1080</x>
      <y>3646</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在低于4G申请内存</panel_attributes>
    <additional_attributes>20.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1096</x>
      <y>3654</y>
      <w>30</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>set_bh_page(bh, page, 0);

bh-&gt;b_next = NULL;
bh-&gt;b_blocknr = bh_orig-&gt;b_blocknr;
bh-&gt;b_size = bh_orig-&gt;b_size;
bh-&gt;b_list = -1;
bh-&gt;b_dev = bh_orig-&gt;b_dev;
bh-&gt;b_count = bh_orig-&gt;b_count;
bh-&gt;b_rdev = bh_orig-&gt;b_rdev;
bh-&gt;b_state = bh_orig-&gt;b_state;
bh-&gt;b_flushtime = jiffies;
bh-&gt;b_next_free = NULL;
bh-&gt;b_prev_free = NULL;
bh-&gt;b_reqnext = NULL;
bh-&gt;b_pprev = NULL;

w:
bh-&gt;b_end_io = bounce_end_io_write;
copy_from_high_bh(bh, bh_orig);
r:
bh-&gt;b_end_io = bounce_end_io_read

bh-&gt;b_private = (void *)bh_orig;
bh-&gt;b_rsector = bh_orig-&gt;b_rsector;
memset(&amp;bh-&gt;b_wait, -1, sizeof(bh-&gt;b_wait));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1081</x>
      <y>3646</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1113</x>
      <y>3636</y>
      <w>39</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.从max_sectors中获取dev的扇区数（默认是MAX_SECTORS）
2.获取latency(r:read_latency;w:write_latency)，用于后期电梯
	算法的优化
3.如果req已经开始执行，但是没从队列里删除，会在执行完
	之后删除（q-&gt;head_active）
	并且不在bottom_half的任务队列tq_disk中（!q-&gt;plugged）
	head指向q-&gt;queue_head-&gt;next
4.如果队列为空：list_empty(head)，执行q-&gt;plug_device_fn
	因为队列为空，所以不用电梯算法优化，直接get_rq（申请req，
	加入到电梯队列中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1082</x>
      <y>3633</y>
      <w>44</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1133</x>
      <y>3655</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;plug_device_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1140</x>
      <y>3652</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1138</x>
      <y>3658</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
blk_init_queue</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1133</x>
      <y>3661</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_plug_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1127</x>
      <y>3668</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果请求队列为空或者
	队列中有req在tq_disk中
	这个req的IO由进程自己启动
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1134</x>
      <y>3664</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1140</x>
      <y>3664</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不由进程启动IO</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1153</x>
      <y>3667</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1148</x>
      <y>3671</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;plugged = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1156</x>
      <y>3667</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将队列挂在tq_disk中</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1164</x>
      <y>3671</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>queue_task</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1154</x>
      <y>3677</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>test_and_set_bit
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1170</x>
      <y>3677</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_add_tail
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1155</x>
      <y>3674</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
队列的plug_tq.sync检查是否为0
并置1</panel_attributes>
    <additional_attributes>130.0;10.0;70.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1168</x>
      <y>3674</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1159</x>
      <y>3636</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>elevator-&gt;elevator_merge_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1081</x>
      <y>3633</y>
      <w>86</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
blk_init_queue
ELEVATOR_LINUS</panel_attributes>
    <additional_attributes>10.0;10.0;840.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1160</x>
      <y>3643</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>elevator_linus_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1167</x>
      <y>3639</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1153</x>
      <y>3650</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果q-&gt;queue_head只是因为没执行完
	而没在队列中删除（head_active），
	而不是其他原因（q-&gt;plugged），就将
	head指向队列中的下一个
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1162</x>
      <y>3646</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1182</x>
      <y>3650</y>
      <w>37</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.向前遍历request_queue链表，滤除以下req：
	1.队列中req信号量sem存在
	2.队列中req的cmd的读写操作和rw不同
	3.队列中的req写的nr_sectors和现在req要写扇区数
	（count）超过了最大扇区数max_sectors
	4.队列中的req的设备号rq_dev和要写的req
		的b_rdev不同
2.如果要写的req在队列中req的后面
	if (__rq-&gt;sector + __rq-&gt;nr_sectors == bh-&gt;b_rsector) {
			ret = ELEVATOR_BACK_MERGE;
3.如果要写的req在队列中req的前面
	if (__rq-&gt;sector - count == bh-&gt;b_rsector) {
		//elevator_sequence来自latency，在这个检测之前，会看其是否为0
		//这个在电梯算法中为了防止order值过大的req饥饿，所以只要在req的前面
		//有插一个新req，req和之后的req的elevator_sequence都会--
			__rq-&gt;elevator_sequence--;
			ret = ELEVATOR_FRONT_MERGE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1169</x>
      <y>3646</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1220</x>
      <y>3650</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>如果新的req需要merge，并且被merge
的req之后链表还有req
因为之后的req前面有添加req，
所以需要把他们的tmp-&gt;elevator_sequence--
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1169</x>
      <y>3646</y>
      <w>62</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;600.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1082</x>
      <y>3633</y>
      <w>193</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1910.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1260</x>
      <y>3637</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ELEVATOR_BACK_MERGE</panel_attributes>
    <additional_attributes>130.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1257</x>
      <y>3641</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1253</x>
      <y>3653</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ll_back_merge_fn</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1253</x>
      <y>3646</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;back_merge_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1259</x>
      <y>3649</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
blk_init_queue</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1230</x>
      <y>3660</y>
      <w>42</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果req中最后一个bh能和插入的bh在物理内存
	上合并成在一起：
	req-&gt;bhtail-&gt;b_data + req-&gt;bhtail-&gt;b_size == bh-&gt;b_data
	直接返回，不对nr_segments操作
2.如果不能，通过ll_new_segment对nr_segments进行操作
	req-&gt;nr_segments++;
	q-&gt;elevator.nr_segments++
	如果req-&gt;nr_segments超过了限制，返回0，从而不对req进行合并
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1253</x>
      <y>3656</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1265</x>
      <y>3641</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果可以进行合并</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1269</x>
      <y>3646</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //bhtail指向req-&gt;bh链表中最后一个bh
req-&gt;bhtail-&gt;b_reqnext = bh;
req-&gt;bhtail = bh;
req-&gt;nr_sectors = req-&gt;hard_nr_sectors += count;
req-&gt;e = elevator;
 //硬盘信息统计
drive_stat_acct
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1264</x>
      <y>3641</y>
      <w>47</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1303</x>
      <y>3646</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>attempt_back_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1303</x>
      <y>3653</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果当前req是队列中的最后一个，没
	办法merge，直接return
2.不是最后一个，通过attempt_merge
	看能否将req和req.next merge
注：因为新插入的req可能将前后两个req
	连接起来
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1308</x>
      <y>3665</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>attempt_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1312</x>
      <y>3649</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1315</x>
      <y>3662</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1302</x>
      <y>3672</y>
      <w>34</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.查看两个相邻的req在扇区上是否能合并
	req-&gt;sector + req-&gt;nr_sectors = next-&gt;sector
2.查看两个req的属性是否相同，参考elevator_linus_merge
	req-&gt;cmd = next-&gt;cmd
	&amp;&amp; req-&gt;rq_dev = next-&gt;rq_dev
	&amp;&amp; req-&gt;nr_sectors + next-&gt;nr_sectors &lt; max_sectors
	&amp;&amp; !next-&gt;sem
3.通过q-&gt;merge_requests_fn查看bh指向的物理内存
	是否可以合并（nr_segments不能超过限制）
4.如果可以合并：
	//将next的bh链表加入到req的bh链表中，bhtail指向next的bh最后一个
	req-&gt;bhtail-&gt;b_reqnext = next-&gt;bh;
	req-&gt;bhtail = next-&gt;bhtail;
	req-&gt;nr_sectors = req-&gt;hard_nr_sectors += next-&gt;hard_nr_sectors;
	//将next从队列中删除
	list_del(&amp;next-&gt;queue);
	blkdev_release_request
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1315</x>
      <y>3668</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1310</x>
      <y>3704</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_release_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1318</x>
      <y>3700</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1304</x>
      <y>3707</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1289</x>
      <y>3711</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>req-&gt;rq_status = RQ_INACTIVE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1307</x>
      <y>3707</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
req-&gt;free_list不为空
free_list记录req是来自read_req还是write_req链表</panel_attributes>
    <additional_attributes>130.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1316</x>
      <y>3710</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
req释放给free_list</panel_attributes>
    <additional_attributes>90.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1313</x>
      <y>3715</y>
      <w>9</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>list_add
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1324</x>
      <y>3714</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>req-&gt;free_list = NULL;
 //唤醒队列的req等待序列
wake_up(&amp;req-&gt;q-&gt;wait_for_request)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1325</x>
      <y>3710</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1272</x>
      <y>3637</y>
      <w>82</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ELEVATOR_FRONT_MERGE</panel_attributes>
    <additional_attributes>10.0;10.0;800.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1338</x>
      <y>3641</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1332</x>
      <y>3646</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;front_merge_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1332</x>
      <y>3653</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ll_front_merge_fn</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1337</x>
      <y>3649</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1337</x>
      <y>3663</y>
      <w>42</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果bh能和req的最前面的bh在物理内存上合并成在一起：
	bh-&gt;b_data + bh-&gt;b_size == req-&gt;bh-&gt;b_data
	直接返回，不对nr_segments操作
2.如果不能，通过ll_new_segment对nr_segments进行操作
	req-&gt;nr_segments++;
	q-&gt;elevator.nr_segments++
	如果req-&gt;nr_segments超过了限制，返回0，从而不对req进行合并
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1337</x>
      <y>3656</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1351</x>
      <y>3641</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果可以进行合并</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1358</x>
      <y>3644</y>
      <w>33</w>
      <h>18</h>
    </coordinates>
    <panel_attributes> //将bh插入到req的头部
bh-&gt;b_reqnext = req-&gt;bh;
req-&gt;bh = bh;
 //buffer指向第一个bh的数据内存地址
req-&gt;buffer = bh-&gt;b_data;
 //第一个bh有多少个扇区
req-&gt;current_nr_sectors = count;
req-&gt;sector = req-&gt;hard_sector = sector;
req-&gt;nr_sectors = req-&gt;hard_nr_sectors += count;
req-&gt;e = elevator;
drive_stat_acct
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1394</x>
      <y>3644</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>attempt_front_merge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1350</x>
      <y>3641</y>
      <w>53</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1393</x>
      <y>3651</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果当前req是队列中的第一个，没
	办法merge，直接return
2.不是第一个，通过attempt_merge
	看能否将req.prev和req merge
注：因为新插入的req可能将前后两个req
	连接起来
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1402</x>
      <y>3647</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1273</x>
      <y>3637</y>
      <w>173</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ELEVATOR_NO_MERGE</panel_attributes>
    <additional_attributes>10.0;10.0;1710.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1439</x>
      <y>3642</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_rq
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1264</x>
      <y>3641</y>
      <w>64</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1322</x>
      <y>3645</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1414</x>
      <y>3644</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1350</x>
      <y>3641</y>
      <w>70</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1419</x>
      <y>3651</y>
      <w>34</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果之前申请过freereq
	req = freereq;
	freereq = NULL
2.如果没申请过req，通过get_request申请，
	因为req在blk_init_free_list规定是有限的
	所以有可能申请不到
3.当申请不到时，如果时预读（rw_ahead），直接结束
	本次读取；如果不是通过__get_request_wait等待
	获取，因为醒来时电梯中的req可能发生改变，所以再次
	遍历dev的request_queue
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1431</x>
      <y>3645</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1420</x>
      <y>3671</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1424</x>
      <y>3667</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1407</x>
      <y>3677</y>
      <w>31</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.首先获取空闲req的read/write链表
	q-&gt;request_freelist[rw]
2.如果空闲req链表不为空，通过blkdev_free_rq
	从空闲链表中获取req
3.如果空闲req为空，尝试从write req空闲链表中
	通过blkdev_free_rq获取req
4.如果获取到req，将req脱链，并进行初始化
	list_del(&amp;rq-&gt;table);
	//释放时，释放给对应的free_list
	rq-&gt;free_list = list;
	rq-&gt;rq_status = RQ_ACTIVE;
	rq-&gt;special = NULL;
	//指向req队列
	rq-&gt;q = q;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1420</x>
      <y>3674</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1440</x>
      <y>3672</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__get_request_wait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1439</x>
      <y>3667</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1442</x>
      <y>3680</y>
      <w>35</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.申明一个wait，加入到队列的wait_for_request链表中
2.将进程的状态设置为TASK_UNINTERRUPTIBLE，并
	试图通过get_request获取req，如果得到了，则退出
	将进程的状态还原，并将wait从wait_for_request从
	链表中移除
3.如果还是无法获取req，通过generic_unplug_device
	执行req队列从而释放req，并schedule
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1447</x>
      <y>3675</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1453</x>
      <y>3696</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>generic_unplug_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1461</x>
      <y>3692</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1454</x>
      <y>3703</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__generic_unplug_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1461</x>
      <y>3699</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1461</x>
      <y>3706</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
q-&gt;plugged
如果有req在tq_disk中</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1456</x>
      <y>3709</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1449</x>
      <y>3712</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;plugged = 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1460</x>
      <y>3709</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
q-&gt;queue_head</panel_attributes>
    <additional_attributes>20.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1464</x>
      <y>3712</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;request_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1470</x>
      <y>3715</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_init_queue-&gt;blk_init_queue</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1465</x>
      <y>3719</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_ide_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1443</x>
      <y>3645</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果获取到了req</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1459</x>
      <y>3648</y>
      <w>37</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>req-&gt;cmd = rw;
req-&gt;errors = 0;
req-&gt;hard_sector = req-&gt;sector = sector;
req-&gt;hard_nr_sectors = req-&gt;nr_sectors = count;
 //第一个bh包含的扇区数
req-&gt;current_nr_sectors = count;
 //最初的bh只有一个内存区间
req-&gt;nr_segments = 1; 
req-&gt;nr_hw_segments = 1;
 //buffer是之后硬盘要返回数据的指针，指向缓冲区
req-&gt;buffer = bh-&gt;b_data;
req-&gt;sem = NULL;
 //bh指向链表，bhtail指向最后一个链表
req-&gt;bh = bh;
req-&gt;bhtail = bh;
req-&gt;rq_dev = bh-&gt;b_rdev;
req-&gt;e = elevator;
 //将req加入到电梯队列中
add_request(q, req, head, latency)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1487</x>
      <y>3682</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1485</x>
      <y>3678</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1482</x>
      <y>3685</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
硬盘信息统计</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1478</x>
      <y>3688</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drive_stat_acct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1492</x>
      <y>3688</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;elevator.elevator_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1489</x>
      <y>3685</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
blk_init_queue
ELEVATOR_LINUS</panel_attributes>
    <additional_attributes>40.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1496</x>
      <y>3695</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>elevator_linus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1500</x>
      <y>3691</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1478</x>
      <y>3702</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>req-&gt;elevator_sequence 
				= orig_latency
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1484</x>
      <y>3698</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1500</x>
      <y>3698</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1497</x>
      <y>3702</y>
      <w>32</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.从后向前扫描req链表
2.通过blkdev_entry_to_request获取temp
3.通过IN_ORDER来看要插入的req是否在权重
	上大于temp，如果大于，req就要插到temp的
	后面
	list_add(&amp;req-&gt;queue, entry)
4.如果小于temp，需要插到temp前面，通过
	检查elevator_sequence查看temp前面是否能
	插入req；如果不能，只能插到temp后面；如果可以
	elevator_sequence--
注：1. linux2.4.0为了防止电梯队列中队列最后的
		req饥饿，通过以下方法：
		1.从前向后遍历req链表
		2.elevator_sequence设置req能允许多少个req
			插入其前面
	2.相比于linux0.11，order的权重少了rw的比较
		另外，linux0.11依靠!IN_ORDER(tmp,tmp-&gt;next)
		来防止后面的req饥饿
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1507</x>
      <y>3643</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>out
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1083</x>
      <y>3633</y>
      <w>429</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;4270.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1082</x>
      <y>3633</y>
      <w>451</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;4490.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1500</x>
      <y>3646</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!q-&gt;plugged
如果不在tq_disk中</panel_attributes>
    <additional_attributes>110.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1497</x>
      <y>3651</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;request_fn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1510</x>
      <y>3651</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>blkdev_release_request
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1509</x>
      <y>3646</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果freereq没用
将其释放</panel_attributes>
    <additional_attributes>20.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1528</x>
      <y>3643</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>end_io
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1527</x>
      <y>3651</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bh-&gt;b_end_io
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1531</x>
      <y>3646</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1492</x>
      <y>3685</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1513</x>
      <y>3688</y>
      <w>26</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>当major满足：
COMPAQ_SMART2_MAJOR~COMPAQ_SMART2_MAJOR+7
COMPAQ_CISS_MAJOR~COMPAQ_CISS_MAJOR+7
DAC960_MAJOR~ DAC960_MAJOR+7
时：
q-&gt;request_fn
注：这里执行request_fn，是即使req加入到
	tq_disk，也要进程自己将其IO启动
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1465</x>
      <y>3726</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_do_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1469</x>
      <y>3722</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1382</x>
      <y>3729</y>
      <w>89</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
关闭中断</panel_attributes>
    <additional_attributes>870.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1380</x>
      <y>3733</y>
      <w>7</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__cli
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1469</x>
      <y>3729</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!hwgroup-&gt;busy</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1389</x>
      <y>3736</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hwgroup-&gt;busy = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1395</x>
      <y>3732</y>
      <w>77</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>750.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1405</x>
      <y>3737</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>choose_drive</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1408</x>
      <y>3732</y>
      <w>64</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1359</x>
      <y>3744</y>
      <w>61</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.遍历hwgroup-&gt;drive（以next连接），如果dev所在
	的req队列不为空，并且设备没有睡眠（!drive-&gt;sleep）
	或者设备已经从睡眠中苏醒（0 &lt;= (signed long)(jiffies - drive-&gt;sleep)）
	时，在下列三种情况下，dev可以参选best：
	1.best还没有
	2.dev有睡过（drive-&gt;sleep，因为前面有条件，所以这里一定是睡着之后醒过来的）
		并且best没睡或者best.sleep比dev大（说明best的req请求是在dev之后，不然best在
		之前就执行完了，不会等到现在才执行）
	3.如果best和dev都不需要睡，就比较执行完操作醒来的时间WAKEUP(best) - WAKEUP(drive)
	（这里有两个假设，1，上次执行的时间service_time和此次执行的时间相同；2，上次执行完的时间点
		和现在执行这个函数的时间点一样，都是drive-&gt;service_start+drive-&gt;service_time
		所以(drive)-&gt;service_start + 2 * (drive)-&gt;service_time是预估dev执行完这个req
		所需的时间）
	如果上述3个条件满足其中一个，并且不在tq_disk中（!drive-&gt;queue.plugged ）
	best = drive
2.如果best存在，且其nice1存在，不曾睡眠（!best-&gt;sleep），best没有和group中的其他dev比较完
	（best != hwgroup-&gt;drive），上一次best的操作时间service_time &gt; WAIT_MIN_SLEEP
	如果上述条件满足，并且此次预估的操作时间WAKEUP(best) - jiffies&gt;WAIT_MIN_SLEEP
	然后再次从best遍历链表，如果在链表中发现有一个dev的sleep为0（只要激活立刻能请求），并且
	dev预估醒来的时间WAKEUP(drive)要大于best上次请求的时间（jiffies - best-&gt;service_time）（这里应该是为了确定dev没有长时间的在tq_disk中，如果长时间在tq_disk中，best留时间给dev也没用）
	并且dev预估醒来的时间比best要块时：
	通过ide_stall_queue让best sleep
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1383</x>
      <y>3783</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_stall_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1377</x>
      <y>3790</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drive-&gt;sleep = timeout + jiffies
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1392</x>
      <y>3740</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1387</x>
      <y>3779</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1385</x>
      <y>3786</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1424</x>
      <y>3732</y>
      <w>48</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive == NULL
如果没找到要执行req的设备</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1421</x>
      <y>3739</y>
      <w>37</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.遍历group的设备链表，找到其中能最早醒来的设备
2.如果sleep=0,表示没有设备睡着，是没有正在请求的req
3.如果sleep存在，设置相应的标志位
	hwgroup-&gt;sleeping = 1
	并且设置定时器hwgroup-&gt;timer，当时间到达之后通知执
	行req的超时（timer的function在init_irq中被设置为ide_timer_expiry）
4.之后直接return
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1433</x>
      <y>3754</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mod_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1437</x>
      <y>3750</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1421</x>
      <y>3762</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>timer-&gt;expires = expires;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1425</x>
      <y>3757</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1439</x>
      <y>3762</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>detach_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1437</x>
      <y>3757</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1451</x>
      <y>3762</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>internal_add_timer
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1437</x>
      <y>3757</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1430</x>
      <y>3769</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.通过timer_pending查看timer是否在链表中
2.如果在，通过list_del将time从链表中删除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1444</x>
      <y>3765</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1460</x>
      <y>3732</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取设备所在的接口</panel_attributes>
    <additional_attributes>100.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1458</x>
      <y>3739</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hwif = HWIF(drive)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1472</x>
      <y>3739</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>SELECT_INTERRUPT
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1469</x>
      <y>3732</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要操作的接口
不是原来的接口</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1461</x>
      <y>3744</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>OUT_BYTE((drive)-&gt;ctl|2, 
hwif-&gt;io_ports[IDE_CONTROL_OFFSET])
注：ctl bit1置1表示中断屏蔽
	第二个参数是是寄存器的IO地址
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1473</x>
      <y>3742</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1490</x>
      <y>3739</y>
      <w>31</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>hwgroup-&gt;hwif = hwif;
hwgroup-&gt;drive = drive;
drive-&gt;sleep = 0;
drive-&gt;service_start = jiffies
 //指向当前的req，make_request中某种情况head指向next是因为next不被遍历
 //这里是处理完了之后才脱链
hwgroup-&gt;rq = blkdev_entry_next_request(&amp;drive-&gt;queue.queue_head)
 //因为要打开中断，防止其他irq被阻塞
 //所以这里将接口的irq屏蔽，打开其他中断
 //但是因为有hwgroup-&gt;busy挡住其他接口的请求
 //所以mask_irq设置位0
disable_irq_nosync
ide__sti
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1469</x>
      <y>3732</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1547</x>
      <y>3737</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1469</x>
      <y>3732</y>
      <w>86</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;840.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1528</x>
      <y>3740</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1522</x>
      <y>3744</y>
      <w>34</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.unit不能大于MAX_DRIVES
2.在ide_disk和ide_floppy进行读写时，
	要写的block号不能大于drive-&gt;part[minor&amp;PARTN_MASK].nr_sects
3.因为block号可能时设备分区的block号，所以通过start_sect+sect0转化
	为设备实际的block号
	block += drive-&gt;part[minor&amp;PARTN_MASK].start_sect + drive-&gt;sect0
4.如果设备的remap_0_to_1置上，那么如果block为0时将其映射到1号block（引导扇区的重新映射）
5.如果设备两次操作之间需要时间间隔，所以需要通过while等待间隔时间
	while ((read_timer() - hwif-&gt;last_time) &lt; DISK_RECOVERY_TIME);
注：unit是实际设备号
minor后面PARTN_BITS指的是设备的逻辑分区
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1566</x>
      <y>3744</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>SELECT_DRIVE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1553</x>
      <y>3740</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1557</x>
      <y>3750</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hwif-&gt;selectproc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1560</x>
      <y>3747</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1571</x>
      <y>3750</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>OUT_BYTE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1564</x>
      <y>3747</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
写寄存器IDE_SELECT_OFFSET
选择磁盘操作的模式，参考P1144</panel_attributes>
    <additional_attributes>90.0;10.0;120.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1585</x>
      <y>3744</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_special</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1553</x>
      <y>3740</y>
      <w>38</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;special.all
如果有什么特殊处理，例如每次操作之后需要回到0号柱面</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1553</x>
      <y>3740</y>
      <w>55</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没什么特殊操作</panel_attributes>
    <additional_attributes>10.0;10.0;530.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1596</x>
      <y>3742</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
IDE_DRIVE_CMD ||
IDE_DRIVE_TASK</panel_attributes>
    <additional_attributes>100.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1595</x>
      <y>3745</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>execute_drive_cmd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1612</x>
      <y>3745</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>driver-&gt;do_request
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1605</x>
      <y>3742</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1617</x>
      <y>3748</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
idedisk_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1613</x>
      <y>3753</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_rw_disk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1569</x>
      <y>3756</y>
      <w>51</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1556</x>
      <y>3759</y>
      <w>35</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.向IDE_CONTROL_REG写drive-&gt;ctl，将中断屏蔽打开
2.向IDE_NSECTOR_REG写要读写的扇区数rq-&gt;nr_sectors
3.如果是lba或者是PDC4030，将block号写入28位寄存器
	低8位写入IDE_SECTOR_REG
	中间16位写入CYL_REG
	最高4位写入IDE_SELECT_REG低4位
4.如果是chs，将block写入到指定寄存器
	扇区模（sect  = block % drive-&gt;sect + 1）写进IDE_SECTOR_REG
	磁头号（track % drive-&gt;head）写进IDE_SELECT_REG低4位
	柱面号（track / drive-&gt;head）写进CYL_REG
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1603</x>
      <y>3756</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
READ</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1594</x>
      <y>3759</y>
      <w>14</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;using_dma
ide_dma_read</panel_attributes>
    <additional_attributes>100.0;10.0;30.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1592</x>
      <y>3767</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>HWIF(drive)-&gt;dmaproc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1603</x>
      <y>3759</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不用DMA</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1613</x>
      <y>3761</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
read_intr</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1607</x>
      <y>3766</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_set_handler</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1601</x>
      <y>3772</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>hwgroup-&gt;handler	= handler;
 //超时之后的函数指针
hwgroup-&gt;expiry		= expiry;
hwgroup-&gt;timer.expires	= jiffies + timeout;
add_timer(&amp;hwgroup-&gt;timer);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1612</x>
      <y>3769</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1619</x>
      <y>3766</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>OUT_BYTE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1606</x>
      <y>3761</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
向IDE_COMMAND_REG寄存器
发送MULTREAD或者READ命令
MULTREAD取决于要读的扇区号和磁盘缓冲区大小</panel_attributes>
    <additional_attributes>120.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1618</x>
      <y>3756</y>
      <w>46</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
WRITE</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1617</x>
      <y>3761</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1636</x>
      <y>3766</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return ide_started
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1650</x>
      <y>3758</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;using_dma
ide_dma_write</panel_attributes>
    <additional_attributes>120.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1641</x>
      <y>3761</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>HWIF(drive)-&gt;dmaproc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1661</x>
      <y>3759</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不用DMA</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1675</x>
      <y>3761</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1670</x>
      <y>3764</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_wait_stat</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1653</x>
      <y>3771</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果硬盘状态为BUSY_STAT，设置timeout
	时间，然后通过while等待，如果在timeout时间
	之内busy标志清除，执行2，否者返回1
2.如果busy标志清除，检查硬盘状态是good而不是
	bad（循环查询10次），正确返回0，否则返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1667</x>
      <y>3767</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1673</x>
      <y>3761</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要求屏蔽其他中断
!drive-&gt;unmask
暂时没看见在什么时候打开</panel_attributes>
    <additional_attributes>30.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1685</x>
      <y>3767</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cli
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1652</x>
      <y>3761</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查看mult_count，
然后写相应的命令至IDE_COMMAND_REG</panel_attributes>
    <additional_attributes>230.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1654</x>
      <y>3766</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>OUT_BYTE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1675</x>
      <y>3761</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1704</x>
      <y>3764</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mult_count</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1704</x>
      <y>3764</y>
      <w>44</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1740</x>
      <y>3767</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
write_intr</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1737</x>
      <y>3770</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_set_handler</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1750</x>
      <y>3770</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>idedisk_output_data</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1746</x>
      <y>3767</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1751</x>
      <y>3778</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_output_data</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1757</x>
      <y>3773</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bswap表示将数据的高8位和低8位换位置</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1737</x>
      <y>3781</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;io_32bit
如果是32位</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1758</x>
      <y>3781</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是16位</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1752</x>
      <y>3785</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
drive-&gt;slow
out在io.h中定义
这里_p是有延时
向IDE_DATA_REG写2个short</panel_attributes>
    <additional_attributes>160.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1752</x>
      <y>3790</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>outw_p
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1766</x>
      <y>3785</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
OUTS
靠rep循环写入16字节
所以wcount左移1位</panel_attributes>
    <additional_attributes>20.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1774</x>
      <y>3791</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>outsw
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1735</x>
      <y>3785</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
rep循环写入32字节</panel_attributes>
    <additional_attributes>30.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1739</x>
      <y>3790</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>outsl
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1765</x>
      <y>3767</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return ide_started
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1661</x>
      <y>3759</y>
      <w>111</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1090.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1731</x>
      <y>3785</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1724</x>
      <y>3788</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过do_vlb_sync读
	3次寄存器IDE_NSECTOR_REG
2.在通过outl写数据
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1704</x>
      <y>3768</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
multwrite_intr</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1700</x>
      <y>3772</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_set_handler</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1686</x>
      <y>3772</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hwgroup-&gt;wrq = *rq
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1692</x>
      <y>3768</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
赋值request</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1714</x>
      <y>3772</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_multwrite</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1705</x>
      <y>3768</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1711</x>
      <y>3775</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1685</x>
      <y>3778</y>
      <w>38</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.确定此次写入的扇区大小，以current_nr_sectors
	为基础，如果超过了mcount，就只写mcount
2.更新mcount
3.通过idedisk_output_data向磁盘写buffer
	将扇区数左移7位换算成32位
4.检查nr_sectors是否读完，如果读完，break
	返回0，之后在上层函数中返回ide_started
5.如果没读完，查看当前bh的扇区是否读完，如果没有读完
	只有可能是mcount比bh扇区数小，所以将buffer指针更新
	返回0，之后在上层函数中返回ide_started
6.如果bh的扇区读完，就读下一个bh，并更新req
	rq-&gt;current_nr_sectors = rq-&gt;bh-&gt;b_size&gt;&gt;9;
	rq-&gt;buffer             = rq-&gt;bh-&gt;b_data;
	执行下一个do...while
7.如果整个req的写完了，通过ide_end_request结束request
	注意uptodate为0，表示数据还没更新
注:磁盘的缓冲区大小是mcount
	如果mcount写完，只能等到中断到来之后，再次通过中断向
	硬盘进行写入
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1593</x>
      <y>3770</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_setup_dma</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1587</x>
      <y>3778</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_dmaproc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1499</x>
      <y>3781</y>
      <w>95</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_dma_read</panel_attributes>
    <additional_attributes>930.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1493</x>
      <y>3791</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reading = 1 &lt;&lt; 3
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1537</x>
      <y>3781</y>
      <w>57</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_dma_read/ide_dma_write</panel_attributes>
    <additional_attributes>550.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1512</x>
      <y>3790</y>
      <w>29</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
&lt;&lt;includes&gt;&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1507</x>
      <y>3793</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>SELECT_READ_WRITE
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1527</x>
      <y>3794</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_build_dmatable</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1524</x>
      <y>3790</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果出错返回0，ide_dmaproc返回1
do_rw_disk放弃dma继续执行io指令</panel_attributes>
    <additional_attributes>150.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1478</x>
      <y>3801</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ide_build_sglist</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1483</x>
      <y>3797</y>
      <w>52</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sg_table</panel_attributes>
    <additional_attributes>500.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1447</x>
      <y>3809</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>Read:
hwif-&gt;sg_dma_direction = PCI_DMA_FROMDEVICE
other:
hwif-&gt;sg_dma_direction = PCI_DMA_TODEVICE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1462</x>
      <y>3804</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1485</x>
      <y>3809</y>
      <w>39</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.遍历req的bh，看两个连着的bh是否在缓冲区上能合并
	virt_addr + size=bh-&gt;b_data
2.如果可以合并，将size增加，并遍历下一个bh
3.如果不能合并，直接退出当前遍历，然后申请一个scatterlist
	sg[nents].address = virt_addr;
	sg[nents].length = size;
	nents++;
4.然后在继续遍历向下遍历那个不能合并的bh
5.bh遍历完成之后，通过pci_map_sg检查，并返回nents
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1484</x>
      <y>3804</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1525</x>
      <y>3803</y>
      <w>44</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.遍历sg_table中的所有scatterlist
2.合并缓冲区的长度在每个DMA处理中都不能超过64K(0x10000)
	的边界，dmatable_cpu中第一项填起始地址，第二项填长度
	（最长不能超过64K,第一个entry可能没超过64K,即使其长度超过
	了64K,因为其内存单位是64K对齐）（两者合起来叫一个entry），
	如果一个DMA entry放不下这个scatterlist，就在下一个DMA entry
	中填写（这个entry不能超过PRD_ENTRIES（256），总共2k，有两个
	ide接口，总共4k）
注：dmatable_cpu指向的虚拟地址，dmatable_dma指向的是物理地址
	因为此时是cpu在操作，所以用的是dmatable_cpu
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1532</x>
      <y>3797</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1538</x>
      <y>3790</y>
      <w>44</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1571</x>
      <y>3798</y>
      <w>45</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.写寄存器
	向dma_base + 4写DMA表的32位指针dmatable_dma（实际物理地址）
	向dma_base（前8位ide0，后8位ide1）8位寄存器写读写命令（reading）
	向dma_base+2中的8位寄存器的第2，3位写1，清intr，error
2.	
	drive-&gt;waiting_for_dma = 1
	ide_set_handler（ide_dma_intr）
3.开启dma
	向IDE_COMMAND_REG写WIN_READDMA/WIN_WRITEDMA
	向dma_base8位寄存器的第1字节写1，开启DMA
注：之后DMA会根据dmatable_dma中的DMA表，向缓冲区读写数据，直到
	表写完之后向cpu发出中断
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1591</x>
      <y>3781</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ide_dma_end</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1619</x>
      <y>3789</y>
      <w>30</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>drive-&gt;waiting_for_dma = 0
 //向dma_base最低位写0，关闭dma
outb(inb(dma_base)&amp;~1, dma_base)
 //读出状态
dma_stat = inb(dma_base+2)
 //清intr error
outb(dma_stat|6, dma_base+2)
 //没有清除dma表，之后写的时候直接覆盖
ide_destroy_dmatable
最后检查dma_stat第3位（应该是error），正确的话是置上的
（此时返回0，正是ide_dma_intr需要的）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>949</x>
      <y>3590</y>
      <w>14</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历bh数组</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>930</x>
      <y>3590</y>
      <w>22</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>945</x>
      <y>3587</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ll_rw_block</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>950</x>
      <y>3579</y>
      <w>3</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>379</x>
      <y>3893</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_lseek</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>364</x>
      <y>3902</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>370</x>
      <y>3896</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>391</x>
      <y>3903</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>llseek</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>384</x>
      <y>3896</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
origin &lt;= 2</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>386</x>
      <y>3906</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file-&gt;f_op-&gt;llseek存在</panel_attributes>
    <additional_attributes>100.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>395</x>
      <y>3906</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>400</x>
      <y>3912</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>default_llseek</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>384</x>
      <y>3913</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;llseek
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>385</x>
      <y>3921</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_file_lseek</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>389</x>
      <y>3916</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_file_operations</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>362</x>
      <y>3924</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>349</x>
      <y>3929</y>
      <w>35</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.origin为2时，偏移从文件最后开始算（i_size+offset）
2.origin为1时，偏移从当前位置开始算(f_pos+offset)
3.origin为0时，偏移从文件首开始算(offset)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>390</x>
      <y>3924</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
offset &gt;&gt; 32 != 0
如果超过了32位</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>388</x>
      <y>3931</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>offset不能超过ext2_max_sizes
ext2_max_sizes规定的是逻辑block数组
最大是15经历了3层映射，所以最大长度是有限制的
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>390</x>
      <y>3924</y>
      <w>37</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
offset != file-&gt;f_pos</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>415</x>
      <y>3930</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>file-&gt;f_pos = offset;
file-&gt;f_reada = 0;
file-&gt;f_version = ++event;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>420</x>
      <y>3903</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>res是64位，retval是32位
当res != (loff_t)retval时，
说明sys_lseek超过了32位，报错-EOVERFLOW
如果超过32位，使用sys_llseek
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>384</x>
      <y>3896</y>
      <w>43</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;


</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>497</x>
      <y>3910</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_dup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>472</x>
      <y>3920</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>519</x>
      <y>3920</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dupfd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>477</x>
      <y>3913</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>503</x>
      <y>3913</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果file存在</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>508</x>
      <y>3930</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>locate_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>514</x>
      <y>3923</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>484</x>
      <y>3933</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
start &lt; files-&gt;next_fd
start不能小于next_fd</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>475</x>
      <y>3940</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start = files-&gt;next_fd
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>494</x>
      <y>3941</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>newfd = start
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>498</x>
      <y>3933</y>
      <w>17</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
newfd在expand_files统一</panel_attributes>
    <additional_attributes>140.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>512</x>
      <y>3933</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
start &lt; files-&gt;max_fdset
</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>511</x>
      <y>3941</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_next_zero_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>529</x>
      <y>3942</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>申请到的fd要小于
RLIMIT_NOFILE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>512</x>
      <y>3933</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>548</x>
      <y>3942</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expand_files</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>512</x>
      <y>3933</y>
      <w>43</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>539</x>
      <y>3945</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果需要扩充</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>531</x>
      <y>3951</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>nr&gt;max_fdset  expand_fdset
nr&gt;max_fds   expand_fd_array
error=1(需要repeat，重新查找)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>552</x>
      <y>3945</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不需要扩充</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>559</x>
      <y>3952</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>error=0
沿用申请到的newfd
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>512</x>
      <y>3933</y>
      <w>65</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
start &lt;= files-&gt;next_fd
如果申请到next_fd
</panel_attributes>
    <additional_attributes>10.0;10.0;630.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>568</x>
      <y>3943</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>files-&gt;next_fd = newfd + 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>591</x>
      <y>3931</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>allocate_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>525</x>
      <y>3923</y>
      <w>75</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;730.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>587</x>
      <y>3938</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>FD_SET(fd, files-&gt;open_fds);
FD_CLR(fd, files-&gt;close_on_exec);
fd_install(fd, file)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>596</x>
      <y>3934</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>497</x>
      <y>3923</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>487</x>
      <y>3927</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>files = current-&gt;files
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>684</x>
      <y>3912</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_ioctl
可扩充
cmd参考657页
Documentation/ioctl_number.txt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>625</x>
      <y>3927</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>629</x>
      <y>3915</y>
      <w>63</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>610.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>689</x>
      <y>3915</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
file不为空</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>646</x>
      <y>3918</y>
      <w>46</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIOCLEX</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>641</x>
      <y>3927</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_close_on_exec(1)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>660</x>
      <y>3927</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_close_on_exec(0)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>667</x>
      <y>3918</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIOCLEX</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>659</x>
      <y>3935</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>689</x>
      <y>3918</y>
      <w>9</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIONBIO</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>664</x>
      <y>3925</y>
      <w>28</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从用户空间拿参数</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>680</x>
      <y>3933</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>if (on)
	filp-&gt;f_flags |= O_NONBLOCK;
else
	filp-&gt;f_flags &amp;= ~O_NONBLOCK;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>689</x>
      <y>3925</y>
      <w>4</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>689</x>
      <y>3918</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIOASYNC</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>705</x>
      <y>3935</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>707</x>
      <y>3926</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从用户空间拿参数</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>715</x>
      <y>3926</y>
      <w>22</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

(flag ^ filp-&gt;f_flags) &amp; FASYNC
FASYNC发生了变化</panel_attributes>
    <additional_attributes>30.0;10.0;180.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>729</x>
      <y>3936</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;fasync
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>717</x>
      <y>3926</y>
      <w>38</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>745</x>
      <y>3934</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>if (on)
	filp-&gt;f_flags |= FASYNC;
else
	filp-&gt;f_flags &amp;= ~FASYNC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>712</x>
      <y>3939</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flag = on ? FASYNC : 0
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>717</x>
      <y>3926</y>
      <w>5</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>689</x>
      <y>3918</y>
      <w>98</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
default</panel_attributes>
    <additional_attributes>10.0;10.0;960.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>771</x>
      <y>3937</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file_ioctl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>774</x>
      <y>3927</y>
      <w>13</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISREG</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>815</x>
      <y>3937</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;ioctl
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>784</x>
      <y>3927</y>
      <w>42</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否则
如果filp-&gt;f_op-&gt;ioctl存在</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>796</x>
      <y>3924</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>689</x>
      <y>3915</y>
      <w>113</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1110.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>773</x>
      <y>3940</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
cmd</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>741</x>
      <y>3945</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIBMAP
返回逻辑块号对应的物理块号</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>702</x>
      <y>3959</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.mapping-&gt;a_ops-&gt;bmap存在
2.进程具有CAP_SYS_RAWIO
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>711</x>
      <y>3952</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>728</x>
      <y>3959</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.得到逻辑块号get_user
2.根据逻辑块号获取物理块号
mapping-&gt;a_ops-&gt;bmap
3.返回物理块号put_user
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>739</x>
      <y>3952</y>
      <w>5</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>756</x>
      <y>3945</y>
      <w>20</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIGETBSZ
返回文件设备的总块数</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>751</x>
      <y>3960</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_user(inode-&gt;i_sb-&gt;s_blocksize
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>773</x>
      <y>3945</y>
      <w>22</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
FIONREAD
返回当前位置到文件末尾的距离</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>777</x>
      <y>3960</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_user(inode-&gt;i_size - filp-&gt;f_pos
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>774</x>
      <y>3940</y>
      <w>36</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filp-&gt;f_op-&gt;ioctl存在</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>800</x>
      <y>3954</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_op-&gt;ioctl
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>913</x>
      <y>3911</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>833</x>
      <y>3914</y>
      <w>89</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制用户空间中源文件名和新文件名</panel_attributes>
    <additional_attributes>870.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>830</x>
      <y>3927</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>from = getname(oldname)
to = getname(newname)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>860</x>
      <y>3927</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>path_init
path_walk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>864</x>
      <y>3914</y>
      <w>58</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
from, 
LOOKUP_POSITIVE和LOOKUP_DIRECTORY置上时，如果找不到
inode会报错</panel_attributes>
    <additional_attributes>560.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>882</x>
      <y>3927</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>path_init
path_walk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>885</x>
      <y>3914</y>
      <w>37</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
to,
LOOKUP_PARENT表示只找到上一层目录</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>905</x>
      <y>3914</y>
      <w>16</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
old_nd.mnt != nd.mnt
安装节点不一致时报错</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>903</x>
      <y>3928</y>
      <w>8</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>-EXDEV
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>917</x>
      <y>3927</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>919</x>
      <y>3914</y>
      <w>7</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>900</x>
      <y>3936</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_hash
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>904</x>
      <y>3930</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在hash和磁盘中找inode</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>923</x>
      <y>3930</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>919</x>
      <y>3934</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果is_dir=0，并且是目录last.name[nd-&gt;last.len]
（如果是目录，这个字符应该是‘\’）
	但是在没找到inode，返回-ENOENT
2.否则返回dentry（没找到d_inode为NULL）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>919</x>
      <y>3914</y>
      <w>49</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!IS_ERR(new_dentry)</panel_attributes>
    <additional_attributes>10.0;10.0;470.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>964</x>
      <y>3932</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>965</x>
      <y>3925</y>
      <w>8</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>984</x>
      <y>3931</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>965</x>
      <y>3925</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>935</x>
      <y>3945</y>
      <w>35</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.源文件inode要存在（old_dentry-&gt;d_inode）
2.新文件may_create
	1.新文件的inode不能存在 new_dentry.d_inode
	2.新文件的目录不是IS_DEADDIR
	3.新文件目录要有MAY_WRITE | MAY_EXEC
3.新文件要和源文件在同一个设备
	dir-&gt;i_dev == inode-&gt;i_dev
4.源文件不能有IS_APPEND  IS_IMMUTABLE标记
5.新文件的dir-&gt;i_op-&gt;link要存在
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>947</x>
      <y>3935</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>979</x>
      <y>3946</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>976</x>
      <y>3939</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_op-&gt;link
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>973</x>
      <y>3935</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>982</x>
      <y>3941</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1010</x>
      <y>3940</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_dir_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>973</x>
      <y>3935</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
DN_CREATE
如果链接建立完成，需要通知父目录
i_dnotify中的通知对象</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>946</x>
      <y>3964</y>
      <w>30</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.建立硬链接的不能是目录
2.inode-&gt;i_nlink不能大于EXT2_LINK_MAX
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>958</x>
      <y>3949</y>
      <w>31</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>981</x>
      <y>3964</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_add_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>986</x>
      <y>3949</y>
      <w>3</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1006</x>
      <y>3961</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //增加inode的硬链接计数
inode-&gt;i_nlink++;
inode-&gt;i_ctime = CURRENT_TIME;
mark_inode_dirty(inode);
atomic_inc(&amp;inode-&gt;i_count);
 //将dentry链接到inode的链表中
d_instantiate(dentry, inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>986</x>
      <y>3949</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>917</x>
      <y>3977</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_bread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>922</x>
      <y>3967</y>
      <w>67</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读dir的数据到内存</panel_attributes>
    <additional_attributes>650.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>933</x>
      <y>3978</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rec_len = EXT2_DIR_REC_LEN(namelen)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>948</x>
      <y>3967</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
要添加entry需要的长度</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>986</x>
      <y>3967</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历dir，找到足够的长度容纳
要添加的entry</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>971</x>
      <y>3975</y>
      <w>71</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>1.ext2_check_dir_entry 检查de中的各类属性
2.ext2_match 检查de中是否有和此次添加entry
	相同的name
3.检查当前的de是否可以容纳当前的entry
	能容纳的两个条件：
		1.de-&gt;inode为0，且这个entry的长度rec_len大于此次要添加entry的长度
		2.如果de-&gt;inode不为0，但是这个entry的长度能容纳自己的entryEXT2_DIR_REC_LEN(de-&gt;name_len)
		和要添加的entry的长度
		如果是第2中情况，将之前entyr的长度更新为EXT2_DIR_REC_LEN(de-&gt;name_len)，剩下的位置给要添加的entry
		de1 =de+EXT2_DIR_REC_LEN(de-&gt;name_len)
		de1-&gt;rec_len =(le16_to_cpu(de-&gt;rec_len) - EXT2_DIR_REC_LEN(de-&gt;name_len)
	为要添加的entry，赋值其他的属性
	de-&gt;file_type = EXT2_FT_UNKNOWN;
	if (inode) {
		de-&gt;inode = cpu_to_le32(inode-&gt;i_ino);
		ext2_set_de_type(dir-&gt;i_sb, de, inode-&gt;i_mode);
	} else
		de-&gt;inode = 0;
	de-&gt;name_len = namelen;
	memcpy (de-&gt;name, name, namelen);
	dir-&gt;i_mtime = dir-&gt;i_ctime = CURRENT_TIME;
	dir-&gt;u.ext2_i.i_flags &amp;= ~EXT2_BTREE_FL;
	mark_inode_dirty(dir);
	dir-&gt;i_version = ++event;
	mark_buffer_dirty_inode(bh, dir);
	如果需要同步的话，会通过ll_rw_block写dir，并wait_on_buffer
4.如果没找到，更新位置和下一个entry
	offset += le16_to_cpu(de-&gt;rec_len);
	de = (struct ext2_dir_entry_2 *) ((char *) de + le16_to_cpu(de-&gt;rec_len))
5.如果超过了当前读取的bh，通过ext2_bread读下一个block的dir数据,然后重复上述过程继续查找
	1.如果offset超过了dir的size，更新dir的size和将下一个block都设置为一个entry
		de = (struct ext2_dir_entry_2 *) bh-&gt;b_data;
		de-&gt;inode = 0;
		de-&gt;rec_len = le16_to_cpu(sb-&gt;s_blocksize);
		dir-&gt;i_size = offset + sb-&gt;s_blocksize;
		dir-&gt;u.ext2_i.i_flags &amp;= ~EXT2_BTREE_FL;
		mark_inode_dirty(dir);
	2.如果没超过dir的size，继续查找dir下一个block数据
		de = (struct ext2_dir_entry_2 *) bh-&gt;b_data
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1259</x>
      <y>3923</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_proc_fs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1236</x>
      <y>3931</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1243</x>
      <y>3926</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1211</x>
      <y>3941</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.要注册fs要存在  -EINVAL
2.fs的next指针不能在链表中  -EBUSY
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1219</x>
      <y>3934</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1241</x>
      <y>3934</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1237</x>
      <y>3940</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过find_filesystem在链表file_systems中查询
2.如果查到当前filesystem在链表中存在，返回-EBUSY
3.如果不存在，将当前的filesystem链入到链表中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1288</x>
      <y>3933</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kern_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1267</x>
      <y>3926</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果成功注册</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1274</x>
      <y>3941</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_unnamed_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1294</x>
      <y>3941</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_super
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1338</x>
      <y>3944</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_vfsmnt
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1278</x>
      <y>3936</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1255</x>
      <y>3950</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.在位图unnamed_dev_in_use中从1开始查找
2.如果找到，返回MKDEV(UNNAMED_MAJOR, i)
	否则，返回0.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1269</x>
      <y>3944</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1294</x>
      <y>3936</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1290</x>
      <y>3949</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过get_empty_super，得到super_block结构体
2.对super_block属性做相关的设置
3.通过file_system的read_super将超级块读进来
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1300</x>
      <y>3944</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1302</x>
      <y>3961</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_read_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1307</x>
      <y>3955</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_fs_type
proc_root</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1276</x>
      <y>3969</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>s-&gt;s_blocksize = 1024;
s-&gt;s_blocksize_bits = 10;
s-&gt;s_magic = PROC_SUPER_MAGIC;
s-&gt;s_op = &amp;proc_sops;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1287</x>
      <y>3964</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置超级块的块大小和
操作函数等属性</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1306</x>
      <y>3971</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_get_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1308</x>
      <y>3964</y>
      <w>11</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取根节点</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1292</x>
      <y>3979</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1296</x>
      <y>3974</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加proc_root计数</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1308</x>
      <y>3980</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iget
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1311</x>
      <y>3974</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1313</x>
      <y>3983</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
首先会在hash表中查找，
如果没找到会申请inode结构体
然后利用sb的proc_sops的read_inode读取</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1307</x>
      <y>3990</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_read_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1306</x>
      <y>3998</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_mtime = 
inode-&gt;i_atime = 
inode-&gt;i_ctime = CURRENT_TIME;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1313</x>
      <y>3993</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里只是设置了inode时间
其他属性需要在iget中查看</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1323</x>
      <y>3972</y>
      <w>18</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>root_inode-&gt;i_nlink++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1309</x>
      <y>3964</y>
      <w>23</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
除了idle_task，其他task都
增加inode的硬链接计数</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1346</x>
      <y>3972</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>d_alloc_root
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1310</x>
      <y>3964</y>
      <w>42</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
给s-&gt;s_root分配root管理</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1397</x>
      <y>3973</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>parse_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1309</x>
      <y>3964</y>
      <w>94</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1333</x>
      <y>3981</y>
      <w>27</w>
      <h>23</h>
    </coordinates>
    <panel_attributes> //generic_ip中存储的inode对应的proc_dir_entry
inode-&gt;u.generic_ip=de (proc_root)
inode-&gt;i_mode = de-&gt;mode;
inode-&gt;i_uid = de-&gt;uid;
inode-&gt;i_gid = de-&gt;gid;
inode-&gt;i_size = de-&gt;size
inode-&gt;i_nlink = de-&gt;nlink
__MOD_INC_USE_COUNT(de-&gt;owner)
如果是块设备/字符设备/FIFO设备
	init_special_inode（reference）
否则：
	inode-&gt;i_op = de-&gt;proc_iops
	inode-&gt;i_fop = de-&gt;proc_fops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1311</x>
      <y>3974</y>
      <w>34</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1362</x>
      <y>3983</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>root_inode-&gt;i_uid=current-&gt;uid
root_inode-&gt;i_gid= current-&gt;gid
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1371</x>
      <y>3976</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1386</x>
      <y>3984</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>return 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1390</x>
      <y>3976</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没有要解析的数据
!options</panel_attributes>
    <additional_attributes>120.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1377</x>
      <y>4008</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>strtok</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1354</x>
      <y>4017</y>
      <w>43</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果要解析的数据为空，就解析之前剩下的数据___strtok，
	否则解析传过来的数据
2.通过strspn计算和分个符相同的长度，然后将s更新为和分个符
	不同的sbegin
3.如果sbegin为'\0'，___strtok=NULL
4.否则，通过strpbrk找到剩下字符串中的第一个分隔符，并且
*send++ = '\0';
___strtok = send;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1373</x>
      <y>4011</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1400</x>
      <y>3986</y>
      <w>39</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.通过strtok将字符串通过‘，’拆分开
2.循环检查，利用strchr将this_char用‘=’分隔开
	this_char指向等号前面，value指向等号后面
3.如果this_char是"uid"，利用simple_strtoul将字符串
	转化成整数，然后使root_inode-&gt;i_uid=current-&gt;uid=value
	如果value中有不能解析的（*value最后还有值），返回0
4.同理，如果this_char是"gid"：
	root_inode-&gt;i_gid=value
5.如果都不是，直接返回1
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1383</x>
      <y>4001</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1431</x>
      <y>4009</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>simple_strtoul</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1426</x>
      <y>4001</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1431</x>
      <y>4018</y>
      <w>37</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.首先确认base（是10进制。8进制、还是16进制）
	其中isxdigit表示字符是否是16进制数，可以将
	_ctype对比ASCII表
2.将各个字符换算成整数，乘上base再相加，其中
	isdigit表示字符是否是10进制数
3.更改value的地址，（返回后可以看value是否指向'\0'
	来检查是否满足整数的要求）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1437</x>
      <y>4012</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1408</x>
      <y>4008</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>strchr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1413</x>
      <y>4001</y>
      <w>8</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1399</x>
      <y>4016</y>
      <w>30</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>"movb %%al,%%ah\n"
 //将s字符加载到al中，s++
"1:\tlodsb\n\t"
"cmpb %%ah,%%al\n\t"
"je 2f\n\t"
	// al &amp;al,如果结果为0
	//zf会置1，表示相等
"testb %%al,%%al\n\t"
"jne 1b\n\t"
 //这里置1，后面--，就会变成NULL
"movl $1,%1\n"
 //将s--，并返回
"2:\tmovl %1,%0\n\t"
"decl %0"
:"=a" (__res), "=&amp;S" (d0) : "1" (s),"0" (c));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1412</x>
      <y>4011</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
用于在字符串中找到
相应的字符</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1401</x>
      <y>3976</y>
      <w>20</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
解析options</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1294</x>
      <y>3936</y>
      <w>52</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注意这里的安装目录是NULL
mnt_mountpoint指向自己的root
mnt_parent指向自己
mnt_child mnt_clash都不用指向自己

之后用户层会通过调用
mount nvt proc /dev/null /proc
讲procfs装载到/proc目录下
</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1369</x>
      <y>3941</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>type-&gt;kern_mnt = mnt
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1295</x>
      <y>3936</y>
      <w>84</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将安装节点放在文件系统中
之后用户在mount的时候
会通过	get_sb_single调用</panel_attributes>
    <additional_attributes>10.0;10.0;820.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1122</x>
      <y>3929</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_mknod</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1071</x>
      <y>3942</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getname
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1076</x>
      <y>3932</y>
      <w>54</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从用户空款copy name到系统空间</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1096</x>
      <y>3932</y>
      <w>34</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取父目录和子文件的name到nd
注意flag是LOOKUP_PARENT</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1093</x>
      <y>3942</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>path_init
path_walk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1109</x>
      <y>3942</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lookup_create
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1114</x>
      <y>3932</y>
      <w>16</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为子节点创建dentry
注意传递的is_dir是0
表示子节点不能是目录</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1128</x>
      <y>3932</y>
      <w>22</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查看传递进来的参数mode
看要创建的文件的类型
注：不能创建目录</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1123</x>
      <y>3942</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
0
S_IFREG</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1119</x>
      <y>3948</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1134</x>
      <y>3942</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_IFCHR
S_IFBLK
S_IFSOCK</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1142</x>
      <y>3948</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_mknod</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1163</x>
      <y>3941</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //释放父目录和mnt
path_release(&amp;nd)
 //释放临时的name内存
putname(tmp)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1128</x>
      <y>3932</y>
      <w>45</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1116</x>
      <y>3951</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1094</x>
      <y>3955</y>
      <w>36</w>
      <h>13</h>
    </coordinates>
    <panel_attributes> //umask规定进程创建的文件不允许有的权限
1.mode &amp;= ~current-&gt;fs-&gt;umask
2.如果是S_ISCHR或者S_ISBLK时，进程要有
	CAP_MKNOD权限
3.may_create（reference）检查父目录的权限
	，并且子节点不能存在
4.父目录要有dir-&gt;i_op-&gt;mknod
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1134</x>
      <y>3958</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>DQUOT_INIT</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1138</x>
      <y>3951</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
磁盘容量相关</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1152</x>
      <y>3958</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dir-&gt;i_op-&gt;mknod
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1148</x>
      <y>3951</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1153</x>
      <y>3965</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_mknod</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1158</x>
      <y>3961</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ext2_dir_inode_operations</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1175</x>
      <y>3957</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode_dir_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1148</x>
      <y>3951</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
DN_CREATE</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1113</x>
      <y>3974</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_new_inode
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1117</x>
      <y>3968</y>
      <w>44</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>420.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1129</x>
      <y>3975</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_uid = current-&gt;fsuid
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1137</x>
      <y>3968</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1151</x>
      <y>3975</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_special_inode
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1157</x>
      <y>3968</y>
      <w>4</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1169</x>
      <y>3975</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ext2_add_entry
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1158</x>
      <y>3968</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将inode号和name加到dir中</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1186</x>
      <y>3975</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>mark_inode_dirty(inode);
d_instantiate(dentry, inode);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1159</x>
      <y>3968</y>
      <w>35</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将inode标dirty
并将其和dentry关联</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1131</x>
      <y>3982</y>
      <w>46</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>注：
1.现在并不会赋值u.ext2_i.i_data，在ext2_update_inode向硬盘写的时候，
	会检查i_mode，然后写入raw_inode-&gt;i_block
2.在ext2_read_inode时，会根据i_mode值将i_block[0]作为dev去
	init_special_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1155</x>
      <y>3978</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>820</x>
      <y>3948</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ioctl_scanner</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>822</x>
      <y>3940</y>
      <w>16</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_scanner_fops</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>817</x>
      <y>3956</y>
      <w>38</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.根据minor找到dev
	scn_minor = USB_SCN_MINOR(inode);
	dev = p_scn_table[scn_minor]-&gt;scn_dev
2.如果是PV8630_IOCTL_INREQUEST（获取状态信息）
	利用copy_from_user将args数据从用户空间复制过来
	然后利用usb_control_msg发送args.request请求
	最后利用copy_to_user将arg返回到用户空间
注：这里使用usb_rcvctrlpipe，
	USB_TYPE_VENDOR表示寄存器时设备制造商定义，不是标准的（USB_TYPE_STANDARD）
	USB_RECIP_DEVICE表示传输的对象是设备，不是接口或者端点
3.如果是PV8630_IOCTL_OUTREQUEST（向扫描器发出控制命令）
	和获取状态信息相似，只是这里只是单纯的发数据（usb_sndctrlpipe）
	，所以size=0，并且不用返回数据到用户空间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>826</x>
      <y>3951</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>707</x>
      <y>3939</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
鼠标
psaux_fops</panel_attributes>
    <additional_attributes>300.0;10.0;220.0;60.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>703</x>
      <y>3947</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fasync_aux</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>685</x>
      <y>3955</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fasync_helper</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>691</x>
      <y>3950</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>673</x>
      <y>3963</y>
      <w>36</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>1.如果要求将file设置成异步
	通过kmem_cache_alloc向fasync_cache
	申请fasync_struct
2.遍历传入的链表，如果链表中存在和要申请的
	file相同的fasync_struct结构：
	1.如果现在要设置异步，那么将新申请的cache释放：
		fa-&gt;fa_fd = fd;
		kmem_cache_free(fasync_cache, new);
	2.如果现在要设置成同步，那么将链表中的结构删除并释放
		*fp = fa-&gt;fa_next;
		kmem_cache_free(fasync_cache, fa);
		result = 1;
	最后直接返回
3.如果要设置成异步，那么将新申请的结构头插至链表中
	之后返回：
	new-&gt;magic = FASYNC_MAGIC;
	new-&gt;fa_file = filp;
	new-&gt;fa_fd = fd;
	new-&gt;fa_next = *fapp;
	*fapp = new;
	result = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>683</x>
      <y>3958</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
queue-&gt;fasync</panel_attributes>
    <additional_attributes>70.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>573</x>
      <y>3886</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_dup2</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>562</x>
      <y>3894</y>
      <w>35</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.通过file_lock将整个过程锁住
2.通过fcheck检查要复制的oldfd是否超过了max_fds，如果没
	超过，返回file
3.如果复制到的newfd和要复制的oldfd相同，直接解锁返回
4.如果newfd超过了进程的限制RLIMIT_NOFILE，返回EBADF
5.通过get_file增加oldfd的file计数，表示newfd要用
6.通过expand_files在必要时扩展得到newfd
7.如果newfd在open_fds位图中置上，但是files-&gt;fd[newfd]
	却不存在，说明这个fd正在被open占用，直接返回
8.如果经过了7表示可以对newfd进行复制：
	files-&gt;fd[newfd] = file;
	FD_SET(newfd, files-&gt;open_fds);
	FD_CLR(newfd, files-&gt;close_on_exec);
9.如果newfd之前存在file，通过filp_close将其关闭
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>577</x>
      <y>3889</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>102</x>
      <y>4214</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_query_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>98</x>
      <y>4217</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
name_user</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>75</x>
      <y>4221</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
NULL</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>69</x>
      <y>4229</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mod = &amp;kernel_module
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>98</x>
      <y>4221</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
请求module name存在</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>92</x>
      <y>4231</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_mod_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>97</x>
      <y>4226</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>91</x>
      <y>4237</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>__get_free_page
strncpy_from_user
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>96</x>
      <y>4234</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>110</x>
      <y>4226</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>114</x>
      <y>4230</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是空字符串
</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>118</x>
      <y>4230</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>126</x>
      <y>4236</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>107</x>
      <y>4236</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mod = &amp;kernel_module
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>138</x>
      <y>4230</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_mod_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>110</x>
      <y>4226</y>
      <w>37</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放name的内存</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>117</x>
      <y>4243</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.遍历module_list链表
2.如果flags &amp; MOD_DELETED，就不遍历
3.比较mod-&gt;name，如果成功就找到module
	直接退出
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>130</x>
      <y>4239</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>109</x>
      <y>4217</y>
      <w>74</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>156</x>
      <y>4230</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qm_modules</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>161</x>
      <y>4223</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
QM_MODULES</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>148</x>
      <y>4237</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.遍历module_list链表
2.计算每个module name的长度，如果buf的空间足够
	则用copy_to_user将name复制到用户空间
3.如果buf的空间不足，则将容纳所有module name所需
	的内存通过put_user返回给用户，sys_call返回-ENOSPC
4.如果一直复制到kernel_module，buf的空间足够，则将
	复制多少个module返回给用户
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>162</x>
      <y>4233</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>158</x>
      <y>4251</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>163</x>
      <y>4248</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>158</x>
      <y>4259</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__put_user_size</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>163</x>
      <y>4254</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
access_ok(VERIFY_WRITE</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>158</x>
      <y>4266</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__put_user_asm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>163</x>
      <y>4262</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将x放到地址ptr处
如果出错，返回-EFAULT</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>201</x>
      <y>4230</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qm_deps</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>180</x>
      <y>4223</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
QM_DEPS</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>249</x>
      <y>4180</y>
      <w>17</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>module_ref
描述一组依赖关系
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>251</x>
      <y>4184</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dep（A依赖B）(父)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>251</x>
      <y>4190</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ref（B被A索引）(子)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>251</x>
      <y>4198</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>next_ref
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>223</x>
      <y>4180</y>
      <w>19</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>module A
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>226</x>
      <y>4185</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>deps
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>238</x>
      <y>4185</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
数组</panel_attributes>
    <additional_attributes>10.0;20.0;110.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>241</x>
      <y>4190</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>100.0;20.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>295</x>
      <y>4180</y>
      <w>19</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>module B
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>298</x>
      <y>4193</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>refs
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>288</x>
      <y>4193</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
链表
next_ref</panel_attributes>
    <additional_attributes>100.0;20.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>286</x>
      <y>4185</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;20.0;90.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>272</x>
      <y>4181</y>
      <w>17</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>module_ref
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>274</x>
      <y>4185</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dep
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>274</x>
      <y>4191</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ref
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>274</x>
      <y>4198</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>next_ref
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>265</x>
      <y>4198</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ref链表指针</panel_attributes>
    <additional_attributes>90.0;20.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>263</x>
      <y>4175</y>
      <w>34</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;110.0;80.0;20.0;290.0;30.0;320.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>298</x>
      <y>4199</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>next
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>227</x>
      <y>4199</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>next
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>232</x>
      <y>4203</y>
      <w>72</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>700.0;10.0;630.0;70.0;100.0;80.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>187</x>
      <y>4237</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.不能是kernel_module
2.如果请求的module的MOD_RUNNING 和
	MOD_INITIALIZING都没置，或者置上MOD_DELETED
	就不执行，ret=0
3.遍历module的deps数组（ndeps个），将module依赖的模块
	名称复制到用户空间；如果复制完成，则ret返回依赖模块的数目
	如果没有足够的内存，就ret返回所需要的空间，sys_call返回-ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>205</x>
      <y>4233</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>239</x>
      <y>4230</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qm_refs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>179</x>
      <y>4223</y>
      <w>70</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
QM_REFS</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>233</x>
      <y>4237</y>
      <w>41</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.不能是kernel_module
2.如果请求的module的MOD_RUNNING 和
	MOD_INITIALIZING都没置，或者置上MOD_DELETED
	就不执行，ret=0
3.遍历module的refs链表，将已用module的模块
	名称复制到用户空间；如果复制完成，则ret返回引用模块的数目
	如果没有足够的内存，就ret返回所需要的空间，sys_call返回-ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>246</x>
      <y>4233</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>305</x>
      <y>4228</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qm_symbols</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>180</x>
      <y>4223</y>
      <w>132</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
QM_SYMBOLS</panel_attributes>
    <additional_attributes>10.0;10.0;1300.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>275</x>
      <y>4237</y>
      <w>39</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果请求的module的MOD_RUNNING 或者
	MOD_INITIALIZING没置，或者置上MOD_DELETED
	就不执行，ret=0
2.检查 buf~buf+mod-&gt;nsyms * 2*sizeof(void *)空间的
	写访问权限access_ok(VERIFY_WRITE
注：这个区间是（address，&amp;name）的组合
	然后在这个区间之后放字符串name，因为字符串name区域
	依靠copy_to_user去确保访问权限，所以在这里不做检查
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>289</x>
      <y>4231</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>316</x>
      <y>4240</y>
      <w>38</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历mod-&gt;syms数组（长度为mod-&gt;nsyms），
2.如果buf有足够的内存，将（address，&amp;name）放在前两，
	name实体放在所有指针的后面。ret返回sybol的数目
3.如果buf在遍历的过程中没有足够的空间，ret返回所需要的空间
	sys_call返回-ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>311</x>
      <y>4231</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>388</x>
      <y>4227</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qm_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>180</x>
      <y>4223</y>
      <w>215</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
QM_INFO</panel_attributes>
    <additional_attributes>10.0;10.0;2130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>357</x>
      <y>4240</y>
      <w>29</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.不能是kernel_module
2.如果buf内存不够，sys_call返回-ENOSPC
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>369</x>
      <y>4230</y>
      <w>26</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>388</x>
      <y>4238</y>
      <w>45</w>
      <h>16</h>
    </coordinates>
    <panel_attributes> //module的地址
info.addr = (unsigned long)mod;
info.size = mod-&gt;size;
info.flags = mod-&gt;flags;
 //如果module的结构体包含can_unload指针，返回-1
 //否则返回usecount
info.usecount = (mod_member_present(mod, can_unload)
		 &amp;&amp; mod-&gt;can_unload ? -1 : atomic_read(&amp;mod-&gt;uc.usecount));
注：mod_member_present是检测member在不在结构体内
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>393</x>
      <y>4230</y>
      <w>8</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>394</x>
      <y>4230</y>
      <w>50</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>437</x>
      <y>4239</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>ret最后都返回
sizeof(struct module_info)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>580</x>
      <y>4218</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_create_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>530</x>
      <y>4230</y>
      <w>25</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.进程需要CAP_SYS_MODULE权限
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>540</x>
      <y>4221</y>
      <w>48</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>556</x>
      <y>4230</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_mod_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>562</x>
      <y>4221</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从用户空间获取
创建module的name</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>575</x>
      <y>4230</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>2.name+module所占的内存空间，
	不能大于用户要求申请的内存大小
	size &lt; sizeof(struct module)+namelen
3.find_module从module_list中如果找到了
	name一样的 module，返回-EEXIST
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>583</x>
      <y>4221</y>
      <w>7</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>604</x>
      <y>4230</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>module_map</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>586</x>
      <y>4221</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请size大小的虚拟内存</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>604</x>
      <y>4237</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>609</x>
      <y>4233</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>621</x>
      <y>4229</y>
      <w>30</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>memset(mod, 0, sizeof(*mod));
mod-&gt;size_of_struct = sizeof(*mod);
 //链入module_list
mod-&gt;next = module_list;
mod-&gt;name = (char *)(mod + 1);
 //module所占内存大小，module+name
mod-&gt;size = size;
 //复制name到module后面
memcpy((char*)(mod+1), name, namelen+1);

put_mod_name(name);
 //更新module_list链表
module_list = mod;
 //正确的话，返回的是module的地址
return error
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>586</x>
      <y>4221</y>
      <w>45</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>842</x>
      <y>4215</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_init_module
(init_module时用户传进来的参数
create_module时用户之前在sys_create_module创建的)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>737</x>
      <y>4241</y>
      <w>42</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.进程要有CAP_SYS_MODULE
2.通过get_mod_name将create_module的name
	复制到系统空间，再通过find_module查找
	如果找不到，返回-ENOENT
3.通过get_user获取init_module的size_of_struct
	（这个size是module结构体的大小），init_module的persist_start
	至少包含到；另外这个size不能大于module size16个指针

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>756</x>
      <y>4218</y>
      <w>94</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>920.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>781</x>
      <y>4243</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>mod_tmp = *mod
name_tmp = kmalloc(strlen(mod-&gt;name) + 1
strcpy(name_tmp, mod-&gt;name)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>793</x>
      <y>4218</y>
      <w>56</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将create_module的module和name复制到temp
</panel_attributes>
    <additional_attributes>540.0;10.0;10.0;250.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>817</x>
      <y>4244</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_from_user
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>822</x>
      <y>4218</y>
      <w>30</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将init_module赋值到mod</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>834</x>
      <y>4242</y>
      <w>49</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>1.init_module的size不能大于create_module的size
2.mod-&gt;name，mod-&gt;syms，mod-&gt;deps，指向的位置要
	在size_of_struct外。并且所占的内存要在size内
	注：因为sys_create_module返回的是内核module的起始地址，用户应该将
	name的指针指向内核地址，而不是用户空间name的实际地址，所以这里
	mod_bound才会通过。
3.mod-&gt;init，mod-&gt;cleanup要在size_of_struct外。
	并且要在size内
4.异常处理表：
	ex_table_start不能大于ex_table_end
	ex_table_start小于mod的尾端的时候，ex_table_end不能小于
	缓冲区（size）的尾端
	ex_table的大小要被exception_table_entry的大小整除
5.mod-&gt;flags中至少要有一个除了MOD_AUTOCLEAN的flage置上
6.can_unload如果要在module 结构内且不为空时，can_unload函数
	要在缓冲区内
7.kallsyms_end在module内，且不为空，kallsyms_start和kallsyms_end
	指向的地址要在缓冲区内
	kallsyms_start不能大于kallsyms_end
8.archdata和kallsyms相似
9.kernel_data在moduler内，mod-&gt;kernel_data不能为空
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>846</x>
      <y>4218</y>
      <w>21</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
对init_module进行filter</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>889</x>
      <y>4242</y>
      <w>51</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.通过get_mod_name从用户层将name实体复制到系统空间
	如果name的长度，或者name不一致，返回错误
2.通过copy_from_user将init_module的缓冲区，复制到用户空间
（如果在cache中，需要通过flush_icache_range刷入到内存）
3.将init_module链入到链表
	mod-&gt;next = mod_tmp.next;
	mod-&gt;refs = NULL;
4.遍历mod-&gt;deps，这个数组中不能有自己，并且数组中的元素要在
	module_list链表中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>849</x>
      <y>4218</y>
      <w>56</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
对init_module的缓冲区进行filter</panel_attributes>
    <additional_attributes>10.0;10.0;540.0;240.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>947</x>
      <y>4243</y>
      <w>21</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //ref指向自己
dep-&gt;ref = mod
 //链入到父的链表中（d是父）
dep-&gt;next_ref = d-&gt;refs;
d-&gt;refs = dep;
d-&gt;flags |= MOD_USED_ONCE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>849</x>
      <y>4218</y>
      <w>108</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
对module的dep的实体，进行初始化</panel_attributes>
    <additional_attributes>10.0;10.0;1060.0;250.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>974</x>
      <y>4244</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes> //n_name 最终的name，name是传进来的参数
 //name_tmp是之前sys_create_module识别的name
put_mod_name(n_name);
put_mod_name(name);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>850</x>
      <y>4218</y>
      <w>132</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放临时内存</panel_attributes>
    <additional_attributes>10.0;10.0;1300.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1014</x>
      <y>4244</y>
      <w>44</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>mod-&gt;flags |= MOD_INITIALIZING;
atomic_set(&amp;mod-&gt;uc.usecount,1);
 //如果init函数存在，执行init
mod-&gt;init &amp;&amp; (error = mod-&gt;init())

atomic_dec(&amp;mod-&gt;uc.usecount);
mod-&gt;flags = (mod-&gt;flags | MOD_RUNNING) &amp; ~MOD_INITIALIZING;
error = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>850</x>
      <y>4218</y>
      <w>175</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1730.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1190</x>
      <y>4214</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_delete_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1121</x>
      <y>4231</y>
      <w>23</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>进程要有CAP_SYS_MODULE权限
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1129</x>
      <y>4217</y>
      <w>70</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>680.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1195</x>
      <y>4217</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果name_user不为NULL</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1159</x>
      <y>4225</y>
      <w>45</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1152</x>
      <y>4231</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_mod_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1172</x>
      <y>4232</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1180</x>
      <y>4225</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1193</x>
      <y>4232</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_mod_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1200</x>
      <y>4225</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到后，释放name</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1200</x>
      <y>4225</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mod-&gt;refs
如果被依赖，则不能释放</panel_attributes>
    <additional_attributes>20.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1212</x>
      <y>4231</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>-EBUSY
goto out;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1201</x>
      <y>4225</y>
      <w>50</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
没被使用
!__MOD_IN_USE
如果can_unload在module中，通过can_unload判断
否则通过mod.uc.usecount判断</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1235</x>
      <y>4228</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1224</x>
      <y>4234</y>
      <w>23</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mod-&gt;flags |= MOD_DELETED
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1255</x>
      <y>4234</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1247</x>
      <y>4228</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tag_freed为0</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1247</x>
      <y>4237</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1236</x>
      <y>4243</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>mod-&gt;cleanup
mod-&gt;flags &amp;= ~MOD_RUNNING
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1263</x>
      <y>4237</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1260</x>
      <y>4242</y>
      <w>35</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.通过mod-&gt;deps数组找到mod依赖的所有module
2.遍历module的refs链表，将mod从其链表中删除
	*pp = dep-&gt;next_ref;
	如果tag_freed为1，且module的refs链表为空
	module.flags |= MOD_JUST_FREED
	注：module_ref脱链之后不用单独释放，因为deps数组
		是和module结构体一起申请的，所以之后一起释放
3.将mod从module_list链表中删除
	注;这里用二重指针更为方便，不用if..else
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1300</x>
      <y>4243</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>module_unmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1263</x>
      <y>4237</y>
      <w>45</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1300</x>
      <y>4249</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1305</x>
      <y>4246</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1196</x>
      <y>4217</y>
      <w>125</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
name_user为NULL时，
表示内核自动删除module_list中满足条件的module</panel_attributes>
    <additional_attributes>10.0;10.0;1230.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1314</x>
      <y>4224</y>
      <w>45</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>条件：
1.mod-&gt;refs指向NULL,表示没有其他module依赖mod
2.MOD_AUTOCLEAN，表示mod允许自动删除
3.MOD_RUNNING，已经成功安装，但是没有free_module-&gt;cleanup
4.！MOD_DELETED，没有free_module
5.MOD_USED_ONCE,模块安装之后受到引用
6.!__MOD_IN_USE，不被使用

上述条件满足且（MOD_VISITED没置或者MOD_JUST_FREED置上）
mod-&gt;flags |= MOD_DELETED;
 //这里可能将其他模块的MOD_JUST_FREED置上
free_module(mod, 1);
 //需要重新遍历module_list链表，因为free_module的tag_freed为1
something_changed = 1;

但是如果MOD_VISITED置上并且MOD_JUST_FREED没置
mod-&gt;flags &amp;= ~MOD_VISITED
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1468</x>
      <y>4216</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1380</x>
      <y>4228</y>
      <w>44</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.current-&gt;fs-&gt;root要存在，因为进程需要通过
	/sbin/insmod去安装module
2.max_threads规定最大的线程数，因为request_module
	会通过创建thread，所以这里规定request_module创建的
	线程数最大是max_threads/2，
	所以嵌套或者共存的request_module最大是
	max(max_threads/2，MAX_KMOD_CONCURRENT)
3.如果嵌套的request_module数目（kmod_concurrent）超过了最大值
	返回-ENOMEM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1398</x>
      <y>4219</y>
      <w>79</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>770.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1431</x>
      <y>4229</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kernel_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1436</x>
      <y>4219</y>
      <w>41</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1448</x>
      <y>4229</y>
      <w>47</w>
      <h>14</h>
    </coordinates>
    <panel_attributes> //存储block的signal，便于之后恢复
tmpsig = current-&gt;blocked;
 //将除SIGKILL和SIGSTOP的signal清掉，以免在安装的途中受到干扰
 //清掉表示在blocked中置1
siginitsetinv(&amp;current-&gt;blocked, sigmask(SIGKILL) | sigmask(SIGSTOP));
 //重新计算pending.signal中是否有被置上的signal（blocked中为0）
 //如果有t-&gt;sigpending置1
recalc_sigpending(current);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1464</x>
      <y>4219</y>
      <w>13</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1474</x>
      <y>4219</y>
      <w>35</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1502</x>
      <y>4231</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //wait子线程
waitpid(pid, NULL, __WCLONE)
 //已经安装完，递减request_module计数
atomic_dec(&amp;kmod_concurrent)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1531</x>
      <y>4231</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //恢复mask，并重新检测是否
 //收到相关信号
current-&gt;blocked = tmpsig;
recalc_sigpending(current);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1474</x>
      <y>4219</y>
      <w>68</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;660.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1431</x>
      <y>4237</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>exec_modprobe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1435</x>
      <y>4232</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1391</x>
      <y>4245</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.设置环境变量
2.设置argv
	这里相当于/sbin/modprobe -s -k module_name
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1406</x>
      <y>4240</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1435</x>
      <y>4246</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>exec_usermodehelper</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1436</x>
      <y>4240</y>
      <w>9</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1408</x>
      <y>4254</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //指向当前线程
curtask = current
 //指向init_task
curtask-&gt;session = 1;
curtask-&gt;pgrp = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1414</x>
      <y>4249</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1425</x>
      <y>4257</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>use_init_fs_context</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1428</x>
      <y>4249</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为线程的根目录可能不是
系统的根目录，所以需要切换成
init_task的根目录</panel_attributes>
    <additional_attributes>160.0;10.0;50.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1409</x>
      <y>4267</y>
      <w>29</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>rootmnt = mntget(init_fs-&gt;rootmnt);
root = dget(init_fs-&gt;root);
pwdmnt = mntget(init_fs-&gt;pwdmnt);
pwd = dget(init_fs-&gt;pwd);

our_fs = current-&gt;fs;
our_fs-&gt;umask = init_fs-&gt;umask;
 //设置root pwd，如果之前的root pwd存在
 //将其dput，mntput
set_fs_root(our_fs, rootmnt, root);
set_fs_pwd(our_fs, pwdmnt, pwd);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1415</x>
      <y>4260</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取init_task的root、pwd、umask
</panel_attributes>
    <additional_attributes>190.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1433</x>
      <y>4260</y>
      <w>13</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
our_fs-&gt;altroot存在</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1440</x>
      <y>4269</y>
      <w>18</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //更新altroot
our_fs-&gt;altrootmnt = NULL;
our_fs-&gt;altroot = NULL;
 //将其原来的释放
dput(dentry);
mntput(mnt);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1462</x>
      <y>4270</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>dput(root);
mntput(rootmnt);
dput(pwd);
mntput(pwdmnt);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1433</x>
      <y>4260</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将原来的root和pwd释放</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1459</x>
      <y>4258</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>	sigemptyset(&amp;curtask-&gt;blocked);
	flush_signals(curtask);
	flush_signal_handlers(curtask);
	recalc_sigpending(curtask);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1442</x>
      <y>4249</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将父进程处理的信号和相应的action丢弃</panel_attributes>
    <additional_attributes>20.0;10.0;240.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1483</x>
      <y>4261</y>
      <w>20</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>if (curtask-&gt;files-&gt;fd[i]) close(i)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1443</x>
      <y>4249</y>
      <w>52</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
关闭所有的文件</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1506</x>
      <y>4258</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>curtask-&gt;user = INIT_USER;
atomic_inc(&amp;INIT_USER-&gt;__count);
atomic_inc(&amp;INIT_USER-&gt;processes);
atomic_dec(&amp;user-&gt;processes);
free_uid(user);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1443</x>
      <y>4249</y>
      <w>71</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复用init_task的user
将之前的user释放</panel_attributes>
    <additional_attributes>10.0;10.0;690.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1536</x>
      <y>4258</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>curtask-&gt;euid = curtask-&gt;fsuid = 0;
curtask-&gt;egid = curtask-&gt;fsgid = 0;
 //所有的进程权限都给予这个内核线程
cap_set_full(curtask-&gt;cap_effective);
set_fs(KERNEL_DS)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1444</x>
      <y>4249</y>
      <w>107</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
给与线程权限</panel_attributes>
    <additional_attributes>10.0;10.0;1050.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1566</x>
      <y>4258</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>execve</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1443</x>
      <y>4249</y>
      <w>130</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1280.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1022</x>
      <y>4263</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sparcaudio_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1027</x>
      <y>4257</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1001</x>
      <y>4270</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_register_chrdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1006</x>
      <y>4266</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1001</x>
      <y>4277</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_chrdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1008</x>
      <y>4273</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>978</x>
      <y>4280</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果major为0</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>966</x>
      <y>4285</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.从 MAX_CHRDEV-1向前遍历，找到
	chrdevs[major].fops为NULL的位置
	赋值：
	chrdevs[major].name = name;
	chrdevs[major].fops = fops;
	return major;
2.如果没找到，返回-EBUSY
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>992</x>
      <y>4287</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果major &gt;= MAX_CHRDEV，返回-EINVAL
2.如果chrdevs[major].fops且和当前注册的fops
	不同，返回return -EBUSY
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1006</x>
      <y>4280</y>
      <w>6</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1025</x>
      <y>4287</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>chrdevs[major].name = name;
chrdevs[major].fops = fops;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1008</x>
      <y>4280</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1060</x>
      <y>4270</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_mk_dir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1025</x>
      <y>4266</y>
      <w>44</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1030</x>
      <y>4280</y>
      <w>22</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.name == NULL时，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1040</x>
      <y>4273</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1055</x>
      <y>4279</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>search_for_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1063</x>
      <y>4273</y>
      <w>6</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1049</x>
      <y>4288</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_root_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1050</x>
      <y>4282</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果dir为NULL
如果通过下面接口无法找到
就返回NULL</panel_attributes>
    <additional_attributes>120.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1034</x>
      <y>4295</y>
      <w>14</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>return root_entry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1041</x>
      <y>4291</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
root_entry != NULL</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1055</x>
      <y>4291</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
root_entry为NULL</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1047</x>
      <y>4294</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请root_entry</panel_attributes>
    <additional_attributes>90.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1040</x>
      <y>4300</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>921</x>
      <y>4303</y>
      <w>130</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果table的size不够
fs_info.num_inodes &gt;= fs_info.table_size</panel_attributes>
    <additional_attributes>1280.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>877</x>
      <y>4324</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>883</x>
      <y>4318</y>
      <w>41</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注：sizeof *table相当于sizeof(*table)</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>895</x>
      <y>4325</y>
      <w>42</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memcpy (table, fs_info.table, sizeof *table *fs_info.num_inodes);
kfree (fs_info.table);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>907</x>
      <y>4318</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fs_info.table存在
就copy原来的table到新申请的内存</panel_attributes>
    <additional_attributes>150.0;10.0;70.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>941</x>
      <y>4325</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fs_info.table = table
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>921</x>
      <y>4318</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新table</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>962</x>
      <y>4326</y>
      <w>18</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>namelen = strlen (name)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>968</x>
      <y>4303</y>
      <w>83</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 name &amp;&amp; (namelen &lt; 1) 时
重新计算name的长度</panel_attributes>
    <additional_attributes>810.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>986</x>
      <y>4303</y>
      <w>65</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请devfs_entry+name长度的内存
并reset</panel_attributes>
    <additional_attributes>630.0;10.0;10.0;220.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>983</x>
      <y>4325</y>
      <w>29</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>kmalloc
 memset (new, 0, sizeof *new + namelen);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1019</x>
      <y>4303</y>
      <w>33</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置新申请的devfs_entry</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1015</x>
      <y>4324</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>new-&gt;parent = parent;
 //注：name是new中的一个字节
if (name) memcpy (new-&gt;name, name, namelen);
new-&gt;namelen = namelen;
 //更新inode号
new-&gt;inode.ino = fs_info.num_inodes + FIRST_INODE;
new-&gt;inode.nlink = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1049</x>
      <y>4303</y>
      <w>32</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
新申请的devfs_entry关联到fs_info</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;220.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1053</x>
      <y>4325</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>fs_info.table[fs_info.num_inodes] = new;
 //更新num_inodes，记录fs_info中inode的个数
++fs_info.num_inodes;
 //如果新申请的devfs_entry是dev的根目录
if (parent == NULL) return new;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1050</x>
      <y>4303</y>
      <w>47</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果新申请的不是dev的根目录
建立new和parent的关系</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1088</x>
      <y>4323</y>
      <w>37</w>
      <h>16</h>
    </coordinates>
    <panel_attributes> //u.dir.last表示parent中的最后一个devfs_entry
 //u.dir.first表示parent中第一个devfs_entry
 //这里将new链接到链表最后
new-&gt;prev = parent-&gt;u.dir.last
 //如果first不存在，更新first，不然链接到链表的最后
if (parent-&gt;u.dir.first == NULL) parent-&gt;u.dir.first = new;
else parent-&gt;u.dir.last-&gt;next = new;
 //更新last
parent-&gt;u.dir.last = new;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1066</x>
      <y>4299</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>root_entry-&gt;registered = TRUE;
root_entry-&gt;mode = S_IFDIR;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1062</x>
      <y>4295</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1099</x>
      <y>4298</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>update_devfs_inode_from_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1062</x>
      <y>4295</y>
      <w>47</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1127</x>
      <y>4310</y>
      <w>61</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>S_ISDIR：
de-&gt;inode.mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;
de-&gt;inode.uid = 0;
de-&gt;inode.gid = 0;

S_ISLNK：
de-&gt;inode.mode = S_IFLNK | S_IRUGO | S_IXUGO;
de-&gt;inode.uid = 0;
de-&gt;inode.gid = 0;

S_ISFIFO：
de-&gt;inode.mode = de-&gt;mode;
de-&gt;inode.uid = de-&gt;u.fifo.uid;
de-&gt;inode.gid = de-&gt;u.fifo.gid;

其他：
 //fcb存在owner
if(u.fcb.auto_owner) de-&gt;inode.mode = (de-&gt;mode &amp; ~S_IALLUGO) | S_IRUGO | S_IWUGO;
else de-&gt;inode.mode = de-&gt;mode;
de-&gt;inode.uid = de-&gt;u.fcb.default_uid;
de-&gt;inode.gid = de-&gt;u.fcb.default_gid;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1111</x>
      <y>4301</y>
      <w>36</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置新申请的devfs_entry的inode</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1054</x>
      <y>4293</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新root_entry</panel_attributes>
    <additional_attributes>20.0;20.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1143</x>
      <y>4298</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1055</x>
      <y>4291</y>
      <w>95</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在root_entry下创建名为.devfsd的devfs_entry</panel_attributes>
    <additional_attributes>10.0;10.0;930.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1056</x>
      <y>4291</y>
      <w>142</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新.devfsd的devfs_entry</panel_attributes>
    <additional_attributes>10.0;10.0;1400.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1190</x>
      <y>4299</y>
      <w>37</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>new-&gt;registered = TRUE;
new-&gt;u.fcb.u.device.major = next_devnum_char &gt;&gt; 8;
new-&gt;u.fcb.u.device.minor = next_devnum_char &amp; 0xff;
++next_devnum_char;
new-&gt;mode = S_IFCHR | S_IRUSR | S_IWUSR;
new-&gt;u.fcb.default_uid = 0;
new-&gt;u.fcb.default_gid = 0;
new-&gt;u.fcb.ops = &amp;devfsd_fops;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1061</x>
      <y>4282</y>
      <w>187</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环解析name</panel_attributes>
    <additional_attributes>10.0;10.0;1850.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1233</x>
      <y>4296</y>
      <w>55</w>
      <h>45</h>
    </coordinates>
    <panel_attributes>1.找到以‘/’隔离的subname
2.如果是最后一个节点，获取最后一个节点的namelen(stop - subname)
	通过search_for_entry_in_dir在父目录dir中查找，如果找到了entry，
	将其返回；如果没有找到，但是!mkfile，返回NULL;如果要求mkfile，通过create_entry
	在dir中创建subname节点。且：
	if (entry &amp;&amp; is_new) *is_new = TRUE
3.如果subname是../，将dir切换成dir = dir-&gt;parent，并且
	 //不能返回到devfs的父目录
	 if (dir == NULL) return NULL;
	 subname += 3;
    continue;
3.获取dir中查找的name长度(len = ptr - subname)
	并通过search_for_entry_in_dir在父目录中查找
4.如果在父目录dir中没找到entry，并且不要求创建新目录（!mkdir）
	返回NULL
5.如果没找到entry，但是要求mkdir，需要通过create_entry在父目录
	下创建一个名为subname的entry，,并且：
	entry-&gt;mode = S_IFDIR | S_IRUGO | S_IXUGO | S_IWUSR
	//标志新创建
	if (is_new) *is_new = TRUE;
6.如果找到或者创建的的entry不是S_ISDIR，返回NULL
7.改变entry的属性：
	entry-&gt;registered = TRUE;
	entry-&gt;hide = FALSE;
8.遍历下一个：
	subname = ptr + 1;
	dir = entry;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1079</x>
      <y>4278</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果没找到entry，返回NULL
2.如果entry不是S_ISDIR，但是
	registered置上，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1068</x>
      <y>4273</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1104</x>
      <y>4278</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>de-&gt;u.dir.first = NULL;
de-&gt;u.dir.last = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1069</x>
      <y>4273</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不是S_ISDIR，并且没有创建（!is_new）</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1121</x>
      <y>4276</y>
      <w>45</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>de-&gt;mode = S_IFDIR | S_IRUGO | S_IXUGO;
de-&gt;info = info;
if (!de-&gt;registered) de-&gt;u.dir.num_removable = 0;
de-&gt;registered = TRUE;
de-&gt;show_unreg = (boot_options &amp; OPTION_SHOW) ? TRUE : FALSE;
de-&gt;hide = FALSE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1069</x>
      <y>4273</y>
      <w>63</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1241</x>
      <y>4348</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1230</x>
      <y>4352</y>
      <w>17</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.父目录要是S_ISDIR
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1250</x>
      <y>4352</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.遍历parent的子节点链表parent-&gt;u.dir.first
2.根据namelen和name滤出对应的devfs_entry
3.如果在链表中没有找到devfs_entry，返回NULL
4.如果找到了，但是不是S_ISLNK，或者是link，
	但是不要求traverse_symlink，直接返回找到的
	devfs_entry
5.如果需要根据link找到实体（traverse_symlink），
	使用search_for_entry在parent中找curr-&gt;u.symlink.linkname
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1254</x>
      <y>4348</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1247</x>
      <y>4345</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>search_for_entry_in_dir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1256</x>
      <y>4340</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>260</x>
      <y>4523</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>uhci_hcd_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>269</x>
      <y>4533</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>pci_module_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>246</x>
      <y>4533</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>kmem_cache_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>253</x>
      <y>4527</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uhci_td
uhci_qh
uhci_urb_priv</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>265</x>
      <y>4527</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>257</x>
      <y>4544</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>pci_register_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>281</x>
      <y>4545</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>pci_unregister_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>262</x>
      <y>4537</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uhci_pci_driver</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>271</x>
      <y>4537</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果register成功，返回0
否则unregister，然后返回-ENODEV</panel_attributes>
    <additional_attributes>50.0;10.0;180.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>223</x>
      <y>4556</y>
      <w>13</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>list_add_tail
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>226</x>
      <y>4548</y>
      <w>39</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将pci_driver链接到pci_drivers链表后面</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>262</x>
      <y>4548</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>256</x>
      <y>4554</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历pci_devices中所有的pci_dev
2.如果dev没有相应的driver（!pci_dev_driver），
	通过pci_announce_device查找和driver match
	的dev去初始化
3.返回所有初始化的dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>255</x>
      <y>4569</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_dev_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>259</x>
      <y>4563</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>247</x>
      <y>4577</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果dev.driver存在，直接返回
2.如果不存在，遍历dev所有的rom resource
	如果其中有一个resource的IORESOURCE_BUSY
	（地址区间已启用）置上，返回pci_compat_driver
3.否则返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>258</x>
      <y>4572</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>277</x>
      <y>4569</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_announce_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>271</x>
      <y>4563</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>277</x>
      <y>4577</y>
      <w>35</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.如果drv-&gt;id_table存在，通过pci_match_device遍历
	表中是否有和dev匹配的pci_device_id，如果没有，则
	直接返回0。如果找到通过drv-&gt;probe初始化
2.如果drv-&gt;id_table不存在，则默认是直接初始化drv-&gt;probe
3.如果初始化成功：
	dev-&gt;driver = drv;
	ret = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>284</x>
      <y>4572</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>277</x>
      <y>4592</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_match_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>281</x>
      <y>4589</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>267</x>
      <y>4600</y>
      <w>26</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果pci_device_id的vendor、subvendor、class_mask都为空
	则到了table的末尾，直接返回NULL
2.否则，只有在pci_device_id和dev的vendor，device、
	subvendor、subdevice以及class（
	class_mask为~0，表示其要完全相同）
	都相同的情况下，才是和dev匹配的pci_device_id
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>279</x>
      <y>4595</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>297</x>
      <y>4597</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drv-&gt;probe
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>302</x>
      <y>4589</y>
      <w>4</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>297</x>
      <y>4605</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_pci_probe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>301</x>
      <y>4600</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uhci_pci_driver</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>286</x>
      <y>4608</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
向dev的USBLEGSUP寄存器写0</panel_attributes>
    <additional_attributes>180.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>277</x>
      <y>4614</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_write_config_word
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>299</x>
      <y>4614</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_enable_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>303</x>
      <y>4608</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>283</x>
      <y>4622</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_enable_device
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>292</x>
      <y>4617</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>308</x>
      <y>4622</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_set_power_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>304</x>
      <y>4617</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>329</x>
      <y>4611</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.遍历pci设备的[0,6)号resource
2.resource的flag中IORESOURCE_IO要置上
3.通过check_region检查resource是否被用
	如果被用直接退出
4.通过pci_set_master将USB竞争总线的能力打开
	（能使用DMA功能）
5.通过setup_uhci初始化USB总线（传入usb设备的其实地址和长度）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>303</x>
      <y>4608</y>
      <w>38</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>320</x>
      <y>4626</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>check_region</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>327</x>
      <y>4622</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>315</x>
      <y>4633</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__check_region</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>321</x>
      <y>4629</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>311</x>
      <y>4640</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过__request_region（reference）
	申请对应的resource
2.如果没申请到，说明有conflict，返回EBUSY
3.如果申请到了，通过release_resource将
	之前申请的resource释放（将其从parent.child
	的sibling链表中删除），并通过kfree将其内存释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>320</x>
      <y>4636</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>337</x>
      <y>4626</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_set_master</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>342</x>
      <y>4622</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>331</x>
      <y>4634</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_write_config_word
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>330</x>
      <y>4629</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
向PCI_COMMAND写
PCI_COMMAND_MASTER</panel_attributes>
    <additional_attributes>120.0;10.0;60.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>349</x>
      <y>4634</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_set_master</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>345</x>
      <y>4629</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>341</x>
      <y>4641</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.更改PCI_LATENCY_TIMER寄存器
	的值，如果原本的值小于16，则取
	pcibios_max_latency（但是最大是64）；
	如果原来的值大于pcibios_max_latency，
	则取pcibios_max_latency
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>348</x>
      <y>4637</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>409</x>
      <y>4629</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_uhci</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>356</x>
      <y>4622</y>
      <w>59</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;570.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>371</x>
      <y>4637</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_uhci</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>376</x>
      <y>4632</y>
      <w>41</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>367</x>
      <y>4681</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_alloc_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>375</x>
      <y>4640</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>374</x>
      <y>4676</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>364</x>
      <y>4688</y>
      <w>30</w>
      <h>23</h>
    </coordinates>
    <panel_attributes> //申请usb_bus
bus = kmalloc
memset(&amp;bus-&gt;devmap, 0
bus-&gt;op = op;
bus-&gt;root_hub = NULL;
bus-&gt;hcpriv = NULL;
bus-&gt;busnum = -1;
bus-&gt;bandwidth_allocated = 0;
bus-&gt;bandwidth_int_reqs  = 0;
bus-&gt;bandwidth_isoc_reqs = 0;

INIT_LIST_HEAD(&amp;bus-&gt;bus_list);
INIT_LIST_HEAD(&amp;bus-&gt;inodes)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>373</x>
      <y>4684</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>365</x>
      <y>4644</y>
      <w>30</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>kmalloc(sizeof(*uhci)
memset(uhci, 0, sizeof(*uhci));
uhci-&gt;irq = -1;
uhci-&gt;io_addr = io_addr;
uhci-&gt;io_size = io_size;
spin_lock_init(&amp;uhci-&gt;qh_remove_lock);
INIT_LIST_HEAD(&amp;uhci-&gt;qh_remove_list);
spin_lock_init(&amp;uhci-&gt;urb_remove_lock);
INIT_LIST_HEAD(&amp;uhci-&gt;urb_remove_list);
nested_init(&amp;uhci-&gt;urblist_lock);
INIT_LIST_HEAD(&amp;uhci-&gt;urb_list);
spin_lock_init(&amp;uhci-&gt;framelist_lock)

 //框架表
uhci-&gt;fl = (void *)__get_free_page

 //申请bus，并建立关系
bus = usb_alloc_bus(&amp;uhci_device_operations)
uhci-&gt;bus = bus;
bus-&gt;hcpriv = uhci

 //读取port的状态，其状态寄存器是1，表示这个port存在
 //从而确定port的数量。注：前16字节是总线控制器本身
 //后面是port寄存器，每2个字节一个port
 //如果port的数量小于2或者大于8，将其赋值成2
 portstatus = inw(io_addr + 0x10 + (port * 2));
	if (!(portstatus &amp; 0x0080))
		break;
 uhci-&gt;rh.numports = port
 //初始化中断交互队列skeltd
 //1.首先索引[1,9)
 //填充status，buffer（都为0，表示空操作），info（是操作码 	(UHCI_NULL_DATA_SIZE &lt;&lt; 21) | (0x7f &lt;&lt; 8) | USB_PID_IN）
 uhci_fill_td
 //指向上一个skeltd的物理地址
	td-&gt;link	=virt_to_bus(&amp;uhci-&gt;skeltd[i - 1])
 //2.其次索引0，填充和[1，9）相同，
 uhci_fill_td
 //link指向skelqh[0]，uhci_td和uhci_qh是16字节对齐，所以低4位为0，可以填标志
 //UHCI_PTR_QH,表示其指向队列描述块
 uhci-&gt;skel_int1_td.link = virt_to_bus(&amp;uhci-&gt;skel_ls_control_qh) | UHCI_PTR_QH;
 //3.其次是索引9，填充和之前相同
 uhci_fill_td
 //UHCI_PTR_TERM,表示结束位
 uhci-&gt;skel_term_td.link = UHCI_PTR_TERM;

 //初始化队列描述块skelqh
 //索引0，link指向下一个队列描述块，element是队列头指针（都初始化为结束，只有最后一个指向skeltd[9]）
 uhci-&gt;skel_ls_control_qh.link = virt_to_bus(&amp;uhci-&gt;skel_hs_control_qh) | UHCI_PTR_QH;
 uhci-&gt;skel_ls_control_qh.element = UHCI_PTR_TERM;
 //索引1
 uhci-&gt;skel_hs_control_qh.link = virt_to_bus(&amp;uhci-&gt;skel_bulk_qh) | UHCI_PTR_QH;
 uhci-&gt;skel_hs_control_qh.element = UHCI_PTR_TERM;
 //索引2
 uhci-&gt;skel_bulk_qh.link = virt_to_bus(&amp;uhci-&gt;skel_term_qh) | UHCI_PTR_QH;
 uhci-&gt;skel_bulk_qh.element = UHCI_PTR_TERM
 //索引3，最后一个，link指向结束
 uhci-&gt;skel_term_qh.link = UHCI_PTR_TERM;
 uhci-&gt;skel_term_qh.element = virt_to_bus(&amp;uhci-&gt;skel_term_td)

注：链表skeltd[8] -link-&gt; ..-link-&gt; skeltd[0] -link-&gt; ls_qh -link-&gt; hs_qh -link-&gt; bulk_qh -link-&gt; term_qh -link-&gt;NULL
																															      |
																															      element
																															      |
																															      skeltd[9]
 //将skeltd（irq）[0,7]数组分配到fl的第（2^n-1）个框架结构中
 //所以第n个skeltd是（2^n）ms执行一次（注：虽然只链接了第n个skeltd到fl中，但是skeltd通过link链接在一起）
 uhci-&gt;fl-&gt;frame[i] =  virt_to_bus(irq)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>387</x>
      <y>4638</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;driver_data = uhci
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>393</x>
      <y>4632</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>411</x>
      <y>4632</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
请求resource
uhci-&gt;io_addr(len=io_size)</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>406</x>
      <y>4637</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_region
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>419</x>
      <y>4637</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reset_hc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>414</x>
      <y>4632</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>411</x>
      <y>4643</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //向USB控制器发送”全局总清“命令，将其初始化
outw(USBCMD_GRESET, io_addr + USBCMD)
wait_ms(50);
outw(0, io_addr + USBCMD);
wait_ms(10);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>421</x>
      <y>4640</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>444</x>
      <y>4637</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_register_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>414</x>
      <y>4632</y>
      <w>38</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>435</x>
      <y>4644</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_next_zero_bit
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>429</x>
      <y>4640</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从1开始查找busmap.busmap中是否有空闲的位</panel_attributes>
    <additional_attributes>200.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>448</x>
      <y>4640</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
busnum &lt; USB_MAXBUS
如果有空闲位</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>449</x>
      <y>4645</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>set_bit(busnum, busmap.busmap);
bus-&gt;busnum = busnum
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>477</x>
      <y>4645</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_add
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>448</x>
      <y>4640</y>
      <w>36</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将bus的bus_list链接到usb_bus_list链表中</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>490</x>
      <y>4645</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usbdevfs_add_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>448</x>
      <y>4640</y>
      <w>50</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>479</x>
      <y>4652</y>
      <w>44</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.遍历usb的超级块链表superlist，然后通过new_bus_inode
	在sb中添加inode
2.通过update_special_inodes检查special数组中如果
	存在inode，将其时间更新
	inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME
3.执行usbdevfs_conn_disc_event：
	wake_up(&amp;deviceconndiscwq);
	conndiscevcnt++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>497</x>
      <y>4648</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>491</x>
      <y>4669</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>new_bus_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>496</x>
      <y>4665</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>467</x>
      <y>4679</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>470</x>
      <y>4672</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
busnum 不能大于255
在超级块中获取IBUS | (busnum &lt;&lt; 8)号inode</panel_attributes>
    <additional_attributes>270.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>495</x>
      <y>4675</y>
      <w>36</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;
inode-&gt;i_uid = sb-&gt;u.usbdevfs_sb.busuid;
inode-&gt;i_gid = sb-&gt;u.usbdevfs_sb.busgid;
inode-&gt;i_mode = sb-&gt;u.usbdevfs_sb.busmode | S_IFDIR;
inode-&gt;i_op = &amp;usbdevfs_bus_inode_operations;
inode-&gt;i_fop = &amp;usbdevfs_bus_file_operations;
 //从inode能找到bus
inode-&gt;u.usbdev_i.p.bus = bus;
 //将inode挂入到sb的链表中
list_add_tail(&amp;inode-&gt;u.usbdev_i.slist, &amp;sb-&gt;u.usbdevfs_sb.ilist);
 //将inode挂入到bus的链表中
list_add_tail(&amp;inode-&gt;u.usbdev_i.dlist, &amp;bus-&gt;inodes);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>497</x>
      <y>4672</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>467</x>
      <y>4689</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_new_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>471</x>
      <y>4682</y>
      <w>3</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.()</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>471</x>
      <y>4692</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.()</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>463</x>
      <y>4697</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;read_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>471</x>
      <y>4700</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usbdevfs_read_super-&gt;usbdevfs_sops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>463</x>
      <y>4706</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usbdevfs_read_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>439</x>
      <y>4715</y>
      <w>32</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_ctime = inode-&gt;i_mtime = inode-&gt;i_atime = CURRENT_TIME;
inode-&gt;i_mode = S_IFREG;
inode-&gt;i_gid = inode-&gt;i_uid = 0;
INIT_LIST_HEAD(&amp;inode-&gt;u.usbdev_i.dlist);
INIT_LIST_HEAD(&amp;inode-&gt;u.usbdev_i.slist);
inode-&gt;u.usbdev_i.p.dev = NULL;
inode-&gt;u.usbdev_i.p.bus = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>455</x>
      <y>4709</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>475</x>
      <y>4715</y>
      <w>37</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果是ISPECIAL:
	1.如果是root_inode
	inode-&gt;i_op = &amp;usbdevfs_root_inode_operations;
	inode-&gt;i_fop = &amp;usbdevfs_root_file_operations;
	inode-&gt;i_mode = S_IFDIR | S_IRUGO | S_IXUGO;
	return;
	2.如果超过了ISPECIAL类型中inode号的限制，直接return
	3.如果是其他special类型的inode
	spec = &amp;special[inode-&gt;i_ino-(IROOT+1)];
	inode-&gt;i_fop = spec-&gt;fops;
	return;
2.如果是其他类型，直接return
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>468</x>
      <y>4709</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查看inode的类型
ITYPE(inode-&gt;i_ino)</panel_attributes>
    <additional_attributes>20.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>541</x>
      <y>4639</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_hc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>414</x>
      <y>4632</y>
      <w>132</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1300.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>526</x>
      <y>4645</y>
      <w>43</w>
      <h>19</h>
    </coordinates>
    <panel_attributes> //reset host controller,并在timeout时间内检测其是否置上
outw (USBCMD_HCRESET, io_addr + USBCMD)
 //打开USB的四种中断: 超时，唤醒，规定的交互完成，short_packet
outw (USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP, io_addr + USBINTR)
 //将框架寄存器设置为0，并将其地址赋给相应的寄存器，表示从s-&gt;framelist[0]开始扫描
outw (0, io_addr + USBFRNUM);
outl (virt_to_bus (s-&gt;framelist), io_addr + USBFLBASEADD);
 //USBCMD_RS启动USB控制器
outw (USBCMD_RS | USBCMD_CF | USBCMD_MAXP, io_addr + USBCMD);
s-&gt;apm_state = 1;
s-&gt;running = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>544</x>
      <y>4642</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>572</x>
      <y>4638</y>
      <w>32</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.通过request_irq请求irq，其中：
	action-&gt;handler = uhci_interrupt;
	action-&gt;flags = SA_SHIRQ;
	action-&gt;name =  "usb-uhci";
	action-&gt;dev_id = uhci;（uhci对象）
2.如果请求成功：
	uhci-&gt;irq = irq;
	//设置USBLEGSUP
	pci_write_config_word(dev, USBLEGSUP, USBLEGSUP_DEFAULT)
	//启用根集中器
	uhci_start_root_hub（）
3.如果irq没请求成功，或者根集中器启动失败
	reset_hc(uhci);
	release_region(uhci-&gt;io_addr, uhci-&gt;io_size);
	release_uhci(uhci);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>578</x>
      <y>4666</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_start_root_hub</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>414</x>
      <y>4632</y>
      <w>172</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1700.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>586</x>
      <y>4663</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>544</x>
      <y>4673</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_alloc_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>552</x>
      <y>4669</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>537</x>
      <y>4679</y>
      <w>27</w>
      <h>20</h>
    </coordinates>
    <panel_attributes> //申请usb_device
dev = kmalloc(sizeof(*dev)

memset(dev, 0, sizeof(*dev))
 //这里bus=uhci-&gt;bus，parent=NULL(因为申请的是根集中器)
dev-&gt;bus = bus;
dev-&gt;parent = parent;
atomic_set(&amp;dev-&gt;refcnt, 1);
INIT_LIST_HEAD(&amp;dev-&gt;inodes);
INIT_LIST_HEAD(&amp;dev-&gt;filelist);

dev-&gt;bus-&gt;op-&gt;allocate(dev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>550</x>
      <y>4676</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>542</x>
      <y>4702</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;bus-&gt;op-&gt;allocate
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>549</x>
      <y>4698</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>549</x>
      <y>4705</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uhci_device_operations
这里直接返回0</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>544</x>
      <y>4709</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_alloc_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>563</x>
      <y>4673</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci-&gt;bus-&gt;root_hub = dev
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>571</x>
      <y>4669</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根集中器的usb_dev赋值</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>587</x>
      <y>4673</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>583</x>
      <y>4669</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>576</x>
      <y>4680</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>dev-&gt;descriptor.bMaxPacketSize0 = 8
 //从dev-&gt;bus-&gt;devmap.devicemap中找到空闲的devnum
 //如果定义了DEVNUM_ROUND_ROBIN，则从devnum_next开始查找
 //并更新devnum_next= devnum + 1
devnum = find_next_zero_bit
 //如果找到的devnum有效：devnum &lt; 128
 set_bit(devnum, dev-&gt;bus-&gt;devmap.devicemap);
	dev-&gt;devnum = devnum
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>593</x>
      <y>4676</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>650</x>
      <y>4670</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_new_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>583</x>
      <y>4669</y>
      <w>74</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>609</x>
      <y>4690</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_set_address</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>609</x>
      <y>4708</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_control_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>613</x>
      <y>4673</y>
      <w>45</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>613</x>
      <y>4693</y>
      <w>46</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_snddefctrl：定义了pipe，__default_pipe中devnum和endpoint为0
(30~31,传输方式，成块传输、等时传输，中断传输，控制传输
26，指示是否为低速设备（dev-&gt;slow）
8~14位，设备号devnum，没被设置地址前是0
15~18位，endpoint号
7位，0指示输出，1指示输入)
USB_REQ_SET_ADDRESS：命令码，设置地址
dev-&gt;devnum：要设置的设备地址</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>609</x>
      <y>4679</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //设置输入，输出预取信包的大小
dev-&gt;epmaxpacketin [0] = 8;
dev-&gt;epmaxpacketout[0] = 8
usb_set_address(dev)
wait_ms(10)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>614</x>
      <y>4687</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>633</x>
      <y>4681</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_get_descriptor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>638</x>
      <y>4673</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
先读8个字节，将
支持的信包容量读出</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>631</x>
      <y>4688</y>
      <w>34</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.将buf(dev-&gt;descriptor)清0
	memset(buf,0,size)
2.请求描述块，如果请求大小为0，则retry（总共5次）
	//这里type=USB_DT_DEVICE，表示设备描述块
	//usb_rcvctrlpipe中定义了devnum+endpoint和方向USB_DIR_IN
	usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
		USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
		(type &lt;&lt; 8) + index, 0, buf, size, HZ * GET_TIMEOUT)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>640</x>
      <y>4684</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>650</x>
      <y>4681</y>
      <w>30</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;epmaxpacketin [0] = dev-&gt;descriptor.bMaxPacketSize0;
dev-&gt;epmaxpacketout[0] = dev-&gt;descriptor.bMaxPacketSize0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>655</x>
      <y>4673</y>
      <w>23</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据读进来的设备描述块
设置控制交互信包的最大容量</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>682</x>
      <y>4680</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_get_device_descriptor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>655</x>
      <y>4673</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>670</x>
      <y>4688</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.再次通过usb_get_descriptor读取设备描述块
	此次读取的size是sizeof(dev-&gt;descriptor)
2.将bcdUSB，idVendor，idProduct，bcdDevice
	从小端模式转化成cpu使用的模式
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>685</x>
      <y>4683</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>706</x>
      <y>4680</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_get_configuration</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>654</x>
      <y>4673</y>
      <w>64</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>701</x>
      <y>4688</y>
      <w>40</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.filter:配置描述快的数量需要在：
	1&lt;dev-&gt;descriptor.bNumConfigurations&lt;USB_MAXCONFIG
2.申请配置描述快数组，并清0
	dev-&gt;config =kmalloc
	memset(dev-&gt;config, 0,
3.申请原始的配置描述快指针数组
	dev-&gt;rawdescriptors=kmalloc
4.循环bNumConfigurations次读取配置描述块：
	1.通过usb_get_descriptor读取配置描述块（USB_DT_CONFIG）
		的前8字节。从而获取到配置描述快的大小（wTotalLength）
	2.通过kmalloc为读进来的原始配置描述块申请内存
	3.然后再次通过usb_get_descriptor读取配置描述快（USB_DT_CONFIG）
		这次的长度是wTotalLength，并将存储配置描述块的指针赋值：
		dev-&gt;rawdescriptors[cfgno] = bigbuffer
	4.通过usb_parse_configuration根据配置描述块解析出各种层次的描述块
		并建立相应的数据结构
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>714</x>
      <y>4683</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>711</x>
      <y>4718</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_parse_configuration</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>718</x>
      <y>4714</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>701</x>
      <y>4724</y>
      <w>44</w>
      <h>47</h>
    </coordinates>
    <panel_attributes>1.通过memcpy将buffer中的原始数据拷贝前9字节（USB硬件管理信息）
	到对应的dev-&gt;config[cfgno]中
2.获取配置描述快的大小：
	size = config-&gt;wTotalLength
3.为usb_interface申请数组（大小为config-&gt;bNumInterfaces，并且其大小
	不能大于32），并将内存空间清0
4.将配置头去掉：
	buffer += config-&gt;bLength;
	size -= config-&gt;bLength
5.遍历所有的interface（bNumInterfaces）
	1.通过usb_descriptor_header解析读进来的数据，
	其中:2&lt;bLength&lt;size,否则返回-1
	2.如果遇到了USB_DT_ENDPOINT，USB_DT_INTERFACE，USB_DT_CONFIG，USB_DT_DEVICE
		则退出未知header的解析
	3.如果不是上述四个，则是未知的header，并继续1~3
	4.如果退出了未知header的解析，
		1.如果不存在未知header（buffer-begin==0），
			config-&gt;extra = NULL;
			config-&gt;extralen = 0
		2.如果存在未知header（buffer-begin!=0),需要为其申请内存，并复制
			config-&gt;extra = kmalloc(len
			memcpy(config-&gt;extra, begin, len);
			config-&gt;extralen = len;
	注：这里如果有多个bNumInterfaces，并且其中的一个interface有未知的header，只要这个interface不在最后
	一个，会造成内存的泄露
	5.通过usb_parse_interface解析上述的四个interface
	6.更新buffer和size，并重新遍历interface
		buffer += retval;
		size -= retval;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>719</x>
      <y>4721</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>714</x>
      <y>4774</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_parse_interface</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>720</x>
      <y>4770</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>701</x>
      <y>4780</y>
      <w>44</w>
      <h>61</h>
    </coordinates>
    <panel_attributes>1.首先初始化
	interface-&gt;act_altsetting = 0;
	interface-&gt;num_altsetting = 0;
	//接口描述块数组暂定为4个
	interface-&gt;max_altsetting = USB_ALTSETTINGALLOC
2.为接口描述块数组申请内存，大小为max_altsetting
	interface-&gt;altsetting = kmalloc
3.遍历buffer
	1.如果这个interface存在的接口描述块（num_altsetting）超过了数组的
		界限，更新数组的界限interface-&gt;max_altsetting += USB_ALTSETTINGALLOC
		并为之分配内存interface-&gt;altsetting = kmalloc，并将之前的数据复制到新申请的内存中
		然后将旧数组释放
	2.获取存放接口描述快的内存，并更新num_altsetting：
		ifp = interface-&gt;altsetting + interface-&gt;num_altsetting;
		interface-&gt;num_altsetting++;
	3.将接口描述块存储到数组中并更新buffer，parse，size
		memcpy(ifp, buffer, USB_DT_INTERFACE_SIZE)
		buffer += ifp-&gt;bLength;
		parsed += ifp-&gt;bLength;
		size -= ifp-&gt;bLength;
	4.继续向下遍历buffer，识别出不能识别的header（和usb_parse_configuration相似）
		将其放入到：
		ifp-&gt;extra
		ifp-&gt;extralen
	5.如果遇到了USB_DT_CONFIG或者USB_DT_DEVICE说明遇到了下一个配置或者设备描述块
		直接返回上层，让usb_parse_configuration处理
	6.为ifp-&gt;endpoint申请数组，大小为bNumEndpoints（不能大于USB_MAXENDPOINTS），
		并清0
	7.遍历所有的endpoint(bNumEndpoints),通过usb_parse_endpoint对其进行解析
		并更新：
		buffer += retval;
		parsed += retval;
		size -= retval;	
	8.更新完endpoint之后，如果size小于USB_DT_INTERFACE_SIZE，说明读进来的描述块已经读完
		如果不为USB_DT_INTERFACE，说明读到了下一个设备或者配置描述块
		如果bAlternateSetting为0，说明读到了下一个interface
		都将退出，由上层usb_parse_endpoin继续处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>720</x>
      <y>4777</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>713</x>
      <y>4844</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_parse_endpoint</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>720</x>
      <y>4840</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>700</x>
      <y>4851</y>
      <w>43</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.filter：header-&gt;bLength不能大于读进来的数据的size
			bDescriptorType必须是USB_DT_ENDPOINT
2.将读进来的数据复制到endpoint中（对于视频是9，其他的长度是7）
3.根据cpu的大小端改变endpoint-&gt;wMaxPacketSize的格式
4.将其他未识别的数据存放在endpoint-&gt;extra中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>719</x>
      <y>4847</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>747</x>
      <y>4680</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_set_configuration</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>654</x>
      <y>4673</y>
      <w>105</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1030.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>744</x>
      <y>4688</y>
      <w>27</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.在dev.config的数组中找到和configuration
	一样的usb_config_descriptor
2.如果没找到，返回EINVAL
	如果找到了，通过usb_control_msg给usb_sndctrlpipe
	设置（USB_REQ_SET_CONFIGURATION）configuration
3.更新正在使用的configuration
	dev-&gt;actconfig = cp;
	dev-&gt;toggle[0] = 0;
	dev-&gt;toggle[1] = 0;
4.通过usb_set_maxpacket更新endpoint
	最大传输信包的数量
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>755</x>
      <y>4683</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>749</x>
      <y>4709</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_set_maxpacket</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>756</x>
      <y>4706</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>747</x>
      <y>4716</y>
      <w>43</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.遍历dev激活的configuration（dev-&gt;actconfig）
	下的所有interface（bNumInterfaces）中的
	所有endpoint（bNumEndpoints）：
	1.如果bmAttributes是USB_ENDPOINT_XFER_CONTROL
	（控制交互是双向的）：
	dev-&gt;epmaxpacketout[b] = ep[e].wMaxPacketSize;
	dev-&gt;epmaxpacketin [b] = ep[e].wMaxPacketSize
	2.如果是输出型endpoint，并且大于既有的epmaxpacketout
		将其更新
		dev-&gt;epmaxpacketout[b] = ep[e].wMaxPacketSize
	3.如果是输入型的endpoint，并且大于存储endpoint的epmaxpacketin
	dev-&gt;epmaxpacketin [b] = ep[e].wMaxPacketSize
注：bEndpointAddress的低四位存储的是endpoint的序号
	第4位存储的是endpoint的方向，0表示输出
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>758</x>
      <y>4712</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>775</x>
      <y>4680</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usbdevfs_add_device
（和usbdevfs_add_bus类似）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>655</x>
      <y>4673</y>
      <w>131</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>800</x>
      <y>4680</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_find_drivers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>656</x>
      <y>4673</y>
      <w>155</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1530.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>790</x>
      <y>4686</y>
      <w>38</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.遍历dev激活configuration所有的interface（bNumInterfaces）
	通过usb_interface_claimed检查改interface是否被认领
	如果没被认领，通过usb_find_interface_driver扫描驱动队列
	为其寻找driver
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>808</x>
      <y>4683</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>782</x>
      <y>4696</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_interface_claimed</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>789</x>
      <y>4692</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>774</x>
      <y>4702</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.检查interface是否有driver
	（iface-&gt;driver != NULL）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>783</x>
      <y>4699</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>812</x>
      <y>4696</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_find_interface_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>812</x>
      <y>4692</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>796</x>
      <y>4703</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.dev要存在
2.ifnum不能大于bNumInterfaces
3.根据interface号（ifnum）找到interface
	interface = dev-&gt;actconfig-&gt;interface + ifnum
4.通过usb_interface_claimed检测interface.driver
	不能存在
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>809</x>
      <y>4699</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>829</x>
      <y>4703</y>
      <w>39</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.遍历usb_driver_list
	1.如果driver-&gt;id_table存在，遍历dev所有的interface
		通过usb_match_id检查这个id是否和dev还有其中的interface
		匹配，如果匹配，通过driver-&gt;probe将其初始化
	2.如果id不存在，直接通过driver-&gt;probe将其初始化
	注：如果已经初始化，则返回NULL
2.如果初始化完成，通过usb_driver_claim_interface完成认领：
	iface-&gt;driver = driver;
	iface-&gt;private_data = priv
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>821</x>
      <y>4699</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>845</x>
      <y>4679</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>call_policy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>656</x>
      <y>4673</y>
      <w>197</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
热插拔相关
注意创建内核线程时使用了VCLONE_VFORK</panel_attributes>
    <additional_attributes>10.0;10.0;1950.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>587</x>
      <y>4477</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>546</x>
      <y>4484</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_major_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>551</x>
      <y>4480</y>
      <w>44</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>420.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>531</x>
      <y>4493</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_register_chrdev
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>538</x>
      <y>4487</y>
      <w>16</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
USB_MAJOR,usb_fops</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>553</x>
      <y>4493</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_mk_dir
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>550</x>
      <y>4487</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs下的目录
usb_devfs_handle</panel_attributes>
    <additional_attributes>20.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>581</x>
      <y>4484</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usbdevfs_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>587</x>
      <y>4480</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>569</x>
      <y>4492</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>INIT_LIST_HEAD
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>570</x>
      <y>4487</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化special数组的inodes链表</panel_attributes>
    <additional_attributes>160.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>585</x>
      <y>4492</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>584</x>
      <y>4487</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usbdevfs_driver</panel_attributes>
    <additional_attributes>20.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>601</x>
      <y>4492</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>585</x>
      <y>4487</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>621</x>
      <y>4492</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_mkdir
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>585</x>
      <y>4487</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usbdir</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>579</x>
      <y>4499</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.new_driver-&gt;fops存在时，usb_minors对应的设备
	要为空，如果为空，将其赋值：
	usb_minors[new_driver-&gt;minor/16] = new_driver
2.将new_driver的driver_list链接到usb_driver_list中
3.调用usb_scan_devices
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>591</x>
      <y>4495</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>585</x>
      <y>4512</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_scan_devices</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>591</x>
      <y>4508</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>591</x>
      <y>4515</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历usb_bus_list链表
中bus的根集中器</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>585</x>
      <y>4519</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_check_support</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>575</x>
      <y>4525</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.dev要存在
2.遍历dev-&gt;children，递归usb_check_support
	为其子设备认领driver
3.如果该设备激活的configuration不存在，该设备不在认领driver
4.如果configuration存在，且其devnum有效，遍历其interface
	通过usb_find_interface_driver为interface认领driver
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>591</x>
      <y>4522</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>645</x>
      <y>4485</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>592</x>
      <y>4480</y>
      <w>61</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;590.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>635</x>
      <y>4492</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_register
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>641</x>
      <y>4488</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hub_driver</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>650</x>
      <y>4488</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>671</x>
      <y>4499</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>670</x>
      <y>4492</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kernel_thread
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>676</x>
      <y>4495</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>639</x>
      <y>4495</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.()
usb_find_interface_driver</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>634</x>
      <y>4503</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hub_probe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>624</x>
      <y>4510</y>
      <w>36</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.集中器的子设备号(bInterfaceSubClass)要是0或者1
2.除了默认的控制端点（代码中没有），还要有一个（bNumEndpoints）
	中断(USB_ENDPOINT_XFER_INT)交互的输入(USB_DIR_IN)端点
3.申请usb_hub数据结构，并初始化
	hub = kmalloc(sizeof(*hub)
	memset(hub, 0
	INIT_LIST_HEAD(&amp;hub-&gt;event_list);
	//hub和dev关联
	hub-&gt;dev = dev
	INIT_LIST_HEAD(&amp;hub-&gt;hub_list);
	//将hub加到hub_list链表中
	list_add(&amp;hub-&gt;hub_list, &amp;hub_list);
4.通过usb_hub_configure对hub进一步初始化，其中有对中断传输
	查询状态进行初始化
5.如果成功，return hub
	如果不成功，将hub从链表中删除，并释放hub内存
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>639</x>
      <y>4506</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>632</x>
      <y>4539</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_configure</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>637</x>
      <y>4535</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>584</x>
      <y>4548</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>589</x>
      <y>4542</y>
      <w>50</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hub-&gt;descriptor
HUB_DESCRIPTOR_MAX_SIZE</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>603</x>
      <y>4549</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_get_hub_descriptor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>610</x>
      <y>4542</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取hub描述符
放在 hub-&gt;descriptor中</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>602</x>
      <y>4556</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_control_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>610</x>
      <y>4552</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
USB_REQ_GET_DESCRIPTOR
USB_DIR_IN | USB_RT_HUB</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>625</x>
      <y>4548</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>hub-&gt;nports = 
dev-&gt;maxchild = 
			hub-&gt;descriptor-&gt;bNbrPorts
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>632</x>
      <y>4542</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>646</x>
      <y>4548</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_get_hub_status</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>636</x>
      <y>4542</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>644</x>
      <y>4557</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_control_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>652</x>
      <y>4551</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
USB_REQ_GET_STATUS
USB_DIR_IN | USB_RT_HUB</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>636</x>
      <y>4542</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请中断传输</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>672</x>
      <y>4547</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.获取中断传输的pipe和最大信包maxp（不能大于hub-&gt;buffer）
2.通过usb_alloc_urb为hub-&gt;urb申请urb_t
3.通过宏FILL_INT_URB填充urb结构体
4.将urb提交，申请uhci_td链入到skeltd中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>667</x>
      <y>4557</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_alloc_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>672</x>
      <y>4554</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>641</x>
      <y>4564</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.申请urb和iso_packets个iso_packet_descriptor_t
2.初始化urb：
	memset(urb, 0, sizeof(*urb))
	spin_lock_init(&amp;urb-&gt;lock)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>655</x>
      <y>4560</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>684</x>
      <y>4558</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>FILL_INT_URB
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>691</x>
      <y>4554</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>678</x>
      <y>4564</y>
      <w>25</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>hub-&gt;urb-&gt;dev=dev;\
hub-&gt;urb-&gt;pipe=pipe;\
hub-&gt;urb-&gt;transfer_buffer=hub-&gt;buffer;\
hub-&gt;urb-&gt;transfer_buffer_length=maxp;\
hub-&gt;urb-&gt;complete=hub_irq;\
hub-&gt;urb-&gt;context=hub;\
hub-&gt;urb-&gt;interval=endpoint-&gt;bInterval;\
hub-&gt;urb-&gt;start_frame=-1;\
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>688</x>
      <y>4561</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>708</x>
      <y>4558</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_submit_urb
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>695</x>
      <y>4554</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>705</x>
      <y>4565</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>urb-&gt;dev-&gt;bus-&gt;op-&gt;submit_urb
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>714</x>
      <y>4561</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果urb和urb.dev存在</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>710</x>
      <y>4547</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up(&amp;khubd_wait);
usb_hub_power_on(hub);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>636</x>
      <y>4542</y>
      <w>81</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;790.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>686</x>
      <y>4581</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hub_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>690</x>
      <y>4578</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>679</x>
      <y>4584</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查集中器hub的状态</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>653</x>
      <y>4588</y>
      <w>32</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果urb-&gt;status为0，表示中断交互正常完成
2.如果status显示没有文件（-ENOENT），直接退出
3.如果是其他错误，错误十次之后，记录
	hub-&gt;error = urb-&gt;status
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>693</x>
      <y>4588</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果等待队列khubd_wait不为空，将hub的event_list
	加入到hub_event_list中，并唤醒khubd_wait
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>691</x>
      <y>4584</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>662</x>
      <y>4506</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>daemonize</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>667</x>
      <y>4502</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>661</x>
      <y>4513</y>
      <w>19</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>exit_mm
current-&gt;session = 1;
current-&gt;pgrp = 1;
exit_fs(current);	/* current-&gt;fs-&gt;count--; */
fs = init_task.fs;
current-&gt;fs = fs;
atomic_inc(&amp;fs-&gt;count);
exit_files(current);
current-&gt;files = init_task.files;
atomic_inc(&amp;current-&gt;files-&gt;count);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>667</x>
      <y>4509</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
退出所有的用户资源</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>677</x>
      <y>4507</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>strcpy(current-&gt;comm, "khubd")
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>676</x>
      <y>4502</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
指定thread的名称</panel_attributes>
    <additional_attributes>20.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>700</x>
      <y>4507</y>
      <w>26</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.通过usb_hub_events处理集中器
	的状态变化
2.通过interruptible_sleep_on等待
	唤醒
3.唤醒之后检测是否有信号pending
	（一般是存在的），然后再去处理
	集中器事件
注：这里先处理usb_hub_events是为了
	处理根集中器的状态
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>677</x>
      <y>4502</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
do..while</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>712</x>
      <y>4523</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_events</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>714</x>
      <y>4521</y>
      <w>6</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>683</x>
      <y>4532</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过usb_hub_reset重置集中器
2.如果出错，通过usb_hub_disconnect
	断开链接，并继续遍历下一个hub
3.重置error
	hub-&gt;nerrors = 0;
	hub-&gt;error = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>717</x>
      <y>4525</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
while读取链表hub_event_list
获取链表中的usb_hub和hub对应的dev = hub-&gt;dev
并将其temp实体从链表中移除，并初始化</panel_attributes>
    <additional_attributes>10.0;20.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>699</x>
      <y>4528</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hub-&gt;error
如果出错超过10次</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>717</x>
      <y>4528</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历hub的所有端口
hub-&gt;nports</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>730</x>
      <y>4534</y>
      <w>35</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.通过usb_get_port_status获取port的状态
2.如果port的链接状态发生了变化（USB_PORT_STAT_C_CONNECTION）
	通过usb_hub_port_connect_change进行处理
3.如果enable状态发生了变化（USB_PORT_STAT_C_ENABLE），
	通过usb_clear_port_feature将USB_RT_PORT的ENABLE改变的状态信息
	清除。
	如果此时port状态是没有enable，但是connect，并且该端口上
	有设备（dev-&gt;children[i])），需要通过usb_hub_port_connect_change
	进行处理
4.如果SUSPEND状态位发生了变化，通过usb_clear_port_feature
	将SUSPEND改变的状态清除
5.如果过流（OVERCURRENT）状态发生了变化，通过usb_clear_port_feature
	清除其改变的状态，并通过usb_hub_power_on将hub中每个port的POWER置上
6.如果RESET状态发生了变化，通过usb_clear_port_feature清除RESET改变的状态
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>717</x>
      <y>4528</y>
      <w>59</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;570.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>768</x>
      <y>4534</y>
      <w>27</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.通过usb_get_hub_status获取hub的状态
2.如果获取hub状态出错，直接报错
	如果成功：
		1.如果POWER状态发生了改变，通过usb_clear_hub_feature
		将其POWER状态清掉
		2.如果其OVERCURRENT状态发生了改变，通过usb_clear_hub_feature
		将其OVERCURRENT状态，并通过usb_hub_power_on将hub中每个port的POWER置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>738</x>
      <y>4561</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_port_connect_change</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>748</x>
      <y>4557</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>734</x>
      <y>4568</y>
      <w>34</w>
      <h>54</h>
    </coordinates>
    <panel_attributes>1.通过usb_clear_port_feature将CONNECTION改变的状态
	清除
2.如果该hub当前端口有子设备（hub-&gt;children[port]）
	通过usb_disconnect将子设备断开
注：1.如果连接状态从无到有，children不可能存在，如果存在
		只有可能是之前没被清除，所以现在将其断开，之后再申请
	2.如果连接状态从有到无，需要将usb设备断开
3.如果设备现在断开了（连接状态是从有到无）
	1.如果此时端口是ENABLE的，通过usb_hub_port_disable
		将hub的该端口禁止
	2.直接return
4.（现在连接状态一定是从无到有）申请tempstr（存储之前的port路径）
	和portstr（存储总的port路径）
5.可以尝试两次去初始化port
	1.通过usb_alloc_dev申请usb_dev,parent是hub
		hub-&gt;children[port] = dev
	2.通过usb_hub_port_reset将该port reset
	3.通过usb_connect申请dev-&gt;devnum
	4.找到当前port从根集中器到当前port的port路径，存储到portstr
		并打印
	5.通过usb_new_device
		1.将dev的地址设置为dev-&gt;devnum
		2.获取设备的设备描述块和配置描述块（包括接口和endpoint）存放在内存中
		3.将configuration默认设置为0号描述符
		4.如果相应的usb驱动已经安装，会通过usb_find_drivers去初始化设备
			否则会在后续安装usb驱动的时候初始化
	6.如果usb_new_device出错了，先通过usb_free_dev将usb_dev释放，
		然后再去尝试初始化port
		如果usb_new_device成功了，将之前申请的tempstr和
		portstr释放，并返回
	7.如果两次尝试初始化都失败了：
		hub-&gt;children[port] = NULL;
		usb_hub_port_disable(hub, port)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>748</x>
      <y>4564</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>752</x>
      <y>4625</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_port_disable</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>752</x>
      <y>4621</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>753</x>
      <y>4631</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_clear_port_feature
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>761</x>
      <y>4628</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
清除port的enable状态</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>728</x>
      <y>4621</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>723</x>
      <y>4626</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_disconnect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>790</x>
      <y>4625</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_port_reset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>760</x>
      <y>4621</y>
      <w>39</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>696</x>
      <y>4629</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
清除actconfig中的所有interface</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>677</x>
      <y>4637</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>driver-&gt;disconnect
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>683</x>
      <y>4633</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>692</x>
      <y>4637</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_driver_release_interface</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>696</x>
      <y>4633</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>676</x>
      <y>4644</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hub_disconnect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>690</x>
      <y>4644</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>iface-&gt;driver = NULL;
iface-&gt;private_data = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>699</x>
      <y>4640</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>681</x>
      <y>4640</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
hub_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>663</x>
      <y>4651</y>
      <w>31</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.将hub从链表中删除，并初始化
	//从khubd的等待链表hub_event_list中删除
	list_del(&amp;hub-&gt;event_list);
	INIT_LIST_HEAD(&amp;hub-&gt;event_list);
	//从所有hub的管理链表hub_list中删除
	list_del(&amp;hub-&gt;hub_list);
	INIT_LIST_HEAD(&amp;hub-&gt;hub_list);
2.如果hub-&gt;urb存在：
	usb_unlink_urb(hub-&gt;urb);-&gt; urb-&gt;dev-&gt;bus-&gt;op-&gt;unlink_urb
	usb_free_urb(hub-&gt;urb);
	hub-&gt;urb = NULL;
3.如果设备描述块hub-&gt;descriptor存在，将其释放：
	kfree(hub-&gt;descriptor);
	hub-&gt;descriptor = NULL
4.释放hub:
	kfree(hub)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>680</x>
      <y>4647</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>706</x>
      <y>4629</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
递归释放掉usb_dev的所有子设备
dev-&gt;children（最多只有USB_MAXCHILDREN个）</panel_attributes>
    <additional_attributes>220.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>711</x>
      <y>4635</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_disconnect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>724</x>
      <y>4635</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>call_policy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>727</x>
      <y>4629</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
热插拔相关</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>737</x>
      <y>4635</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes> //将devnum在devicemap中清除
clear_bit(dev-&gt;devnum, &amp;dev-&gt;bus-&gt;devmap.devicemap);
usbdevfs_remove_device(dev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>725</x>
      <y>4629</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果设备号dev-&gt;devnum存在</panel_attributes>
    <additional_attributes>30.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>749</x>
      <y>4636</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_free_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>727</x>
      <y>4629</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>739</x>
      <y>4643</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果dev-&gt;refcnt递减至0，需要彻底释放dev：
	1.dev-&gt;bus-&gt;op-&gt;deallocate(dev)
	2.通过usb_destroy_configuration
		1.释放掉原始数据的rawdescriptors（指针数组，指针
		指向原始数据）
		2.释放掉从原始数据中提取的管理结构，config--interface--endpoint
	3.释放掉dev：
		kfree(dev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>755</x>
      <y>4639</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>783</x>
      <y>4632</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.设置port的reset状态
2.通过usb_hub_port_wait_reset检测port是否在delay时间
	内reset
3.如果在delay时间reset，清掉reset改变的状态信息，并return 0
	如果在delay时间内没检测到reset，将delay时间换成HUB_LONG_RESET_TIME
	之后，再去将尝试将port reset
4.如果两次都没reset，return -1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>797</x>
      <y>4628</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>798</x>
      <y>4643</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>788</x>
      <y>4647</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_hub_port_wait_reset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>779</x>
      <y>4654</y>
      <w>42</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.等待delay的时间
2.通过usb_get_port_status获取port的状态
3.如果port的CONNECTION从有到无，返回-1
4.如果完成了reset（RESET状态没有），并且
	ENABLE置上时：
	1.dev-&gt;slow在LOW_SPEED置上时，是1，否则为0
	2.return 0
5.如果检测时间超过了2*HUB_SHORT_RESET_TIME，就换算
	成HUB_LONG_RESET_TIME继续检测是否reset
6.等到HUB_RESET_TIMEOUT时间就return -1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>797</x>
      <y>4650</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>868</x>
      <y>4499</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_scanner_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>873</x>
      <y>4502</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
scanner_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>869</x>
      <y>4506</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_register
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>874</x>
      <y>4509</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.()</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>869</x>
      <y>4514</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>probe_scanner</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>831</x>
      <y>4523</y>
      <w>30</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.下面两种情况的其中之一满足，就是有效的dev（valid_device）：
	1.遍历scanner_device_ids数组，查看其中是否有和
	设备描述块的idVendor和idProduct一致的项
	2.用户定义的vendor和product和设备描述块中的相同
2.配置描述块的数量（bNumConfigurations）和接口的数量
	（bNumInterfaces）都要是1
3.接口中endpoint的数量（bNumEndpoints）不是2就是3个
	如果是2个，就分别是成块传输的输入和输出
	如果是3个，就分别是成块传输的输入，输出和中断传输

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>843</x>
      <y>4517</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>866</x>
      <y>4523</y>
      <w>36</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.找到p_scn_table中空闲的scn_usb_data指针位
注：minor的高4位指示的是usb_driver的位置
	后4位指示的是特定的usb设备的位置(就是这里在p_scn_table中的位置)
2.申请scn_usb_data，并初始化为0
	scn = kmalloc
	memset (scn, 0,
3.如果有中断传输的endpoint（have_intr），设置urb
	scn-&gt;scn_irq-&gt;dev=dev;\
	scn-&gt;scn_irq-&gt;pipe=usb_rcvintpipe(dev, have_intr);\
	scn-&gt;scn_irq-&gt;transfer_buffer=&amp;scn-&gt;button;\
	scn-&gt;scn_irq-&gt;transfer_buffer_length=1;\
	scn-&gt;scn_irq-&gt;complete=irq_scanner;\
	scn-&gt;scn_irq-&gt;context=scn;\
	scn-&gt;scn_irq-&gt;interval=250;\
	scn-&gt;scn_irq-&gt;start_frame=-1;\
4.为scanner的ouput buffer和input buffer申请内存
	scn-&gt;obuf =kmalloc(OBUF_SIZE
	scn-&gt;ibuf = kmalloc(IBUF_SIZE
5.初始化scanner：
	//分别指示成块传输的输入，成块传输的输出，中断传输的endpoint号
	scn-&gt;bulk_in_ep = have_bulk_in;
	scn-&gt;bulk_out_ep = have_bulk_out;
	scn-&gt;intr_ep = have_intr;
	scn-&gt;present = 1;
	scn-&gt;scn_dev = dev;
	//在p_scn_table中的位置
	scn-&gt;scn_minor = scn_minor;
	scn-&gt;isopen = 0;
	init_MUTEX(&amp;(scn-&gt;gen_lock))
	p_scn_table[scn_minor] = scn
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>874</x>
      <y>4517</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>553</x>
      <y>4715</y>
      <w>23</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>dr = kmalloc(sizeof(devrequest)
 //8位，最高位-方向，5~6--寄存器类型，是否是标准的，0~4--操作的对象
dr-&gt;requesttype = requesttype;
 //操作的类型
dr-&gt;request = request;
 //参数
dr-&gt;value = cpu_to_le16p(&amp;value);
 //设备/接口/endpoint具体的单元（“设备”的缓冲区地址寄存器）
dr-&gt;index = cpu_to_le16p(&amp;index);
	//读写缓冲区大小
dr-&gt;length = cpu_to_le16p(&amp;size)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>563</x>
      <y>4711</y>
      <w>54</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请devrequest，并初始化</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>607</x>
      <y>4716</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_internal_control_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>632</x>
      <y>4715</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kfree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>614</x>
      <y>4711</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放devrequest</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>614</x>
      <y>4711</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>578</x>
      <y>4723</y>
      <w>23</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>urb = usb_alloc_urb(0)
spin_lock_init(&amp;urb-&gt;lock);\
urb-&gt;dev=usb_dev;\
urb-&gt;pipe=pipe;\
urb-&gt;setup_packet=devrequest;\
urb-&gt;transfer_buffer=data;\
urb-&gt;transfer_buffer_length=len;\
urb-&gt;complete=usb_api_blocking_completion;\
urb-&gt;context=0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>586</x>
      <y>4719</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请urb（reference），并初始化CONTROL_URB</panel_attributes>
    <additional_attributes>300.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>609</x>
      <y>4727</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_start_wait_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>615</x>
      <y>4719</y>
      <w>5</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>648</x>
      <y>4721</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果出错，返回错误信息
	否则返回buffer实际长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>615</x>
      <y>4719</y>
      <w>40</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>268</x>
      <y>4745</y>
      <w>27</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.声明局部变量wait，wqh（等待队列）
2.
	//将等待队列放在awd中，
	awd.wakeup = &amp;wqh;
	init_waitqueue_head(&amp;wqh); 	
	current-&gt;state = TASK_INTERRUPTIBLE;
	//将wait放到等待队列中
	add_wait_queue(&amp;wqh, &amp;wait);
	//之后在中断时可通过urb找到其等待队列
	urb-&gt;context = &amp;awd
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>277</x>
      <y>4730</y>
      <w>342</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>3400.0;10.0;3220.0;90.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>310</x>
      <y>4746</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_submit_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>317</x>
      <y>4730</y>
      <w>303</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>3010.0;10.0;2840.0;100.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>304</x>
      <y>4752</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>urb-&gt;dev-&gt;bus-&gt;op-&gt;submit_urb
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>315</x>
      <y>4749</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>316</x>
      <y>4755</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
alloc_uhci-&gt;uhci_device_operations</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>311</x>
      <y>4758</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_submit_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>261</x>
      <y>4764</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.urb要存在
2.urb-&gt;dev，urb-&gt;dev-&gt;bus，
	urb-&gt;dev-&gt;bus-&gt;hcpriv（存储的是uhci）
	都要存在
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>270</x>
      <y>4761</y>
      <w>49</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>287</x>
      <y>4761</y>
      <w>33</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果是根集中器
(usb_pipedevice(urb-&gt;pipe) == uhci-&gt;rh.devnum)
就不需要usb总线参与，
直接操作root_hub的
寄存器</panel_attributes>
    <additional_attributes>300.0;10.0;20.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>282</x>
      <y>4771</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rh_submit_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>316</x>
      <y>4761</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不是根集中器</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>310</x>
      <y>4765</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果能找到dev和pipe相同的urb
并且不是需要串行化成块传输（USB_QUEUE_BULK）
返回ENXIO</panel_attributes>
    <additional_attributes>180.0;10.0;160.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>320</x>
      <y>4768</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_find_urb_ep</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>307</x>
      <y>4774</y>
      <w>38</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.取pipe的最高2位，查看是不是等时传输（usb_pipeisoc）
	如果是，返回NULL
	注：等时传输等时传输中有时间戳信息，不能造成交互夹杂（猜测）。
		等时传输有1个交互，每个交互中有2个信包（传令，数据，没有握手）。
2.通过nested_lock给urblist_lock上锁。这个上锁机制是：如果是同进程给其
	上锁，只是增加锁的count；如果是不同进程则是通过spin_lock自旋
3.遍历uhci-&gt;urb_list链表，如果传进来的urb和链表中的urb的dev和pipe
	相同，则在nested_unlock解锁之后，返回链表中的urb
4.否则在nested_unlock解锁之后，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>325</x>
      <y>4771</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>335</x>
      <y>4768</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_inc_dev_use
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>326</x>
      <y>4765</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
增加urb-&gt;dev-&gt;refcnt计数</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>352</x>
      <y>4768</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_alloc_urb_priv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>327</x>
      <y>4765</y>
      <w>34</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>348</x>
      <y>4774</y>
      <w>24</w>
      <h>17</h>
    </coordinates>
    <panel_attributes> //申请urb_priv，并初始化
urbp = kmem_cache_alloc(uhci_up_cachep
memset((void *)urbp, 0
urbp-&gt;inserttime = jiffies;
urbp-&gt;urb = urb;

INIT_LIST_HEAD(&amp;urbp-&gt;list);
INIT_LIST_HEAD(&amp;urbp-&gt;urb_queue_list);

urb-&gt;hcpriv = urbp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>359</x>
      <y>4771</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>326</x>
      <y>4764</y>
      <w>75</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
usb_pipetype(urb-&gt;pipe)
查看传输的类型</panel_attributes>
    <additional_attributes>10.0;10.0;730.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>191</x>
      <y>4806</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_submit_control</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>197</x>
      <y>4767</y>
      <w>204</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_CONTROL</panel_attributes>
    <additional_attributes>2020.0;10.0;1770.0;270.0;10.0;390.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>176</x>
      <y>4814</y>
      <w>35</w>
      <h>21</h>
    </coordinates>
    <panel_attributes> //0~7位定义交互类型（setup）,8~18定义为dev endpoint
 //后面21~31定义信包的长度
destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | USB_PID_SETUP
 //26位表示是否为低速设备，23位 1表示等待执行（TD_CTRL_ACTIVE），0表示已经执行
 //27位表示允许出错的次数（3）
status = (urb-&gt;pipe &amp; TD_CTRL_LS) | TD_CTRL_ACTIVE | (3 &lt;&lt; 27)

td = uhci_alloc_td(urb-&gt;dev)
uhci_add_td_to_urb(urb, td);
 //(7 &lt;&lt; 21)表示信包的长度是（7+1）=8字节
uhci_fill_td(td, status, destination | (7 &lt;&lt; 21),
	virt_to_bus(urb-&gt;setup_packet));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>185</x>
      <y>4809</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备setup交互</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>151</x>
      <y>4837</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_alloc_td</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>156</x>
      <y>4834</y>
      <w>26</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>143</x>
      <y>4843</y>
      <w>28</w>
      <h>24</h>
    </coordinates>
    <panel_attributes> //申请uhci_td
td = kmem_cache_alloc(uhci_td_cachep
 //bit0是1表示链接终结，bit1是1表示队列头
 //bit2是1表示纵向执行，0表示横向执行
td-&gt;link = UHCI_PTR_TERM;
td-&gt;buffer = 0;

td-&gt;frameptr = NULL;
td-&gt;nexttd = td-&gt;prevtd = NULL;
td-&gt;dev = dev;
INIT_LIST_HEAD(&amp;td-&gt;list);

 //增加dev-&gt;refcnt计数
usb_inc_dev_use(dev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>156</x>
      <y>4840</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>175</x>
      <y>4839</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_add_td_to_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>184</x>
      <y>4833</y>
      <w>26</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这是将td挂入到链表urb_priv中，
这里是虚拟地址，以便cpu遍历
为了usb DMA设备遍历，还有一个
物理地址链表头uhci_qh
</panel_attributes>
    <additional_attributes>40.0;20.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>173</x>
      <y>4847</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>td-&gt;urb = urb;
 //将td挂入到urb-&gt;hcpriv指向的urb_priv链表中
list_add_tail(&amp;td-&gt;list, &amp;urbp-&gt;list);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>182</x>
      <y>4842</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>202</x>
      <y>4839</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_fill_td</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>197</x>
      <y>4834</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>202</x>
      <y>4846</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>td-&gt;status = status;
 //destination
td-&gt;info = info;
 //setup_packet
td-&gt;buffer = buffer;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>208</x>
      <y>4842</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>196</x>
      <y>4809</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备数据交互</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>215</x>
      <y>4814</y>
      <w>30</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.针对数据交互，更新destination和status
 //将setup清除，看其pipe的输入输出特性，看是USB_PID_IN还是USB_PID_OUT
destination ^= (USB_PID_SETUP ^ usb_packetid(urb-&gt;pipe));
 //如果urb-&gt;transfer_flags中USB_DISABLE_SPD（short packet dected）没被置上
status |= TD_CTRL_SPD
2.遍历传输数据的长度urb-&gt;transfer_buffer_length，单次交互最长信包长度是epmaxpacketout或者epmaxpacketin
	1.申请td=uhci_alloc_td(urb-&gt;dev)
	2.data0和data1信包指示连续信包：
	destination ^= 1 &lt;&lt; TD_TOKEN_TOGGLE;
	3.将td加入到urb_priv链表中，并初始化
		uhci_add_td_to_urb(urb, td);
		//长度是pktsze，buffer是urb-&gt;transfer_buffer
		uhci_fill_td(td, status, destination | ((pktsze - 1) &lt;&lt; 21),
			virt_to_bus(data));
	4.更新长度和buffer，直到传输数据完成
		data += pktsze;
		len -= pktsze;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>196</x>
      <y>4809</y>
      <w>66</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备状态交互</panel_attributes>
    <additional_attributes>10.0;10.0;640.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>247</x>
      <y>4814</y>
      <w>29</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.申请td = uhci_alloc_td(urb-&gt;dev);
2.清除交互的属性（destination &amp;= ~TD_PID;）
	如果数据交互是输出，或者不要求传输数据
	destination |= USB_PID_IN
	否则为：
	destination |= 1 &lt;&lt; TD_TOKEN_TOGGLE;
3.清除status中的short packet dected
	status &amp;= ~TD_CTRL_SPD
4.加入到urb_priv链表中，并初始化
	uhci_add_td_to_urb(urb, td);
	//TD_CTRL_IOC表示交互完成之后向cpu发送中断
	uhci_fill_td(td, status | TD_CTRL_IOC,
		destination | (UHCI_NULL_DATA_SIZE &lt;&lt; 21), 0)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>197</x>
      <y>4809</y>
      <w>128</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将td挂入到usb总线的调度队列</panel_attributes>
    <additional_attributes>10.0;10.0;1260.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>307</x>
      <y>4813</y>
      <w>38</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.通过uhci_alloc_qh申请队列头uhci_qh
2.通过uhci_insert_tds_in_qh将urbp中的td挂入到qh的链表中
	如果是低速设备(TD_CTRL_LS)，深度优先，纵向连接,通过uhci_insert_qh将其插入到skel_ls_control_qh中
	如果是高速设备，宽度优先，横向连接，通过uhci_insert_qh将其插入到skel_hs_control_qh中，并通过uhci_inc_fsbr
		使term_qh的link指向hs_qh，使总线的空闲的时候能继续执行hs_qh后面的qh
3.将qh和urbp关联，并将urb挂入到uhci链表中
	urbp-&gt;qh = qh;
	//将urb挂入到uhci-&gt;urb_list
	uhci_add_urb_list(uhci, urb);
	//表示正在处理这个urb，需要在中断中将其complete
	return -EINPROGRESS
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>276</x>
      <y>4835</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_alloc_qh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>264</x>
      <y>4841</y>
      <w>25</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>qh = kmem_cache_alloc(uhci_qh_cachep
qh-&gt;element = UHCI_PTR_TERM;
qh-&gt;link = UHCI_PTR_TERM;

qh-&gt;dev = dev;
qh-&gt;prevqh = qh-&gt;nextqh = NULL;

INIT_LIST_HEAD(&amp;qh-&gt;remove_list);

usb_inc_dev_use(dev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>272</x>
      <y>4838</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请uhci_qh，并初始化</panel_attributes>
    <additional_attributes>100.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>295</x>
      <y>4835</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_insert_tds_in_qh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>291</x>
      <y>4841</y>
      <w>36</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.遍历urb-&gt;hcpriv（urbp）链表
2.如果链表是空（head == tmp）直接返回
3.将qh-&gt;element指向链表中的第一个td
	如果是低速设备将纵向连接（UHCI_PTR_DEPTH）置上
4.然后遍历链表中剩下的td用td.link指针连接到第一个td的
	链表中（qh-&gt;element）
5.最后一个td指向UHCI_PTR_TERM（表示连接的终结）
注：1.qh.element和td.link指向的都是物理地址，后4位
		是对齐的，用于指示
	2.qh-&gt;element指向一个urb的td队列，纵向连接
	 qh-&gt;link用于队列之间的连接，横向连接
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>303</x>
      <y>4838</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>332</x>
      <y>4835</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_insert_qh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>329</x>
      <y>4841</y>
      <w>31</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.将申请的qh连接到规定的qh链表中（头插）（虚拟地址连接）
	qh-&gt;nextqh = skelqh-&gt;nextqh;
	qh-&gt;prevqh = skelqh;
	if (skelqh-&gt;nextqh)
		skelqh-&gt;nextqh-&gt;prevqh = qh;
	skelqh-&gt;nextqh = qh;
2.将申请的qh插入到规定qh的link链表中（物理地址连接）
	qh-&gt;link = skelqh-&gt;link;
	skelqh-&gt;link = virt_to_bus(qh) | UHCI_PTR_QH;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>338</x>
      <y>4838</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>364</x>
      <y>4835</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_inc_fsbr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>362</x>
      <y>4841</y>
      <w>34</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果urb-&gt;transfer_flags的USB_NO_FSBR
	没置上，且urbp-&gt;fsbr为0时：
	urbp-&gt;fsbr=1
	如果uhci-&gt;fsbr为0（注意这里是uhci）
	uhci-&gt;fsbr++
	//term是终结的qh，现在将其指向hs_qh，在总线空闲的时候，
	//会返回到hs_qh继续执行
	uhci-&gt;skel_term_qh.link = virt_to_bus(&amp;uhci-&gt;skel_hs_control_qh) | UHCI_PTR_QH
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>368</x>
      <y>4838</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>281</x>
      <y>4831</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>303</x>
      <y>4831</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>313</x>
      <y>4831</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>314</x>
      <y>4831</y>
      <w>56</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;540.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>316</x>
      <y>4761</y>
      <w>359</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;3570.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>655</x>
      <y>4766</y>
      <w>38</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.记录提交urb之后的返回状态
	urb-&gt;status = ret
2.如果是返回状态是-EINPROGRESS，说明urb正在被处理，
	需要中断之后提醒uhci结束，所以ret=0
	如果是其他状态，说明urb已经被处理完，或者产生一些错误
	需要将提交的urb摧毁(uhci_unlink_generic)，并
	递减对dev.rfecnt的引用 
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>645</x>
      <y>4782</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_unlink_generic</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>686</x>
      <y>4783</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_dec_dev_use</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>652</x>
      <y>4777</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>667</x>
      <y>4777</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>688</x>
      <y>4790</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_free_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>693</x>
      <y>4786</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
reference</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>616</x>
      <y>4788</y>
      <w>13</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.urb_priv要存在
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>621</x>
      <y>4785</y>
      <w>34</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>631</x>
      <y>4788</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_dec_fsbr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>637</x>
      <y>4785</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>617</x>
      <y>4793</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果urb-&gt;transfer_flags的USB_NO_FSBR
	没置上，且urbp-&gt;fsbr为1时：
	urbp-&gt;fsbr=0
	先递减uhci-&gt;fsbr，如果uhci-&gt;fsbr为0（注意这里是uhci）
	//term是终结的qh，
	uhci-&gt;skel_term_qh.link =UHCI_PTR_TERM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>631</x>
      <y>4791</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>645</x>
      <y>4789</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_remove_urb_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>650</x>
      <y>4785</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过nested_lock锁住
uhci-&gt;urblist_lock</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>644</x>
      <y>4794</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.将urb.urb_list在uhci-&gt;urb_list
	链表中，通过list_del将urb从链表中
	删除，并初始化uhci-&gt;urb_list
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>648</x>
      <y>4792</y>
      <w>6</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>668</x>
      <y>4789</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_remove_qh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>652</x>
      <y>4785</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果urbp-&gt;qh存在</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>659</x>
      <y>4796</y>
      <w>20</w>
      <h>17</h>
    </coordinates>
    <panel_attributes> //将qh从虚拟地址链表和物理地址链表中断开
if (qh-&gt;prevqh) {
	qh-&gt;prevqh-&gt;nextqh = qh-&gt;nextqh;
	qh-&gt;prevqh-&gt;link = qh-&gt;link;
}
if (qh-&gt;nextqh)
	qh-&gt;nextqh-&gt;prevqh = qh-&gt;prevqh;
 //初始化qh链表指针
qh-&gt;prevqh = qh-&gt;nextqh = NULL;
qh-&gt;element = qh-&gt;link = UHCI_PTR_TERM;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>665</x>
      <y>4792</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>680</x>
      <y>4796</y>
      <w>21</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果qh在skelqh队列中(delay)	
	1.如果uhci-&gt;qh_remove_list为空
		通过uhci_set_next_interrupt将
		skel最后一个td(uhci-&gt;skel_term_td.status)
		的TD_CTRL_IOC置上，使其结束之后
		向cpu发送中断，让cpu将qh_remove_list
		链表中的qh回收
	2.通过list_add将qh.remove_list加入到
		qh_remove_list链表中（有可能usb控制器暂时
		还没出这个qh，需要放在remove_list中冷却）
2.如果不在skelqh队列中，通过uhci_free_qh
	将qh释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>674</x>
      <y>4792</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>684</x>
      <y>4817</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_free_qh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>690</x>
      <y>4814</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>680</x>
      <y>4823</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.如果qh-&gt;dev存在，通过usb_dec_dev_use递减其rfecnt
2.将qh释放给uhci_qh_cachep
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>689</x>
      <y>4820</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>590</x>
      <y>4741</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //释放urb
usb_free_urb(urb);
current-&gt;state = TASK_RUNNING;
 //将wait从等待队列wqh中删除
remove_wait_queue(&amp;wqh, &amp;wait);
 //返回出错信息
return status;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>598</x>
      <y>4730</y>
      <w>26</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果出错（status不为0）
-EINPROGRESS已经将status转化成0
并将其存在urb-&gt;status中</panel_attributes>
    <additional_attributes>200.0;10.0;50.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>619</x>
      <y>4734</y>
      <w>50</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.如果原始信息urb-&gt;status显示是EINPROGRESS，（表示urb正在被处理，需要等待）
	如果定义了timeout，通过schedule_timeout使进程休眠，到timeout时间唤醒（或者中间有其他进程唤醒）
	status和timeout记录剩余的时间
	如果原来正常返回，表示urb已经处理完，status=1
2.将进程的状态设置为running，并将wait从等待队列中删除
3.如果status为0，表示timeout时间到了，进程才被唤醒：
	//如果正常处理完成，usb将link element等物理地址清除
	//但是timeout需要通过unlink将其物理地址链表清除
	usb_unlink_urb(urb);  // remove urb safely
	status = -ETIMEDOUT;
	如果因为被处理完而被唤醒，将其原始状态返回
	status = urb-&gt;status
4.如果要求返回actual_length
	*actual_length = urb-&gt;actual_length
5.通过usb_free_urb释放urb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>617</x>
      <y>4730</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>676</x>
      <y>4740</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_unlink_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>668</x>
      <y>4739</y>
      <w>13</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>671</x>
      <y>4746</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>urb-&gt;dev-&gt;bus-&gt;op-&gt;unlink_urb
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>682</x>
      <y>4743</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>682</x>
      <y>4749</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
uhci_device_operations</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>676</x>
      <y>4752</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_unlink_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>397</x>
      <y>4767</y>
      <w>11</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_BULK</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;260.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>392</x>
      <y>4793</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_submit_bulk</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>308</x>
      <y>4801</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.要读的长度len &lt; 0，返回EINVAL
2.如果是低速设备（TD_CTRL_LS），返回EINVAL
	（因为成块传输的数据量大，可能没办法通过深度优先
	在1ms内将数据传输完成）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>334</x>
      <y>4796</y>
      <w>66</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>640.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>345</x>
      <y>4801</y>
      <w>39</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.destination：设备号+方向
	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe)
2.status：td传输标记+出错次数+SPD(short packer dectected)
	status = TD_CTRL_ACTIVE | (3 &lt;&lt; TD_CTRL_C_ERR_SHIFT)
	如果urb的USB_DISABLE_SPD没置上，
	status |= TD_CTRL_SPD
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>351</x>
      <y>4796</y>
      <w>50</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备数据</panel_attributes>
    <additional_attributes>480.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>387</x>
      <y>4802</y>
      <w>27</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.循环准备len长度的数据交互，每个交互的最大长度
	是maxsze
	1.利用uhci_alloc_td申请交互td
	2.通过uhci_add_td_to_urb将td加入到链表urbp-&gt;list中
	3.利用uhci_fill_td填充td：
	info=destination | ((pktsze - 1) &lt;&lt; 21) |TD_TOKEN_TOGGLE(事先有翻转)
	buffer=virt_to_bus(data)
	4.更新buffer和长度
	data += pktsze;
	len -= maxsze;
	5.如果是最后一个td（len &lt;= 0）
	td-&gt;status |= TD_CTRL_IOC
	6.通过usb_dotoggle将urb-&gt;dev-&gt;toggle[out]对应的endpoint中翻转
	（之后用于TD_TOKEN_TOGGLE位）
注：利用do..while，所以即使len=0，还是有一个数据td
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>391</x>
      <y>4796</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备数据交互</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>418</x>
      <y>4802</y>
      <w>42</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.利用uhci_alloc_qh申请qh，并赋值给urbp
	urbp-&gt;qh = qh
2.通过uhci_insert_tds_in_qh将urbp.list中的
	td通过物理指针element link链接在qh中
3.如果该传输urb被标记为USB_QUEUE_BULK，
	并且在uhci中有和其dev和endpoint相同的
	eurb，将新添加进去的urbp标记成不是队列头
	（urbp-&gt;queued = 1），并通过uhci_append_queued_urb
	将其加入到队列中
	如果上述情况不满足，通过uhci_insert_qh将其加入到skel_bulk_qh
	后
4.通过uhci_add_urb_list将urb加入到uhci-&gt;urb_list链表中
5.通过uhci_inc_fsbr查看该urb是否需要usb总线空闲时间，如果需要
	递增uhci-&gt;fsbr，并将term_qh链接到hs_qh
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>397</x>
      <y>4796</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
准备qh</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>431</x>
      <y>4829</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_append_queued_urb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>439</x>
      <y>4825</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>422</x>
      <y>4836</y>
      <w>37</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.找到队列的队列头furbp：
	1.如果eurbp-&gt;queued=0，那么eurbp就是队列头
	2.如果queued=1，那么就顺着eurbp-&gt;urb_queue_list链表
	查找，直到找到turbp-&gt;queued为0的urbp退出（或者整个链表查找完，没找到也退出）
	注：这里tmp = tmp-&gt;next位置应该是个bug
2.通过furbp-&gt;urb_queue_list.prev找到最后一个urbp（lurbp）
3.找到lurbp的最后一个td：
	ltd= list_entry(lurbp-&gt;list.prev, struct uhci_td, list)
4.找到要插入队列urbp的第一个td：
	td = list_entry(urbp-&gt;list.next, struct uhci_td, list)
5.将ltd链接到td
	ltd-&gt;link = virt_to_bus(td)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>439</x>
      <y>4832</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>398</x>
      <y>4767</y>
      <w>93</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_INTERRUPT</panel_attributes>
    <additional_attributes>10.0;10.0;910.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>472</x>
      <y>4788</y>
      <w>38</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果urb没被分配带宽urb-&gt;bandwidth == 0
	1.通过usb_check_bandwidth计算该交互需要的带宽
	2.如果返回错误（小于0），返回错误信息
		如果bustime正确返回，通过uhci_submit_interrupt将
		urb提交，并通过usb_claim_bandwidth将bustime申请带宽
2.如果urb已经被分配带宽，直接通过uhci_submit_interrupt将urb提交
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>465</x>
      <y>4803</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_check_bandwidth</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>471</x>
      <y>4798</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>462</x>
      <y>4810</y>
      <w>33</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.通过usb_calc_bus_time计算该传输需要的bustime
	主要和usb_maxpacket相关。但是在计算时会考虑
	是否是低速设备，传输的方向、是否是等时传输
2.如果是等时传输，因为会将等时传输的包放在不同的框架中
	所以bustime/=number_of_packets（每个信包构成一个交互）
	如果是中断传输，就是之前计算的bustime
3.计算如果加入该urb之后的带宽：
	new_alloc=dev-&gt;bus-&gt;bandwidth_allocated+ (int)bustime
4.如果没有带宽检查，直接返回bustime；如果有，在总体带宽大于框架
	时间的90%时，会报USB_ST_BANDWIDTH_ERROR，其他情况，返回bustime
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>471</x>
      <y>4806</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>522</x>
      <y>4804</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>usb_claim_bandwidth</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>499</x>
      <y>4798</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>536</x>
      <y>4811</y>
      <w>28</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>dev-&gt;bus-&gt;bandwidth_allocated += bustime
 //如果是等时传输
dev-&gt;bus-&gt;bandwidth_isoc_reqs++
 //如果是中断传输
dev-&gt;bus-&gt;bandwidth_int_reqs++

urb-&gt;bandwidth = bustime
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>530</x>
      <y>4807</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>499</x>
      <y>4806</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_submit_interrupt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>493</x>
      <y>4798</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>497</x>
      <y>4813</y>
      <w>33</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.要发送的长度transfer_buffer_length，
	不能大于usb_maxpacket，因为中断传输
	只有一个交互
2.准备数据
	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe);
	status = (urb-&gt;pipe &amp; TD_CTRL_LS) | TD_CTRL_ACTIVE | TD_CTRL_IOC;
3.准备td：
	td = uhci_alloc_td
	//准备TD_TOKEN_TOGGLE位，和长度
	destination |= usb_gettoggle&lt;&lt; TD_TOKEN_TOGGLE | ((urb-&gt;transfer_buffer_length - 1) &lt;&lt; 21)
	//翻转(dev)-&gt;toggle[out]
	usb_dotoggle
4.建立td的关系
	//将td加入到urbp.list
	uhci_add_td_to_urb(urb, td);
	uhci_fill_td(td, status, destination,
		virt_to_bus(urb-&gt;transfer_buffer));
	//将td的物理链表挂入到框架对应的td下
	uhci_insert_td(uhci, &amp;uhci-&gt;skeltd[__interval_to_skel(urb-&gt;interval)], td);
	//将urb挂入到uhci-&gt;urb_list链表中
	uhci_add_urb_list(uhci, urb)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>507</x>
      <y>4809</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>506</x>
      <y>4850</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__interval_to_skel</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>513</x>
      <y>4846</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>505</x>
      <y>4856</y>
      <w>16</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>interval		实际间隔		index
0~1			int1			0
2~3			int2			1
4~7			int4			2
8~15			int8			3
16~31			int16			4
32~63			int32			5
64~127		int64			6
128~255		int128		7
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>512</x>
      <y>4853</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>398</x>
      <y>4767</y>
      <w>183</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PIPE_ISOCHRONOUS</panel_attributes>
    <additional_attributes>10.0;10.0;1810.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>567</x>
      <y>4788</y>
      <w>37</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果传输urb之前没被分配带宽（urb-&gt;bandwidth == 0）
	1.如果需要发的信包的数量（number_of_packets）小于0，返回EINVAL
	2.通过usb_check_bandwidth为等时交互分配bustime，如果出现错误，直接返回
	3.通过uhci_submit_isochronous将urb提交
	4.如果urb在框架内执行，通过usb_claim_bandwidth将urb的带宽加在总线上
2.如果之前被分配过带宽，直接使用uhci_submit_isochronous将urb提交
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>577</x>
      <y>4801</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_submit_isochronous</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>585</x>
      <y>4798</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>569</x>
      <y>4807</y>
      <w>39</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.准备数据：
	//激活td，等时传输
	status = TD_CTRL_ACTIVE | TD_CTRL_IOS;
	//pipe 方向
	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe)
2.通过isochronous_find_start寻找等时传输的首个框架
3.要从urb-&gt;start_frame，分配number_of_packets依次到每个框架内：
	1.如果urb-&gt;iso_frame_desc[i].length为0，该框架内不分配
	2.如果该框架内需要分配交互，通过uhci_alloc_td申请td结构
	3.通过uhci_add_td_to_urb将td加入到urbp.list链表中
	4.通过uhci_fill_td填充td
		长度为urb-&gt;iso_frame_desc[i].length
		buffer为：urb-&gt;transfer_buffer + urb-&gt;iso_frame_desc[i].offset
	5.如果是最后一个td（i + 1 &gt;= urb-&gt;number_of_packets）：
		td-&gt;status |= TD_CTRL_IOC;
	6.通过uhci_insert_td_frame_list将td挂入到框架中
4.通过uhci_add_urb_list将urb挂入到uhci-&gt;urb_list中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>586</x>
      <y>4804</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>558</x>
      <y>4840</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>isochronous_find_start</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>565</x>
      <y>4835</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>541</x>
      <y>4847</y>
      <w>36</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.number_of_packets不能大于900
2.通过isochronous_find_limits查看是否有在框架内的urb
	的pipe和dev和此次交互相同，如果有，得到其结束的框架号
	并返回0；没有返回-1
3.如果要求尽快传输（transfer_flags &amp; USB_ISO_ASAP），
	如果2步返回-1，通过uhci_get_current_frame_number得到正在运行的框架号：
	urb-&gt;start_frame = (curframe + 10) % UHCI_NUMFRAMES;
	如果2步返回0：
	urb-&gt;start_frame = end
4.如果不要求尽快传输
	urb-&gt;start_frame %= UHCI_NUMFRAMES
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>558</x>
      <y>4843</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>550</x>
      <y>4869</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>isochronous_find_limits</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>539</x>
      <y>4876</y>
      <w>35</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.遍历uhci-&gt;urb_list链表，看其中有没有和现在要操作的传输
	相同的dev，pipe，并处于EINPROGRESS（不是当前操作的传输）
	start记录第一个u-&gt;start_frame
	last_urb记录最后一个传输
2.如果有相同的urb
	*end = (last_urb-&gt;start_frame + last_urb-&gt;number_of_packets) &amp; 1023;
	ret = 0;
	否则
	ret = -1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>557</x>
      <y>4865</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>556</x>
      <y>4872</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>591</x>
      <y>4840</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_insert_td_frame_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>583</x>
      <y>4835</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>589</x>
      <y>4843</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
加入到物理链表中</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>580</x>
      <y>4847</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes> //td为链表头，所以frameptr有值
td-&gt;frameptr = &amp;uhci-&gt;fl-&gt;frame[framenum];
td-&gt;link = uhci-&gt;fl-&gt;frame[framenum];
uhci-&gt;fl-&gt;frame[framenum] = virt_to_bus(td)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>595</x>
      <y>4843</y>
      <w>26</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果当前td不是该链表中的最后一个td
（不是term，或者没链接到qh）</panel_attributes>
    <additional_attributes>50.0;10.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>609</x>
      <y>4846</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //获取下一个td的虚拟地址
nexttd = (struct uhci_td *)uhci_ptr_to_virt(td-&gt;link);
 //虚拟链表连接
td-&gt;nexttd = nexttd;
nexttd-&gt;prevtd = td;
 //链表头已经发生转变，所以赋值为NULL
nexttd-&gt;frameptr = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>243</x>
      <y>4776</y>
      <w>47</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.如果是中断传输（PIPE_INTERRUPT）
	uhci-&gt;rh.urb = urb;
	uhci-&gt;rh.send = 1;
	uhci-&gt;rh.interval = urb-&gt;interval;
	rh_init_int_timer(urb)
	return 0
2.因为根集中器是和controller在一起，不需要通过总线usb总线访问，
	可以直接通过io地址读写相应的状态和数据.
	通过解析cmd（urb-&gt;setup_packet），数据存放在urb-&gt;transfer_buffer中，
	数据的预期长度是urb-&gt;transfer_buffer_length
3.处理完urb之后，更新actual_length,并执行urb-&gt;complete
	urb-&gt;actual_length = len;
	urb-&gt;status = stat;
	if (urb-&gt;complete)
		urb-&gt;complete(urb);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>274</x>
      <y>4774</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>232</x>
      <y>4782</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>226</x>
      <y>4784</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rh_init_int_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>205</x>
      <y>4790</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.赋值usb polling的间隔
	uhci-&gt;rh.interval = urb-&gt;interval
2.赋值timer，并添加：
	init_timer(&amp;uhci-&gt;rh.rh_int_timer);
	uhci-&gt;rh.rh_int_timer.function = rh_int_timer_do;
	uhci-&gt;rh.rh_int_timer.data = (unsigned long)urb;
	uhci-&gt;rh.rh_int_timer.expires = jiffies + (HZ * (urb-&gt;interval &lt; 30 ? 30 : urb-&gt;interval)) / 1000;
	add_timer(&amp;uhci-&gt;rh.rh_int_timer)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>225</x>
      <y>4787</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>159</x>
      <y>4799</y>
      <w>52</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>500.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>154</x>
      <y>4803</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rh_int_timer_do</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>130</x>
      <y>4810</y>
      <w>41</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.通过rh_send_irq获取port中USBPORTSC1寄存器的状态
	存储到urb-&gt;transfer_buffer中，并：
	urb-&gt;actual_length = len;
	urb-&gt;status = USB_ST_NOERROR;
	返回0
2.遍历uhci-&gt;urb_list中的urb
	1.如果urb要求做空闲时间回收（fsbr），但是却长期没得到执行
	（jiffies&lt;urbp-&gt;inserttime + IDLE_TIMEOUT）,通过
	uhci_fsbr_timeout断开其回收机制
	2.如果urb设置了timeout时间（u-&gt;timeout），并且已经timeout（jiffies&lt;u-&gt;timeout）
	将urb.transfer_flags的USB_ASYNC_UNLINK | USB_TIMEOUT_KILLED置上
	并且通过uhci_unlink_urb将urb的交互队列从框架中移除
3.	通过rh_init_int_timer重新将timer添加
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>156</x>
      <y>4806</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>128</x>
      <y>4835</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>uhci_fsbr_timeout</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>134</x>
      <y>4832</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>121</x>
      <y>4842</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过uhci_dec_fsbr将总线回收断开
2.urbp-&gt;fsbr_timeout = 1
3.遍历urbp-&gt;list中的td，将第一个TD_CTRL_ACTIVE
	的td中的TD_CTRL_IOC置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>130</x>
      <y>4838</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1101</x>
      <y>4490</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>amd7930_init/
init_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1101</x>
      <y>4499</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>amd7930_attach</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1106</x>
      <y>4493</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1097</x>
      <y>4508</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_sparcaudio_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1106</x>
      <y>4502</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
amd7930向上层模块sparcaudio注册
sparcaudio在sparcaudio_init中向内核注册
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1100</x>
      <y>4516</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1105</x>
      <y>4511</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1046</x>
      <y>4526</y>
      <w>59</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.节点名name不能为NULL
2.如果传递的ops为NULL,
	1.如果是S_ISBLK，返回blkdevs[major].bdops（并打印消息）
	2.如果是其他设备，返回NULL，打印错误
3.如果是S_ISDIR，返回NULL
4.S_ISLNK，返回NULL
5.如果是S_ISCHR，并且要求自动分配设备号，next_devnum_char不能大于MAX_DEVNUM
	如果不大于：
	major = next_devnum_char &gt;&gt; 8;
	minor = next_devnum_char &amp; 0xff;
	++next_devnum_char;
6.如果是S_ISBLK，并且要求自动分配设备号，next_devnum_block不能大于MAX_DEVNUM
	如果不大于：
	major = next_devnum_block &gt;&gt; 8;
	minor = next_devnum_block &amp; 0xff;
	++next_devnum_block;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1073</x>
      <y>4519</y>
      <w>34</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1109</x>
      <y>4527</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>search_for_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1098</x>
      <y>4519</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在devfs中找name，如果没找到就创建</panel_attributes>
    <additional_attributes>80.0;10.0;170.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1105</x>
      <y>4519</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果不是新创建的
!is_new</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1126</x>
      <y>4527</y>
      <w>34</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.一定要是S_ISCHR  S_ISBLK  S_ISREG其中一个
2.de-&gt;registered不能为true
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1161</x>
      <y>4526</y>
      <w>54</w>
      <h>52</h>
    </coordinates>
    <panel_attributes>1.de-&gt;registered = TRUE;
2.如果是S_ISCHR或者S_ISBLK
	de-&gt;u.fcb.u.device.major = major;
	de-&gt;u.fcb.u.device.minor = minor;
	如果是S_ISREG
	de-&gt;u.fcb.u.file.size = 0
3.如果是其他设备，返回NULL
4.de-&gt;info = info;
  de-&gt;mode = mode;
5.如果是指定current为owner（DEVFS_FL_CURRENT_OWNER）
	de-&gt;u.fcb.default_uid = current-&gt;uid;
	de-&gt;u.fcb.default_gid = current-&gt;gid;
	否则：
	de-&gt;u.fcb.default_uid = 0;
	de-&gt;u.fcb.default_gid = 0;
6. 
 //之前不是设置registered了吗？
	 de-&gt;registered = TRUE;
	 //设置ops
	 de-&gt;u.fcb.ops = ops;
 	de-&gt;u.fcb.auto_owner = (flags &amp; DEVFS_FL_AUTO_OWNER) ? TRUE : FALSE;
 	de-&gt;u.fcb.aopen_notify = (flags &amp; DEVFS_FL_AOPEN_NOTIFY) ? TRUE : FALSE;
7.DEVFS_FL_REMOVABLE：
	de-&gt;u.fcb.removable = TRUE;
	++de-&gt;parent-&gt;u.dir.num_removable;
8.
	de-&gt;u.fcb.open = FALSE;
    de-&gt;show_unreg = ( (boot_options &amp; OPTION_SHOW)
			|| (flags &amp; DEVFS_FL_SHOW_UNREG) ) ? TRUE : FALSE;
    de-&gt;hide = (flags &amp; DEVFS_FL_HIDE) ? TRUE : FALSE;
    de-&gt;no_persistence = (flags &amp; DEVFS_FL_NO_PERSISTENCE) ? TRUE : FALSE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1106</x>
      <y>4519</y>
      <w>83</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;810.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1220</x>
      <y>4526</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfsd_notify</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1106</x>
      <y>4519</y>
      <w>123</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1210.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1032</x>
      <y>4633</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_select</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1021</x>
      <y>4636</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取用户层的tvp</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1007</x>
      <y>4644</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过verify_area验证tvp的VERIFY_READ权限
	然后通过__get_user获取用户层的tv_sec和tv_usec
2.filter:tv_sec和tv_usec不能小于0
3.将tvp的时间转化成hz（timeout）
注：ROUND_UP是如果超出了bound，就按bound算
	1s=1hz=(1000000/hz)us
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1040</x>
      <y>4642</y>
      <w>39</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.n不能小于0（n表示位图的个数）
2.当n超过进程的max_fdset时：
	n = current-&gt;files-&gt;max_fdset
3.通过FDS_BYTES计算n需要size的空间（几个long型大小）
4.通过select_bits_alloc申请6个size长度的
	这6个空间分别用于
	//要求监测的输入，输出，异常
	fds.in      = (unsigned long *)  bits;
	fds.out     = (unsigned long *) (bits +   size);
	fds.ex      = (unsigned long *) (bits + 2*size);
	//因为唤醒的输入，输出，异常
	fds.res_in  = (unsigned long *) (bits + 3*size);
	fds.res_out = (unsigned long *) (bits + 4*size);
	fds.res_ex  = (unsigned long *) (bits + 5*size);
5.通过get_fd_set将要求监测的输入（inp），输出（outp）
	，异常（exp）复制到内核空间，并通过zero_fd_set将其清0
6.通过do_select对要求的文件进行监测，并等待监测结果
7.如果tvp存在，并且进程的personality STICKY_TIMEOUTS标记
	置上，timeout剩余事件转化为us，s，并将其通过put_user
	放在用户空间中
8.检查是否有错（ret&lt;0）,是否有signal_pending，直接返回
9.将fds.res_in，res_out，res_ex中的数据通过set_fd_set
	放到用户空间
10.通过select_bits_free将申请的6个size长度的bits释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1039</x>
      <y>4636</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1028</x>
      <y>4676</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_fd_set</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1032</x>
      <y>4670</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1019</x>
      <y>4682</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过FDS_BYTES获取位图的实际字节数
2.通过verify_area验证写权限
注：虽然这里是读，但是之后需要对齐进行写，
	所以这里直接验证写权限
3.通过__copy_from_user从用户层将数据复制到内核空间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1033</x>
      <y>4679</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1067</x>
      <y>4676</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_select
主要是申请多个wait结构（poll_table）
其他一个wait一样，都是挂在相应inode的等待队列中</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1055</x>
      <y>4670</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1055</x>
      <y>4683</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>max_select_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1060</x>
      <y>4679</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
files-&gt;file_lock</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1047</x>
      <y>4689</y>
      <w>26</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.首先获取不足long长度的mask
	set =~(~0UL &lt;&lt; (n &amp; (__NFDBITS-1)))
2.如果mask存在，获取其关心的mask
	set &amp;= BITS(fds, n);
注：BITS表示in，out，ex中关心的fd
3.如果set存在，且其关心的fd都没有关闭（!(set &amp; ~*open_fds)）
	直接去计算max
4.如果关心的fd有关的，返回EBADF
5.然后按照long去遍历低字节
	1.在这个long中存在关心的fd（set不为0）
	2.所有关心的fd都没有关闭（set &amp; ~*open_fds），否则返回EBADF
	3.如果max得到了，continue（这里去5.2检查传入数据的有效性）
6.返回max
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1059</x>
      <y>4686</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从高bit向低遍历</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1075</x>
      <y>4683</y>
      <w>16</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //初始化table
poll_initwait(&amp;table);
 //如果timeout存在
wait = &amp;table;
 //如果timeout为0
wait = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1072</x>
      <y>4679</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1072</x>
      <y>4679</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1092</x>
      <y>4683</y>
      <w>42</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.将task的状态设置为TASK_INTERRUPTIBLE
2.遍历要关注的最大fd，
	1.通过bit &amp; BITS(fds, off)，检查这个fd是否关心
	2.如果改fd是其关心的，通过fget得到file：
		mask = file-&gt;f_op-&gt;poll(file, wait)
		fput(file)
	3.检查mask中POLLIN_SET，POLLOUT_SET,POLLEX_SET是否
		置上，如果置上通过ISSET检查是否关心，如果关心
		//x是__RES_IN，__RES_OUT，__RES_EX
		SET(bit, x(fds,off));
		retval++;
		wait = NULL;
3.将所有关注的fd遍历完之后，如果有关注的fd事件发生（retval）
	不需要休眠（!__timeout）或者有signal_pending，跳出死循环
4.检查table.error，如果有错，跳出死循环
5.__timeout = schedule_timeout(__timeout)
	当其因为事件发生，或者因为timeout而醒来时，因为是死循环，所以
	从1再次开始检测
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1098</x>
      <y>4724</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_poll</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1098</x>
      <y>4717</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>file-&gt;f_op-&gt;poll
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1103</x>
      <y>4712</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1103</x>
      <y>4720</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
read_pipe_fops</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1083</x>
      <y>4717</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_poll</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1088</x>
      <y>4712</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1081</x>
      <y>4723</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>pt-&gt;error = 0;
pt-&gt;table = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1087</x>
      <y>4720</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1086</x>
      <y>4731</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>poll_wait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1090</x>
      <y>4727</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
&amp;inode.i_pipe-&gt;wait</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1090</x>
      <y>4734</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果poll_table和wait_queue_head_t
都存在</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1085</x>
      <y>4738</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__pollwait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1057</x>
      <y>4741</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果poll_table中table不存在
或者table中entry满了
（(table-&gt;entry+1) &gt; PAGE_SIZE + table）
注：table-&gt;entry指向空闲的entry，table-&gt;entry+1
	指的是空闲entry填满之后的地址</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1046</x>
      <y>4747</y>
      <w>27</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.通过__get_free_page获取poll_table_page
	（new_table），并初始化
	//空闲的entry，指向第一个
	new_table-&gt;entry = new_table-&gt;entries;
	//table头插至链表中
	new_table-&gt;next = table;
	p-&gt;table = new_table;
	table = new_table;
	注：这里这个管理结构在page中，之后就全是数组entries了
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1084</x>
      <y>4746</y>
      <w>32</w>
      <h>19</h>
    </coordinates>
    <panel_attributes> //获取空闲的entry
entry = table-&gt;entry;
table-&gt;entry = entry+1;
 //初始化entry
get_file(filp);
entry-&gt;filp = filp;
entry-&gt;wait_address = wait_address;
init_waitqueue_entry(&amp;entry-&gt;wait, current);//初始化wait
 //将wait插入到等待队列中
add_wait_queue(wait_address,&amp;entry-&gt;wait);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1082</x>
      <y>4741</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取空闲的entry放到inode的等待队列中</panel_attributes>
    <additional_attributes>80.0;10.0;180.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1103</x>
      <y>4727</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
先遍历一遍
查看是否有使进程醒着的原因</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1121</x>
      <y>4733</y>
      <w>25</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.mask = POLLIN | POLLRDNORM;
1.PIPE_EMPTY（inode.i_size==0）：
	mask = POLLOUT | POLLWRNORM;
2.!(inode).i_pipe-&gt;writers
	&amp;&amp; filp-&gt;f_version !=(inode).i_pipe-&gt;w_counter
	mask |= POLLHUP;
3.! (!PIPE_READERS(*inode))
		mask |= POLLERR;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1138</x>
      <y>4684</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>current-&gt;state = TASK_RUNNING
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1073</x>
      <y>4679</y>
      <w>74</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
跳出之前，因为在死循环第一步将其状态设置为TASK_INTERRUPTIBLE</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1167</x>
      <y>4684</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>poll_freewait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1074</x>
      <y>4679</y>
      <w>99</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;970.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1154</x>
      <y>4690</y>
      <w>36</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.遍历p-&gt;table链表
2.得到空闲的entry（p-&gt;entry）
3.然后通过do..while释放p-&gt;entries
	中的所有entry：
	entry--;
	remove_wait_queue(entry-&gt;wait_address,&amp;entry-&gt;wait);
	fput(entry-&gt;filp);
4.然后在遍历下一个table：
	old = p;
	p = p-&gt;next;
	free_page((unsigned long) old);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1171</x>
      <y>4687</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1247</x>
      <y>4647</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.打开文件
2.设置号SIGIO的信号响应
2.将文件与本进程（要通知的进程）关联（fcntl）
3.iocntl为file添加通知本进程的fasync
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1240</x>
      <y>4662</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_fcntl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1223</x>
      <y>4669</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1243</x>
      <y>4670</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_fcntl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1265</x>
      <y>4670</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fput</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1229</x>
      <y>4665</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通过fd获取file</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1247</x>
      <y>4665</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放file</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1246</x>
      <y>4665</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1242</x>
      <y>4673</y>
      <w>10</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
F_SETOWN
设置f_owner</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1225</x>
      <y>4680</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>filp-&gt;f_owner.pid = arg;
filp-&gt;f_owner.uid = current-&gt;uid;
filp-&gt;f_owner.euid = current-&gt;euid;
注：inode是对磁盘的抽象
	dentry是对路径的抽象（路径+inode）
	file是对进程的抽象（进程+dentry）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1255</x>
      <y>4681</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_fcntl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1249</x>
      <y>4673</y>
      <w>14</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sock_fcntl</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1306</x>
      <y>4662</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_mouse_event</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1314</x>
      <y>4665</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
head != queue-&gt;tail
如果buffer没满</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1313</x>
      <y>4669</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1308</x>
      <y>4674</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kill_fasync</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1306</x>
      <y>4680</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__kill_fasync</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1312</x>
      <y>4677</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
&amp;queue-&gt;fasync, SIGIO, POLL_IN
fasync_lock</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1301</x>
      <y>4687</y>
      <w>30</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.遍历链表，如果magic != FASYNC_MAGIC
	直接返回
2.获取file.f_owner
3.如果f_owner.pid不为0，并且不是在fown-&gt;signum == 0
	的时候发SIGURG
	通过send_sigio将信号发送
4.遍历链表的下一个
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1312</x>
      <y>4683</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1311</x>
      <y>4703</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>send_sigio</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1315</x>
      <y>4699</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1301</x>
      <y>4710</y>
      <w>30</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果pid&gt;0,通过find_task_by_pid在hash表中
	查找task，并通过send_sigio_to_task将信号发出去
2.如果pid=0（或者pid暂时没存储到hash中），遍历task链表，
	通过send_sigio_to_task发送信号
3.如果pid&lt;0，遍历task链表，查找进程组号和-pid相同的
	进程，并通过send_sigio_to_task对这些进程发送信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1315</x>
      <y>4706</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tasklist_lock</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1309</x>
      <y>4724</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>send_sigio_to_task</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1316</x>
      <y>4720</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1251</x>
      <y>4688</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.socki_lookup通过inode找到sock
2.如果sock存在，且其ops存在，调用sock_no_fcntl
3.否则返回EINVAL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1260</x>
      <y>4684</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1257</x>
      <y>4697</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_no_fcntl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1263</x>
      <y>4694</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1249</x>
      <y>4703</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.根据sock获取sk
2.如果是F_SETOWN：
	1.要满足当前进程组是-arg，或者当前进程是arg，或者当前进程有CAP_KILL权限这三个条件之一
	2.sk-&gt;proc = arg
 如果是F_GETOWN，返回sk-&gt;proc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1262</x>
      <y>4700</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2842</x>
      <y>2368</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_pipe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2827</x>
      <y>2376</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_pipe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2833</x>
      <y>2371</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2848</x>
      <y>2375</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果没有出错（!error），通过copy_to_user
	将两个fd复制到用户空间fildes中
2.如果出错，返回错误码
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2847</x>
      <y>2371</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2802</x>
      <y>2384</y>
      <w>43</w>
      <h>57</h>
    </coordinates>
    <panel_attributes>1.通过get_empty_filp得到读端和写端的
	file结构
2.通过get_pipe_inode获取管道的inode结构
3.通过get_unused_fd获取读端和写端的文件
	描述符
4.通过d_alloc给inode分配dentry：
	this.name = name;
	this.len = strlen(name);
	this.hash = inode-&gt;i_ino; /* will go */
	dentry = d_alloc(pipe_mnt-&gt;mnt_sb-&gt;s_root, &amp;this);
	dentry-&gt;d_op = &amp;pipefs_dentry_operations;
	//将dentry加入到inode的链表中，并且entry-&gt;d_inode指向inode
	d_add(dentry, inode);
5.增加挂载点和dentry的计数
	f1-&gt;f_vfsmnt = f2-&gt;f_vfsmnt = mntget(mntget(pipe_mnt));
	//注：d_alloc中有对dentry计数，这里只需记一次
	f1-&gt;f_dentry = f2-&gt;f_dentry = dget(dentry);
6.初始化读file和写file
	f1-&gt;f_pos = f2-&gt;f_pos = 0;
	f1-&gt;f_flags = O_RDONLY;
	f1-&gt;f_op = &amp;read_pipe_fops;
	f1-&gt;f_mode = 1;
	f1-&gt;f_version = 0;

	f2-&gt;f_flags = O_WRONLY;
	f2-&gt;f_op = &amp;write_pipe_fops;
	f2-&gt;f_mode = 2;
	f2-&gt;f_version = 0;
注：f_flags表示进程要求对file的权限（读写，append，block）
	f_mode表示file本身的读写权限（第0位置上表示可读，第1位置上表示可写）
7.在fd处安装file，并返回两个fd
	fd_install(i, f1);
	fd_install(j, f2);
	fd[0] = i;
	fd[1] = j;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2809</x>
      <y>2444</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_pipe_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2832</x>
      <y>2379</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2792</x>
      <y>2450</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_empty_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2796</x>
      <y>2447</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2807</x>
      <y>2451</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipe_new</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2812</x>
      <y>2447</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化inode</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2791</x>
      <y>2458</y>
      <w>38</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.为inode申请fifo内存
	(inode).i_pipe-&gt;base=__get_free_page
2.为pipe申请pipe_inode_info结构
	inode-&gt;i_pipe = kmalloc(sizeof(struct pipe_inode_info)
3.初始化pipe_inode_info和inode.size：
	init_waitqueue_head(PIPE_WAIT(*inode));
	PIPE_START(*inode) = PIPE_LEN(*inode) = 0;
	PIPE_READERS(*inode) = PIPE_WRITERS(*inode) = 0;
	PIPE_WAITING_READERS(*inode) = PIPE_WAITING_WRITERS(*inode) = 0;
	PIPE_RCOUNTER(*inode) = PIPE_WCOUNTER(*inode) = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2811</x>
      <y>2454</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2822</x>
      <y>2452</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>PIPE_READERS(*inode) = 
PIPE_WRITERS(*inode) = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2813</x>
      <y>2447</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2846</x>
      <y>2452</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //i_fop不赋给file，因为读端和写端都
 //只具有读或者写，但是对inode却具有
 //读和写的特性
inode-&gt;i_fop = &amp;rdwr_pipe_fops;
inode-&gt;i_sb = pipe_mnt-&gt;mnt_sb;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2814</x>
      <y>2447</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2872</x>
      <y>2452</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_state = I_DIRTY;
inode-&gt;i_mode = S_IFIFO | S_IRUSR | S_IWUSR;
inode-&gt;i_uid = current-&gt;fsuid;
inode-&gt;i_gid = current-&gt;fsgid;
inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;
inode-&gt;i_blksize = PAGE_SIZE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2814</x>
      <y>2447</y>
      <w>66</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;640.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2814</x>
      <y>2440</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2758</x>
      <y>2547</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_signal
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2729</x>
      <y>2554</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>new_sa.sa.sa_handler = handler;
new_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK
注：SA_ONESHOT：“一次性”，使用函数指针之后，将其改为SIG_DFL
	SA_NOMASK：不适用信号屏蔽
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2746</x>
      <y>2550</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2773</x>
      <y>2554</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_sigaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2762</x>
      <y>2550</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果正常返回
则返回old_sa.sa.sa_handler</panel_attributes>
    <additional_attributes>30.0;10.0;150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2801</x>
      <y>2546</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_rt_sigaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2794</x>
      <y>2553</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.判断sigsetsize的大小是否sigset_t一致
2.通过copy_from_user将sigaction复制到new_sa.sa
3.调用do_sigaction，安装signal
4.通过copy_to_user将old_sa.sa复制到用户空间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2806</x>
      <y>2549</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2843</x>
      <y>2546</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sigaction</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2835</x>
      <y>2552</y>
      <w>32</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.通过verify_area验证待安装的act的读权限
	并通过__get_user将act中的元素，依次从
	用户空间取出，填充到new_ka.sa中
注：因为old_sigaction和k_sigaction中mask的偏移
	不相同，所以不能像sys_rt_sigaction一样copy
2.通过do_sigaction安装signal
3.同样通过verify_area验证之前oact的写权限
	然后通过__put_user依次将old_ka.sa中的元素填入
	oact中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2848</x>
      <y>2549</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2722</x>
      <y>2565</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.sig要在1~_NSIG之间
2.如果要安装signal，不能覆盖SIGKILL和
	SIGSTOP的响应
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2738</x>
      <y>2557</y>
      <w>43</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter
</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2749</x>
      <y>2565</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.current-&gt;sig-&gt;siglock保护
2.如果要输出之前的响应：
	*oact=current-&gt;sig-&gt;action[sig-1]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2756</x>
      <y>2557</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2772</x>
      <y>2563</y>
      <w>40</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>signal_pending1.current-&gt;sig-&gt;action[sig-1]=*act
2.通过sigdelsetmask将sa_mask中的SIGKILL
	和SIGSTOP的屏蔽去掉：
	sigdelsetmask：
		set-&gt;sig[0] &amp;= ~mask
3.如果要将信号的响应设置成SIG_IGN
	或者将SIGCONT、SIGCHLD、SIGWINCH
		的响应设置成SIG_DFL
	1.通过rm_sig_from_queue将信号队列中对这个信号的请求取消
	2.通过recalc_sigpending重新计算
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2778</x>
      <y>2557</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果要替换signal的响应
</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2769</x>
      <y>2584</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rm_sig_from_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2775</x>
      <y>2580</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2767</x>
      <y>2592</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rm_from_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2772</x>
      <y>2587</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2758</x>
      <y>2599</y>
      <w>30</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.通过sigismember查看是否在signal中存在信号
	请求，如果不存在直接返回0
2.如果存在信号请求，通过sigdelset将信号请求去掉
	set-&gt;sig[sig / _NSIG_BPW] &amp;= ~(1UL &lt;&lt; (sig % _NSIG_BPW));
3.遍历task的信号请求队列pending.head
	如果队列中请求的信号和当前的信号相同（q-&gt;info.si_signo == sig）
	1.将其中链表中移除（*pp = q-&gt;next），如果移除的info是最后一个
		将s-&gt;tail指向链表最后一个的next
	2.释放队列中的sigqueue，并递减信号数：
		kmem_cache_free(sigqueue_cachep,q);
		atomic_dec(&amp;nr_queued_signals);
4.返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2772</x>
      <y>2595</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2797</x>
      <y>2584</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>recalc_sigpending</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2803</x>
      <y>2580</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2799</x>
      <y>2592</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>has_pending_signals</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2804</x>
      <y>2587</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
t-&gt;sigpending
因为信号可能不止用一个字能表示
所以不能用pending.signal直接显示</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2792</x>
      <y>2599</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.检查t-&gt;pending.signal中除了t-&gt;blocked
	中屏蔽的信号，是否还有其他信号需要处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2805</x>
      <y>2595</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2886</x>
      <y>2545</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sigprocmask</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2875</x>
      <y>2551</y>
      <w>35</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果带设置的set不为NULL
	1.通过copy_from_user将set从用户层复制到内核，并将
		其SIGKILL和SIGSTOP清除（不允许屏蔽）
	2.将之前的block信号先提取：
		old_set = current-&gt;blocked.sig[0];
	3.如果是SIG_BLOCK，那么利用sigaddsetmask将urrent-&gt;blocked中set规定的位置上
	如果是SIG_UNBLOCK，那么利用sigdelsetmask将current-&gt;blocked中set规定的位清除
	如果SIG_SETMASK，那么将直接用set覆盖blocked：
		current-&gt;blocked.sig[0] = new_set	
	4.利用recalc_sigpending重新计算sigpending
2.如果oset不为空，那么将task原来的blocked通过copy_to_user返回到用户空间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2891</x>
      <y>2548</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2927</x>
      <y>2546</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sigpending</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2927</x>
      <y>2553</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_sigpending</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2932</x>
      <y>2549</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2914</x>
      <y>2560</y>
      <w>42</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.传入参数sigsetsize的大小不能大于sizeof(sigset_t)
2.通过sigandsets查看除了blocked的信号之外，pending.signal
	中是否还有其他未处理的信号
3.通过copy_to_user将未处理的信号复制到用户空间
注：sigandsets是通过_SIG_SET_BINOP(sigandsets, _sig_and)
	定义的，_SIG_SET_BINOP是逐位的按照_sig_and的方法操作
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2931</x>
      <y>2556</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2971</x>
      <y>2546</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sigsuspend</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2959</x>
      <y>2553</y>
      <w>33</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.将要求屏蔽的mask中的SIGKILL和SIGSTOP去掉
2.将之前屏蔽的保存：
	saveset = current-&gt;blocked;
3.通过siginitset将mask赋给blocked
4.通过recalc_sigpending重新计算sigpending
5.regs-&gt;eax = -EINTR;
6.将task睡眠
	current-&gt;state = TASK_INTERRUPTIBLE;
	schedule()
7.醒来之后通过do_signal处理信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2976</x>
      <y>2549</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2753</x>
      <y>2641</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_kill</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2738</x>
      <y>2648</y>
      <w>17</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>info.si_signo = sig;
info.si_errno = 0;
 //标记从用户空间过来
info.si_code = SI_USER;
info.si_pid = current-&gt;pid;
info.si_uid = current-&gt;uid;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2746</x>
      <y>2644</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2762</x>
      <y>2649</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kill_something_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2758</x>
      <y>2644</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2756</x>
      <y>2656</y>
      <w>38</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果pid=0，通过kill_pg_info给当前进程组（current-&gt;pgrp）
	发信号
2.如果pid=-1，遍历task链表，通过send_sig_info对每个
	task发信号
3.如果pid&lt;-1,通过kill_pg_info给进程组（-pid）发信号
4.如果pid&gt;0，通过kill_proc_info给task发信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2755</x>
      <y>2671</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kill_pg_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2778</x>
      <y>2672</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kill_proc_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2770</x>
      <y>2652</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2761</x>
      <y>2666</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2774</x>
      <y>2666</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2750</x>
      <y>2678</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.遍历task链表，通过send_sig_info
	给该进程组（p-&gt;pgrp == pgrp）
	task发信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2760</x>
      <y>2674</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2776</x>
      <y>2678</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过find_task_by_pid在hash表
	中查找pid对应的task
2.通过send_sig_info给task发信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2784</x>
      <y>2675</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2780</x>
      <y>2687</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>send_sig_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2785</x>
      <y>2684</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2800</x>
      <y>2649</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_rt_sigqueueinfo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2797</x>
      <y>2656</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过copy_from_user将siginfo_t
	从用户空间赋值到内核
2.info.si_code 需要小于0（不能是SI_USER和SI_KERNEL）
3.info.si_signo = sig
4.通过kill_proc_info向task发信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2806</x>
      <y>2652</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2739</x>
      <y>2694</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.0&lt;sig&lt;_NSIG,否则返回EINVAL
2.!bad_signal,否则返回EPERM
	1.当info为0或者不为1的时候，info.si_code&lt;=0(来自用户空间)
	2.当信号为SIGCONT，唤醒task的session不和当前task相同
	3.当前task的euid和接收信号task的suid和uid都不相等
	4.当前task的uid和接收信号task的suid和uid都不相等
	5.没有CAP_KILL权限
	上述条件全满足时，bad_signal
3.sig不为0，并且接收信号的task的"信号向量表"（sig）需要注册
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2750</x>
      <y>2690</y>
      <w>38</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>360.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2780</x>
      <y>2694</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_stop_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2785</x>
      <y>2690</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2770</x>
      <y>2700</y>
      <w>34</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果发送SIGKILL或者SIGCONT，让task继续运行
	1.如果进程处于TASK_STOPPED，通过wake_up_process将进程唤醒
	2.通过rm_sig_from_queue移除信号动作队列中因为SIGSTOP，SIGTSTP
		SIGTTOU，SIGTTIN停止的动作
注：SIGKILL虽然是让进程终止，但是需要其运行自行终止
2.如果发送SIGSTOP，SIGTSTP，SIGTTIN，SIGTTOU，让task停止运行
	通过rm_sig_from_queue取消队列中让其运行（SIGCONT）的动作
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2786</x>
      <y>2697</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2808</x>
      <y>2693</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ignored_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2786</x>
      <y>2690</y>
      <w>29</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2806</x>
      <y>2700</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果接收信号的task的ptrace &amp; PT_PTRACED置上，不忽略
2.如果信号blocked，不忽略，防止之后blocked取消能处理
3.signal_type返回0才忽略
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2813</x>
      <y>2696</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2813</x>
      <y>2708</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>signal_type</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2818</x>
      <y>2705</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2792</x>
      <y>2714</y>
      <w>42</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.如果“信号向量表不存在”，返回0（忽略）
2.如果向量表中的action不为ign，dfl，err，返回1（不忽略）
3.如果action为ign（1），如果是SIGCHLD就不忽略，不是就忽略
4.如果action为dfl（或者err），
	1.如果信号是SIGCONT，SIGWINCH，SIGCHLD，SIGURG，忽略
	2.如果信号是SIGTSTP，SIGTTIN，SIGTTOU停止task运行信号，不忽略
	3.如果是其他信号，返回-1（不忽略）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2818</x>
      <y>2711</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2837</x>
      <y>2694</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果sig&lt;SIGRTMIN(rt signal)
	并且通过sigismember检查到已经在
	pending中置上，因为这样的信号合并
	成一次info，所以这次忽略
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2787</x>
      <y>2690</y>
      <w>59</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;570.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2863</x>
      <y>2694</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>deliver_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2786</x>
      <y>2690</y>
      <w>84</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;820.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2858</x>
      <y>2701</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>send_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2863</x>
      <y>2697</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2863</x>
      <y>2697</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果正常返回，
并通过sigismember检查没被blocked</panel_attributes>
    <additional_attributes>60.0;10.0;170.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2874</x>
      <y>2702</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>signal_wake_up</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2872</x>
      <y>2709</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>t-&gt;sigpending = 1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2886</x>
      <y>2709</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2876</x>
      <y>2705</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2878</x>
      <y>2705</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果task的状态是
TASK_INTERRUPTIBLE</panel_attributes>
    <additional_attributes>30.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2835</x>
      <y>2708</y>
      <w>36</w>
      <h>47</h>
    </coordinates>
    <panel_attributes>1.如果队列中的info数量（nr_queued_signals）
	没超过max_queued_signals，才通过kmem_cache_alloc
	申请sigqueue
2.如果申请到sigqueue
	1.增加nr_queued_signals的计数
	2.将sigqueue加到链表中：
		q-&gt;next = NULL;
		*signals-&gt;tail = q;
		signals-&gt;tail = &amp;q-&gt;next;
	3.初始化sigqueue：
		info：0
		q-&gt;info.si_signo = sig;
		q-&gt;info.si_errno = 0;
		q-&gt;info.si_code = SI_USER;
		q-&gt;info.si_pid = current-&gt;pid;
		q-&gt;info.si_uid = current-&gt;uid;
		info：1
		q-&gt;info.si_signo = sig;
		q-&gt;info.si_errno = 0;
		q-&gt;info.si_code = SI_KERNEL;
		q-&gt;info.si_pid = 0;
		q-&gt;info.si_uid = 0;
		普通info：
		copy_siginfo(&amp;q-&gt;info, info);
3.如果因为队列中的info足够多，所以没申请sigqueue：
	如果sig不是rt（sig &gt;= SIGRTMIN），并且是普通info
	且si_code不是SI_USER，直接返回EAGAIN
4.如果正常，通过sigaddset将pending中sig-1位置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2853</x>
      <y>2704</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2888</x>
      <y>2693</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wake_up_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2787</x>
      <y>2690</y>
      <w>109</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果接收信号的task是TASK_INTERRUPTIBLE
并且signal_pending
注；情形1：blocked，但是有其他信号</panel_attributes>
    <additional_attributes>10.0;10.0;1070.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2853</x>
      <y>2643</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>force_sig</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2853</x>
      <y>2650</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>force_sig_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2858</x>
      <y>2646</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
info:1</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2840</x>
      <y>2657</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果接收task的“信号向量表”sig不存在，返回ESRCH
2.如果sa_handler是ign，将其变换位dfl
3.通过sigdelset将bloced中的位清除（强制执行singal）
	并通过recalc_sigpending重新计算sigpending
4.通过send_sig_info向task发送信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2858</x>
      <y>2653</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2955</x>
      <y>2618</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2923</x>
      <y>2626</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果不是从用户空间陷入到系统空间
	((regs-&gt;xcs &amp; 3) != 3),直接返回1
2.如果要求返回之前的blocked
	oldset = &amp;current-&gt;blocked
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2934</x>
      <y>2621</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2960</x>
      <y>2621</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
死循环</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2941</x>
      <y>2710</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dequeue_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3051</x>
      <y>2710</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>handle_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2978</x>
      <y>2704</y>
      <w>81</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;790.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2947</x>
      <y>2704</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2961</x>
      <y>2621</y>
      <w>66</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
regs-&gt;orig_eax &gt;= 0
中断：这里是中断号-255，小于0
异常：这里是-1，error_code
sys_call:这里是系统调用号，大于0</panel_attributes>
    <additional_attributes>10.0;10.0;640.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3008</x>
      <y>2624</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果要求重新sys_call(返回值regs-&gt;eax是
	ERESTARTNOHAND,ERESTARTSYS，ERESTARTNOINTR)
	将regs-&gt;eax换成系统调用号，并将eip调整到
	系统调用的语句：
	regs-&gt;eax = regs-&gt;orig_eax;
	regs-&gt;eip -= 2;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2928</x>
      <y>2717</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>next_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2916</x>
      <y>2724</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.在pending.signal.sig中查看没被mask（这里是blocked）
	屏蔽的信号，如果有返回sig，否则返回0
注；ffz：find first zero 
	bsf：bit scan forward 是从低向高位检索bit，找到第一个1
	传参和ffz分别经过了两次非
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2935</x>
      <y>2713</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2931</x>
      <y>2720</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2944</x>
      <y>2713</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果存在current-&gt;notifier
并且notifier_mask中sig有置上</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2945</x>
      <y>2720</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>current-&gt;notifier)(current-&gt;notifier_data)
current-&gt;sigpending = 0;
return 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2944</x>
      <y>2713</y>
      <w>37</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2974</x>
      <y>2720</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>collect_signal</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2955</x>
      <y>2727</y>
      <w>38</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>1.如果sig在pending中被置上
	1.遍历pending的info队列，查找队列中是否有和sig一致的
	info.si_signo，如果有跳到3
	2.如果队列中没有，通过sigdelset清除sig在pending中的标志并初始化info：
		info-&gt;si_signo = sig;
		info-&gt;si_errno = 0;
		info-&gt;si_code = 0;
		info-&gt;si_pid = 0;
		info-&gt;si_uid = 0;
	3.如果在队列中找到了info
		1.将info从链表中断开
			*pp = q-&gt;next
			//如果info是链表中的最后一个
			list-&gt;tail = pp
		2.复制info，释放链表中的info
			copy_siginfo(info, &amp;q-&gt;info);
			kmem_cache_free(sigqueue_cachep,q);
			atomic_dec(&amp;nr_queued_signals);
		3.如果信号不是rt（&gt;= SIGRTMIN），继续遍历链表
			如果再次找到，就不清pending中的sig。
			否则通过sigdelset将sig清掉
2.如果sig没在pending中置上，直接返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2978</x>
      <y>2723</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2992</x>
      <y>2719</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>recalc_sigpending</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2944</x>
      <y>2713</y>
      <w>55</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
重新计算sigpending</panel_attributes>
    <additional_attributes>10.0;10.0;530.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3025</x>
      <y>2713</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
regs-&gt;orig_eax &gt;= 0
如果来自sys_call</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3004</x>
      <y>2720</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果返回值是ERESTARTNOHAND，返回EINTR
2.如果返回值是ERESTARTSYS，如果信号向量表
	的sa_flags中的SA_RESTART没置上，返回EINTR
	否则，重新执行sys_call
3.如果返回值是ERESTARTNOINTR，重新执行sys_call:
	regs-&gt;eax = regs-&gt;orig_eax;
	regs-&gt;eip -= 2;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3051</x>
      <y>2713</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3041</x>
      <y>2716</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
信号向量表的sa_flags
中SA_SIGINFO置上</panel_attributes>
    <additional_attributes>110.0;10.0;30.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3038</x>
      <y>2723</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_rt_frame</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3051</x>
      <y>2716</y>
      <w>21</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SA_SIGINFO没置上</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3064</x>
      <y>2725</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_frame</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3053</x>
      <y>2713</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
之前在SA_ONESHOT置上的时候，handler设成SIG_DFL
防止中断嵌套，现在可以通过信号向量表中的mask屏蔽</panel_attributes>
    <additional_attributes>50.0;10.0;320.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3080</x>
      <y>2719</y>
      <w>20</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>ka-&gt;sa.sa_handler = SIG_DFL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3058</x>
      <y>2713</y>
      <w>63</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SA_NODEFER没置上
</panel_attributes>
    <additional_attributes>10.0;10.0;610.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3104</x>
      <y>2717</y>
      <w>34</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //blocked|=mask
sigorsets(&amp;current-&gt;blocked,&amp;current-&gt;blocked,&amp;ka-&gt;sa.sa_mask);
 //blocked |=sig
sigaddset(&amp;current-&gt;blocked,sig);
recalc_sigpending(current);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3030</x>
      <y>2728</y>
      <w>40</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请栈帧</panel_attributes>
    <additional_attributes>380.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3025</x>
      <y>2734</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_sigframe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3004</x>
      <y>2741</y>
      <w>34</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.默认是用户栈regs-&gt;esp
2.如果SA_ONSTACK置上，并且通过on_sig_stack
	查看用户栈是否在sig的栈上（current-&gt;sas_ss_sp + current-&gt;sas_ss_size）
	如果不在：
	esp = current-&gt;sas_ss_sp + current-&gt;sas_ss_size
注；系统调用sigaltstack设置信号栈
3.如果xss不在用户段（__USER_DS）
	并且SA_RESTORER没置上
	sa_restorer存在
	esp =ka-&gt;sa.sa_restorer
注：不清楚为什么xss会不在用户段，sig只有xss在用户段的时候才会处理啊？
4.申请栈空间：
	(esp - frame_size) &amp; -8ul
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3023</x>
      <y>2737</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3038</x>
      <y>2736</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>access_ok
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3043</x>
      <y>2728</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
验证栈的写（VERIFY_WRITE）权限</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3058</x>
      <y>2728</y>
      <w>15</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3053</x>
      <y>2737</y>
      <w>29</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.通过__put_user压栈参数sig：
	如果进程有要求转换：
	current-&gt;exec_domain
  &amp;&amp; current-&gt;exec_domain-&gt;signal_invmap
  &amp;&amp; sig &lt; 32
  	就通过current-&gt;exec_domain-&gt;signal_invmap[sig]转换
  	否则就是sig
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3087</x>
      <y>2738</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_sigcontext</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3070</x>
      <y>2728</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将上下文环境保存到sigcontext中</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3084</x>
      <y>2745</y>
      <w>27</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>__put_user(tmp, (unsigned int *)&amp;sc-&gt;gs);
__put_user(tmp, (unsigned int *)&amp;sc-&gt;fs);
__put_user(regs-&gt;xes, (unsigned int *)&amp;sc-&gt;es);
__put_user(regs-&gt;xds, (unsigned int *)&amp;sc-&gt;ds);
__put_user(regs-&gt;edi, &amp;sc-&gt;edi);
__put_user(regs-&gt;esi, &amp;sc-&gt;esi);
__put_user(regs-&gt;ebp, &amp;sc-&gt;ebp);
__put_user(regs-&gt;esp, &amp;sc-&gt;esp);
__put_user(regs-&gt;ebx, &amp;sc-&gt;ebx);
__put_user(regs-&gt;edx, &amp;sc-&gt;edx);
__put_user(regs-&gt;ecx, &amp;sc-&gt;ecx);
__put_user(regs-&gt;eax, &amp;sc-&gt;eax);
__put_user(current-&gt;thread.trap_no, &amp;sc-&gt;trapno);
__put_user(current-&gt;thread.error_code, &amp;sc-&gt;err);
__put_user(regs-&gt;eip, &amp;sc-&gt;eip);
__put_user(regs-&gt;xcs, (unsigned int *)&amp;sc-&gt;cs);
__put_user(regs-&gt;eflags, &amp;sc-&gt;eflags);
__put_user(regs-&gt;esp, &amp;sc-&gt;esp_at_signal);
__put_user(regs-&gt;xss, (unsigned int *)&amp;sc-&gt;ss);
 //do_signal在entry.S中调用的是oldmask好像是edx，所以是blocked
 //这里只复制了blocked[0]
__put_user(mask, &amp;sc-&gt;oldmask);
__put_user(current-&gt;thread.cr2, &amp;sc-&gt;cr2);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3092</x>
      <y>2741</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3070</x>
      <y>2728</y>
      <w>44</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制oldset.sig[1]开始的mask到frame-&gt;extramask</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3106</x>
      <y>2737</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__copy_to_user
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3070</x>
      <y>2728</y>
      <w>64</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3121</x>
      <y>2735</y>
      <w>29</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.如果SA_RESTORER置上，ka-&gt;sa.sa_restorer将作为其信号处理完成之后的返回地址
	__put_user(ka-&gt;sa.sa_restorer, &amp;frame-&gt;pretcode
2.如果没置上，frame-&gt;retcode将作为其信号处理完的返回地址
	__put_user(frame-&gt;retcode, &amp;frame-&gt;pretcode);
	//依次执行popl %eax ; movl $,%eax ; int $0x80
	__put_user(0xb858, (short *)(frame-&gt;retcode+0));
	__put_user(__NR_sigreturn, (int *)(frame-&gt;retcode+2));
	__put_user(0x80cd, (short *)(frame-&gt;retcode+6));
3.设置返回用户空间的ip和sp
	regs-&gt;esp = (unsigned long) frame;
	regs-&gt;eip = (unsigned long) ka-&gt;sa.sa_handler;

	set_fs(USER_DS);
	regs-&gt;xds = __USER_DS;
	regs-&gt;xes = __USER_DS;
	regs-&gt;xss = __USER_DS;
	regs-&gt;xcs = __USER_CS;
	//将硬件跟踪的flag清掉
	regs-&gt;eflags &amp;= ~TF_MASK;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3091</x>
      <y>2615</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sigreturn</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3073</x>
      <y>2622</y>
      <w>47</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.*frame = (struct sigframe *)(regs-&gt;esp - 8)
注：因为进入系统调用的时候，pretcode返回，并且会有popl eax
2.通过verify_area验证栈帧区域的写权限
3.通过__get_user和__copy_from_user将之前的blocked信息
	存储到set.sig中
4.通过sigdelsetmask清除set中的SIGKILL和SIGSTOP
5.还原blocked，并重新计算sigpending
	current-&gt;blocked = set;
	recalc_sigpending(current);
6.通过restore_sigcontext恢复signal_handler破坏的现场
注：处理完signal不能直接回到原理陷入内核的地方，是因为：
	1.signal_handler会破环用户层的寄存器现场，需要save_all和restore_all
		但是用户层没手段去做寄存器现场的保护和恢复
	2.返回系统空间有利于一次性处理完所有的sig
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3097</x>
      <y>2618</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3089</x>
      <y>2649</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>restore_sigcontext</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3095</x>
      <y>2645</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3079</x>
      <y>2656</y>
      <w>33</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.恢复gs，fs到相应的段寄存器中
2.恢复es，ds，edi，esi，ebp，esp，ebx，edx，ecx，eip，cs，ss
	到对应的reg上下文现场中
3.用户层的（~0x40DD5）和之前现场的（0x40DD5）组成恢复现场的regs-&gt;eflags
4.禁止sys_call检查
	regs-&gt;orig_eax = -1;
5.通过restore_i387将sc-&gt;fpstate恢复
6.将do_signal之前的返回值，放在peax中
	__get_user(*peax, &amp;sc-&gt;eax)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3095</x>
      <y>2652</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2955</x>
      <y>2625</y>
      <w>45</w>
      <h>80</h>
    </coordinates>
    <panel_attributes>1.通过dequeue_signal找到要处理的信号（signr），
	并将其从info队列中移除
2.如果返回是0，则退出循环
3.如果task的ptrace &amp; PT_PTRACED置上，且
	处理的信号不是SIGKILL：
	1.task stopped
		current-&gt;exit_code = signr;
		current-&gt;state = TASK_STOPPED;
		notify_parent(current, SIGCHLD);
		schedule();
	2.如果gdb continue时，exit_code为0，继续处理其他信号
		并清楚current-&gt;exit_code = 0
	3.如果exit_code是SIGSTOP，继续处理其他信号
	4.如果信号变了，更新info
		info.si_signo = signr;
		info.si_errno = 0;
		info.si_code = SI_USER;
		info.si_pid = current-&gt;p_pptr-&gt;pid;
		info.si_uid = current-&gt;p_pptr-&gt;uid;
	5.如果信号被blocked，通过send_sig_info重新将信号加入到队列中
4.获取信号向量表：
	ka = &amp;current-&gt;sig-&gt;action[signr-1]
5.如果sa_handler是ign，但是信号不是SIGCHLD
	继续下一个信号；如果是，通过sys_wait4等待
	子进程stopped或者zombie
注：WNOHANG表示不睡眠
6.如果sa_handler是SIG_DFL：
	1.不能是init进程接收
	2.如果是SIGCONT，SIGCHLD，SIGWINCH不处理
	3.如果是SIGTSTP，SIGTTIN，SIGTTOU，如果是孤儿进程，不处理
		否则4一致
	4.如果是SIGSTOP
		1.如果父进程没有要求在子进程stopped时停发SIGCHLD
			通过notify_parent给父进程发送SIGCHLD
		2.schedule
	5.如果是以下情况
		case SIGQUIT: case SIGILL: case SIGTRAP:
		case SIGABRT: case SIGFPE: case SIGSEGV:
		case SIGBUS: case SIGSYS: case SIGXCPU: case SIGXFSZ:
		通过do_coredump将必要信息存储到core文件中，exit_code |= 0x80;
		然后与6一致
	6.默认是：
		1.通过sigaddset将pending中sig重新置上，并通过recalc_sigpending
			计算sigpending
		2.标识进程被信号杀死
			current-&gt;flags |= PF_SIGNALED
		3.do_exit(exit_code)
	注：如果是ign和dfl，基本上是在这里（内核空间）处理完
7.如果需要用户空间处理，通过handle_signal处理信号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2785</x>
      <y>2871</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_ptrace</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2730</x>
      <y>2874</y>
      <w>62</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_TRACEME</panel_attributes>
    <additional_attributes>600.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2714</x>
      <y>2880</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果进程ptrace &amp; PT_PTRACED置上
	直接返回
2.否则置上标志，并返回0
	current-&gt;ptrace |= PT_PTRACED;
	ret = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2743</x>
      <y>2882</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_task_by_pid
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2747</x>
      <y>2874</y>
      <w>46</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2758</x>
      <y>2882</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_task_struct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2763</x>
      <y>2874</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2755</x>
      <y>2888</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>atomic_inc(page.count)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2764</x>
      <y>2885</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
task虚拟地址转换成page管理结构</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2773</x>
      <y>2882</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.如果pid找不到child，返回ESRCH
2.如果是init进程（pid == 1），返回EPERM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2779</x>
      <y>2874</y>
      <w>14</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2791</x>
      <y>2874</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_ATTACH</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2796</x>
      <y>2881</y>
      <w>30</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.要跟踪的进程不能是当前进程（child == current）
2.下面条件要全满足，或者进程有CAP_SYS_PTRACE权限
	child-&gt;dumpable不为0
	当前进程uid要和child的euid，suid，uid相同
	当前进程的gid要和child的egid，sgid，gid相同
	child的cap_permitted要是当前进程cap_permitted的子集
3.child的	PT_PTRACED要置上
4.如果child的养父（pptr）不是当前进程
	通过REMOVE_LINKS将其从task链表和其族谱中删除
	并通过以下方法将其加入到current的族谱中
	child-&gt;p_pptr = current;
	SET_LINKS(child);
5.给child发送SIGSTOP，并返回0
	send_sig(SIGSTOP, child, 1);
	ret = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2827</x>
      <y>2881</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果PT_PTRACED没置上，报ESRCH
2.如果child的状态不是TASK_STOPPED时，只要发送的不是
	PTRACE_KILL就直接返回ESRCH
3.child养父要是当前进程
注：虽然1，3也在attached中检测，但是报错好像不一样
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2791</x>
      <y>2874</y>
      <w>43</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2792</x>
      <y>2874</y>
      <w>86</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;840.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2856</x>
      <y>2879</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_PEEKTEXT
PTRACE_PEEKDATA
读取数据段或者代码段addr上4个字节的数据</panel_attributes>
    <additional_attributes>190.0;10.0;90.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2857</x>
      <y>2886</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2859</x>
      <y>2886</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查读取的长度和期待的长度相同</panel_attributes>
    <additional_attributes>60.0;10.0;150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2869</x>
      <y>2890</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2850</x>
      <y>2891</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>access_process_vm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2840</x>
      <y>2897</y>
      <w>30</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.获取mm
	mm = tsk-&gt;mm;
	atomic_inc(&amp;mm-&gt;mm_users
2.通过find_extend_vma找到addr所处的vma
3.通过access_mm将vma中的数据存储到buf中
4.释放mm
	mmput(mm)
5.返回复制的字节数copied
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2856</x>
      <y>2894</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2836</x>
      <y>2913</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_extend_vma</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2840</x>
      <y>2910</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2862</x>
      <y>2912</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>access_mm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2856</x>
      <y>2909</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;20.0;110.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2825</x>
      <y>2919</y>
      <w>29</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.addr &amp;= PAGE_MASK
2.通过find_vma找到end高于addr的最小vma
3.如果没找到vma，返回NULL
4.如果vm_start &lt;= addr，地址完全在这个vma内
	返回vma
5.如果vma的VM_GROWSDOWN没置上(不是栈)，返回NULL
6.通过expand_stack将栈扩展
7.如果vma的VM_LOCKED，通过make_pages_present给其分配
	物理页面
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2840</x>
      <y>2916</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2857</x>
      <y>2919</y>
      <w>35</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.计算当前页有多少空间可以读
	offset = addr &amp; ~PAGE_MASK
	 this_len = PAGE_SIZE - offset
	 //确定此次读的长度
	 min（this_len， len）
2.通过access_one_page将此次要读的长度，读到buf中
3.更新：
	copied += retval;//如果没读到预期长度，直接退出
	len -= retval;//len读完了，退出
	addr += retval;
	buf += retval;
4.如果当前vma没读完，再次读这个vma
5.如果当前vma读完了，下一个vma存在且和当前vma连续
	vma = vma-&gt;vm_next
	否则退出
halign=left
</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2867</x>
      <y>2915</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2867</x>
      <y>2947</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>access_one_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2873</x>
      <y>2943</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2857</x>
      <y>2954</y>
      <w>34</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.获取pgdir
2.检查pgd_none，pgd_bad，pmd_none，pmd_bad
	pte_present，pte_write&amp;&amp;pte_dirty（如果要求写）
	如果是none或者！present,先去handle_mm_fault分配物理页，然后再次执行
3.获取物理页
	page = pte_page(*pgtable)
4.在要写或者不是ZERO_PAGE时，要是VALID_PAGE并且不是PageReserved
5.执行读写操作
	//获取page的虚拟地址
	maddr = kmap(page)
	//写
	memcpy(maddr + (addr &amp; ~PAGE_MASK), buf, len);
	//读
	memcpy(buf, maddr + (addr &amp; ~PAGE_MASK), len);
	kunmap(page);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2872</x>
      <y>2950</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2875</x>
      <y>2879</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_PEEKUSR</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2885</x>
      <y>2886</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2881</x>
      <y>2890</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.addr要4字节对齐（addr &amp; 3）!=0
2.addr&gt;=0
3.addr读取的数据不能超过sizeof(struct user)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2903</x>
      <y>2891</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getreg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2893</x>
      <y>2886</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
addr &lt; 17*sizeof(long)
如果要读取寄存器</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2893</x>
      <y>2886</y>
      <w>35</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
u_debugreg[0]&lt;=addr&lt;=u_debugreg[7]
如果要读取调试寄存器，算出偏移量</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2919</x>
      <y>2891</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tmp = child-&gt;thread.debugreg[addr]
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2949</x>
      <y>2891</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>put_user</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2893</x>
      <y>2886</y>
      <w>62</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;600.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2909</x>
      <y>2894</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2889</x>
      <y>2898</y>
      <w>34</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果要读fs，gs，从thread中读取
	retval = child-&gt;thread.fs;
	retval = child-&gt;thread.gs;
2.ds，es，ss,cs只读16位，其他读32位
	1.因为有pt_regs中没有fs，gs，所以gs之后的序号需要向前2个
	2.计算在pt_regs中的偏移，这里正负没关系，之后会越界
		regno = regno - sizeof(struct pt_regs);
	3.通过get_stack_long得到栈上寄存器的值
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2901</x>
      <y>2915</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_stack_long</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2905</x>
      <y>2911</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2895</x>
      <y>2922</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.获取系统栈顶,每次用户栈切换系统栈时，会到这
	stack=task-&gt;thread.esp0
2.计算寄存器的实际地址
	stack += offset;//offset虽然解析时正值，但是会发生越界
3.返回栈中地址的值
	return (*((int *)stack))
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2906</x>
      <y>2918</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2874</x>
      <y>2879</y>
      <w>101</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_POKETEXT
PTRACE_POKEDATA
写用户数据段和代码段</panel_attributes>
    <additional_attributes>10.0;10.0;990.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2964</x>
      <y>2889</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>access_process_vm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2875</x>
      <y>2879</y>
      <w>121</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_POKEUSR</panel_attributes>
    <additional_attributes>10.0;10.0;1190.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2983</x>
      <y>2887</y>
      <w>27</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.filter和PTRACE_PEEKUSR相同
2.如果需要写寄存器（addr &lt; 17*sizeof(long)），
	通过putreg将数据写入
3.如果要写debugreg寄存器
	1.不能写4,5，
	2如果写0,1,2,3（&lt;4）需要data在用户空间
	3.如果是7,data的DR_CONTROL_RESERVED位清掉
		并且其数据需要使下列不成立
		((0x5f54 &gt;&gt; ((data &gt;&gt; (16 + 4*i)) &amp; 0xf)) &amp; 1)
	4.将addr转换之后，将data存入到thread中
		child-&gt;thread.debugreg[addr] = data
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2992</x>
      <y>2909</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>putreg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2996</x>
      <y>2905</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2976</x>
      <y>2916</y>
      <w>45</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果是FS，gs(低2位是3，可以是0)
	child-&gt;thread.fs = value
	child-&gt;thread.gs = value
	return 0;
2.如果是ds，es（低2位是3，可以是0），ss,cs(低2位是3，所以一定不能是0)
	只取低16位
3.如果是eflag，只取value &amp;= FLAG_MASK;其他位和get_stack_long中
	相同
4.换算regno在pt_regs中的offset，并通过put_stack_long填入到栈中
注：put_stack_long和get_stack_long，只不过这个是将data写入stack中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2998</x>
      <y>2912</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2875</x>
      <y>2879</y>
      <w>152</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_SYSCALL
PTRACE_CONT</panel_attributes>
    <additional_attributes>10.0;10.0;1500.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3015</x>
      <y>2884</y>
      <w>37</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.data要小于 _NSIG
2.如果是PTRACE_SYSCALL
	child-&gt;ptrace |= PT_TRACESYS
	如果不是，将其清掉
	child-&gt;ptrace &amp;= ~PT_TRACESYS
注：这将在每次sys_call时检测这个标志
3.child-&gt;exit_code = data;
4.将eflag中的TRAP_FLAG清掉，防止单步运行
	tmp = get_stack_long(child, EFL_OFFSET) &amp; ~TRAP_FLAG;
	put_stack_long(child, EFL_OFFSET,tmp);
5.唤醒子进程，返回0
	wake_up_process(child)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3038</x>
      <y>2909</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>syscall_trace
详情查看entry.S中的system_call
在PT_TRACESYS置上时，这个函数将会执行
注;在sys_call前后都会执行一次，会让用户查看sys_call返回值</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3032</x>
      <y>2916</y>
      <w>26</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.PT_PTRACED|PT_TRACESYS要置上
2.因为要使进程进sys_call时睡眠，所以stopped
	current-&gt;exit_code = SIGTRAP | ((current-&gt;ptrace &amp; PT_TRACESYSGOOD)
					? 0x80 : 0);
	current-&gt;state = TASK_STOPPED;
	notify_parent(current, SIGCHLD);
	schedule();
注:这里stopped，父进程可以查看其内存和寄存器
	例如可以将orig_eax设置为NR_syscalls，就可以跳过系统调用
3.醒来之后，检查current-&gt;exit_code，如果存在就给当前进程发
	send_sig(current-&gt;exit_code, current, 1);
	current-&gt;exit_code = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3044</x>
      <y>2912</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2874</x>
      <y>2879</y>
      <w>189</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_KILL</panel_attributes>
    <additional_attributes>10.0;10.0;1870.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3056</x>
      <y>2883</y>
      <w>28</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.进程的state不能是TASK_ZOMBIE
2. //疑问：此时只有child在syscall_trace中schedule了，才能将这个信号发送到child
	child-&gt;exit_code = SIGKILL;
	//取消单步运行
	tmp = get_stack_long(child, EFL_OFFSET) &amp; ~TRAP_FLAG;
	put_stack_long(child, EFL_OFFSET, tmp);
	wake_up_process(child);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2875</x>
      <y>2879</y>
      <w>226</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PTRACE_SINGLESTEP</panel_attributes>
    <additional_attributes>10.0;10.0;2240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3088</x>
      <y>2883</y>
      <w>25</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.data不能大于_NSIG
2.将sys_call的trace去掉
	child-&gt;ptrace &amp;= ~PT_TRACESYS
3.置上单步运行的标志
	child-&gt;ptrace |= PT_DTRACE;
	tmp = get_stack_long(child, EFL_OFFSET) | TRAP_FLAG;
	put_stack_long(child, EFL_OFFSET, tmp);
4.唤醒子进程
	child-&gt;exit_code = data;
	wake_up_process(child);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3532</x>
      <y>2363</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>sys_ipc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3539</x>
      <y>2367</y>
      <w>53</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MSGGET</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3585</x>
      <y>2380</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_msgget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3590</x>
      <y>2383</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3576</x>
      <y>2387</y>
      <w>39</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果自己收自己发（key == IPC_PRIVATE），通过newque
	申请一个报文队列
2.如果不是IPC_PRIVATE，通过ipc_findkey，寻找key
	如果没找到：
	1.如果IPC_CREAT没置上，返回ENOENT
	2.如果置上，通过newque申请报文队列
3.如果找到了key
	1.如果IPC_CREAT和IPC_EXCL（独享）都置上，返回EEXIST
	2.通过msg_lock获取报文队列msq（ids-&gt;entries[lid].p），并获取锁（ids-&gt;ary）
		通过ipcperms检查队列中key的权限是否和msgflg要求的相同
		如果相同就通过msg_buildid为其建一个标识号
注：整个过程通过msg_ids.sem保护
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3576</x>
      <y>2408</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>newque</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3582</x>
      <y>2405</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>100.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3567</x>
      <y>2415</y>
      <w>28</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.通过kmalloc申请msg_queue
注：msg_queue中的第一个元素就是kern_ipc_perm
	是数组指针entries指向的元素
2.通过ipc_addid在msg_ids.entries申请一个空闲位
	并将kern_ipc_perm装入entries
3.初始化msg_queue
	msq-&gt;q_perm.mode = (msgflg &amp; S_IRWXUGO);
	msq-&gt;q_perm.key = key;

	msq-&gt;q_stime = msq-&gt;q_rtime = 0;
	msq-&gt;q_ctime = CURRENT_TIME;
	msq-&gt;q_cbytes = msq-&gt;q_qnum = 0;
	msq-&gt;q_qbytes = msg_ctlmnb;
	msq-&gt;q_lspid = msq-&gt;q_lrpid = 0;
	INIT_LIST_HEAD(&amp;msq-&gt;q_messages);
	INIT_LIST_HEAD(&amp;msq-&gt;q_receivers);
	INIT_LIST_HEAD(&amp;msq-&gt;q_senders);
4.为了防止标识号在一段时间内重复，通过msg_buildid
	重构标识号：
	SEQ_MULTIPLIER*seq + id
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3580</x>
      <y>2411</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3563</x>
      <y>2451</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipc_addid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3568</x>
      <y>2447</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3551</x>
      <y>2458</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>grow_ary</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3570</x>
      <y>2458</y>
      <w>29</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.遍历entries，找到其中空闲的位，如果没找到，返回-1
2.更新msg_ids：
	ids-&gt;in_use++;
	//当id大于max_id
	ids-&gt;max_id = id
3.初始化kern_ipc_perm
	new-&gt;cuid = new-&gt;uid = current-&gt;euid;
	new-&gt;gid = new-&gt;cgid = current-&gt;egid;
	new-&gt;seq = ids-&gt;seq++;
	//如果seq&gt;seq_max
	ids-&gt;seq = 0
4.安装kern_ipc_perm
	spin_lock(&amp;ids-&gt;ary)
	ids-&gt;entries[id].p = new
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3569</x>
      <y>2454</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3555</x>
      <y>2454</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
要求扩充到size</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3537</x>
      <y>2464</y>
      <w>31</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.size最大只能是IPCMNI，并且不能缩小
2.通过ipc_alloc申请size大小的空间，valloc（&gt;1页）
	kalloc
3.通过memcpy将之前的entries复制到新申请的空间，并将其他
	空间赋值为0
4.保存之前的entries和size，并将新申请的数组赋值给entries
	old = ids-&gt;entries;
	ids-&gt;entries = new;
	i = ids-&gt;size;
	ids-&gt;size = newsize;
5.通过ipc_free释放旧的entries
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3556</x>
      <y>2461</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3600</x>
      <y>2409</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipc_findkey</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3596</x>
      <y>2406</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3597</x>
      <y>2415</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.遍历entries（最大是max_id）
	找到其中p.key是key的id
	否则返回-1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3605</x>
      <y>2412</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3625</x>
      <y>2408</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipcperms</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3604</x>
      <y>2405</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;20.0;260.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3621</x>
      <y>2414</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.将flag的u，g，o所有请求权限都集中在低3位
2.如果当前进程的euid和报文队列ipcp的cuid，uid相同，选取6~8位
	如果报文队列ipcp的cgid或者gid在当前进程的进程组中，选取3~5位
3.检查requested_mode和granted_mode是否存在不一致，或者进程有没有
	CAP_IPC_OWNER权限，当两者都不满足时返回-1，否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3631</x>
      <y>2411</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3448</x>
      <y>2367</y>
      <w>92</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MSGSND</panel_attributes>
    <additional_attributes>900.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3442</x>
      <y>2376</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_msgsnd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3432</x>
      <y>2379</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3410</x>
      <y>2384</y>
      <w>45</w>
      <h>51</h>
    </coordinates>
    <panel_attributes>1.0&lt;=msgsz(message size)&lt;=msg_ctlmax
	msqid(标识号)&gt;=0
2.通过get_user获取msgp-&gt;mtype，其值不能小于1
注：msgp是用户层传下的type和message
3.通过load_msg将msgp中的数据复制到msg中，并
	msg-&gt;m_type = mtype;
	msg-&gt;m_ts = msgsz;//msg_msg长度是整个链表数据的长度
4.通过msg_lock将ids-&gt;ary上锁，并获取报文队列msq
5.通过msg_checkid检查msqid是否符合ipcp-&gt;seq
	通过ipcperms检查当前进程对msq是否有写权限
6.如果报文队列满了（msgsz+q_cbytes&gt;q_qbytes
	1+q_qnum&gt;q_qbytes(队列中的message的size可能是0)）：
	1.如果要求不等待（IPC_NOWAIT）,解锁，返回EAGAIN退出
	2.如果要求等待，通过ss_add将msg_sender挂入到msq的发送等待队列
		并通过msg_unlock解锁后schedule
	3.醒来之后：
		current-&gt;state= TASK_RUNNING;
		msq = msg_lock(msqid)//上锁
		ss_del(&amp;s);//将msg_sender从msq的发送等待队列中移除
	4.如果检测到signal_pending，返回EINTR，
		否则重新执行5
7.通过pipelined_send检测msq中是否有等待接收msg的rcv，
	如果没有，将msg挂入到msq的q_messages中：
	list_add_tail(&amp;msg-&gt;m_list,&amp;msq-&gt;q_messages);
	msq-&gt;q_cbytes += msgsz;
	msq-&gt;q_qnum++;
	atomic_add(msgsz,&amp;msg_bytes);
	atomic_inc(&amp;msg_hdrs);
8.更新数据，并返回0
	msq-&gt;q_lspid = current-&gt;pid;
	msq-&gt;q_stime = CURRENT_TIME;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3393</x>
      <y>2439</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ss_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3385</x>
      <y>2446</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>mss-&gt;tsk=current;
current-&gt;state=TASK_INTERRUPTIBLE;
list_add_tail(&amp;mss-&gt;list,&amp;msq-&gt;q_senders);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3395</x>
      <y>2442</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3420</x>
      <y>2439</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pipelined_send</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3408</x>
      <y>2446</y>
      <w>25</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.遍历msq的接收等待队列q_receivers
	1.通过testmsg验证在相应的r_mode下
		msg的type和msr的r_msgtype条件是否满足
	2.如果不满足，遍历下一个。
		如果满足：
		1.通过list_del将接收等待者脱链
		2.如果msg的size大于接收者的r_maxsize，返回ERR_PTR(-E2BIG)
			并通过wake_up_process唤醒msr-&gt;r_tsk
		3.如果大小满足条件：
			msr-&gt;r_msg = msg;//将msg挂入到msr中
			msq-&gt;q_lspid = msr-&gt;r_tsk-&gt;pid;
			msq-&gt;q_rtime = CURRENT_TIME;
			wake_up_process(msr-&gt;r_tsk);
			return 1;
2.遍历完整个链表，没有接受者接收这个msg，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3424</x>
      <y>2442</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3364</x>
      <y>2439</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>load_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3344</x>
      <y>2446</y>
      <w>39</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.msg_msg管理的数据长度不能超过PAGE_SIZE-sizeof(struct msg_msg)
2.通过kmalloc申请管理结构msg和数据alen
	msg-&gt;next = NULL
3.通过copy_from_user复制用户数据到msg+1，并更新数据
	len -= alen;
	src = ((char*)src)+alen;
4.如果还有数据需要复制（说明1到了最大长度）
	1.需要通过kmalloc申请msg_msgseg和数据alen，并将管理结构加入到msg链表中
		*pseg = seg;
		seg-&gt;next = NULL;
	2.通过copy_from_user将数据复制到seg+1，并更新：
		pseg = &amp;seg-&gt;next;
		len -= alen;
		src = ((char*)src)+alen;
5.最后返回链表头msg
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3366</x>
      <y>2442</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3370</x>
      <y>2434</y>
      <w>48</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>460.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3398</x>
      <y>2434</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3415</x>
      <y>2434</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3499</x>
      <y>2367</y>
      <w>42</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MSGRCV</panel_attributes>
    <additional_attributes>400.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3495</x>
      <y>2386</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_msgrcv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3482</x>
      <y>2375</y>
      <w>36</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果call高16位是0：
	1.通过copy_from_user将用户层的ptr复制到ipc_kludge
	2.调用sys_msgrcv接收报文
2.否则，直接调用sys_msgrcv接收message
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3500</x>
      <y>2382</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3474</x>
      <y>2393</y>
      <w>47</w>
      <h>90</h>
    </coordinates>
    <panel_attributes>1.标识号不能小于0，要收的size不能小于0
2.通过convert_mode计算要接收的方式：
	1.如果msgtyp=0，SEARCH_ANY，任意message都收
	2.如果msgtyp&lt;0,SEARCH_LESSEQUAL,只有msg.m_type&lt;=-msgtyp才接收
	3.如果msgflg中MSG_EXCEPT置上，SEARCH_NOTEQUAL，只有msg.m_type！=msgtyp才接收
	4.除此之外，SEARCH_EQUAL，只有msg.m_type=msgtyp才接收
3.通过msg_lock得到报文队列msq，并上锁
4.通过ipcperms检查当前进程是否有msq的读权限S_IRUGO，没有返回EACCES
5.遍历报文队列的q_messages链表：
	1.通过testmsg检查在mode下msg.m_type和msgtyp是否符合条件
	2.如果符合条件：
		1.要求SEARCH_LESSEQUAL，如果msg-&gt;m_type不是最小（1）：
			//将msg定为暂时最优
			found_msg=msg;
			//继续查找更小的值
			msgtyp=msg-&gt;m_type-1;
		2.其他条件找到msg，直接退出
	3.如果没退出循环，继续查找链表
6.如果找到了message
	1.如果要接收的size小于message的size，并且MSG_NOERROR（不报错，允许截断）
		没置上，报E2BIG
	2.否则将msg脱链，并更新数据
		list_del(&amp;msg-&gt;m_list);//将msg脱链
		msq-&gt;q_qnum--;
		msq-&gt;q_rtime = CURRENT_TIME;
		msq-&gt;q_lrpid = current-&gt;pid;
		msq-&gt;q_cbytes -= msg-&gt;m_ts;
		atomic_sub(msg-&gt;m_ts,&amp;msg_bytes);
		atomic_dec(&amp;msg_hdrs);
		ss_wakeup(&amp;msq-&gt;q_senders,0);//唤醒msq的发送等待队列
		msg_unlock(msqid);//释放锁
	3.要收的长度是msgsz和msg-&gt;m_ts的最小值，通过put_user将msg-&gt;m_type
		存入到msgp，通过store_msg将数据存入到msgp
7.如果队列中没有对应的message：
	1.如果要求IPC_NOWAIT，返回ENOMSG
	2.通过list_add_tail将msr_d加入到msq的接收等待队列中
		msr_d.r_tsk = current;
		msr_d.r_msgtype = msgtyp;
		msr_d.r_mode = mode;	
		//当MSG_NOERROR置上是INT_MAX
		msr_d.r_maxsize = msgsz
		msr_d.r_msg = ERR_PTR(-EAGAIN);//默认返回EAGAIN，不是接收的到信息唤醒
		current-&gt;state = TASK_INTERRUPTIBLE;
		msg_unlock(msqid);
		schedule();
	3.如果醒来之后：
		1.current-&gt;state = TASK_RUNNING
		2.如果接收到msg（msr_d.r_msg），去6.3执行
		3.试图通过msg_lock获取锁和msq
			1.因为获取锁可能等待，需要再次检查msr_d.r_msg，如果收到了msg
				去6.3执行
			2.如果检测到是EAGAIN（不是接收msg唤醒）
				1.通过list_del将接收者msr_d从报文的接收等待队列中删除
				2.如果signal_pending，返回EINTR
				3.否则继续执行4
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3500</x>
      <y>2389</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3479</x>
      <y>2488</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ss_wakeup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3503</x>
      <y>2488</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>store_msg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3484</x>
      <y>2482</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3496</x>
      <y>2482</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3465</x>
      <y>2495</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.遍历msq的发送等待队列msq-&gt;q_senders
	通过wake_up_process唤醒队列中sender
	对应的mss-&gt;tsk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3480</x>
      <y>2491</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3506</x>
      <y>2491</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3497</x>
      <y>2494</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.遍历msg链表，将其中的内容，通过copy_to_user
	存放在用户空间
注：msg链表的具体结构参考load_msg
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3539</x>
      <y>2367</y>
      <w>147</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MSGCTL</panel_attributes>
    <additional_attributes>10.0;10.0;1450.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3676</x>
      <y>2381</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_msgctl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3665</x>
      <y>2388</y>
      <w>32</w>
      <h>58</h>
    </coordinates>
    <panel_attributes>IPC_INFO，MSG_INFO：
	memset(&amp;msginfo,0,sizeof(msginfo));	
	msginfo.msgmni = msg_ctlmni;
	msginfo.msgmax = msg_ctlmax;
	msginfo.msgmnb = msg_ctlmnb;
	msginfo.msgssz = MSGSSZ;
	msginfo.msgseg = MSGSEG
	msginfo.msgpool = msg_ids.in_use;
	msginfo.msgmap = atomic_read(&amp;msg_hdrs);
	msginfo.msgtql = atomic_read(&amp;msg_bytes);
	copy_to_user
MSG_STAT，IPC_STAT：
	kernel_to_ipc64_perm(&amp;msq-&gt;q_perm, &amp;tbuf.msg_perm);
	tbuf.msg_stime  = msq-&gt;q_stime;
	tbuf.msg_rtime  = msq-&gt;q_rtime;
	tbuf.msg_ctime  = msq-&gt;q_ctime;
	tbuf.msg_cbytes = msq-&gt;q_cbytes;
	tbuf.msg_qnum   = msq-&gt;q_qnum;
	tbuf.msg_qbytes = msq-&gt;q_qbytes;
	tbuf.msg_lspid  = msq-&gt;q_lspid;
	tbuf.msg_lrpid  = msq-&gt;q_lrpid;
	copy_msqid_to_user
IPC_SET:
	copy_msqid_from_user
	msq-&gt;q_qbytes = setbuf.qbytes;
	ipcp-&gt;uid = setbuf.uid;
	ipcp-&gt;gid = setbuf.gid;
	ipcp-&gt;mode = (ipcp-&gt;mode &amp; ~S_IRWXUGO) | 
		(S_IRWXUGO &amp; setbuf.mode);
	msq-&gt;q_ctime = CURRENT_TIME;
	//因为改变了msq的属性，需要唤醒接收和发送等待队列，重新检查
	expunge_all(msq,-EAGAIN);
	ss_wakeup(&amp;msq-&gt;q_senders,0)
IPC_RMID：释放msq
	freeque (msqid)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3680</x>
      <y>2384</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3659</x>
      <y>2450</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>expunge_all</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3686</x>
      <y>2451</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>freeque</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3663</x>
      <y>2445</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3679</x>
      <y>2445</y>
      <w>15</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3651</x>
      <y>2456</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.遍历msq的q_receivers链表：
	msr-&gt;r_msg = ERR_PTR(res);//res是传参
	wake_up_process(msr-&gt;r_tsk);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3662</x>
      <y>2453</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3676</x>
      <y>2458</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>msg_rmid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3676</x>
      <y>2465</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipc_rmid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3680</x>
      <y>2454</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3681</x>
      <y>2461</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3669</x>
      <y>2472</y>
      <w>26</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.检查标识号在entries中的位置id % SEQ_MULTIPLIER
	并提取msq
	p = ids-&gt;entries[lid].p;
	ids-&gt;entries[lid].p = NULL;
	ids-&gt;in_use--;
2.如果lid是max_id，需要为其重新选择max_id
	1.倒序遍历id（lid--）,直到找到第一个不为NULL的entry
		ids-&gt;max_id = lid;
3.返回msq
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3682</x>
      <y>2468</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3696</x>
      <y>2459</y>
      <w>27</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.唤醒接收等待队列，提醒id_remove
	expunge_all(msq,-EIDRM);
2.唤醒发送等待队列，并脱链
	ss_wakeup(&amp;msq-&gt;q_senders,1);
3.遍历q_messages链表：
	atomic_dec(&amp;msg_hdrs);
	free_msg(msg);
4.更新数据，并释放
	atomic_sub(msq-&gt;q_cbytes, &amp;msg_bytes);
	kfree(msq);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3690</x>
      <y>2454</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3540</x>
      <y>2367</y>
      <w>179</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SHMGET</panel_attributes>
    <additional_attributes>10.0;10.0;1770.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3712</x>
      <y>2380</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_shmget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3704</x>
      <y>2387</y>
      <w>37</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.如果IPC_PRIVATE，直接通过newseg申请shmid_kernel
2.通过ipc_findkey查看在shm_ids中是否找到key
	如果不能找到，
	1.如果IPC_CREAT没置，返回ENOENT
	2.如果置上，通过newseg申请shmid_kernel
	如果能找到
	1.如果IPC_CREAT置上，IPC_EXCL（独享）置上，返回EEXIST
	2.通过shm_lock在entries获取shp，并获取锁
	3.shp-&gt;shm_segsz要大于要获取的size
	4.通过ipcperms对比权限
	5.通过shm_buildid获取统一标识号
	6.通过shm_unlock释放锁
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3717</x>
      <y>2383</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3714</x>
      <y>2411</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>newseg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3719</x>
      <y>2407</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3720</x>
      <y>2414</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3704</x>
      <y>2418</y>
      <w>37</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.SHMMIN&lt;=size&lt;=shm_ctlmax
2.shm_tot+numpages(size的页大小)要小于shm_ctlall
3.通过kmalloc申请shmid_kernel结构shp
4.通过shmem_file_setup给shp分配file
5.通过shm_addid（ipc_addid）给shp分配统一标识号
6.初始化shp
	shp-&gt;shm_perm.key = key;
	shp-&gt;shm_flags = (shmflg &amp; S_IRWXUGO);
	shp-&gt;shm_cprid = current-&gt;pid;
	shp-&gt;shm_lprid = 0;
	shp-&gt;shm_atim = shp-&gt;shm_dtim = 0;
	shp-&gt;shm_ctim = CURRENT_TIME;
	shp-&gt;shm_segsz = size;
	shp-&gt;shm_nattch = 0;
	shp-&gt;id = shm_buildid(id,shp-&gt;shm_perm.seq);
	shp-&gt;shm_file = file;
	file-&gt;f_dentry-&gt;d_inode-&gt;i_ino = shp-&gt;id;
	file-&gt;f_op = &amp;shm_file_operations;
	shm_tot += numpages;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3731</x>
      <y>2454</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shmem_file_setup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3726</x>
      <y>2449</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3667</x>
      <y>2336</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_shmem_fs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3652</x>
      <y>2344</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3658</x>
      <y>2339</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历file_systems链表
看有没有shmem_fs_type
没有就将其挂入到链表</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3680</x>
      <y>2346</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kern_mount
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3670</x>
      <y>2339</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1.获取设备号get_unnamed_dev
2.read_super
3.add_vfsmnt，</panel_attributes>
    <additional_attributes>50.0;10.0;150.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3725</x>
      <y>2461</y>
      <w>33</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.通过vm_enough_memory验证有没有足够的物理内存供共享内存
2.申请dentry
	//kern_mount中将root赋值
	root = shmem_fs_type.kern_mnt-&gt;mnt_root;
	dentry = d_alloc(root, &amp;this);
3.通过get_empty_filp申请file
4.通过shmem_get_inode获取inode
5.初始化dentry，file
	//将dentry和inode挂钩
	d_instantiate(dentry, inode);
	dentry-&gt;d_inode-&gt;i_size = size;
	file-&gt;f_vfsmnt = mntget(shmem_fs_type.kern_mnt);
	file-&gt;f_dentry = dentry;
	file-&gt;f_op = &amp;shmem_file_operations;
	file-&gt;f_mode = FMODE_WRITE | FMODE_READ;
	inode-&gt;i_nlink = 0;	/* It is unlinked */
	return(file);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3737</x>
      <y>2457</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3735</x>
      <y>2492</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shmem_get_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3740</x>
      <y>2488</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3726</x>
      <y>2499</y>
      <w>32</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.检查有没有空闲inode，并递减
	sb-&gt;u.shmem_sb.free_inodes--;
2.通过new_inode申请inode
3.初始化inode
	inode-&gt;i_mode = mode;
	inode-&gt;i_uid = current-&gt;fsuid;
	inode-&gt;i_gid = current-&gt;fsgid;
	inode-&gt;i_blksize = PAGE_CACHE_SIZE;
	inode-&gt;i_blocks = 0;
	inode-&gt;i_rdev = to_kdev_t(dev);
	inode-&gt;i_mapping-&gt;a_ops = &amp;shmem_aops;
	inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;
	spin_lock_init (&amp;inode-&gt;u.shmem_i.lock);
	S_IFREG：
	inode-&gt;i_op = &amp;shmem_inode_operations;
	inode-&gt;i_fop = &amp;shmem_file_operations;
	S_IFDIR：
	inode-&gt;i_op = &amp;shmem_dir_inode_operations;
	inode-&gt;i_fop = &amp;shmem_dir_operations;
	S_IFLNK：
	inode-&gt;i_op = &amp;page_symlink_inode_operations;
	其他：
	init_special_inode(inode, mode, dev);
4.将inode挂入到shmem_inodes链表中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3740</x>
      <y>2495</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3752</x>
      <y>2379</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_shmat</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3539</x>
      <y>2367</y>
      <w>222</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SHMAT</panel_attributes>
    <additional_attributes>10.0;10.0;2200.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3744</x>
      <y>2386</y>
      <w>36</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.标识号不能小于0
2.	如果指定了映射的地址shmaddr
	1.如果没按页对齐：
		如果SHM_RND（自动调整）置上，
		addr &amp;= ~(SHMLBA-1)
		如果没置上：返回EINVAL
	2.flags = MAP_SHARED | MAP_FIXED//fixed表示map地址固定
	如果没指定地址(shmaddr为0)
	flags = MAP_SHARED;
3.转换shmflg的权限
4.通过shm_lock获取shp，并上锁
5.通过ipcperms验证当前进程对shp的权限
6.获取file
	file = shp-&gt;shm_file;
	shp-&gt;shm_nattch++;
7.通过do_mmap获取虚存空间（current-&gt;mm-&gt;mmap_sem保护）
8.将shp的attach计数递减
	shp-&gt;shm_nattch--
	如果减到0，并且SHM_DEST置上，通过shm_destroy将shp释放
9.raddr返回map的地址
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3758</x>
      <y>2382</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3749</x>
      <y>2422</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shm_mmap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3754</x>
      <y>2418</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
do_mmap-&gt;do_mmap_pgoff-&gt;
file-&gt;f_op-&gt;mmap(shm_file_operations)</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3744</x>
      <y>2429</y>
      <w>25</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.通过UPDATE_ATIME更新inode-&gt;i_atime
	并且其中利用mark_inode_dirty_sync
	将inode置上I_DIRTY_SYNC
2.vma-&gt;vm_ops = &amp;shm_vm_ops;//do_page_fault中用
3.通过shm_inc递增attache计数
	shp-&gt;shm_atim = CURRENT_TIME;
	shp-&gt;shm_lprid = current-&gt;pid;
	shp-&gt;shm_nattch++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3754</x>
      <y>2425</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3776</x>
      <y>2422</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shm_destroy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3769</x>
      <y>2418</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3773</x>
      <y>2429</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>shm_tot -= (shp-&gt;shm_segsz + PAGE_SIZE - 1) &gt;&gt; PAGE_SHIFT;
shm_rmid (shp-&gt;id);
fput (shp-&gt;shm_file);
kfree (shp)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3782</x>
      <y>2425</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3770</x>
      <y>2447</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shmem_nopage</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3757</x>
      <y>2443</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
do_no_page-&gt;
vma-&gt;vm_ops-&gt;nopage(shm_vm_ops)</panel_attributes>
    <additional_attributes>50.0;10.0;200.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3763</x>
      <y>2454</y>
      <w>41</w>
      <h>59</h>
    </coordinates>
    <panel_attributes>1.计算访问的地址在文件中的页偏移
	idx = (address - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT;
	idx += vma-&gt;vm_pgoff;//vm_pgoffi是start在file中的页偏移
2.在vm_mm是当前进程的mm时，要访问的页不能大于inode的size，vma
3.通过__find_lock_page在page_hash_table中查找page
4.如果找到，跳到6
	如果没找到，通过shmem_swp_entry勋在在设备上的entry：
	1.如果entry-&gt;val不为零：
		1.首先通过lookup_swap_cache查找页面是否在交换队列swapper_space中
		2.如果没找到，去交换盘中将page读进内存
			swapin_readahead(*entry);
			page = read_swap_cache(*entry);
		3.将page从swapper_space移除
			swap_free(*entry);
			lock_page(page);
			delete_from_swap_cache_nolock(page);
			*entry = (swp_entry_t) {0};
		4.将page加入到inode-&gt;i_mapping中：
			flags = page-&gt;flags &amp; ~((1 &lt;&lt; PG_uptodate) | (1 &lt;&lt; PG_error) | (1 &lt;&lt; PG_referenced) | (1 &lt;&lt; PG_arch_1));
			page-&gt;flags = flags | (1 &lt;&lt; PG_dirty);
			add_to_page_cache_locked(page, mapping, idx);
			info-&gt;swapped--;
	2.如果entry-&gt;val为零,表示没有交换到盘上，需要从内存重新申请;
		inode-&gt;i_sb-&gt;u.shmem_sb.free_blocks--
		page = page_cache_alloc();
		clear_user_highpage(page, address);
		inode-&gt;i_blocks++;
		add_to_page_cache (page, mapping, idx);
5.将page uptodate
	SetPageUptodate
6.如果不要求共享（no_share）
	new_page = page_cache_alloc
	copy_user_highpage(new_page, page, address)
	page_cache_release(page);
	return new_page;
7.如果要求共享，返回page
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3776</x>
      <y>2450</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3764</x>
      <y>2517</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>shmem_swp_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3761</x>
      <y>2524</y>
      <w>26</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果是直接映射（SHMEM_NR_DIRECT），
	返回info-&gt;i_direct+index
2.如果SHMEM_NR_DIRECT&lt; index&lt;ENTRIES_PER_PAGE*ENTRIES_PER_PAGE
	如果i_indirect为NULL,先为其分配get_zeroed_page
	如果i_indirect[index/ENTRIES_PER_PAGE]为NULL,也先为其分配get_zeroed_page
注：i_direct是数组，i_indirect又为其分配零页
	所以返回的entry地址必定存在，只不过里面的内容可能是零
3.返回index在i_indirect中的间接引用
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3770</x>
      <y>2520</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3769</x>
      <y>2512</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3540</x>
      <y>2367</y>
      <w>263</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SHMDT</panel_attributes>
    <additional_attributes>10.0;10.0;2610.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3794</x>
      <y>2376</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_shmdt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3786</x>
      <y>2383</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.遍历vma链表（current-&gt;mm.mmap），
	其vm_ops要是shm_vm_ops
	要释放的地址shmaddr=vm_start-vm_pgoff(vm_pgoff在sys_shmat中为0)
	满足以上两个条件，通过do_munmap将vma释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3800</x>
      <y>2379</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3824</x>
      <y>2374</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_shmctl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3829</x>
      <y>2377</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3820</x>
      <y>2381</y>
      <w>30</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.SHM_LOCK/SHM_UNLOCK
	1.进程要有CAP_IPC_LOCK
	2.shm_lock获取shp，并上锁
	3.shm_checkid检查标识号
	4.SHM_LOCK：
		shp-&gt;shm_file-&gt;f_dentry-&gt;d_inode-&gt;u.shmem_i.locked = 1;
		shp-&gt;shm_flags |= SHM_LOCKED;
	SHM_UNLOCK：
		shp-&gt;shm_file-&gt;f_dentry-&gt;d_inode-&gt;u.shmem_i.locked = 0;
		shp-&gt;shm_flags &amp;= ~SHM_LOCKED;
	5.通过	shm_unlock解锁shp
2.其他的和sys_msgctl相似
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3540</x>
      <y>2367</y>
      <w>291</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SHMCTL</panel_attributes>
    <additional_attributes>10.0;10.0;2890.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3539</x>
      <y>2367</y>
      <w>334</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SEMGET</panel_attributes>
    <additional_attributes>10.0;10.0;3320.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3864</x>
      <y>2373</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_semget</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3864</x>
      <y>2380</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>newary</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3869</x>
      <y>2376</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
其他和MSGGET相似
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3855</x>
      <y>2387</y>
      <w>33</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.如果要申请的这组信号量的数目nsems是0，返回EINVAL
2.如果用的信号量的数目（used_sems + nsems）超过了
	sc_semmns，返回ENOSPC
3.通过ipc_alloc申请sma和nsems个信号量的内存空间
	并清0
注：为了防止死锁，用户每次申请信号量是所有的信号量一起申请
4.通过ipc_addid在sem_ids中找到空闲的entry
5.更新并初始化：
	used_sems += nsems;
	sma-&gt;sem_perm.mode = (semflg &amp; S_IRWXUGO);
	sma-&gt;sem_perm.key = key;
	//sma后面紧接着就是sem
	sma-&gt;sem_base = (struct sem *) &amp;sma[1];
	/* sma-&gt;sem_pending = NULL; */
	sma-&gt;sem_pending_last = &amp;sma-&gt;sem_pending;
	/* sma-&gt;undo = NULL; */
	sma-&gt;sem_nsems = nsems;
	sma-&gt;sem_ctime = CURRENT_TIME;
6.通过sem_buildid生成统一标识号
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3869</x>
      <y>2383</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3539</x>
      <y>2367</y>
      <w>375</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SEMOP</panel_attributes>
    <additional_attributes>10.0;10.0;3730.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3906</x>
      <y>2372</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_semop</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3911</x>
      <y>2375</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3892</x>
      <y>2379</y>
      <w>63</w>
      <h>77</h>
    </coordinates>
    <panel_attributes>1.	1&lt;nsops&lt;sc_semopm,semid&gt;=0
2.当nsops&gt;SEMOPM_FAST时，就不用栈上的空间了
	需要通过kmalloc申请到nsops个sembuf的内存
3.将用户层想要申请的一组信号量tsops通过copy_from_user
	复制到sops
4.通过sem_lock获取sma并上锁，并通过sem_checkid检查标识号
5.遍历sops数组，记录其中的SEM_UNDO的数量undos，是否申请decrease
	是否释放alter，最后alter表示是否改变（lter |= decrease）
注：SEM_UNDO：是进程exit之后，如果没将信号量释放，内核会自动释放(sem_exit)
6.通过ipcperms验证当前进程的权限，如果要申请或者释放，需要写
	否则只需要读
7.遍历进程的current-&gt;semundo链表(proc_next链接)，
	1.如果semid为-1，通过freeundos释放（因为semundo是单向链表，所以需要重新遍历链表，然后再将其从链表中删除）
	2.如果semid和现在要申请的相同，即找到，退出循环
	3.如果遍历完整个链表都没找到，通过alloc_undo申请sem_undo
8.通过try_atomic_semop申请释放信号量（do_undo是0，表示不是查询，是真实的想申请）
9.如果申请到了，去update处处理sma的等待链表
	如果没申请到，初始化queue，并加入到sma的sem_pending链表中
	queue.sma = sma;
	queue.sops = sops;
	queue.nsops = nsops;
	queue.undo = un;
	queue.pid = current-&gt;pid;
	queue.alter = decrease;
	queue.id = semid;
	如果alter（信号量改变），append_to_queue尾插至链表（sem_pending_last指向最后一个箭头，q-&gt;prev指向（指向自己的）箭头）
	否则通过prepend_to_queue头插至链表
	current-&gt;semsleeping = &amp;queue;
10.循环等待信号量：
	1.让进程睡眠：
		//默认返回状态是EINTR
		queue.status = -EINTR;
		queue.sleeper = current;
		current-&gt;state = TASK_INTERRUPTIBLE;
		sem_unlock(semid);
		schedule();
	2.进程醒来时：
		1.通过sem_lock获取sma，如果没获取到，说明是因为sma被释放唤醒，此时queue.status=EIDRM
		2.queue.status为1，表示是在其他进程update_queue时，试着给当前进程申请信号量成功
			所以通过try_atomic_semop真正去申请，如果成功，退出循环；如果失败，继续循环1
		3.queue.status不为1时：
			1.如果queue.prev存在，所以queue在sem_pending链表中，所以是信号唤醒，所以退出等待，通过remove_from_queue将queue移除队列
			，处理信号
			2.如果不在链表中，只有可能是其他进程在update_queue时，为其申请信号量时出错，remove_from_queue
				所以返回queue.status（这里因为在update_queue中已经移除了queue，所以不用再移除）
11.如果能正常申请到信号量（或者信号唤醒？）	，如果信号量发生了改变（alter），通过update_queue
	去唤醒sem_pending链表中的等待队列	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3885</x>
      <y>2461</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_undo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3891</x>
      <y>2455</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3875</x>
      <y>2469</y>
      <w>25</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.通过kmalloc申请sem_undo管理结构，和其semadj
	数组（sma-&gt;sem_nsems个元素），并清0
2.因为kmalloc有可能睡，所以通过sem_revalidate重新检查
	sma，标识号，权限
3.初始化：
	//exit后要调整的值
	un-&gt;semadj = (short *) &amp;un[1];
	un-&gt;semid = semid;
	//头插至current-&gt;semundo链表中
	un-&gt;proc_next = current-&gt;semundo;
	current-&gt;semundo = un;
	//头插至sma-&gt;undo链表中
	un-&gt;id_next = sma-&gt;undo;
	sma-&gt;undo = un;
	//返回值
	*unp = un;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3886</x>
      <y>2464</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3908</x>
      <y>2462</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>try_atomic_semop</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3912</x>
      <y>2455</y>
      <w>3</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3902</x>
      <y>2469</y>
      <w>27</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.遍历数组sops，找到数组在sma中对应的sem
	curr = sma-&gt;sem_base + sop-&gt;sem_num;
	1.如果要申请的信号量sem_op为0，并且sem存在可申请的值semval
	将其block（为什么？）
	2.curr-&gt;sempid低16位记入最新申请的进程
		curr-&gt;sempid = (curr-&gt;sempid &lt;&lt; 16) | pid;
		//申请释放信号量
		curr-&gt;semval += sem_op;
		//SEM_UNDO
		un-&gt;semadj[sop-&gt;sem_num] -= sem_op;
	3.如果申请信号量之后semval &lt; 0将会block
		如果semval&gt;SEMVMX,将会返回ERANGE
2.如果do_undo置上，将会将所有申请的信号量还原，只是为了
	尝试申请，看是否能申请到
注：如果block：
		1.如果IPC_NOWAIT置上，则返回EAGAIN，否则返回1
	如果出错，或者block，或者do_undo，
		1.都会将其申请的信号量，记入的pid，以及进程记入的undo还原

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3914</x>
      <y>2465</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3932</x>
      <y>2462</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>update_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3934</x>
      <y>2456</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3931</x>
      <y>2469</y>
      <w>28</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.遍历sem_pending链表：
	1.如果queue能申请到（q-&gt;status == 1），直接跳过
	2.通过try_atomic_semop试图（在要改变信号量时q-&gt;alter）为其申请信号量
	3.如果申请成功或者出错：
		1.通过wake_up_process唤醒进程
		2.如果申请成功，并且需要改变（q-&gt;alter）
			q-&gt;status = 1;
		注：1.这里没有将queue从链表中移除
			 2.这里只要能申请成功，就直接返回，所以使用的队列的方式，和进程的优先级没关系
		3.如果出错，移除queue，并继续循环
			q-&gt;status = error;
			remove_from_queue(sma,q);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3939</x>
      <y>2465</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3539</x>
      <y>2367</y>
      <w>437</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SEMCTL</panel_attributes>
    <additional_attributes>10.0;10.0;4350.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3968</x>
      <y>2372</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_semctl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3961</x>
      <y>2379</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>SETVAL：给单个信号量设置semval
SETALL：给sma这组所有的信号量设置semval
GETALL：获取sma这组所有的信号量semval
GETNCNT：获取sma中因为某个信号量因获取信号量被pending的queue数目
注：其他和sys_msgctl类似，参考代码
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3973</x>
      <y>2375</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3942</x>
      <y>2745</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_socketcall</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3260</x>
      <y>2748</y>
      <w>690</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_SOCKET</panel_attributes>
    <additional_attributes>6880.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3255</x>
      <y>2765</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_socket</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3242</x>
      <y>2772</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3246</x>
      <y>2768</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3233</x>
      <y>2779</y>
      <w>30</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.域：0&lt;=family&lt;NPROTO
2.将(PF_INET,SOCK_PACKET)转换成PF_PACKET
3.如果net_families[family]为空，利用request_module请求模块，如果还为空返回EAFNOSUPPORT
4.通过sock_alloc申请inode（socket是inode内的结构）
	sock-&gt;type  = type;
5.调用 net_families[family]-&gt;create创建socket
6.*res = sock
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3246</x>
      <y>2775</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3232</x>
      <y>2795</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3235</x>
      <y>2791</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3218</x>
      <y>2802</y>
      <w>30</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.通过sock_alloc获取inode
2.初始化inode
	inode-&gt;i_sb = sock_mnt-&gt;mnt_sb;//sock_mnt在sock_init中被kern_mount
	sock = socki_lookup(inode);//sock为inode中的union结构
	inode-&gt;i_mode = S_IFSOCK|S_IRWXUGO;
	inode-&gt;i_sock = 1;
	inode-&gt;i_uid = current-&gt;fsuid;
	inode-&gt;i_gid = current-&gt;fsgid;
3.初始化sock
	sock-&gt;inode = inode;
	init_waitqueue_head(&amp;sock-&gt;wait);
	sock-&gt;fasync_list = NULL;
	sock-&gt;state = SS_UNCONNECTED;
	sock-&gt;flags = 0;
	sock-&gt;ops = NULL;
	sock-&gt;sk = NULL;
	sock-&gt;file = NULL;
	sockets_in_use[smp_processor_id()].counter++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3236</x>
      <y>2798</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3253</x>
      <y>2795</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>net_families[family]-&gt;create
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3248</x>
      <y>2791</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3262</x>
      <y>2798</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
 unix_family_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3257</x>
      <y>2802</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3253</x>
      <y>2809</y>
      <w>31</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果protocol存在，就必须是PF_UNIX
	不存在默认是PF_UNIX
2.默认是unconnected
	sock-&gt;state = SS_UNCONNECTED
3.sock-&gt;type：
	SOCK_STREAM：sock-&gt;ops = &amp;unix_stream_ops
	SOCK_RAW-&gt;SOCK_DGRAM:sock-&gt;ops = &amp;unix_dgram_ops
4.通过unix_create1申请sock结构
注：socket和sock一一对应
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3263</x>
      <y>2805</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3261</x>
      <y>2827</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_create1</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3266</x>
      <y>2824</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3266</x>
      <y>2830</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3254</x>
      <y>2833</y>
      <w>32</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.unix_nr_socks不能超过2*files_stat.max_files
2.通过sk_alloc申请sk
	1.在sk_cachep中申请
	2.如果zero_it置上：
		memset(sk, 0, sizeof(struct sock));
		sk-&gt;family = family;
		sock_lock_init(sk);
3.增加unix_nr_socks计数
4.sock_init_data初始化sk：
	skb_queue_head_init(&amp;sk-&gt;receive_queue);
	skb_queue_head_init(&amp;sk-&gt;write_queue);
	skb_queue_head_init(&amp;sk-&gt;error_queue);
	init_timer(&amp;sk-&gt;timer);
	sk-&gt;rcvbuf	=	sysctl_rmem_default;
	sk-&gt;sndbuf	=	sysctl_wmem_default;
	sk-&gt;state_change	=	sock_def_wakeup;
	sk-&gt;data_ready		=	sock_def_readable;
	...
5.继续初始化sk
	sk-&gt;write_space		=	unix_write_space;

	sk-&gt;max_ack_backlog = sysctl_unix_max_dgram_qlen;
	sk-&gt;destruct = unix_sock_destructor;
	sk-&gt;protinfo.af_unix.dentry=NULL;
	sk-&gt;protinfo.af_unix.mnt=NULL;
	sk-&gt;protinfo.af_unix.lock = RW_LOCK_UNLOCKED;
	atomic_set(&amp;sk-&gt;protinfo.af_unix.inflight, 0);
	//信号量设置为1
	init_MUTEX(&amp;sk-&gt;protinfo.af_unix.readsem);/* single task reading lock */
	init_waitqueue_head(&amp;sk-&gt;protinfo.af_unix.peer_wait);
	sk-&gt;protinfo.af_unix.list=NULL;
6.通过unix_insert_socket将sk加入到hash表中，这里加到unix_socket_table
	最后一个中（容纳unbound）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3264</x>
      <y>2876</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_insert_socket</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3269</x>
      <y>2872</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3257</x>
      <y>2882</y>
      <w>27</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.sk-&gt;protinfo.af_unix.list指向hash头
	sk-&gt;protinfo.af_unix.list = list
2.将sk头插至hash中
	sk-&gt;prev = NULL;
	sk-&gt;next = *list;
	if (*list)
		(*list)-&gt;prev = sk;
	*list=sk;
3.通过sock_hold递增refcnt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3268</x>
      <y>2879</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3270</x>
      <y>2773</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_map_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3260</x>
      <y>2768</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3267</x>
      <y>2780</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过get_unused_fd从当前进程的open_fds位图中获取空闲fd
2.通过get_empty_filp获取file结构体
3.通过d_alloc给file-&gt;f_dentry申请dentry，注意这里的parent是sock_mnt-&gt;mnt_sb-&gt;s_root
4.初始化file，并将dentry和inode关联
	file-&gt;f_dentry-&gt;d_op = &amp;sockfs_dentry_operations;
	d_add(file-&gt;f_dentry, sock-&gt;inode);
	file-&gt;f_vfsmnt = mntget(sock_mnt);

	sock-&gt;file = file;
	file-&gt;f_op = sock-&gt;inode-&gt;i_fop = &amp;socket_file_ops;
	file-&gt;f_mode = 3;
	file-&gt;f_flags = O_RDWR;
	file-&gt;f_pos = 0;
5.通过fd_install将file安装在fd处，并返回fd
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3276</x>
      <y>2776</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3344</x>
      <y>2766</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_bind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3348</x>
      <y>2748</y>
      <w>603</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_BIND</panel_attributes>
    <additional_attributes>6010.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3318</x>
      <y>2774</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sockfd_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3323</x>
      <y>2769</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3315</x>
      <y>2781</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过fget获取file（增加了file的计数）
2.找到file中的inode（i_sock标志位要存在），
	并通过socki_lookup找到inode中的uion--socket结构
3.检查socket中的file指针是否指向该file
	（sock_map_fd中关联）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3323</x>
      <y>2777</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3344</x>
      <y>2775</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>move_addr_to_kernel</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3341</x>
      <y>2781</y>
      <w>25</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.要复制的长度0&lt;=ulen&lt;=ulen
2.如果长度ulen是0，直接返回0，不bind
3.通过copy_from_user复制地址（包括sa_family）
	到内核
注：kernel的内存是在栈上申请的MAX_SOCK_ADDR字节的地址
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3348</x>
      <y>2769</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3351</x>
      <y>2778</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3351</x>
      <y>2769</y>
      <w>57</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放socket.file</panel_attributes>
    <additional_attributes>10.0;10.0;550.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3400</x>
      <y>2775</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sockfd_put</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3385</x>
      <y>2776</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;bind
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3350</x>
      <y>2769</y>
      <w>43</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果需要bind</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3374</x>
      <y>2784</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_bind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3375</x>
      <y>2779</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops/unix_dgram_ops</panel_attributes>
    <additional_attributes>160.0;10.0;60.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3347</x>
      <y>2791</y>
      <w>54</w>
      <h>59</h>
    </coordinates>
    <panel_attributes>1.获取sk：
	sk = sock-&gt;sk
2.以sockaddr_un解析用户层传来的地址
3.用户传来的sun_family必须是AF_UNIX
4.如果传来的长度addr_len是short，表示是自动分配地址
	通过unix_autobind完成
5.通过unix_mkname解析name，并计算hash
 //readsem临界区
6.如果sk的早就bind（sk-&gt;protinfo.af_unix.addr），返回EINVAL
7.通过kmalloc申请unix_address和其name（sockaddr_un）的内存空间，并初始化：
	memcpy(addr-&gt;name, sunaddr, addr_len);
	addr-&gt;len = addr_len;
	addr-&gt;hash = hash^sk-&gt;type;
	atomic_set(&amp;addr-&gt;refcnt, 1);
8.如果是普通地址：
	1.通过path_init和path_walk找到传来地址（sun_path）的父目录（sun_path）
	2.最后一个元素要是LAST_NORM
	3.通过lookup_hash找到文件的dentry，不管有没有找到都会返回dentry，没找到dentry中的inode会是NULL
	4.如果是文件夹（最后一个字节是/），其inode要存在
	5.通过vfs_mknod创建socket的inode
		inode-&gt;i_fop = &amp;bad_sock_fops;
	注：这里没把dentry挂入到hash表中，所以不能用fops的open打开，不然会有两个inode
	6.替换nd下的dentry为socket的dentry
		dput(nd.dentry);
		nd.dentry = dentry;
	7.以inode的i_ino为hash值选择在unix_socket_table中的链表list，并将其dentry和mnt赋给sk
		sk-&gt;protinfo.af_unix.dentry = nd.dentry;
		sk-&gt;protinfo.af_unix.mnt = nd.mnt;
9.如果是抽象地址（!sun_path[0]）
	1.通过__unix_find_socket_byname遍历unix_socket_table中对应的链表（注意：其hash值在前面有对type异或）
		查找其中有没有name相同的sk
	2.如果有，释放addr，并退出。如果没有选择在unix_socket_table中的链表（addr-&gt;hash）
10.通过__unix_remove_socket将sk移除hash表，
11.赋值addr
	sk-&gt;protinfo.af_unix.addr = addr;
12.将sk通过__unix_insert_socket加到对应的hash中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3380</x>
      <y>2787</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3342</x>
      <y>2854</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_autobind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3369</x>
      <y>2855</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_mkname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3361</x>
      <y>2862</y>
      <w>28</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.len如果不在sizeof(short)~sizeof(*sunaddr)之间，返回EINVAL
2.如果sunaddr不存在，或者sun_family不是AF_UNIX，返回EINVAL
3.如果是普通地址（首字节不是0）
	1.在sun_path最后一位添0，使其字符串结束
	2.返回的长度是:地址字符串的长度+sun_family长度
4.如果是抽象地址（首字节是0），通过unix_hash_fold对其checksum(csum_partial)
	计算hash，返回len是传进来的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3374</x>
      <y>2858</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3397</x>
      <y>2855</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__unix_remove_socket</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3393</x>
      <y>2862</y>
      <w>25</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.找到sk挂载的hash表
	list = sk-&gt;protinfo.af_unix.list
2.先和前后断开
	if (sk-&gt;next)
		sk-&gt;next-&gt;prev = sk-&gt;prev;
	if (sk-&gt;prev)
		sk-&gt;prev-&gt;next = sk-&gt;next;
3.如果是list的第一个，指向下一个
	if (*list == sk)
		*list = sk-&gt;next;
4.还原，并释放sk
	sk-&gt;protinfo.af_unix.list = NULL;
	sk-&gt;prev = NULL;
	sk-&gt;next = NULL;
	__sock_put(sk);//递减refcnt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3403</x>
      <y>2858</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3374</x>
      <y>2849</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3369</x>
      <y>2849</y>
      <w>6</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3347</x>
      <y>2849</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3331</x>
      <y>2862</y>
      <w>29</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.sk-&gt;protinfo.af_unix.addr不能存在
2.通过kmalloc申请unix_address+sockaddr_un（name是16字节）
	内存，并清0
3.初始化addr
	addr-&gt;name-&gt;sun_family = AF_UNIX;
	atomic_set(&amp;addr-&gt;refcnt, 1);
	addr-&gt;len（长度是ordernum+1+sizeof(short)，首字节是0）
	addr-&gt;hash = unix_hash_fold
4.递增ordernum = (ordernum+1)&amp;0xFFFFF
5.通过__unix_find_socket_byname寻找hash中有没有对应的sk
	如果有，再次计算len，hash
6.真实hash
	addr-&gt;hash ^= sk-&gt;type;
7.地址，挂载hash
	__unix_remove_socket(sk);
	sk-&gt;protinfo.af_unix.addr = addr;
	__unix_insert_socket(&amp;unix_socket_table[addr-&gt;hash], sk);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3346</x>
      <y>2857</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3492</x>
      <y>2748</y>
      <w>459</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_LISTEN</panel_attributes>
    <additional_attributes>4570.0;10.0;10.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3487</x>
      <y>2765</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_listen</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3484</x>
      <y>2772</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过sockfd_lookup依据fd找到sock
2.backlog最大只能是SOMAXCONN
3.通过sock-&gt;ops-&gt;listen监听sock
4.通过sockfd_put将file释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3493</x>
      <y>2768</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3490</x>
      <y>2783</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;listen
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3495</x>
      <y>2779</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3495</x>
      <y>2786</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3490</x>
      <y>2790</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_listen</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3481</x>
      <y>2797</y>
      <w>31</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.sock类型必须是“有链接”（SOCK_STREAM）
2.bind了socket地址（sk-&gt;protinfo.af_unix.addr）
3.要是TCP_CLOSE（sock刚建立），或者TCP_LISTEN（已经设置成serve，链接没建立）
	才能调用
4.如果扩大其队列长度（backlog），唤醒等待挂入队列的进程
	wake_up_interruptible_all(&amp;sk-&gt;protinfo.af_unix.peer_wait)
5.设置队列长度和状态：
	sk-&gt;max_ack_backlog=backlog;
	sk-&gt;state=TCP_LISTEN;
6.设置sk主：
	sk-&gt;peercred.pid = current-&gt;pid;
	sk-&gt;peercred.uid = current-&gt;euid;
	sk-&gt;peercred.gid = current-&gt;egid
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3495</x>
      <y>2793</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3594</x>
      <y>2764</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_accept</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3598</x>
      <y>2748</y>
      <w>353</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_ACCEPT</panel_attributes>
    <additional_attributes>3510.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3587</x>
      <y>2770</y>
      <w>37</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.根据fd通过sockfd_lookup查找sock
2.通过sock_alloc重新申请一个newsock（新inode）
	newsock-&gt;type = sock-&gt;type;
	newsock-&gt;ops = sock-&gt;ops;
3.通过sock-&gt;ops-&gt;accept接收链接
4.如果要求返回client地址（upeer_sockaddr），通过
	newsock-&gt;ops-&gt;getname获取
5.通过move_addr_to_user将地址和长度复制到用户空间
6.通过sock_map_fd为newsock分配新的fd，file，dentry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3599</x>
      <y>2767</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3595</x>
      <y>2789</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;accept
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3595</x>
      <y>2796</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_accept</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3600</x>
      <y>2792</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3600</x>
      <y>2799</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3583</x>
      <y>2803</y>
      <w>37</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.要是“有链接”（SOCK_STREAM），否则返回EOPNOTSUPP
2.要处于TCP_LISTEN，否则返回EINVAL
3.通过skb_recv_datagram接收控制请求
4.通过skb_free_datagram将sk_buff（skb）释放
5.通过wake_up_interruptible唤醒因为投递报文超过backlog
	而睡眠的进程（sk-&gt;protinfo.af_unix.peer_wait）
6.设置newsock的状态，并通过sock_graft将newsock和
	client的sk关联
	newsock-&gt;state = SS_CONNECTED;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3610</x>
      <y>2823</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_graft</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3606</x>
      <y>2830</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //指向new_socket的等待队列
sk-&gt;sleep = &amp;parent-&gt;wait;
 //将new_socket和client的sk关联
parent-&gt;sk = sk;
sk-&gt;socket = parent;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3616</x>
      <y>2826</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3602</x>
      <y>2818</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3589</x>
      <y>2822</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_free_datagram</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3595</x>
      <y>2818</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3589</x>
      <y>2828</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kfree_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3596</x>
      <y>2825</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3595</x>
      <y>2831</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
atomic_dec_and_test
skb-&gt;users=1</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3590</x>
      <y>2835</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__kfree_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3571</x>
      <y>2822</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_recv_datagram</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3580</x>
      <y>2818</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3556</x>
      <y>2829</y>
      <w>31</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.通过sock_error提取sk-&gt;err，并置0，如果有错返回NULL
2.通过sock_rcvtimeo查看noblock标志，如果没置上，就设置timeout时间
3.do..while
	1.如果file.flag中MSG_PEEK置上，表示只是查询是否有报文可以接收
		所以通过skb_peek查询serve的receive_queue链表是否为空
		如果不为空，递增skb-&gt;users计数
	2.如果MSG_PEEK没置上，通过skb_dequeue将skb取出链表
	3.如果找到了skb，返回
	4.如果不要求等待（timeo=0），返回EAGAIN
	5.如果要求等待，通过wait_for_packet等待client发送控制报文
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3577</x>
      <y>2825</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3551</x>
      <y>2851</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_dequeue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3555</x>
      <y>2847</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3551</x>
      <y>2857</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__skb_dequeue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3556</x>
      <y>2854</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3548</x>
      <y>2863</y>
      <w>16</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.取出skb
	result = next;
	//链表个数和链表操作
	next = next-&gt;next;
	list-&gt;qlen--;
	next-&gt;prev = prev;
	prev-&gt;next = next;
2.初始化skb
	result-&gt;next = NULL;
	result-&gt;prev = NULL;
	result-&gt;list = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3555</x>
      <y>2860</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3574</x>
      <y>2851</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait_for_packet</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3568</x>
      <y>2847</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3579</x>
      <y>2854</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3566</x>
      <y>2857</y>
      <w>46</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.栈中申明wait（DECLARE_WAITQUEUE），并将其加入导等待头
	__set_current_state(TASK_INTERRUPTIBLE);
	add_wait_queue_exclusive(sk-&gt;sleep, &amp;wait);
2.通过sock_error检查sk的error
3.通过skb_queue_empty查看serve的接收队列（receive_queue）是否为空
	如果不为空跳到8，如果为空，说明没数据
4.查看sk.shutdown的RCV_SHUTDOWN是否置上，如果置上，返回
5.如果sk的类型是SOCK_SEQPACKET（顺序包），SOCK_STREAM（有链接）类型时，
	sk的状态一定要是TCP_ESTABLISHED或者TCP_LISTEN
6.如果检查到signal_pending，通过sock_intr_errno查看是否有限时间等待，
	如果是，返回EINTR，否则，返回ERESTARTSYS重试
7.根据timeo时间通过schedule_timeout将其挂入到闹钟中
8.醒来之后，直接返回0。
	current-&gt;state = TASK_RUNNING;
	remove_wait_queue(sk-&gt;sleep, &amp;wait);
	return 0;
注：直接返回0，使其进do..while中检测skb，如果没检查到skb
	1.timeo时间到，执行上一层的4
	2.如果sk.error，执行本层2
	3.如果sigal_pending,执行本层6
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3681</x>
      <y>2789</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>newsock-&gt;ops-&gt;getname
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3674</x>
      <y>2792</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops/unix_dgram_ops</panel_attributes>
    <additional_attributes>160.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3675</x>
      <y>2796</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_getname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3680</x>
      <y>2799</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3666</x>
      <y>2803</y>
      <w>30</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果peer置上，通过unix_peer_get获得对方sk
	否则，是要获取自己的sk地址，通过sock_hold增加自己sk的refcnt计数
2.如果sk没地址（对于unix域，client可以没有地址,就是没bind）(!sk-&gt;protinfo.af_unix.addr)
	sunaddr-&gt;sun_family = AF_UNIX;
	sunaddr-&gt;sun_path[0] = 0;
	*uaddr_len = sizeof(short);
	如果存在地址：
	addr = sk-&gt;protinfo.af_unix.addr
	//地址和长度，传给caller
	*uaddr_len = addr-&gt;len;
	memcpy(sunaddr, addr-&gt;name, *uaddr_len
3.通过sock_put递减refcnt计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3679</x>
      <y>2826</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_peer_get</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3685</x>
      <y>2822</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3672</x>
      <y>2833</y>
      <w>27</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.获取连接的sk（sk.pair）
2.通过sock_hold递增获取sk.refcnt计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3684</x>
      <y>2829</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3600</x>
      <y>2785</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3611</x>
      <y>2785</y>
      <w>80</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;780.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3749</x>
      <y>2748</y>
      <w>202</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_CONNECT</panel_attributes>
    <additional_attributes>2000.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3745</x>
      <y>2759</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3735</x>
      <y>2766</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过sockfd_lookup利用fd查找sock
2.通过move_addr_to_kernel将用户想要连接的地址复制到用户层
3.通过sock-&gt;ops-&gt;connect连接到serve
4.通过sockfd_put将sock.file释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3750</x>
      <y>2762</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3736</x>
      <y>2784</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_stream_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3745</x>
      <y>2777</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;connect
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3751</x>
      <y>2773</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3742</x>
      <y>2780</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3794</x>
      <y>2785</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_dgram_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3753</x>
      <y>2780</y>
      <w>52</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3731</x>
      <y>2792</y>
      <w>45</w>
      <h>61</h>
    </coordinates>
    <panel_attributes>1.通过unix_mkname计算具体地址的长度
	如果是抽象地址，计算其hash值
2.如果要求传递地址给server（passcred），但是
	没有地址（!sk-&gt;protinfo.af_unix.addr），通过unix_autobind
	自动将socket bind
3.通过sock_sndtimeo确定其timeout时间，如果O_NONBLOCK没置上
	时间是sk-&gt;sndtimeo
4.通过unix_create1为serve创建sock结构sk（子serve）
5.通过sock_wmalloc申请skb准备发给serve
6.通过unix_find_other找到serve端的sock
7.当other-&gt;dead置上时，表示该sock已经被serve撤销
	解开锁，并通过sock_put释放sock，并进一步去6查询hash表中
	是否还有对应地址的sock
注：这里说的是通过unix_find_other递增sock.refcnt，但是其他核撤销该sock，递减refcnt
	然后该核通过unix_state_rlock获取锁，但是此时已经撤销，所以把dead置上
	主要原因是获取sock和sock的相关操作没在一把大锁下，因为获取sock可能会睡。
8.serve端sock.state必须是TCP_LISTEN，否则返回ECONNREFUSED
9.如果serve端receive_queue的qlen超过了其限制max_ack_backlog
	1.如果不要求等待（!timeo），返回EAGAIN
	2.否则通过unix_wait_for_peer等待
	3.醒来之后发现有signal_pending，如果等待实现timeo是不限时，返回ERESTARTSYS重试
		否则返回EINTR
	4.如果是其他原因唤醒，通过sock_put将sk释放，并跳到6重试
10.检查client sk的状态，只有TCP_CLOSE才可以，TCP_ESTABLISHED时返回EISCONN，其他返回EINVAL
注：这里通过写锁对client sk上锁，前面是通过读锁对serve sk上锁
11.上锁之后需要检查sk.state和上锁之前是否相同，如果不同，将锁解开，并将other释放，重试6
注：因为上写锁时，其他进程可能正在读或者写（不同核）
12.对new_sk(serve子sock的)初始化：
	sock_hold(sk);
	unix_peer(newsk)=sk;//和client sk挂钩
	newsk-&gt;state=TCP_ESTABLISHED;//连接状态
	newsk-&gt;type=SOCK_STREAM;
	newsk-&gt;peercred.pid = current-&gt;pid;
	newsk-&gt;peercred.uid = current-&gt;euid;
	newsk-&gt;peercred.gid = current-&gt;egid;
	newsk-&gt;sleep = &amp;newsk-&gt;protinfo.af_unix.peer_wait
	//sk的地址和serve端源sk地址相同
	atomic_inc(&amp;other-&gt;protinfo.af_unix.addr-&gt;refcnt);
	newsk-&gt;protinfo.af_unix.addr=other-&gt;protinfo.af_unix.addr;
	newsk-&gt;protinfo.af_unix.dentry=dget(other-&gt;protinfo.af_unix.dentry);
	newsk-&gt;protinfo.af_unix.mnt=mntget(other-&gt;protinfo.af_unix.mnt);
13.设置client端sk：
	sk-&gt;peercred = other-&gt;peercred;
	sock_hold(newsk);
	unix_peer(sk)=newsk; //和newsk挂钩
	sock-&gt;state=SS_CONNECTED;
	sk-&gt;state=TCP_ESTABLISHED;
14.通过skb_queue_tail将skb尾插到serve sk的receive_queue中
	调用other-&gt;data_ready提醒数据准备好了
	通过sock_put将serve sk释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3742</x>
      <y>2787</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3716</x>
      <y>2858</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_wmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3720</x>
      <y>2852</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3714</x>
      <y>2861</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3704</x>
      <y>2865</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.sk的skb计数wmem_alloc应该小于其限额sndbuf
	除非在force置上的时候
2.通过alloc_skb申请skb
3.通过skb_set_owner_w初始化skb关系
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3708</x>
      <y>2876</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3714</x>
      <y>2872</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3689</x>
      <y>2883</y>
      <w>34</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果是在中断中（alloc_skb），并且要求申请内存时
	等待（__GFP_WAIT），将其等待标志__GFP_WAIT清除
2.通过skb_head_from_pool向skb_head_pool链表中申请skb
	如果在链表中没找到，通过kmem_cache_alloc向skbuff_head_cache
	申请skb
3.申请skb中数据的内存，需要16字节对齐，并且需要加上atomic_t的空间
	size = ((size + 15) &amp; ~15); 
	data = kmalloc(size + sizeof(atomic_t), gfp_mask);
	如果没申请到，通过skb_head_to_pool将skb释放
4.初始化skb数据
	//实际长度=data+skb
	skb-&gt;truesize = size + sizeof(struct sk_buff);
	//数据指针，head和tail是队列的头尾指针，data和end是缓冲区的头尾指针
	skb-&gt;head = data;
	skb-&gt;data = data;
	skb-&gt;tail = data;
	skb-&gt;end = data + size;
	//长度
	skb-&gt;len = 0;
	skb-&gt;cloned = 0;
	skb-&gt;users=1
	skb-&gt;end=1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3713</x>
      <y>2879</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3695</x>
      <y>2903</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_head_to_pool</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3701</x>
      <y>2900</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3686</x>
      <y>2910</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.遍历skb_head_pool链表，如果其长度小于
	限值sysctl_hot_list_len，就通过__skb_queue_head
	释放到链表中
2.否则通过kmem_cache_free释放到skbuff_head_cache中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3698</x>
      <y>2906</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3691</x>
      <y>2920</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__skb_queue_head</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3697</x>
      <y>2917</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3688</x>
      <y>2926</y>
      <w>19</w>
      <h>17</h>
    </coordinates>
    <panel_attributes> //newsk就是skb
newsk-&gt;list = list;
list-&gt;qlen++;
prev = (struct sk_buff *)list;
next = prev-&gt;next;
 //头插置链表中
newsk-&gt;next = next;
newsk-&gt;prev = prev;
next-&gt;prev = newsk;
prev-&gt;next = newsk;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3697</x>
      <y>2923</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3728</x>
      <y>2876</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_set_owner_w</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3721</x>
      <y>2872</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3725</x>
      <y>2883</y>
      <w>20</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //递增sk引用
sock_hold(sk);
 //将其和sk关联，accept会通过skb找到newsk
skb-&gt;sk = sk;
 //skb释放时执行
skb-&gt;destructor = sock_wfree;
wmem_alloc+=truesize
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3733</x>
      <y>2879</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3748</x>
      <y>2860</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_find_other</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3746</x>
      <y>2852</y>
      <w>9</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3746</x>
      <y>2866</y>
      <w>32</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果是具体地址（sunname-&gt;sun_path[0]）：
	1.通过path_init和path_walk寻找到sock inode
		LOOKUP_POSITIVE：在找不到indoe时，返回ENOENT
		LOOKUP_FOLLOW：顺着link查找，直到找到真实inode
	2.通过permission检查MAY_WRITE
	3.如果inode的S_ISSOCK没置上，返回ECONNREFUSED
	4.利用unix_find_socket_byinode通过inode的ino
		作为hash值，在hash表中查找sk
	5.通过path_release释放获取的nd
	6.如果要连接地址的sk的type和client的type不相同，返回EPROTOTYPE
2.如果是抽象地址，通过unix_find_socket_byname查找sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3755</x>
      <y>2863</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3747</x>
      <y>2890</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_find_socket_byinode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3753</x>
      <y>2884</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3746</x>
      <y>2897</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.遍历hash表unix_socket_table，查看其中的sk
	（protinfo.af_unix.dentry.inode）是否
	和当前传进的inode相同，如果相同通过sock_hold
	递增sever sk的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3754</x>
      <y>2893</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3769</x>
      <y>2890</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_find_socket_byname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3774</x>
      <y>2897</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过__unix_find_socket_byname遍历unix_socket_table
	hash表，找到其中name和len相同的sk返回
2.通过sock_hold递增sever sk的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3771</x>
      <y>2884</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3779</x>
      <y>2893</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3784</x>
      <y>2860</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_wait_for_peer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3758</x>
      <y>2852</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3782</x>
      <y>2867</y>
      <w>28</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.申明等待wait，并将task状态设置为TASK_INTERRUPTIBLE
	最后将wait挂入到peer_wait中
2.下面要都成立，才schedule_timeout：
	1.other-&gt;dead没置上
	2.other的RCV_SHUTDOWN没置上
	3.receive_queue长度没超过max_ack_backlog
3.将task状态设置为TASK_RUNNING，并将wait从peer_wait移除
注：这里没有像wait_for_packet一样，在醒来之后先去查看receive_queue
	再去看signal_pending。因为connect不仅需要控制报文投递，需要等待到serve
	端accept，这是一个不确定的时间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3792</x>
      <y>2863</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3813</x>
      <y>2858</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>other-&gt;data_ready
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3758</x>
      <y>2852</y>
      <w>62</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;600.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3819</x>
      <y>2861</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sock_init_data</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3812</x>
      <y>2865</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_def_readable</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3812</x>
      <y>2872</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过wake_up_interruptible唤醒同步等待队列sk-&gt;sleep
2.通过sk_wake_async给异步等待队列socket-&gt;fasync_list
	发信号(原因是POLL_IN)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3818</x>
      <y>2868</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3819</x>
      <y>2882</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_wake_async</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3824</x>
      <y>2878</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3824</x>
      <y>2885</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果存在异步等待队列fasync_list</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3819</x>
      <y>2889</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_wake_async</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3824</x>
      <y>2892</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3809</x>
      <y>2896</y>
      <w>37</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.how=1：sock-&gt;flags的SOCK_ASYNC_WAITDATA不能置上
	并通过__kill_fasync给队列发SIGIO
	how=2:SOCK_ASYNC_NOSPACE要置上，并通过__kill_fasync给队列发SIGIO
	how=3:通过__kill_fasync给队列发SIGURG
	how=0:通过__kill_fasync给队列发SIGIO
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3777</x>
      <y>2792</y>
      <w>46</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.如果sa_family是AF_UNSPEC，表示单向连接关系断开
	other = NULL
	如果sa_family不为AF_UNSPEC：
	1.通过unix_mkname获取addr的长度，并且为抽象地址分配hash
	2.如果要求传递地址（passcred），但是地址没有sk-&gt;protinfo.af_unix.addr
		通过unix_autobind为其bind一个地址
	3.通过unix_find_other利用地址，找到inode，并进一步在hash中找到sock
	4.为其sk上写锁
	5.通过unix_may_send检查other是否有链接，如果有，是否是sk，如果不是，返回EPERM
2.如果sk已经有连接（sk.pair）
	1.取出其连接，并连接到other
		old_peer = unix_peer(sk);
		unix_peer(sk)=other;
		unix_state_wunlock(sk);
	2.如果old_peer不是现在要连接的other，通过unix_dgram_disconnected将其连接断开
	3.通过sock_put将old_peer释放
3.如果sk没有连接：
	unix_peer(sk)=other;
	unix_state_wunlock(sk);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3801</x>
      <y>2788</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3791</x>
      <y>2827</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_dgram_disconnected</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3799</x>
      <y>2823</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3783</x>
      <y>2834</y>
      <w>32</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果receive_queue中qlen不为0
	1.通过skb_queue_purge将receive_queue中所有的skb释放
	2.通过wake_up_interruptible_all唤醒sk的peer_wait
	3.如果old_peer没被撤销（other-&gt;dead ），并且其连接的还是
		当前的sk：
		other-&gt;err = ECONNRESET;
		other-&gt;error_report(other);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3799</x>
      <y>2830</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3949</x>
      <y>2748</y>
      <w>153</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_SENDTO
SYS_SEND只是在地址为NULL
文件系统的sys_write对应的sock_write也和这个类似</panel_attributes>
    <additional_attributes>10.0;10.0;1510.0;190.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4093</x>
      <y>2767</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sendto</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4099</x>
      <y>2770</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4081</x>
      <y>2774</y>
      <w>35</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.通过sockfd_lookup利用fd找到sock
2.初始化msg：
	//缓冲区
	iov.iov_base=buff;
	iov.iov_len=len;
	msg.msg_name=NULL;
	msg.msg_iov=&amp;iov;
	msg.msg_iovlen=1;
	//附加信息
	msg.msg_control=NULL;
	msg.msg_controllen=0;
	//地址
	msg.msg_namelen=addr_len;
	move_addr_to_kernel(addr, addr_len, address)
	msg.msg_name=address
	//如果O_NONBLOCK置上，就将MSG_DONTWAIT置上
	msg.msg_flags = flags
3.通过sock_sendmsg发送msg
4.通过sockfd_put将file释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4092</x>
      <y>2808</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_sendmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4097</x>
      <y>2804</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3948</x>
      <y>2748</y>
      <w>347</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_RECVFROM
SYS_RECV只是在地址为NULL
文件系统的sys_read对应的sock_read也和这个类似</panel_attributes>
    <additional_attributes>10.0;10.0;3450.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4287</x>
      <y>2768</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_recvfrom</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4292</x>
      <y>2771</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4276</x>
      <y>2775</y>
      <w>35</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.通过sockfd_lookup利用fd找到sock
2.初始化msg：
	//附加信息
	msg.msg_control=NULL;
	msg.msg_controllen=0
	//缓冲区
	msg.msg_iovlen=1;
	msg.msg_iov=&amp;iov;
	iov.iov_len=size;
	iov.iov_base=ubuf;
	//用来接收发送者的地址
	msg.msg_name=address;
	msg.msg_namelen=MAX_SOCK_ADDR;
	//如果O_NONBLOCK置上，就将MSG_DONTWAIT置上
	flags |= MSG_DONTWAIT
3.通过sock_recvmsg接收msg
4.通过move_addr_to_user将发送者的地址复制到用户层
5.通过sockfd_put将file释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4286</x>
      <y>2808</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_recvmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4290</x>
      <y>2804</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4279</x>
      <y>2814</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.将scm清0
2.通过sock-&gt;ops-&gt;recvmsg接收msg
3.如果有收到msg，通过scm_recv将发送方授权的file
	安装在进程中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4292</x>
      <y>2811</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4277</x>
      <y>2823</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;recvmsg
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4284</x>
      <y>2820</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4249</x>
      <y>2831</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_stream_recvmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4258</x>
      <y>2826</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4283</x>
      <y>2826</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4305</x>
      <y>2830</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_dgram_recvmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4294</x>
      <y>2837</y>
      <w>54</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果flag的MSG_OOB置上，返回EOPNOTSUPP
注：MSG_OOB主要是有链接用于控制传输的目的
2.通过skb_recv_datagram接收发送方传过来的skb
3.通过wake_up_interruptible唤醒接收方peer_wait队列中
	等待发送的进程
4.如果要求返回发送方的地址（msg_name），通过unix_copy_addr获取
5.读取的长度不能超过skb的长度skb-&gt;len，如果不足这个长度，长度就是用户提供的size
	但是需要将msg-&gt;msg_flags |= MSG_TRUNC
6.通过skb_copy_datagram_iovec将skb中的报文读取到用户层
7.将skb.cb的48字节通过unix_skb_parms解析，将其中的creds放在scm-&gt;creds中
8.如果MSG_PEEK没置上（正常读取数据），通过unix_detach_fds将发送方传来的file取出
	如果MSG_PEEK置上（查看一下），通过scm_fp_dup将file复制到scm-&gt;fp
9.最后通过skb_free_datagram将skb释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4313</x>
      <y>2833</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4285</x>
      <y>2861</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_copy_addr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4291</x>
      <y>2858</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4278</x>
      <y>2867</y>
      <w>22</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果没有addr，则：
	msg-&gt;msg_namelen = sizeof(short)
2.如果有addr，则：
	msg-&gt;msg_namelen=sk-&gt;protinfo.af_unix.addr-&gt;len
	memcpy(msg-&gt;msg_name,
		       sk-&gt;protinfo.af_unix.addr-&gt;name,
		       sk-&gt;protinfo.af_unix.addr-&gt;len);
注：有链接skb的sk指向的子serve方的sk
	无连接skb的sk指向的是发送方的sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4288</x>
      <y>2864</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4306</x>
      <y>2862</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_copy_datagram_iovec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4313</x>
      <y>2858</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4306</x>
      <y>2875</y>
      <w>28</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.将skb中的内容通过copy_to_user复制到iov_base中
	复制的长度是要读的长度len和iov的长度iov_len的最小值
2.更新：
	kdata+=copy;
	len-=copy;
	iov-&gt;iov_len-=copy;
	iov-&gt;iov_base+=copy;
3.如果一个iov放不下，将iov++
注；如果用户层没注意，将要读的长度，超过了iov的长度，可能要自己负责
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4311</x>
      <y>2869</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memcpy_toiovec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4316</x>
      <y>2865</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4316</x>
      <y>2872</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4338</x>
      <y>2862</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_detach_fds</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4332</x>
      <y>2858</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4336</x>
      <y>2869</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.将skb中的scm_fp_list复制到scm-&gt;fp
	并将其fp置NULL
2.skb-&gt;destructor = sock_wfree
3.遍历scm_fp_list，通过unix_notinflight
	提示sock不在飞行中：
	atomic_dec(&amp;s-&gt;protinfo.af_unix.inflight);
	atomic_dec(&amp;unix_tot_inflight);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4344</x>
      <y>2865</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4366</x>
      <y>2862</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>scm_fp_dup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4342</x>
      <y>2858</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4361</x>
      <y>2869</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果要复制的scm_fp_list为NULL,直接返回
2.通过kmalloc申请file数组。通过get_file
	递增file的计数，并通过memcpy将scm_fp_list复制到
	申请的内存中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4372</x>
      <y>2865</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4379</x>
      <y>2823</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>scm_recv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4297</x>
      <y>2820</y>
      <w>90</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;880.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4371</x>
      <y>2831</y>
      <w>32</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.如果不要求传输控制消息（!msg_control）
	1.如果是要求传递消息（passcred），或者对方有传递消息过来scm-&gt;fp
		将msg-&gt;msg_flags |= MSG_CTRUNC
	2.通过scm_destroy将发送方传过来的file释放，并释放数组结构scm_fp_list
2.如果passcred置上，通过put_cmsg将类型（参数）和creds复制到msg_control中
3.如果发送方没传送file过来（!fp），直接返回
4.通过scm_detach_fds将传送过来的file安装
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4385</x>
      <y>2826</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4386</x>
      <y>2846</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>scm_detach_fds</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4386</x>
      <y>2843</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4389</x>
      <y>2852</y>
      <w>36</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.计算出用户给的msg中能容纳的fd的数量（fdmax），（空间是msg_controllen-cmsghdr）
	所以要传递给用户fd的数量是传送方传递的file和fdmax的最小值
2.通过get_unused_fd获取fd，并将其通过put_user放到CMSG_DATA中，
	通过get_file递增 scm-&gt;fp-&gt;fp数组中相应file的计数，并通过fd_install将其安装至当前进程中
3.将SOL_SOCKET，SCM_RIGHTS，cmlen（data长度，即fd）填充cmsghdr
	并更新：
	cmlen = CMSG_SPACE(i*sizeof(int));
	msg-&gt;msg_control += cmlen;
	msg-&gt;msg_controllen -= cmlen;
4.如果发送方的file没全部传递msg-&gt;msg_flags |= MSG_CTRUNC
5.通过__scm_destroy将scm中的file数组释放
注；1.这里将发送方的file传递给接收方，应用于如下场景
	在有链接的时候，serve因为要accept，所以会fork一个子进程去和client通信，这会在通信时有相当大的花费
	如果提前fork一些进程，然后通过传递连接的sock_file给子进程，这样就不用在通信的时候fork了
	2.msg_controll由多个cmsghdr+data组成（data中包含creds（put_cms）或者fd数组）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4394</x>
      <y>2849</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4086</x>
      <y>2815</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过scm_send将用户层中传输的控制信息msg组装金scm中
2.通过sock-&gt;ops-&gt;sendmsg将msg发送
	并通过scm_destroy将scm中的file数组和file释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4042</x>
      <y>2826</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>scm_send</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4097</x>
      <y>2811</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4046</x>
      <y>2821</y>
      <w>53</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4034</x>
      <y>2832</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.将scm清0
2.将进程的pid，uid，gid赋给scm-&gt;creds
3.如果msg_controllen&gt;0,通过__scm_send将msg的controll信息复制到scm中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4045</x>
      <y>2829</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4037</x>
      <y>2840</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__scm_send</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4043</x>
      <y>2837</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4034</x>
      <y>2846</y>
      <w>31</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.利用cmsghdr解析msg的各个片段（cmsghdr+data（data长度是cmsg-&gt;cmsg_len））
	这个片段的长度不能超过msg_controllen
2.cmsg_level要是SOL_SOCKET
3.如果cmsg_type是SCM_RIGHTS，通过scm_fp_copy将fp数组从msg中复制到scm中
	如果是SCM_CREDENTIALS，将数据复制到scm-&gt;creds中，并通过scm_check_creds检查其cred
4.如果没有任何file需要传输（!p-&gt;fp-&gt;count）将scm中的scm_fp_list释放
注：scm_fp_copy中可能是继续向scm中添加file（fp已经存在，所有count+num不能大于SCM_MAX_FD，num是msg传递的file）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4042</x>
      <y>2843</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4127</x>
      <y>2823</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;sendmsg
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4099</x>
      <y>2821</y>
      <w>38</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4137</x>
      <y>2826</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4151</x>
      <y>2831</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_dgram_sendmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4086</x>
      <y>2831</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_stream_sendmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4096</x>
      <y>2826</y>
      <w>42</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_stream_ops</panel_attributes>
    <additional_attributes>400.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4128</x>
      <y>2837</y>
      <w>60</w>
      <h>48</h>
    </coordinates>
    <panel_attributes>1.msg_flags的MSG_OOB不能置上，否则返回EOPNOTSUPP
2.如果用户提供和发送地址（msg_namelen）通过unix_mkname计算其len和抽象地址hash
	如果没提供通过unix_peer_get获取接收方的sk--other(connect时连接)，如果没有返回ENOTCONN
3.如果要求传递地址（passcred），但是却没有地址（！af_unix.addr），通过unix_autobind
	自动bind一个地址
4.如果发送长度超过了sndbuf - 32（要留32字节冗余），返回EMSGSIZE
5.通过sock_alloc_send_skb分配skb，注意传参是发送方的sk
6.将scm-&gt;creds复制到skb的cb中
7.如果要求传递文件（scm-&gt;fp），通过unix_attach_fds将scm.fp复制到skb的cb中
8.将skb-&gt;h.raw指向缓冲区skb-&gt;data，并通过memcpy_fromiovec将数据冲io_base
	复制到缓冲区，并通过skb_put更新尾指针tail和长度len
9.通过sock_sndtimeo确定进程是否block
10.如果没有确定收方（!other），unix_find_other通过sunaddr在hash中找到收方的sk
11.unix_may_send检查发方sk，不能和除了other之外的其他sk相连
12.如果收方的sk被撤销（other-&gt;dead）
	1.通过sock_put将other释放
	2.如果sk和other相连，将其接触绑定
		unix_peer(sk)=NULL;
		unix_dgram_disconnected(sk, other);
		sock_put(other);
		并返回err = -ECONNREFUSED;
	3.如果other为null，从10再次查询执行
13.如果RCV_SHUTDOWN，返回EPIPE
14.如果收方other没和sk相连，并且收方的receive_queue超过了其max_ack_backlog
	1.如果没要求等待（!timeo），返回EAGAIN
	2.如果要求等待，通过unix_wait_for_peer等待other释放空间
	3.醒来之后，检查signal_pending，根据timeo决定返回值
15.利用skb_queue_tail将skb加入到receive_queue链表
16.执行other-&gt;data_ready，释放other，返回发送长度len
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4160</x>
      <y>2834</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4138</x>
      <y>2889</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_alloc_send_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4145</x>
      <y>2884</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4116</x>
      <y>2896</y>
      <w>45</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.通过sock_sndtimeo确定如果要睡眠需要等待的时间
2.循环等待sndbuf空闲，申请skb
	1.通过sock_error检查sk.err，如果出错，返回错误
	2.如果sk-&gt;shutdown&amp;SEND_SHUTDOWN，返回EPIPE
	3.如果sk发送的长度wmem_alloc没超过sndbuf
		1.如果fallback置上，通过alloc_skb申请用户定义大小的buffer，如果没申请到利用fallback大小再试
		2.通过alloc_skb申请skb，如果没申请到返回ENOBUFS
		3.如果上述两个任意一个申请到，退出循环
	4.将socket-&gt;flags中的SOCK_ASYNC_NOSPACE和SOCK_NOSPACE置上
	5.如果不要求等待（!timeo），返回EAGAIN
	6.如果signal_pending，如果是无限等待，返回ERESTARTSYS重试；否则返回EINTR
	7.通过sock_wait_for_wmem等待，醒来之后再次执行循环，重新申请
3.通过skb_set_owner_w设置sk（注意这里是发送方的sk）和skb的关系，并更新wmem_alloc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4144</x>
      <y>2892</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4131</x>
      <y>2924</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_wait_for_wmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4117</x>
      <y>2931</y>
      <w>33</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.申请wait，并挂入到sk-&gt;sleep
2.将socket-&gt;flags中的SOCK_ASYNC_NOSPACE清掉
3.循环检查醒来之后的状态：
	1.如果signal_pending，退出循环
	2.将socket的SOCK_NOSPACE置上，并将task状态设置为TASK_INTERRUPTIBLE
	3.如果sk的wmem_alloc小于发送限值sndbuf，退出循环
	4.如果SEND_SHUTDOWN，退出循环
	5.如果err，退出循环
	6.否则采用schedule_timeout调度task
4.确认退出检查之后，将task状态改为TASK_RUNNING，并将wait移除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4138</x>
      <y>2927</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4138</x>
      <y>2918</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4166</x>
      <y>2889</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_attach_fds</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4163</x>
      <y>2896</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历scm中的fp数组，通过unix_inflight检查如果是sock_file
	递增sk的af_unix.inflight和总数unix_tot_inflight
2.将scm-&gt;fp复制到skb的cb中，并：
	skb-&gt;destructor = unix_destruct_fds;
	scm-&gt;fp = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4173</x>
      <y>2892</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4163</x>
      <y>2884</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4204</x>
      <y>2838</y>
      <w>70</w>
      <h>61</h>
    </coordinates>
    <panel_attributes>1.如果sk的状态不是TCP_ESTABLISHED，返回EINVAL
2.flag中MSG_OOB不能置上，这个控制报文对Unix域不适用
3.通过sock_rcvlowat计算本次接收的最少接收量
	1.如果要求MSG_WAITALL，要接收就是用户规定的size
	2.否则是用户规定和sk-&gt;rcvlowat的最小值
	3.如果上述两个条件返回0，则最小是1
4.通过sock_rcvtimeo确定进程是否需要等待
 //这里耗时较长，用信号量readsem，是进程能够睡眠
5.循环读取skb，知道读取size
	1.利用skb_dequeue从receive_queue中获取skb
	2.如果sk没有skb：
		1.如果接收的已经超过了规定的最小值target，退出循环，返回copied
		2.检查sock_error，检查RCV_SHUTDOWN
		3.如果要求等待，通过unix_stream_data_wait等待，等待之前将信号量readsem释放：
			1.receive_queue中有skb，有sk.err,RCV_SHUTDOWN,signal_pending,！timeo退出等待
			2.再调度之前将SOCK_ASYNC_WAITDATA置上，醒来之后，将SOCK_ASYNC_WAITDATA清除
		4.醒来之后检查signal_pending，是否重试，看timeo，
		5.重新申请信号量readsem，并执行5.1
	3.如果之前有接收skb（check_creds），通过memcmp对比两个skb的creds是否一致，如果不一致通过skb_queue_head
		将skb重新加入队列，并且退出循环，返回接收的长度copied
		如果之前没接收skb：
			scm-&gt;creds = *UNIXCREDS(skb);
			check_creds = 1;
	4.如果要求接收发送方地址（sunaddr），通过unix_copy_addr将发送方sk的地址复制到sunaddr
	5.通过memcpy_toiovec将数据从skb的缓冲区data中复制到msg_iov，复制的长度是skb的长度和要读的长度size的最小值
		如果复制因为权限出错，将skb通过skb_queue_head重新加入到队列中，然后退出循环返回复制的长度，并更新：
		copied += chunk;//复制的长度
		size -= chunk//剩下要读的量
	6.如果是正式读（！MSG_PEEK）:
		1.通过skb_pull更新skb
		2.如果skb中fp存在，通过unix_detach_fds将skb中的fp复制到scm中
		3.如果skb中还存在数据，通过skb_queue_head将skb重新加入队列
		4.如果skb被读完，通过kfree_skb将skb释放
		5.如果此次传输了文件scm.fp，直接退出，返回复制长度
	7.如果是偷看一下（MSG_PEEK）：
		1.通过scm_fp_dup将skb.cb中的数据复制到scm-&gt;fp
		2.并通过skb_queue_head将skb重新连入链表中，退出循环，返回读取的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4256</x>
      <y>2834</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4243</x>
      <y>2898</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4238</x>
      <y>2902</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_pull</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4232</x>
      <y>2909</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果读取的长度超过了skb.len,直接返回NULL
2.skb-&gt;len-=len
	skb-&gt;data+=len
3.返回skb.data指针
注：这里直接调整data，是因为skb数据读完之后会直接释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4243</x>
      <y>2905</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4069</x>
      <y>2838</y>
      <w>55</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.Unix域没有MSG_OOB
2.在发送时，不能传递地址（msg_namelen），需要通过
	unix_peer_get获取接收方的sk--other
3.发送方sk不能SEND_SHUTDOWN
4.while循环发送数据：
	1.一次发送的长度不能超过sk-&gt;sndbuf/2（16字节是头，但是sk_buff却不止16字节？）
		这是为了可以交替向sk的buf中发送数据
	2.如果发送的长度超过了一页，可以用一页的长度进行尝试（fallback）
	3.通过sock_alloc_send_skb申请skb，如果其中超过了sendbuf会睡眠
注：无连接会检查发送长度是否超过了receive_queue的限制，但是有链接却没有检查
	这是因为无连接不关心两个sk是否相连，只要有接收方的地址就能发过去（所以任何进程只要有对方的地址都可以放到接收方的sk上）
	但是有链接必须是两个连接的sk才能互相收发，所以接收方的sk只有与其连接的sk才能发送，所以这里只通过发送方的sendbuf长度控制发送
	4.发送的长度不能超过skb的剩余空间（skb_tailroom）
	5.复制scm-&gt;creds到skb的cb中
	6.通过memcpy_fromiovec复制数据msg_iov到skb.tail，并通过skb_put更新tail和len
	7.如果读端dead，或者RCV_SHUTDOWN，解锁other，释放skb，并返回发送的长度
	8.通过skb_queue_tail将skb添加到receive_queue
	9.other-&gt;data_ready(other, size);
		sent+=size;
5.通过sock_put释放ohtre，并返回发送的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4091</x>
      <y>2834</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3590</x>
      <y>2842</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.通过dst_release释放skb-&gt;dst
2.执行skb-&gt;destructor
3.通过skb_headerinit在skb初始化
4.通过kfree_skbmem将skb的数据缓冲释放
	其中通过skb_head_to_pool将skb释放至cache或者pool
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3595</x>
      <y>2838</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3615</x>
      <y>2854</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb-&gt;destructor
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3617</x>
      <y>2850</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3612</x>
      <y>2862</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_wfree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3617</x>
      <y>2857</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
skb_set_owner_w</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3727</x>
      <y>2898</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_wfree</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3732</x>
      <y>2894</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3723</x>
      <y>2905</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.释放skb申请的空间
	wmem_alloc-=truesize
2.调用sk-&gt;write_space
3.通过sock_put将sk释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3732</x>
      <y>2901</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3727</x>
      <y>2915</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_write_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3732</x>
      <y>2911</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_create1</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3719</x>
      <y>2921</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.上callback_lock锁
2.通过unix_writable检查已写的buf是否超过了sk的限制的一半
	如果没超过：
	1.如果sk-&gt;sleep中存在等待进程，通过wake_up_interruptible将其唤醒
	2.通过sk_wake_async异步通知sock-&gt;fasync_list进程POLL_OUT
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3732</x>
      <y>2918</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3948</x>
      <y>2748</y>
      <w>438</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_SENDMSG</panel_attributes>
    <additional_attributes>10.0;10.0;4360.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4377</x>
      <y>2766</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sendmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3949</x>
      <y>2748</y>
      <w>498</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_RECVMSG</panel_attributes>
    <additional_attributes>10.0;10.0;4960.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4439</x>
      <y>2766</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_recvmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4361</x>
      <y>2772</y>
      <w>41</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.通过copy_from_user将用户要传输的msghdr复制到用户空间
2.利用sockfd_lookup通过fd找到sock
3.iov的个数（msg_iovlen）不能超过UIO_MAXIOV
4.如果iov的个数是8，就用栈中的空间，否则通过通过sock_kmalloc申请
5.通过verify_iovec将iov复制到内核，并返回总共传输数据的长度
注：这里没有复制具体数据，具体数据的复制是在sock-&gt;ops-&gt;sendmsg中
	通过memcpy_fromiovec复制
6.msg_controllen不能超过INT_MAX，如果超过了一个control，通过sock_kmalloc
	申请空间，否则利用栈上的空间ctl
7.通过copy_from_user将msg_control复制到内核
	msg_sys.msg_control = ctl_buf
8.复制flag
	msg_sys.msg_flags = flags
	//O_NONBLOCK置上
	msg_sys.msg_flags |= MSG_DONTWAIT
9.sock_sendmsg发送msg
注：只有这个函数会传递control，进而授权file
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4383</x>
      <y>2769</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4364</x>
      <y>2802</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4370</x>
      <y>2799</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4354</x>
      <y>2808</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果申请的内存size，不能超过sysctl_optmem_max
	omem_alloc+size不能超过sysctl_optmem_max
2.通过kmalloc申请size，之前要将omem_alloc+=size
	之后要omem_alloc-=size（不清楚为什么要这样？）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4369</x>
      <y>2805</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4398</x>
      <y>2803</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>verify_iovec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4389</x>
      <y>2799</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4391</x>
      <y>2809</y>
      <w>32</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果传递了name（msg_namelen）：
	1.如果要VERIFY_READ，就将name复制到address中
	2.m-&gt;msg_name = address
	没传递name，m-&gt;msg_name = NULL
2.通过copy_from_user将iov复制到内核，并修改其指向内核
	m-&gt;msg_iov=iov
3.算出iov数组的总长度，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4404</x>
      <y>2806</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4426</x>
      <y>2774</y>
      <w>40</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.通过copy_from_user将msg复制到内核
2.利用sockfd_lookup通过fd找到sock
3.获取内核iov，过程和sys_sendmsg类似
4.通过verify_iovec验证iov，并将m-&gt;msg_name
	指向内核
5.查看O_NONBLOCK是否置上，决定MSG_DONTWAIT是否置上
6.通过sock_recvmsg继续填充msg
7.如果有地址（用户接收，且地址传过来），通过move_addr_to_user将地址复制到用户空间
8.通过__put_user分别将msg_flags和msg_controllen复制到用户
注：data和msgcontrol分别在sock-&gt;ops-&gt;recvmsg和scm_recv中复制到用户空间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4444</x>
      <y>2769</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3622</x>
      <y>2862</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_destruct_fds</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3621</x>
      <y>2857</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
unix_attach_fds</panel_attributes>
    <additional_attributes>30.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4173</x>
      <y>2908</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unix_destruct_fds</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4178</x>
      <y>2905</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>4164</x>
      <y>2914</y>
      <w>31</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.将scm清0
2.通过unix_detach_fds将skb.cb中的fp放到scm中
	并在其中通过unix_notinflight递减sk中inflight的file计数
	最后将skb-&gt;destructor = sock_wfree
3.通过scm_destroy释放scm.fp中的file，及其管理数组
4.通过sock_wfree释放skb的缓存，并递减sk计数（是对发送端计数）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>4178</x>
      <y>2911</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3264</x>
      <y>2798</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_family_ops</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3290</x>
      <y>2802</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3287</x>
      <y>2808</y>
      <w>33</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.设置sock状态
	sock-&gt;state = SS_UNCONNECTED
2.通过sk_alloc申请sk
3.根据sock-&gt;type确定运输层协议：
	//SOCK_STREAM
	protocol = IPPROTO_TCP;
	prot = &amp;tcp_prot;
	sock-&gt;ops = &amp;inet_stream_ops;
	//SOCK_DGRAM
	protocol = IPPROTO_UDP;
	sk-&gt;no_check = UDP_CSUM_DEFAULT;
	prot=&amp;udp_prot;
	sock-&gt;ops = &amp;inet_dgram_ops;
	//SOCK_RAW
4.初始化sk
	sock_init_data(sock,sk);

	sk-&gt;destruct = inet_sock_destruct;

	sk-&gt;zapped = 0;
	sk-&gt;family = PF_INET;
	sk-&gt;protocol = protocol;

	sk-&gt;prot = prot;
	sk-&gt;backlog_rcv = prot-&gt;backlog_rcv;

	sk-&gt;protinfo.af_inet.ttl=sysctl_ip_default_ttl;

	sk-&gt;protinfo.af_inet.mc_loop=1;
	sk-&gt;protinfo.af_inet.mc_ttl=1;
	sk-&gt;protinfo.af_inet.mc_index=0;
	sk-&gt;protinfo.af_inet.mc_list=NULL;
5.sk.num不为0（只有在SOCK_RAW）：
	sk-&gt;sport = htons(sk-&gt;num)
	sk-&gt;prot-&gt;hash(sk)
6.初始化sk-&gt;prot-&gt;init
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3296</x>
      <y>2805</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3295</x>
      <y>2841</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;prot-&gt;init
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3300</x>
      <y>2838</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3295</x>
      <y>2844</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3289</x>
      <y>2848</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_init_sock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3287</x>
      <y>2854</y>
      <w>27</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.初始化skb链表tp-&gt;out_of_order_queue
2.初始化timer：
	tp-&gt;retransmit_timer.function=&amp;tcp_write_timer;
	tp-&gt;retransmit_timer.data = (unsigned long) sk;
	tp-&gt;pending = 0;

	tp-&gt;delack_timer.function=&amp;tcp_delack_timer;
	tp-&gt;delack_timer.data = (unsigned long) sk;
	tp-&gt;ack.pending = 0;

	sk-&gt;timer.function=&amp;tcp_keepalive_timer;
	sk-&gt;timer.data = (unsigned long) sk;
3.初始化tp-&gt;ucopy
	tp-&gt;ucopy.task = NULL;
	tp-&gt;ucopy.len = 0;
	tp-&gt;ucopy.memory = 0;
	skb_queue_head_init(&amp;tp-&gt;ucopy.prequeue)
4.初始化tp
	tp-&gt;rto  = TCP_TIMEOUT_INIT;
	tp-&gt;mdev = TCP_TIMEOUT_INIT;
	tp-&gt;snd_cwnd = 2;
	tp-&gt;snd_ssthresh = 0x7fffffff;	/* Infinity */
	tp-&gt;snd_cwnd_clamp = ~0;
	tp-&gt;mss_cache = 536;
	tp-&gt;reordering = sysctl_tcp_reordering;
5.初始化sk
	sk-&gt;state = TCP_CLOSE;
	sk-&gt;write_space = tcp_write_space;
	sk-&gt;tp_pinfo.af_tcp.af_specific = &amp;ipv4_specific;
	sk-&gt;sndbuf = sysctl_tcp_wmem[1];
	sk-&gt;rcvbuf = sysctl_tcp_rmem[1];
	atomic_inc(&amp;tcp_sockets_allocated);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3294</x>
      <y>2851</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3392</x>
      <y>2778</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops/inet_dgram_ops</panel_attributes>
    <additional_attributes>10.0;20.0;200.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3405</x>
      <y>2781</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_bind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3402</x>
      <y>2787</y>
      <w>36</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.如果sk-&gt;prot-&gt;bind存在（这里不存在），则运行
2.用户传来的地址长度不能小于内核解析（sockaddr_in）的长度
3.通过inet_addr_type查看用户传来的ip地址的类型
4.filter：
	1.如果没有local的bind（sysctl_ip_nonlocal_bind）
		并且已经被bind（freebind），地址类型也不是（0，local，多播或者广播），报错
	2.如果要申请1024一下的port，需要CAP_NET_BIND_SERVICE的权限
	3.sk的状态要不是TCP_CLOSE，或者sk已经关联了port（sk-&gt;num），报错EINVAL
5.设置地址：
	sk-&gt;rcv_saddr = sk-&gt;saddr = addr-&gt;sin_addr.s_addr;
	如果是广播或者多播：sk-&gt;saddr = 0
6.通过sk-&gt;prot-&gt;get_port分配port
7.设置sk
	sk-&gt;userlocks（rcv_saddr指定，SOCK_BINDADDR_LOCK置上；
		snum指定，SOCK_BINDPORT_LOCK置上）
	sk-&gt;sport = htons(sk-&gt;num);
	sk-&gt;daddr = 0;
	sk-&gt;dport = 0;
	sk_dst_reset(sk);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3411</x>
      <y>2784</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3404</x>
      <y>2812</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_addr_type</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3403</x>
      <y>2818</y>
      <w>37</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果最高字节是0或者最高4位是f，RTN_BROADCAST
2.如果最高4位是e,RTN_MULTICAST
3.如果local_table存在，默认是RTN_UNICAST，
	通过local_table-&gt;tb_lookup查找其类型，如果返回是0
	表示有新的type
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3411</x>
      <y>2836</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fn_hash_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3409</x>
      <y>2829</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>local_table-&gt;tb_lookup
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3410</x>
      <y>2815</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3412</x>
      <y>2824</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3416</x>
      <y>2832</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ip_fib_init-&gt;fib_hash_init</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3403</x>
      <y>2843</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>注：
1.local_table.tb_data中有一个fn_zone的链表
2.每个fn_zone中有一个关于fib_node的hash表
3.fib_node中的fn_key是这个域内，这个type对应的最大值。
	如果是小于这个值，推出这个循环（hash链表中可能按照从大到小的顺序）
	如果等于这个值，还需要通过fib_semantic_match验证，验证通过后返回0.
4.如果在local_table中没有找到，返回1。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3417</x>
      <y>2839</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3457</x>
      <y>2812</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;prot-&gt;get_port
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3442</x>
      <y>2818</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_get_port</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3447</x>
      <y>2815</y>
      <w>18</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3434</x>
      <y>2825</y>
      <w>31</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.如果传入的port（snum），表示由os指定，os会遍历low~high之间的
	port，在hash表tcp_bhash中查找，看是否被用，如果没有被用，则找到
	（snum = rover;tb = NULL;）如果所有的port都被用，则fail
2.如果snum不为0，同样查看tcp_bhash，如果没找到tb为NULL,否则如果
	重复使用port，tb则会被找到。
3.如果port被重复使用（tb!=NULL）:
	1.如果port允许重复使用（tb-&gt;fastreus），并且申请port的sk也允许
		重复使用（sk-&gt;reuse），只要sk的状态不是TCP_LISTEN，tb就能被重复申请
	2.查看tb的bind链表，查看其中是否有和当前申请sk冲突的sk2（地址相同），如果有
		port不能被重复使用，否则也是可以重复使用的。
4.如果找到了空闲的port，通过tcp_bucket_create申请tb，并根据情况设置tb-&gt;fastreuse
5.如果sk没被分配tb（sk-&gt;prev == NULL），将sk加入到tb的bind链表（tb-&gt;owners是
	链表头，双向链表（bind_pprev，bind_next））
	sk-&gt;prev = (struct sock *) tb;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3447</x>
      <y>2821</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3443</x>
      <y>2851</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_bucket_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3449</x>
      <y>2847</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3437</x>
      <y>2857</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过kmem_cache_alloc申请tb
2.初始化tb，并将tb加入到hash表头head中
	tb-&gt;port = snum;
	tb-&gt;fastreuse = 0;
	tb-&gt;owners = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3450</x>
      <y>2854</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3409</x>
      <y>2807</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3421</x>
      <y>2807</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3499</x>
      <y>2786</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3518</x>
      <y>2790</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_listen</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3514</x>
      <y>2797</y>
      <w>38</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.sock的状态要是SS_UNCONNECTED，类型要是SOCK_STREAM
2.sk的状态要是TCPF_CLOSE或者TCPF_LISTEN
3.如果sk状态是close，通过tcp_listen_start监听网络
4.设置队列长度
	sk-&gt;max_ack_backlog = backlog;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3524</x>
      <y>2793</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3522</x>
      <y>2809</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_listen_start</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3527</x>
      <y>2805</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3513</x>
      <y>2816</y>
      <w>34</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.设置sk，tp
	sk-&gt;max_ack_backlog = 0;
	sk-&gt;ack_backlog = 0;
	tp-&gt;accept_queue = tp-&gt;accept_queue_tail = NULL;
	tp-&gt;syn_wait_lock = RW_LOCK_UNLOCKED;
2.申请tcp_listen_opt，并初始化其lopt-&gt;max_qlen_log
	最后赋给：
	tp-&gt;listen_opt = lopt;
3.sk-&gt;state = TCP_LISTEN;
4.通过sk-&gt;prot-&gt;get_port申请port，如果之前通过bind申请，
	这里只是改变tb的fastreuse
5.成功之后：
	sk-&gt;sport = htons(sk-&gt;num);
	sk_dst_reset(sk);
	sk-&gt;prot-&gt;hash(sk);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3526</x>
      <y>2812</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3521</x>
      <y>2841</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;prot-&gt;hash
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3527</x>
      <y>2836</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3521</x>
      <y>2847</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3527</x>
      <y>2844</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3526</x>
      <y>2850</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!= TCP_CLOSE</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3521</x>
      <y>2853</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__tcp_v4_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3503</x>
      <y>2860</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果sk的状态在TCP_LISTEN，链入到tcp_listening_hash
	（tcp_lhash_lock保护），以port号sk.num为hash值
	tcp_lhash_users要为0，否则睡眠（等待队列是tcp_lhash_wait）
2.如果处于其他状态，链入到tcp_ehash（每个表头都有一个锁）
3.将sk头插置hash表中（双链表（pprev，next））
4.prot-&gt;stats[smp_processor_id()].inuse++;
5.如果在TCP_LISTEN，需要唤醒等待队列tcp_lhash_wait
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3526</x>
      <y>2856</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3465</x>
      <y>2815</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
udp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3470</x>
      <y>2819</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_v4_get_port</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3466</x>
      <y>2825</y>
      <w>34</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果snum为0，表示由os指定port号，遍历hash表（以port号找sk）
	如果表头是空，说明该port号（或者result/UDP_HTABLE_SIZE）是空闲的
注：1.sysctl_local_port_range[0]是UDP_HTABLE_SIZE的整数倍
	2.port号要在sysctl_local_port_range[0]~sysctl_local_port_range[1]之间
2.如果在hash表中找不到空闲的，就选择hash链表中最短的那个，然后查看port号
	（result += UDP_HTABLE_SIZE）是否空闲（!udp_lport_inuse）
注：这里一直在循环遍历，直到找到为止。

3.如果snum不为0，则在hash表udp_hash中找对应链表，遍历链表，查看是否有和要申请sk
	冲突的sk2（port相同，但是不能reuse），如果存在，fail
4.找到之后，sk-&gt;num = snum;
5.将sk加入到udp_hash对应的链表中，增加计数prot-&gt;stats[smp_processor_id()].inuse++;
	并通过sock_hold增加sk的计数。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3476</x>
      <y>2822</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3600</x>
      <y>2792</y>
      <w>40</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3632</x>
      <y>2796</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_accept</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3622</x>
      <y>2803</y>
      <w>40</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过sk1-&gt;prot-&gt;accept接受client发来的请求
2.通过sock_graft将创建的newsock和接收的sk2建立关系
3.newsock-&gt;state = SS_CONNECTED
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3637</x>
      <y>2799</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3634</x>
      <y>2813</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk1-&gt;prot-&gt;accept
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3639</x>
      <y>2809</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3639</x>
      <y>2816</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3634</x>
      <y>2820</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_accept</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3629</x>
      <y>2826</y>
      <w>35</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果sk.state不是TCP_LISTEN，返回EINVAL
2.如果暂时没收到connect请求（!tp-&gt;accept_queue）
	1.通过sock_rcvtimeo确定serve端等待的时间timeo，如果O_NONBLOCK，返回EAGAIN
	2.通过wait_for_connect等待client端连接
3.接收到连接请求：
	1.将req移出链表，并更新链表
		req = tp-&gt;accept_queue;
		tp-&gt;accept_queue = req-&gt;dl_next
	2.获取新的sk
		newsk = req-&gt;sk;
	3.通过tcp_acceptq_removed减少sk接收队列的长度
		sk-&gt;ack_backlog--
	4.通过tcp_openreq_fastfree释放req
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3640</x>
      <y>2823</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3639</x>
      <y>2851</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait_for_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3644</x>
      <y>2847</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3635</x>
      <y>2857</y>
      <w>47</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.申请wait，通过add_wait_queue_exclusive加入到sk-&gt;sleep
2.循环等待，直到client端连接
	1.task状态设置为TASK_INTERRUPTIBLE
	2.如果没有connect请求（tcp.accept_queue == NULL），通过schedule_timeout睡眠
	3.醒来之后查看：
		1.如果有连接请求（tcp.accept_queue），跳出循环处理
		2.如果没有连接请求，sk的状态不在TCP_LISTEN，返回EINVAL
		3.如果signal_pending，根据timeo的值看在处理完signal之后，是否在继续accept
		4.如果超时，返回EAGAIN
3.跳出循环后，task状态设置为TASK_RUNNING，并移除wait
注：accept_queue&lt;-tcp_acceptq_queue&lt;-tcp_check_req&lt;-tcp_v4_hnd_req&lt;-tcp_v4_do_rcv&lt;-tcp_prot
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3645</x>
      <y>2854</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3690</x>
      <y>2792</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops/inet_dgram_ops</panel_attributes>
    <additional_attributes>50.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3700</x>
      <y>2797</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_getname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3697</x>
      <y>2803</y>
      <w>28</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.sin-&gt;sin_family = AF_INET
2.如果peer不为0
	1.如果没有目标port（!sk-&gt;dport），返回ENOTCONN
	2.如果sk处于TCPF_CLOSE|TCPF_SYN_SENT，但是peer=1，返回ENOTCONN
	3.如果检查通过：
		sin-&gt;sin_port = sk-&gt;dport;
		sin-&gt;sin_addr.s_addr = sk-&gt;daddr;
3.如果peer为0
	1.sin-&gt;sin_port = sk-&gt;sport;
	2.sin-&gt;sin_addr.s_addr默认是sk-&gt;rcv_saddr，只有当其不存在时，才是sk-&gt;saddr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3707</x>
      <y>2800</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sock是server端创建的sock</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3753</x>
      <y>2780</y>
      <w>90</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops</panel_attributes>
    <additional_attributes>10.0;10.0;880.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3834</x>
      <y>2786</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_stream_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3864</x>
      <y>2784</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_dgram_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3755</x>
      <y>2780</y>
      <w>119</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;1170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3825</x>
      <y>2792</y>
      <w>37</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果要连接的地址的sa_family是AF_UNSPEC，通过sk-&gt;prot-&gt;disconnect
	断开连接
2.如果sock的状态是SS_UNCONNECTED，才能处理，其他返回错误码
	1.sk的状态要在TCP_CLOSE
	2.如果sk没被分配port（sk-&gt;num为0），通过sk-&gt;prot-&gt;get_port给sk分配port号
		sk-&gt;sport = htons(sk-&gt;num)
	3.通过sk-&gt;prot-&gt;connect连接serve：
		sock-&gt;state = SS_CONNECTING
3.
注：sock状态：SS_UNCONNECTED  SS_CONNECTING SS_CONNECTED
	sk的状态：TCPF_CLOSE，TCPF_LISTEN
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3841</x>
      <y>2789</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3826</x>
      <y>2805</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;prot-&gt;disconnect
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3827</x>
      <y>2812</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_disconnect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3832</x>
      <y>2801</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3832</x>
      <y>2808</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3843</x>
      <y>2805</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;prot-&gt;connect
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3849</x>
      <y>2801</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3849</x>
      <y>2808</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3844</x>
      <y>2812</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3585</x>
      <y>2654</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_init
(linux/net/ipv4)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3576</x>
      <y>2661</y>
      <w>42</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.检查网络传输数据（inet_skb_parm）的大小是否超过skb.cb
	如果超过，返回EINVAL
2.通过sock_register将inet_family_ops注册到net_families中
3.遍历链表inet_protocol_base，通过inet_add_protocol将协议
	放在hash表inet_protos中
4.分别执行一下初始化：arp_init，ip_init，tcp_v4_init，tcp_init，icmp_init
5.在proc_net下创建raw，netstat，snmp，sockstat，tcp，udp文件
	并赋值其get_info方法：raw_get_info，netstat_get_info，snmp_get_info，afinet_get_info，tcp_get_info，udp_get_info
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3591</x>
      <y>2657</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3519</x>
      <y>2682</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_add_protocol</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3505</x>
      <y>2689</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过prot-&gt;protocol计算hash值，并将inet_protocol连接到inet_protos
2.检查原来的hash表中是否有和当前protocol一样的inet_protocol，如果有：
	prot-&gt;copy = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3522</x>
      <y>2685</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3580</x>
      <y>2679</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3586</x>
      <y>2674</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp是地址解析协议
用于硬件通过广播利用ip地址获取以太网地址</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3553</x>
      <y>2685</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_table_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3559</x>
      <y>2682</y>
      <w>28</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_tbl</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3541</x>
      <y>2691</y>
      <w>30</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.将tbl-&gt;parms.reachable_time取1/2~3/2的tbl-&gt;parms.base_reachable_time
2.申请tbl-&gt;entry_size长度（16字节对齐）的内存，tbl-&gt;id是其cache的名字
3.通过tasklet_init初始化tbl-&gt;gc_task：
	tasklet-&gt;routine = SMP_TIMER_NAME(neigh_periodic_timer)
	tasklet-&gt;data = tbl
4.初始化tbl-&gt;gc_timer，并通过add_timer将其加入timer队列
	tbl-&gt;lock = RW_LOCK_UNLOCKED;
	tbl-&gt;gc_timer.data = (unsigned long)tbl;
	tbl-&gt;gc_timer.function = neigh_periodic_timer;
	tbl-&gt;gc_timer.expires = now + tbl-&gt;gc_interval + tbl-&gt;parms.reachable_time;
5.初始化tbl-&gt;proxy_timer
	init_timer(&amp;tbl-&gt;proxy_timer);
	tbl-&gt;proxy_timer.data = (unsigned long)tbl;
	tbl-&gt;proxy_timer.function = neigh_proxy_process;
	skb_queue_head_init(&amp;tbl-&gt;proxy_queue);
6.设置时间，并将其加入链表neigh_tables
	tbl-&gt;last_flush = now;
	tbl-&gt;last_rand = now + tbl-&gt;parms.reachable_time*20;
	tbl-&gt;next = neigh_tables;
	neigh_tables = tbl;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3553</x>
      <y>2688</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3525</x>
      <y>2674</y>
      <w>64</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3575</x>
      <y>2686</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_add_pack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3577</x>
      <y>2682</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_packet_type</panel_attributes>
    <additional_attributes>80.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3572</x>
      <y>2692</y>
      <w>35</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果CONFIG_NET_FASTROUTE打开，并且pt-&gt;data存在
	通过dev_clear_fastroute清除其fast_path，并：
	netdev_fastroute_obstacles++
2.如果type是ETH_P_ALL，将其加入链表ptype_all，并递增netdev_nit
3.否则加入到hash表ptype_base中
	hash=ntohs(pt-&gt;type)&amp;15;
	pt-&gt;next = ptype_base[hash];
	ptype_base[hash] = pt;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3581</x>
      <y>2689</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3575</x>
      <y>2709</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_clear_fastroute</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3572</x>
      <y>2717</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果dev存在，通过dev_do_clear_fastroute
	清除其fast_path
2.如果不存在，遍历链表dev_base，通过dev_do_clear_fastroute
	清除其fast_path
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3573</x>
      <y>2728</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_do_clear_fastroute</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3570</x>
      <y>2735</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.遍历数组dev-&gt;fastpath：
	dst = dev-&gt;fastpath[i];
	dev-&gt;fastpath[i] = NULL;
2.通过dst_release释放dst
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3581</x>
      <y>2705</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3582</x>
      <y>2712</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3581</x>
      <y>2724</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3580</x>
      <y>2731</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3594</x>
      <y>2686</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_net_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3583</x>
      <y>2682</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在proc_net下创建文件arp
get_info是arp_get_info</panel_attributes>
    <additional_attributes>20.0;10.0;150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3611</x>
      <y>2686</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_sysctl_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3584</x>
      <y>2682</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3608</x>
      <y>2692</y>
      <w>35</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.申请neigh_sysctl_table，
2.创建目录：neigh_root_dir/neigh_proto_dir/neigh_neigh_dir/neigh_dev
	并对每一层赋值（前面一大段是将neigh_sysctl_template赋值，并对其中的neigh_vars.data赋值）
3.通过register_sysctl_table申请ctl_table_header，加入到root_table_header链表
	并返回赋给t-&gt;sysctl_header。其次通过register_proc_table在procfs中创建1的路径
	（如果有table-&gt;proc_handler是普通文件，没有是dir。另外如果是dir会在root-&gt;subdir中
		查找是否有procname一直的文件夹，有的话就不创建了）
4.将neigh_sysctl_table赋给p-&gt;sysctl_table
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3620</x>
      <y>2689</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>181</x>
      <y>4042</y>
      <w>66</w>
      <h>67</h>
    </coordinates>
    <panel_attributes>dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>33</x>
      <y>4042</y>
      <w>58</w>
      <h>66</h>
    </coordinates>
    <panel_attributes>VFS
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>109</x>
      <y>4042</y>
      <w>48</w>
      <h>67</h>
    </coordinates>
    <panel_attributes>file_system
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>112</x>
      <y>4046</y>
      <w>40</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>do_initcalls
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>114</x>
      <y>4049</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>module_init(init_ext2_fs)
(FS_REQUIRES_DEV)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>126</x>
      <y>4052</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>115</x>
      <y>4062</y>
      <w>35</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>module_init(init_proc_fs)
(FS_SINGLE)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>125</x>
      <y>4064</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>125</x>
      <y>4069</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kern_mount
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>112</x>
      <y>4086</y>
      <w>40</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>filesystem_setup
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>114</x>
      <y>4089</y>
      <w>35</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>init_devfs_fs
(FS_SINGLE)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>126</x>
      <y>4091</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>126</x>
      <y>4096</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kern_mount
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>65</x>
      <y>4062</y>
      <w>49</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sys_mount</panel_attributes>
    <additional_attributes>10.0;20.0;470.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>65</x>
      <y>4094</y>
      <w>49</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
do_mount
在/dev上安装devfs</panel_attributes>
    <additional_attributes>10.0;20.0;470.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>0</x>
      <y>4059</y>
      <w>14</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>用户
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1</x>
      <y>4089</y>
      <w>14</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>内核
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>197</x>
      <y>4050</y>
      <w>38</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>(FS_REQUIRES_DEV)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>190</x>
      <y>4072</y>
      <w>50</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>(FS_SINGLE)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>208</x>
      <y>4056</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>实际存在的块设备
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>137</x>
      <y>4070</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_fs_type</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>138</x>
      <y>4077</y>
      <w>30</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_fs_type</panel_attributes>
    <additional_attributes>10.0;210.0;280.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>165</x>
      <y>4076</y>
      <w>27</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建设备</panel_attributes>
    <additional_attributes>10.0;20.0;250.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>54</x>
      <y>4094</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>mount_devfs_fs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>14</x>
      <y>4094</y>
      <w>42</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>53</x>
      <y>4062</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_call
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>13</x>
      <y>4063</y>
      <w>42</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>193</x>
      <y>4079</y>
      <w>44</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>dev: MKDEV(UNNAMED_MAJOR, i)
sb:	get_empty_super和属性初始化
root:	type-&gt;read_super 
		proc通过proc_root新建inode和dentry，并赋值
		devfs通过root_entry新建inode和dentry，并赋值
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>117</x>
      <y>4010</y>
      <w>30</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>132</x>
      <y>4036</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
type-&gt;read_super </panel_attributes>
    <additional_attributes>10.0;60.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>126</x>
      <y>4017</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>super
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>126</x>
      <y>4025</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>root:inode
		dentry
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>65</x>
      <y>4024</y>
      <w>54</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;180.0;520.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>146</x>
      <y>4022</y>
      <w>68</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
procfs的read/write能转接到虚拟设备对应的read/write，所以设备驱动可以在proc中不需要有主次设备号
</panel_attributes>
    <additional_attributes>10.0;10.0;660.0;200.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>295</x>
      <y>4021</y>
      <w>73</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>ext2.i_fop
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>304</x>
      <y>4028</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>S_ISCHR：def_chr_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>304</x>
      <y>4036</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>S_ISBLK：def_blk_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>304</x>
      <y>4044</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>S_ISFIFO：def_fifo_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>304</x>
      <y>4052</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>S_ISSOCK：bad_sock_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>340</x>
      <y>4028</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>chrdevs[major].fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>328</x>
      <y>4028</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filp-&gt;f_op替换为</panel_attributes>
    <additional_attributes>10.0;20.0;120.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>294</x>
      <y>4068</y>
      <w>74</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>procfs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>303</x>
      <y>4075</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>S_ISREG：proc_file_operations
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>327</x>
      <y>4074</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_file_read</panel_attributes>
    <additional_attributes>10.0;30.0;130.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>327</x>
      <y>4076</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proc_file_write</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>340</x>
      <y>4073</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_proc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>340</x>
      <y>4078</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>write_proc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>316</x>
      <y>4078</y>
      <w>10</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
可以自定义</panel_attributes>
    <additional_attributes>10.0;80.0;10.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>311</x>
      <y>4086</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>293</x>
      <y>4110</y>
      <w>77</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>System
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>304</x>
      <y>4123</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>331</x>
      <y>4133</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>def_blk_fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>321</x>
      <y>4126</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISBLK</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>321</x>
      <y>4118</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
S_ISCHR</panel_attributes>
    <additional_attributes>10.0;50.0;160.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>349</x>
      <y>4112</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>de-&gt;u.fcb.ops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>336</x>
      <y>4114</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
de-&gt;u.fcb.ops存在</panel_attributes>
    <additional_attributes>10.0;50.0;130.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>349</x>
      <y>4120</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>chrdevs[major].fops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>335</x>
      <y>4118</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
不存在</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
</diagram>
