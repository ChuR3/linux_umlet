<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram program="umlet" version="14.3.0">
  <zoom_level>1</zoom_level>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>877</x>
      <y>118</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_kernel
bg=red</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>498</x>
      <y>89</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>startup_32</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>277</x>
      <y>104</y>
      <w>22</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>ds=es=fs=gs=__KERNEL_DS

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>289</x>
      <y>92</y>
      <w>216</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置相应的数据段</panel_attributes>
    <additional_attributes>2140.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>302</x>
      <y>103</y>
      <w>45</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>	movl $pg0-__PAGE_OFFSET,%edi /* initialize page tables */
	movl $007,%eax		/* "007" doesn't mean with right to kill, but
				   PRESENT+RW+USER */
2:	stosl					//将eax加载到edi对应的地址中，因为前面有cld，所以edi自增4
	add $0x1000,%eax
	cmp $empty_zero_page-__PAGE_OFFSET,%edi
	jne 2b
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>318</x>
      <y>92</y>
      <w>187</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化PT</panel_attributes>
    <additional_attributes>1850.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>349</x>
      <y>105</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>	movl $swapper_pg_dir-__PAGE_OFFSET,%eax
	movl %eax,%cr3		/* set the page table pointer.. */
	movl %cr0,%eax
	orl $0x80000000,%eax
	movl %eax,%cr0		/* ..and set paging (PG) bit */
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>362</x>
      <y>92</y>
      <w>143</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化PGD</panel_attributes>
    <additional_attributes>1410.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>388</x>
      <y>92</y>
      <w>117</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化栈</panel_attributes>
    <additional_attributes>1150.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>386</x>
      <y>106</y>
      <w>14</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>lss stack_start,%esp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>403</x>
      <y>106</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>	xorl %eax,%eax
	movl $ SYMBOL_NAME(__bss_start),%edi
	movl $ SYMBOL_NAME(_end),%ecx
	subl %edi,%ecx
	rep
	stosb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>417</x>
      <y>92</y>
      <w>88</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
clear bss</panel_attributes>
    <additional_attributes>860.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>442</x>
      <y>108</y>
      <w>12</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>call setup_idt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>445</x>
      <y>92</y>
      <w>60</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化idt（中断描述表）</panel_attributes>
    <additional_attributes>580.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>443</x>
      <y>115</y>
      <w>11</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>IDT

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>443</x>
      <y>115</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ignore_int(高16)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>443</x>
      <y>119</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>8E00
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>443</x>
      <y>123</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>KERNEL_CS
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>443</x>
      <y>127</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ignore_int(低16)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>447</x>
      <y>110</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>375</x>
      <y>117</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>ENTRY(stack_start)
.long SYMBOL_NAME(init_task_union)+8192
.long __KERNEL_DS
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>390</x>
      <y>108</y>
      <w>5</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>493</x>
      <y>82</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arch/i386/kernel/head.S
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>503</x>
      <y>85</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>378</x>
      <y>122</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arch/i386/kernel/init_task.c</panel_attributes>
    <additional_attributes>120.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>375</x>
      <y>129</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>union task_union init_task_union 
	__attribute__((__section__(".data.init_task"))) =
		{ INIT_TASK(init_task_union.task) };
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>387</x>
      <y>135</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
include/linux/sched.h</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>377</x>
      <y>142</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>#define INIT_TASK(tsk)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>385</x>
      <y>145</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
include/asm-i386/processor.h</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>377</x>
      <y>152</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>#define INIT_THREAD
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>453</x>
      <y>108</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arch/i386/kernel/trap.c</panel_attributes>
    <additional_attributes>10.0;20.0;170.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>470</x>
      <y>108</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>struct desc_struct idt_table[256] 
__attribute__((__section__(".data.idt"))) = { {0, 0}, };
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>503</x>
      <y>92</y>
      <w>39</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
复制参数到empty_zero_page开始的2K的块
复制命令行到empty_zero_page+2K开始的2K的块

参数位置引用定义在：arch/i386/kernel/setup.c</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>508</x>
      <y>108</y>
      <w>45</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>	movl $ SYMBOL_NAME(empty_zero_page),%edi
	movl $512,%ecx
	cld
	rep
	movsl			//将esi的内容复制到edi指向的地址中，esi和edi自增4（cld）
	xorl %eax,%eax
	movl $512,%ecx
	rep
	stosl
	movl SYMBOL_NAME(empty_zero_page)+NEW_CL_POINTER,%esi
	andl %esi,%esi
	jnz 2f			# New command line protocol
	cmpw $(OLD_CL_MAGIC),OLD_CL_MAGIC_ADDR
	jne 1f
	movzwl OLD_CL_OFFSET,%esi
	addl $(OLD_CL_BASE_ADDR),%esi
2:
	movl $ SYMBOL_NAME(empty_zero_page)+2048,%edi
	movl $512,%ecx
	rep
	movsl
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>561</x>
      <y>110</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>checkCPUtype
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>503</x>
      <y>92</y>
      <w>64</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检测cpu的类型</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>579</x>
      <y>111</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lgdt gdt_descr
lidt idt_descr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>504</x>
      <y>92</y>
      <w>82</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
加载gdt和IDT</panel_attributes>
    <additional_attributes>10.0;10.0;800.0;190.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>503</x>
      <y>92</y>
      <w>102</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1000.0;170.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>602</x>
      <y>108</y>
      <w>283</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
主cpu
init/main.c</panel_attributes>
    <additional_attributes>10.0;10.0;2810.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>602</x>
      <y>108</y>
      <w>1898</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
次cpu

arch/i386/kernel/smpboot.c</panel_attributes>
    <additional_attributes>10.0;10.0;18960.0;270.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2493</x>
      <y>135</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>initialize_secondary</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2489</x>
      <y>143</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>"movl %0,%%esp\n\t"
"jmp *%1"
:
:"r" (current-&gt;thread.esp),"r" (current-&gt;thread.eip));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2499</x>
      <y>138</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>641</x>
      <y>136</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_arch</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>647</x>
      <y>121</y>
      <w>236</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arch/i386/kernel/setup.c</panel_attributes>
    <additional_attributes>2340.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>375</x>
      <y>187</y>
      <w>35</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>ROOT_DEV = to_kdev_t(ORIG_ROOT_DEV);
drive_info = DRIVE_INFO;
screen_info = SCREEN_INFO;
apm_info.bios = APM_BIOS_INFO;
if( SYS_DESC_TABLE.length != 0 ) {
MCA_bus = SYS_DESC_TABLE.table[3] &amp;0x2;
machine_id = SYS_DESC_TABLE.table[0];
machine_submodel_id = SYS_DESC_TABLE.table[1];
BIOS_revision = SYS_DESC_TABLE.table[2];
}
aux_device_present = AUX_DEVICE_INFO;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>388</x>
      <y>139</y>
      <w>262</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据boot中的参数
设置相应的全局变量</panel_attributes>
    <additional_attributes>2600.0;10.0;10.0;480.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>415</x>
      <y>183</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_memory_region</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>421</x>
      <y>139</y>
      <w>229</w>
      <h>46</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2270.0;10.0;10.0;440.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>411</x>
      <y>190</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>copy_e820_map</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>417</x>
      <y>186</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>410</x>
      <y>198</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_memory_region</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>416</x>
      <y>193</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果申明了A0000
到100000的内存区域，则忽略</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>410</x>
      <y>206</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>e820.map[x].addr = start;
e820.map[x].size = size;
e820.map[x].type = type;
e820.nr_map++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>416</x>
      <y>201</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>437</x>
      <y>139</y>
      <w>213</w>
      <h>47</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2110.0;10.0;10.0;450.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>435</x>
      <y>184</y>
      <w>30</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>	init_mm.start_code = (unsigned long) &amp;_text;
	init_mm.end_code = (unsigned long) &amp;_etext;
	init_mm.end_data = (unsigned long) &amp;_edata;
	init_mm.brk = (unsigned long) &amp;_end;

	code_resource.start = virt_to_bus(&amp;_text);
	code_resource.end = virt_to_bus(&amp;_etext)-1;
	data_resource.start = virt_to_bus(&amp;_etext);
	data_resource.end = virt_to_bus(&amp;_edata)-1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>467</x>
      <y>186</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>parse_mem_cmdline</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>472</x>
      <y>139</y>
      <w>178</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1760.0;10.0;10.0;470.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>485</x>
      <y>186</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_pfn = PFN_UP(__pa(&amp;_end));
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>490</x>
      <y>139</y>
      <w>160</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
计算首个参与内存分配的页面号</panel_attributes>
    <additional_attributes>1580.0;10.0;10.0;470.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>512</x>
      <y>186</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>max_pfn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>515</x>
      <y>139</y>
      <w>135</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历整个e820
找到最大的页号max_pfn
整个内存的最大页面</panel_attributes>
    <additional_attributes>1330.0;10.0;10.0;470.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>526</x>
      <y>185</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>max_low_pfn
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>532</x>
      <y>139</y>
      <w>118</w>
      <h>48</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
系统内存的最大页面</panel_attributes>
    <additional_attributes>1160.0;10.0;10.0;460.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>538</x>
      <y>179</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_bootmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>538</x>
      <y>186</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_bootmem_core</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>542</x>
      <y>139</y>
      <w>109</w>
      <h>42</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将start_pfn到max_low_pfn保留</panel_attributes>
    <additional_attributes>1070.0;10.0;10.0;400.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>544</x>
      <y>182</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>522</x>
      <y>193</y>
      <w>47</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>bdata-&gt;node_bootmem_map = phys_to_virt(_end &lt;&lt; PAGE_SHIFT);
bdata-&gt;node_boot_start = (0 &lt;&lt; PAGE_SHIFT);
bdata-&gt;node_low_pfn = max_low_pfn;
memset(bdata-&gt;node_bootmem_map, 0xff, mapsize)（位图）
注：node_boot_start表示内存的初始位置，即0
node_bootmem_map：从内核结束的位置开始，从这里开始存储系统内存
						的分配位图这里的位图显示的是系统内存的页面分布情况，1表示占用
						在free_bootmem中会没被占用的页面置为0
node_low_pfn：系统内存最大页面号（不包含最尾端的128M）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>544</x>
      <y>189</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>553</x>
      <y>178</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_bootmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>557</x>
      <y>139</y>
      <w>93</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将0~max_low_pfn所有type为E820_RAM
的区域释放</panel_attributes>
    <additional_attributes>910.0;10.0;10.0;390.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>555</x>
      <y>186</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>test_and_clear_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>558</x>
      <y>181</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>573</x>
      <y>177</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reserve_bootmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>577</x>
      <y>139</y>
      <w>73</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这里将内核区域和系统页面映射位图
还有最开始的一个页面
置为已用</panel_attributes>
    <additional_attributes>710.0;10.0;10.0;380.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>578</x>
      <y>180</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>573</x>
      <y>186</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>test_and_set_bit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>629</x>
      <y>175</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>paging_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>634</x>
      <y>139</y>
      <w>56</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arch/i386/mm/init.c
将访问0xC0000000-0xCFFFFFFF时，访问的是0x00000000-0x3FFFFFFF</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;360.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>605</x>
      <y>183</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pagetable_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>611</x>
      <y>178</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
虚拟内存的制作只到了max_low_pfn
后128MB的虚拟内存留给vmlist</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>574</x>
      <y>193</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_bootmem_low_pages</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>582</x>
      <y>186</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为pte申请页面</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>602</x>
      <y>194</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_pmd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>606</x>
      <y>186</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
对于32位寻址，pgd和pmd相同</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>573</x>
      <y>199</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__alloc_bootmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>580</x>
      <y>196</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>572</x>
      <y>208</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__alloc_bootmem_core</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>579</x>
      <y>202</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>575</x>
      <y>211</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>593</x>
      <y>201</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>*pmd=_KERNPG_TABLE + __pa(pte)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>606</x>
      <y>197</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>669</x>
      <y>60</y>
      <w>83</w>
      <h>45</h>
    </coordinates>
    <panel_attributes>#define __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))  //将内核实际地址转换成虚拟地址
#define PAGE_MASK	(~(PAGE_SIZE-1))  //对page取整
#define pmd_page(pmd) \
((unsigned long) __va(pmd_val(pmd) &amp; PAGE_MASK)) //pmd所在页面的起始虚拟地址
#define __pte_offset(address) \
		((address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1))  //虚拟地址在页表中的偏移
#define pmd_offset(dir, address) ((pmd_t *) pgd_page(*(dir)) + \
			__pmd_offset(address))					//将address中页表部分提取出来，在*dir指向页表中的偏移


typedef struct { unsigned long pgprot; } pgprot_t;

#define pmd_val(x)	((x).pmd)
#define pgd_val(x)	((x).pgd)
#define pgprot_val(x)	((x).pgprot)

#define __pte(x) ((pte_t) { (x) } )
#define __pmd(x) ((pmd_t) { (x) } )
#define __pgd(x) ((pgd_t) { (x) } )
#define __pgprot(x)	((pgprot_t) { (x) } )
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>609</x>
      <y>186</y>
      <w>29</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将实际的物理地址写入pte中</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>623</x>
      <y>203</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>*pte = mk_pte_phys(__pa(vaddr), PAGE_KERNEL)
注：PAGE_KERNEL中没有_PAGE_USER，表示cpl
	是3的时候，mmu访问时会出现页错误
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>693</x>
      <y>194</y>
      <w>41</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__asm__( "movl %%ecx,%%cr3\n" ::"c"(__pa(swapper_pg_dir)));
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>632</x>
      <y>178</y>
      <w>81</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将内存中的页面映射重新装入高速缓存中</panel_attributes>
    <additional_attributes>10.0;10.0;790.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1062</x>
      <y>84</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__alloc_bootmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1059</x>
      <y>93</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__alloc_bootmem_core
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1068</x>
      <y>87</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历pgdat_list</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>557</x>
      <y>215</y>
      <w>70</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.检查需要申请的size，和需要对齐的字节，看是否满足要求
2.preferred，对align对齐，要申请的内存要比goal高，也就是要申请的起始idx
	areasize对page对齐，表示要处理几个页面
	incr：遍历的过程中，需要对align对齐
3.从preferred开始找到node_bootmem_map位图中为0的idx，然后从idx开始向后看
	是否在要申请的页面的范围内有页面被占用，如果被占用且不是从0开始查找的，就从0开始
	重新查找，如果是从0开始查找的，就返回NULL.（这里应该是为了不让内存成为一个个小碎片。
	如果有内存在想要申请的大块内存的中间，可能就需要等待）
	如果连续的areasize的页面没被占用，就申请到了，记录最开始的页面为start
4.如果align没有到一页对齐，并且要申请的页面和之前申请的页面紧挨着，并且那个页面还有内存没被使用
	，就从前一个还没申请完的页面开始，其中得更新areasize：需要新占用的页面，bdata-&gt;last_pos：
	更新最后一个申请的页面，bdata-&gt;last_offset：在上述页面中的偏移。ret：内存开始的虚拟地址
5.如果页面4的情况不满足，就直接申请过areasize个页面
6.在node_bootmem_map位图中置上相应的位，并且将申请的内存清0.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1084</x>
      <y>138</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_all_bootmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1082</x>
      <y>146</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_all_bootmem_core</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1091</x>
      <y>141</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
contig_page_data</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1071</x>
      <y>156</y>
      <w>41</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.查看node_bootmem_map中没被占用的页面，将这些页面
	Reserved标记清除，将couter置1，并释放页面，这里所占据
	的初始页面存储在pgdat-&gt;node_mem_map中
2.将node_bootmem_map所占据的页面释放，并将Reserved
	标记清除，count置1，并释放页面
3.bdata-&gt;node_bootmem_map = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1091</x>
      <y>149</y>
      <w>3</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>738</x>
      <y>196</y>
      <w>44</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>if (low &lt; max_dma)
	zones_size[ZONE_DMA] = low; //low是16M对应的页面
else {
	zones_size[ZONE_DMA] = max_dma;//max_low_pfn对应的页面
	zones_size[ZONE_NORMAL] = low - max_dma;
	zones_size[ZONE_HIGHMEM] = high - low;//highend_pfn对应的页面
}
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>633</x>
      <y>178</y>
      <w>119</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1170.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>812</x>
      <y>193</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_area_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>633</x>
      <y>178</y>
      <w>184</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1820.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>807</x>
      <y>200</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_area_init_core</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>816</x>
      <y>196</y>
      <w>38</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
0, &amp;contig_page_data, &amp;mem_map, zones_size, 0, 0, 0</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>786</x>
      <y>207</y>
      <w>64</w>
      <h>71</h>
    </coordinates>
    <panel_attributes>1.算出传入zones总共有totalpages页面
2.初始化链表active_list inactive_list
3.通过alloc_bootmem_node申请系统内存（查找的起始点从16MB开始）
	申请的大小为（totalpages+1）个page的大小
	得到的起始地址对page取整，并将起始地址赋给mem_map，
	contig_page_data.node_mem_map//节点页在mem_map中的起始位置
	pgdat-&gt;node_size = totalpages;
	pgdat-&gt;node_start_paddr = 0;
	pgdat-&gt;node_start_mapnr = 0;//节点相对于mem_map的偏移
	pgdat-&gt;nr_zones = 0;
4.初始化page结构
	set_page_count(p, 0);
	SetPageReserved(p)
	p.wait.lock=WAITQUEUE_RW_LOCK_UNLOCKED
	INIT_LIST_HEAD(p.wait.task_list)
	INIT_LIST_HEAD(p.list) //free_area 链接的链表
5.初始化节点的zone
pgdat-&gt;node_zones[j].size = zones_size[j];
pgdat-&gt;node_zones[j].name = zone_names[j]; //DMA/normal/highmem
pgdat-&gt;node_zones[j].lock = SPIN_LOCK_UNLOCKED;
pgdat-&gt;node_zones[j].zone_pgdat = pgdat;
pgdat-&gt;node_zones[j].free_pages = 0;
pgdat-&gt;node_zones[j].need_balance = 0;
pgdat-&gt;nr_zones = j+1
mask = (realsize / zone_balance_ratio[j]);
if (mask &lt; zone_balance_min[j])
	mask = zone_balance_min[j];
else if (mask &gt; zone_balance_max[j])
	mask = zone_balance_max[j];
zone-&gt;pages_min = mask;  //设置water_mark
zone-&gt;pages_low = mask*2;
zone-&gt;pages_high = mask*3;
zone-&gt;zone_mem_map = mem_map + offset; //该节点所有区域的偏移是一样的
zone-&gt;zone_start_mapnr = offset;
zone-&gt;zone_start_paddr = 0;
6.记录page所在的zone（page-&gt;zone），和page的虚拟地址（page-&gt;virtual）
7.初始化链表zone-&gt;free_area[i].free_list
	zone-&gt;free_area[MAX_ORDER-1].map = NULL
8.初始化伙伴算法中的标志位map
	bitmap_size = (size-1) &gt;&gt; (i+4); //i+4=i+1+3,+1的原因是和伙伴共用一个位，+3的原因是一个字节有8位
												//这里可以看到所有的page在所有的order中都有映射，只不过这个page可能在其他块当中
	bitmap_size = LONG_ALIGN(bitmap_size+1);//对字节取整
	zone-&gt;free_area[i].map = 
	  (unsigned long *) alloc_bootmem_node(pgdat, bitmap_size);//获取map的内存空间，并将所有的位置0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>813</x>
      <y>203</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>852</x>
      <y>207</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>build_zonelists</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>818</x>
      <y>203</y>
      <w>40</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>851</x>
      <y>215</y>
      <w>46</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>gfp_mask中（__GFP_DMA置上时，不管__GFP_HIGHMEM）
__GFP_HIGHMEM：zonelist中会依次存储ZONE_HIGHMEM ZONE_NORMAL ZONE_DMA
没有__GFP_HIGHMEM和__GFP_DMA：zonelist中会依次存储ZONE_NORMAL ZONE_DMA
__GFP_DMA：zonelist中只会存储ZONE_DMA
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>856</x>
      <y>210</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注意没有break</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>633</x>
      <y>196</y>
      <w>39</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__fix_to_virt(__end_of_fixed_addresses - 1) &amp; PMD_MASK
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>609</x>
      <y>186</y>
      <w>40</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
获取fix_adress最低位的
22~32位</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>655</x>
      <y>192</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fixrange_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>610</x>
      <y>186</y>
      <w>53</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请pte，并填入pmd
但是并没有将页表填入pte</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>672</x>
      <y>192</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pkmap_page_table
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>610</x>
      <y>186</y>
      <w>69</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将从Fe000000开始的4MB的虚拟内存的pte赋给</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>883</x>
      <y>121</y>
      <w>209</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
linux/arch/i386/mm/init.c</panel_attributes>
    <additional_attributes>10.0;10.0;1740.0;90.0;2070.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1086</x>
      <y>130</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mem_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1090</x>
      <y>133</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从这开始bootmem就不再使用
而使用mem_map</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1040</x>
      <y>143</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>highmem_start_page = mem_map + highstart_pfn;
max_mapnr = num_physpages = highend_pfn;
high_memory = (void *) __va(max_low_pfn * PAGE_SIZE)
memset(empty_zero_page, 0, PAGE_SIZE);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1060</x>
      <y>133</y>
      <w>31</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1115</x>
      <y>137</y>
      <w>51</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>for (tmp = 0; tmp &lt; max_low_pfn; tmp++) //对于低896M,计算reservedpages
	if (page_is_ram(tmp) &amp;&amp; PageReserved(mem_map+tmp))
		reservedpages++;
//对于高于896M的区域
if (!page_is_ram(tmp)) {
		SetPageReserved(page);
		continue;
	}
	if (bad_ppro &amp;&amp; page_kills_ppro(tmp))
	{
		SetPageReserved(page);
		continue;
	}
	ClearPageReserved(page);
	set_bit(PG_highmem, &amp;page-&gt;flags);
	atomic_set(&amp;page-&gt;count, 1);
	__free_page(page);
	totalhigh_pages++;
}
totalram_pages += totalhigh_pages;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1090</x>
      <y>133</y>
      <w>50</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>999</x>
      <y>134</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmem_cache_sizes_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>883</x>
      <y>121</y>
      <w>122</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1200.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1001</x>
      <y>145</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cs_cachep
cs_dmacachep
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1008</x>
      <y>137</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为cache_sizes中不同size的
通用缓冲区申请cache</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>66</x>
      <y>83</y>
      <w>102</w>
      <h>107</h>
    </coordinates>
    <panel_attributes>1.并发产生的问题
	1.原子性：因为中断导致一些共享资源的竞争，如果在并发程序中，只要一个线程有store操作，就可能产生资源的竞争
	2.顺序性：cpu在执行的时候，因为下一句指令和当前的指令没产生任何影响，所以在当前指令可能会miss，例如：
				peterson算法：
					T1								T2
				store(flag1,1)				store(flage2,1)
				store(turn,2)				store(turn,1)			//礼让，让对方先执行
				load(flag2)					load(flag1)
				load(turn)					load(turn)
			while(flag2&amp;&amp;turn==2);	while(flag1&amp;&amp;turn==1);   //如果不是自己执行就自旋
			因为对于T1而言，在读flag2之前无需对flag2进行操作，而store（flag1）需要在总线空闲的状态去操作，所以可能
			是先读的flag2，因为此时flag2还没置上，此时如果切换到T2，也有可能是乱序执行，先读的flag1，导致此时读的flag1和
			flag2都是0，所以T1和T2都可能进入临界区。
		这个是因为cpu为了使得单线程执行更加优化而设计的，但是在并发的时候，因为cpu的乱序执行，导致了两者同时进入临界区。
	3.可见性：在不同的核内，都存在store buffer，cpu在load和store的过程中，可能都没讲变量放在内存中，而是放在store buffer中
				这就导致如果core0对内存进行了写操作，其他core根本看不见，从而使不同的核在操作内存时并没有考虑到另一个核对内存的写
2.原子操作
	1.单个的汇编代码并不是一个原子操作，例如__asm__（addq $1,%0 :"m"(*addr)）,这条内联汇编指令会转换成说一次load，或者一次
		store或者本地的操作
	2.cpu提供的原子操作：
		1.cpu提供的原子操作指令 如x86 test_and_set，这个指令会使读和写操作会不做打断的完成
		2.x86提供的总线锁：例如上述指令，加上lock， __asm__（lock addq $1,%0 :"m"(*addr)）,但是这个lock会将总线锁住，使cpu没办法通过总线访问
		内存
		3.RISCV的架构提供了LR/SC的缓存锁，在LR的时候，会将变量对应的缓存加载，并对缓存做标记；当SC的时候，会检查是否有本cpu的标记，如果有，则将
		变量存入到缓存，并且将缓存上的所有cpu的标记全部清除，如果没有标记则会反应错误，程序需要while重新执行。
			但是这个缓存锁可能只对不同核之间有效（猜测），同一个核之间可能需要另外的方法实现临界区
	3.原子操作保证了内存操作的原子性；另外在原子操作前后cpu也不会乱序执行，保证了顺序性；在原子操作前后，会将缓存中的数据写入到内存中，保证了可见性
3.自旋锁
	1.通过原子操作，保证了cpu在不受打断的过程中完成检查锁和设置锁的过程，通过锁，保证了临界区内内存操作的安全性。
	2.但是liveness确得不到保障，因为在spinlock的过程中，其他线程都在自旋等待，如果在spinlock期间发生了中断，导致spinlock的时间过长（或者如果两个线程
		在同一个核上，即使从当前线程调度到另一个线程，那个线程也是自旋等待），导致线程自旋时间过长，影响cpu的性能，所以在操作系统中spinlock一般会在外面包
		一层禁止中断的代码：
		disableinterrupt（）//在禁止中断的时候，需要将eflag压进栈，是为了防止在spinlock中的因为一些其他锁的需求而禁止中断
		sinlock（）
		
		disableinterrupt（）//压eflag，此时应该是禁止中断
		sinlock（）

		un_sinlock()
		enableinterrupt()//虽然打开了中断，但是将eflag pop，所以此时中断还是关着的

		un_sinlock()
		enableinterrupt()//在开中断的时候将eflag pop
4.互斥锁
	互斥锁，是因为线程要长时间呆在临界区，另外自旋锁实现的时候需要关闭中断，但是有时线程释放锁，是在中断中进行的（例如文件的读写）
	所以同样通过原子操作将临界区锁住，但是当无法获得锁的时候，将task的状态设置成等待状态，从而将cpu的使用权交出去，保证cpu的性能

5.同步
	1.条件变量,用一个大锁保证条件和操作变量的原子性
		mutex_lock(&amp;mutex)
		while(!condition) sleep(quene,&amp;mutex)//在睡的时候解锁，在醒的时候上锁
		condition signal(quene)
		mutex_unlock(&amp;mutex)
	2.信号量
		注意每一个状态都要设置一个信号量（例如，队列里面满和空两个状态）
	3.主从结构：
		每个consumer想要消费时，需要向master申请；同样需要生产的时候也需要向master申请
	注：条件变量和主从结构的效率较低，但是代码较好实现；信号量则与他们相反

6.并发编程中注意的问题：
	1.死锁：1.主要是lock（A）..lock(A)，在同一个线程中获取锁（例如在中断中获取lock（A），导致线程的死锁）
			2.是lock（A） lock（B）,另一个线程lock（B） lock(A)，这个解决办法是按照顺序获取锁，例如两个线程都按照lock（A） lock(B)的线程获取锁
			3.同步造成的死锁，例如 A醒通知B醒 ，B醒通知A睡，A睡的时候通知B睡，B睡通知A醒
	2.原子违反：没对变量进行上锁
		顺序违反，没对线程进行同步
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>748</x>
      <y>135</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>trap_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>784</x>
      <y>135</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_IRQ</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>754</x>
      <y>121</y>
      <w>131</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
系统保留中断的 IDT</panel_attributes>
    <additional_attributes>1290.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>789</x>
      <y>121</y>
      <w>94</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
外设中断的IDT
</panel_attributes>
    <additional_attributes>920.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>728</x>
      <y>141</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>set_trap_gate(14,&amp;page_fault)
set_system_gate(0x80,&amp;system_call)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>737</x>
      <y>138</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>784</x>
      <y>143</y>
      <w>58</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>void (*interrupt[NR_IRQS])(void) 中断服务函数指针数组 名字结构为IRQ##x##y##_interrupt
BUILD_16_IRQS(0x0)  中断服务函数 BUILD_IRQ(x##y) 

"pushl $"#nr"-256
"jmp common_interrupt"
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>772</x>
      <y>140</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_ISA_irqs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>778</x>
      <y>138</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>787</x>
      <y>138</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>967</x>
      <y>142</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>softirq_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>883</x>
      <y>121</y>
      <w>91</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;890.0;210.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>959</x>
      <y>149</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tasklet_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>986</x>
      <y>149</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>open_softirq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>974</x>
      <y>145</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TASKLET_SOFTIRQ
HI_SOFTIRQ</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>964</x>
      <y>145</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
bh_action</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>955</x>
      <y>155</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>t-&gt;func = func;
t-&gt;data = data;
t-&gt;state = 0;
atomic_set(&amp;t-&gt;count, 0);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>962</x>
      <y>152</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>984</x>
      <y>156</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>softirq_vec[nr].data = data
softirq_vec[nr].action = action
softirq_mask(i) |= (1&lt;&lt;nr)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>991</x>
      <y>152</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
softirq_vec
表示软中断通道</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>862</x>
      <y>136</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sched_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>867</x>
      <y>121</y>
      <w>19</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>852</x>
      <y>145</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_bh</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>856</x>
      <y>139</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TIMER_BH
TQUEUE_BH
IMMEDIATE_BH</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>836</x>
      <y>153</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bh_base[nr] = routine
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>858</x>
      <y>153</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>842</x>
      <y>148</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>855</x>
      <y>148</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>903</x>
      <y>136</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>time_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>882</x>
      <y>121</y>
      <w>29</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>874</x>
      <y>143</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>xtime.tv_sec = get_cmos_time();
xtime.tv_usec = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>881</x>
      <y>139</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
从cmos芯片获取时间
这个芯片由电池供电</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>899</x>
      <y>144</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cpu_has_tsc
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>906</x>
      <y>139</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tsc是提供时钟的精度</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>918</x>
      <y>144</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_irq
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>906</x>
      <y>139</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
0，irq0</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>910</x>
      <y>151</y>
      <w>31</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>irq0因为SA_SHIRQ没置，所以由时钟中断独占
	因为SA_INTERRUPT置上，所以不允许被打断
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>924</x>
      <y>147</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>4438</x>
      <y>5704</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>Use case 1</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>883</x>
      <y>121</y>
      <w>574</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;5720.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1235</x>
      <y>128</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_root_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1206</x>
      <y>135</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_misc_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1212</x>
      <y>131</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1170</x>
      <y>146</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>simple_ones
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1175</x>
      <y>138</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化在/proc下生成的节点
name  read_proc</panel_attributes>
    <additional_attributes>380.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1197</x>
      <y>147</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_proc_read_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1203</x>
      <y>138</y>
      <w>14</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为数组simple_ones
创建节点</panel_attributes>
    <additional_attributes>100.0;10.0;20.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1116</x>
      <y>176</y>
      <w>33</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>如果parent不存在，则需要通过xlate_proc_name
在proc_root中查到相应的component
注：1.de-&gt;subdir表示其子节点
	其所有的子节点通过（de-&gt;next）
	链表连接
	2.strchr在找不到'/'的时候，返回NULL
	此时会将parent赋值。从这里可以知道，如果parent
	为NULL,创建的节点最后不能带'/'
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1133</x>
      <y>171</y>
      <w>46</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>440.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1164</x>
      <y>171</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1157</x>
      <y>178</y>
      <w>46</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.kmalloc申请proc_dir_entry和name的内存
2.将proc_dir_entry区域清空
3.将name复制到proc_dir_entry后面
4.赋值name属性
	ent-&gt;name = ((char *) ent) + sizeof(*ent);
	ent-&gt;namelen = len;
5.如果是dir，如果没有任何权限，添加读、执行权限给u/g/o
	ent-&gt;proc_fops = &amp;proc_dir_operations;
	ent-&gt;proc_iops = &amp;proc_dir_inode_operations;
	ent-&gt;nlink = 2;
	如果不是dir，如果类型没置（reg、dir等这种属性），添加S_IFREG属性
				如果权限没置，添加读属性给u/g/o
			 ent-&gt;nlink = 1
6.ent-&gt;mode = mode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1239</x>
      <y>175</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1177</x>
      <y>171</y>
      <w>70</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1221</x>
      <y>181</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>make_inode_number</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1209</x>
      <y>189</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过find_first_zero_bit在proc_alloc_map
	中查找空闲位
2.利用set_bit将proc_alloc_map找到的空闲位置上
3.返回PROC_DYNAMIC_FIRST + i
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1218</x>
      <y>184</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1226</x>
      <y>178</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1247</x>
      <y>186</y>
      <w>18</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //赋值找到的inode号
dp-&gt;low_ino = i;
 //连入到目录树
dp-&gt;next = dir-&gt;subdir;
dp-&gt;parent = dir;
dir-&gt;subdir = dp;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1246</x>
      <y>178</y>
      <w>7</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1269</x>
      <y>186</y>
      <w>30</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果是dir
	dp-&gt;proc_fops = &amp;proc_dir_operations;
	dp-&gt;proc_iops = &amp;proc_dir_inode_operations;
	dir-&gt;nlink++
2.如果是link
	dp-&gt;proc_iops = &amp;proc_link_inode_operations;
3.如果是reg
	dp-&gt;proc_fops = &amp;proc_file_operations
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1246</x>
      <y>178</y>
      <w>34</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1179</x>
      <y>156</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_proc_entry</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1187</x>
      <y>150</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1176</x>
      <y>159</y>
      <w>12</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1198</x>
      <y>157</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes> //赋值simple_ones中定义的函数
res-&gt;read_proc=read_proc;
res-&gt;data=data;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1206</x>
      <y>150</y>
      <w>4</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1212</x>
      <y>138</y>
      <w>16</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建reg读文件
</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1221</x>
      <y>141</y>
      <w>39</w>
      <h>31</h>
    </coordinates>
    <panel_attributes> //创建kmg节点
create_proc_entry("kmsg", S_IRUSR
entry-&gt;proc_fops = &amp;proc_kmsg_operations
 //创建kcore节点
create_proc_entry("kcore", S_IRUSR,
proc_root_kcore-&gt;proc_fops = &amp;proc_kcore_operations;
proc_root_kcore-&gt;size =
		(size_t)high_memory - PAGE_OFFSET + PAGE_SIZE
 //如果prof_shift存在，创建profile
create_proc_entry("profile", S_IWUSR | S_IRUGO
entry-&gt;proc_fops = &amp;proc_profile_operations;
entry-&gt;size = (1+prof_len) * sizeof(unsigned int);
 //定义了__powerpc__，创建ppc_htab
entry = create_proc_entry("ppc_htab", S_IRUGO|S_IWUSR
entry-&gt;proc_fops = &amp;ppc_htab_operations
	//创建slabinfo
create_proc_read_entry("slabinfo", S_IWUSR | S_IRUGO, NULL,
			       slabinfo_read_proc
entry-&gt;write_proc = slabinfo_write_proc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1241</x>
      <y>131</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1262</x>
      <y>137</y>
      <w>37</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>proc_net = proc_mkdir("net"
proc_mkdir("sysvipc"
proc_sys_root = proc_mkdir("sys"
proc_root_fs = proc_mkdir("fs"
proc_root_driver = proc_mkdir("driver"
proc_mkdir("openprom"
注：proc_mkdir和create_proc_entry类似，
	只不过是专用来创建dir。 mode也不在是参数，
	直接赋值ent-&gt;mode = S_IFDIR | S_IRUGO | S_IXUGO
	其他和create_proc_entry创建目录一样
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1310</x>
      <y>137</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_tty_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1240</x>
      <y>131</y>
      <w>77</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;750.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1302</x>
      <y>144</y>
      <w>41</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.创建tty目录
	proc_mkdir("tty"
2.在tty下创建ldisc和driver两个目录
	proc_tty_ldisc = proc_mkdir("tty/ldisc"
	proc_tty_driver = proc_mkdir("tty/driver"
3.在tty下创建两个reg文件，并赋值read_proc
	create_proc_read_entry("tty/ldiscs", 0, 0, tty_ldiscs_read_proc
	create_proc_read_entry("tty/drivers", 0, 0, tty_drivers_read_proc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1316</x>
      <y>140</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1361</x>
      <y>138</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_device_tree_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1241</x>
      <y>131</y>
      <w>129</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1270.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1347</x>
      <y>147</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_mkdir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1352</x>
      <y>141</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建device-tree目录</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1364</x>
      <y>148</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_path_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1367</x>
      <y>141</y>
      <w>6</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1383</x>
      <y>148</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_node</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1368</x>
      <y>141</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1388</x>
      <y>137</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proc_bus = proc_mkdir("bus"
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1241</x>
      <y>131</y>
      <w>158</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1560.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>887</x>
      <y>120</y>
      <w>1349</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;13470.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2228</x>
      <y>131</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kernel_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2229</x>
      <y>138</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2233</x>
      <y>134</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
第一个内核线程</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2222</x>
      <y>145</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_basic_setup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2227</x>
      <y>141</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2221</x>
      <y>148</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将所有静态编译的module_init的
函数指针链接到.initcall.init
moudule_init的申明在
linux/include/linux/init.h</panel_attributes>
    <additional_attributes>70.0;10.0;140.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2229</x>
      <y>155</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_initcalls</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2216</x>
      <y>158</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
__initcall_start应该是第一个函数指针的地址
但是在这里却被申明为函数指针（不清楚原因）
在3.4.2中被声明为函数指针的地址</panel_attributes>
    <additional_attributes>190.0;10.0;110.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2213</x>
      <y>164</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>do {
	(*call)();
	call++;
} while (call &lt; &amp;__initcall_end);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2239</x>
      <y>165</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_scheduled_tasks</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2234</x>
      <y>158</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2227</x>
      <y>148</y>
      <w>52</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2270</x>
      <y>152</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>filesystem_setup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2262</x>
      <y>160</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_devfs_fs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2267</x>
      <y>155</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2253</x>
      <y>169</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2276</x>
      <y>170</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kern_mount
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2253</x>
      <y>163</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将filesystem放到file_systems
链表中</panel_attributes>
    <additional_attributes>140.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2265</x>
      <y>163</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将mnt放在type.kern_mnt中
然后用户通过sys_mount去安装
至根目录上</panel_attributes>
    <additional_attributes>20.0;10.0;180.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2227</x>
      <y>148</y>
      <w>186</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1840.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2405</x>
      <y>158</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mount_devfs_fs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2385</x>
      <y>167</y>
      <w>30</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>boot_options的OPTION_NOMOUNT不能置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2399</x>
      <y>161</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2417</x>
      <y>166</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2409</x>
      <y>161</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
安装devfs到/dev下</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2277</x>
      <y>177</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>read_super
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2282</x>
      <y>173</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2277</x>
      <y>184</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>type-&gt;read_super
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2283</x>
      <y>180</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_fs_type</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2277</x>
      <y>191</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_read_super</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2283</x>
      <y>187</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2218</x>
      <y>202</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_root_entry
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2224</x>
      <y>194</y>
      <w>62</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>600.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2237</x>
      <y>201</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>atomic_set (&amp;fs_info.devfsd_overrun_count, 0);
init_waitqueue_head (&amp;fs_info.devfsd_wait_queue);
init_waitqueue_head (&amp;fs_info.revalidate_wait_queue);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2253</x>
      <y>194</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2274</x>
      <y>199</y>
      <w>27</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>fs_info.sb = sb;
sb-&gt;u.generic_sbp = &amp;fs_info;
sb-&gt;s_blocksize = 1024;
sb-&gt;s_blocksize_bits = 10;
sb-&gt;s_magic = DEVFS_SUPER_MAGIC;
sb-&gt;s_op = &amp;devfs_sops;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2283</x>
      <y>194</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2315</x>
      <y>201</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_vfs_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2283</x>
      <y>194</y>
      <w>39</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
root_inode</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2298</x>
      <y>211</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.如果de-&gt;inode.dentry存在，打印问题
	返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2306</x>
      <y>204</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2328</x>
      <y>211</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>iget
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2321</x>
      <y>204</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
de-&gt;inode.ino</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2343</x>
      <y>211</y>
      <w>19</w>
      <h>3</h>
    </coordinates>
    <panel_attributes> de-&gt;inode.dentry = dentry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2322</x>
      <y>204</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2333</x>
      <y>214</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2328</x>
      <y>219</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_new_inode
(reference)</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2333</x>
      <y>222</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2326</x>
      <y>225</y>
      <w>17</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_op-&gt;read_inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2334</x>
      <y>227</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
devfs_sops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2329</x>
      <y>232</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_read_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2291</x>
      <y>240</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_devfs_entry_from_vfs_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2301</x>
      <y>235</y>
      <w>36</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2270</x>
      <y>248</y>
      <w>26</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.inode不能为NULL
2.inode-&gt;i_ino不能小于FIRST_INODE
3.通过sb得到fs_info
	fs_info = inode-&gt;i_sb-&gt;u.generic_sbp
4.fs_info不能为NULL
5。i_ino不能大于num_inodes
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2274</x>
      <y>243</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2299</x>
      <y>243</y>
      <w>18</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
参考create_entry
返回inode对应的设备存储</panel_attributes>
    <additional_attributes>30.0;10.0;140.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2300</x>
      <y>252</y>
      <w>31</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>fs_info-&gt;table[inode-&gt;i_ino - FIRST_INODE]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2326</x>
      <y>240</y>
      <w>19</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_blocks = 0;
inode-&gt;i_blksize = 1024;
inode-&gt;i_op = &amp;devfs_iops;
inode-&gt;i_fop = &amp;devfs_fops;
inode-&gt;i_rdev = NODEV;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2334</x>
      <y>235</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2348</x>
      <y>240</y>
      <w>39</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>S_ISCHR：
	inode-&gt;i_rdev = MKDEV (de-&gt;u.fcb.u.device.major,
			       de-&gt;u.fcb.u.device.minor);
S_ISBLK：
	inode-&gt;i_rdev = MKDEV (de-&gt;u.fcb.u.device.major,
			       de-&gt;u.fcb.u.device.minor);
	inode-&gt;i_bdev = bdget (inode-&gt;i_rdev)
	如果i_bdev存在，但是bd_op不存在，并且de-&gt;u.fcb.ops存在
	inode-&gt;i_bdev-&gt;bd_op = de-&gt;u.fcb.ops
S_ISFIFO：
	inode-&gt;i_fop = &amp;def_fifo_fops
S_ISREG：
	inode-&gt;i_size = de-&gt;u.fcb.u.file.size
S_ISDIR：
	inode-&gt;i_op = &amp;devfs_dir_iops
S_ISLNK：
	inode-&gt;i_op = &amp;devfs_symlink_iops;
	inode-&gt;i_size = de-&gt;u.symlink.length
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2335</x>
      <y>235</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2392</x>
      <y>240</y>
      <w>25</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_mode = de-&gt;inode.mode;
inode-&gt;i_uid = de-&gt;inode.uid;
inode-&gt;i_gid = de-&gt;inode.gid;
inode-&gt;i_atime = de-&gt;inode.atime;
inode-&gt;i_mtime = de-&gt;inode.mtime;
inode-&gt;i_ctime = de-&gt;inode.ctime;
inode-&gt;i_nlink = de-&gt;inode.nlink;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2335</x>
      <y>235</y>
      <w>66</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;640.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2346</x>
      <y>200</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sb-&gt;s_root = d_alloc_root (root_inode)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2283</x>
      <y>194</y>
      <w>75</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;730.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1829</x>
      <y>150</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1832</x>
      <y>147</y>
      <w>398</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>3960.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1691</x>
      <y>178</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_init
1.获取宿主-pci桥的类型，确定操作函数
2.通过pci_scan_bus建立bus树， bus和设备之间的关系（pci_do_scan_bus）
	初始化设备的irq和resource（pci_setup_device），初始化bridge的资源（pci_read_bridge_bases）
	最后通过pci_scan_bridge递归的建立所有桥上的bus树和dev（包含irq和resource）
3.找到固件配置的设备中断数据，找到路径连接器的操作函数pirq_router
	最后通过pcibios_lookup_irq将BIOS建立的中断请求，设置dev.irq,并向procfs注册
4.将pci桥和设备的资源注册或者申请（conflict，通过pcibios_assign_resources）到资源树中</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1695</x>
      <y>153</y>
      <w>140</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>1380.0;10.0;10.0;250.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1482</x>
      <y>197</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_find_bios</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1485</x>
      <y>181</y>
      <w>212</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CONFIG_PCI_BIOS
pci_probe &amp; PCI_PROBE_BIOS</panel_attributes>
    <additional_attributes>2100.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1537</x>
      <y>199</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_check_direct</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1545</x>
      <y>181</y>
      <w>152</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CONFIG_PCI_DIRECT
PCI_PROBE_CONF1 | PCI_PROBE_CONF2</panel_attributes>
    <additional_attributes>1500.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1509</x>
      <y>208</y>
      <w>40</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.检查pci 1型和2型设备（2型此后不再用，这里只是为了兼容）
2.1型设备检测：
	1.向CFB写1（即CF8(4字节)的最高位）
	2.将CF8（4字节）读出来存储
	3.再向CF8写0x80000000
	4.如果CF8读出来是0x80000000，并且pci_sanity_check通过
	就将之前存储的CF8恢复，并通过request_region
	最后返回pci_direct_conf1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1534</x>
      <y>202</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1507</x>
      <y>226</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_sanity_check</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1513</x>
      <y>222</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pci_direct_conf1</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1489</x>
      <y>234</y>
      <w>41</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.将dev初始化，
	dev.bus(bus.number初始化为0)
	dev.devfn（逻辑设备号）递增
2.遍历bus0上的256个设备，读取设备的PCI_CLASS_DEVICE
	是BRIDGE_HOST或者DISPLAY_VGA
	或者读取设备的PCI_VENDOR_ID是INTEL或者COMPAQ
	表示是一个pci总线
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1510</x>
      <y>229</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1533</x>
      <y>226</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_region</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1525</x>
      <y>222</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1532</x>
      <y>233</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__request_region</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1538</x>
      <y>229</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ioport_resource，0xCF8，8，"PCI conf1"</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1533</x>
      <y>243</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1537</x>
      <y>236</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请resource内存</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1547</x>
      <y>241</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>res-&gt;name = name;
res-&gt;start = start;（CF8）
res-&gt;end = start + n - 1;(CFF)
res-&gt;flags = IORESOURCE_BUSY;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1537</x>
      <y>236</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1538</x>
      <y>236</y>
      <w>48</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;460.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1577</x>
      <y>239</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1572</x>
      <y>243</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__request_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1549</x>
      <y>253</y>
      <w>20</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //new本身存在问题
1.new的end&lt;start
 //new不在root范围内
2.new的start小于root的start
3.new的end大于root的end
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1557</x>
      <y>246</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
下面三种情况不能再root下申请resource
所以在__request_region中会将new释放</panel_attributes>
    <additional_attributes>200.0;10.0;60.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1571</x>
      <y>253</y>
      <w>42</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.遍历root的子树root-&gt;child
2.如果子树中遍历到了最后（!temp）或者new在temp的前面
	将new插入到子树的链表中
		new-&gt;sibling = tmp;
		*p = new;
		new-&gt;parent = root;
		return NULL;
3.如果temp.end&gt;new，表示temp的区域和new有重合
	return temp
4.如果上述条件均不满足（temp.end&lt;new）,遍历链表的下一个
	重复过程2~4
注：child：表示当前resource的子链表头
	sibling：同级的resource通这个链表链接在一起
	parent:指向当前resource的父资源（子资源空间在父资源空间之内）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1576</x>
      <y>246</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1613</x>
      <y>247</y>
      <w>35</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果conflict为NULL,则new能正确的链入
	到parent的child链表中
2.如果conflict是parent，则new存在问题，
	直接释放new
3.如果confict不是parent，并且conflict.flags
	的IORESOURCE_BUSY没置上，就以conflict为parent
	重新通过__request_resource来查看new释放在conflict
	的子链表中有重叠
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1583</x>
      <y>239</y>
      <w>43</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1555</x>
      <y>199</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_root_ops = dir
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1561</x>
      <y>181</y>
      <w>136</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1340.0;10.0;10.0;180.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1629</x>
      <y>193</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_scan_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1634</x>
      <y>181</y>
      <w>63</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>610.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1565</x>
      <y>206</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_alloc_primary_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1572</x>
      <y>196</y>
      <w>64</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>620.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1558</x>
      <y>212</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_bus_exists</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1563</x>
      <y>209</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查bus是否存在
pci_root_buses</panel_attributes>
    <additional_attributes>90.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1550</x>
      <y>218</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.遍历node链表（同级链表）
2.如果发现bus.number=nr，
	或者在该bus的children中
	发现nr的bus（利用pci_bus_exists递归）
	就找到编号为nr的bus
3.如果遍历完整个pci的bus树，没找到nr的
	bus，说明目前并不存在该bus
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1561</x>
      <y>215</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1570</x>
      <y>209</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没找到相应编号的bus</panel_attributes>
    <additional_attributes>40.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1582</x>
      <y>212</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1577</x>
      <y>217</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_alloc_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1578</x>
      <y>225</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1581</x>
      <y>220</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请bus的内存空间</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1598</x>
      <y>225</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>memset(b, 0, sizeof(*b));
INIT_LIST_HEAD(&amp;b-&gt;children);
INIT_LIST_HEAD(&amp;b-&gt;devices);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1582</x>
      <y>220</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化bus</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1599</x>
      <y>216</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>list_add_tail
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1582</x>
      <y>212</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将bus.node链接到
pci_root_buses的尾端</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1615</x>
      <y>215</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>b-&gt;number = b-&gt;secondary = bus;
b-&gt;resource[0] = &amp;ioport_resource;
b-&gt;resource[1] = &amp;iomem_resource;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1581</x>
      <y>212</y>
      <w>40</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化primary_bus</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1660</x>
      <y>205</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>b-&gt;sysdata = sysdata;
b-&gt;ops = ops;
 //pci桥子设备中的最大总线号
b-&gt;subordinate = pci_do_scan_bus(b);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1633</x>
      <y>196</y>
      <w>41</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;390.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1670</x>
      <y>215</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_do_scan_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1675</x>
      <y>211</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1621</x>
      <y>224</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>memset(&amp;dev0, 0, sizeof(dev0));
dev0.bus = bus;
dev0.sysdata = bus-&gt;sysdata;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1630</x>
      <y>218</y>
      <w>49</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化dev0</panel_attributes>
    <additional_attributes>470.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1651</x>
      <y>223</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_scan_slot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1657</x>
      <y>218</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将dev0.devfn设置为0~0x100
每次扫描8个设备</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1656</x>
      <y>226</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历8个功能设备</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1650</x>
      <y>229</y>
      <w>59</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.先将0号设备的header读进来（pci_read_config_byte）
	temp-&gt;hdr_type = hdr_type &amp; 0x7f
2.在通过pci_scan_device检测pci总线上否存在该设备
	并对其属性根据配置赋值
3.如果设备存在，通过pci_name_device对dev的name属性赋值
4.如果是0号设备，就检测header中的最高位是否为1，如果是0，表示是
	单功能设备（整个接口卡提供一个功能），之后的7个逻辑设备就不用遍历了
	is_multi = hdr_type &amp; 0x80;
	first_dev = dev;
	...
	if (func &amp;&amp; !is_multi)		/* not a multi-function device */
			continue;
5.将设备的global_list链入到pci_devices链表中
	将设备的bus_list链入到bus的devices中
6.通过pci_fixup_device使得当dev的ventor或者device满足pcibios_fixups
	和pci_fixups中的相应条件时，通过其hook函数做出相应的修改(这里PCI_FIXUP_HEADER
	表示将头部信息读出之后就进行修改，PCI_FIXUP_FINAL表示设置了总线地址之后进行修改)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1653</x>
      <y>259</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_scan_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1659</x>
      <y>256</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1617</x>
      <y>269</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_config_dword</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1624</x>
      <y>262</y>
      <w>37</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
这个函数通过 pci_##rw##_config_##size定义
这里是调用bus.ops从PCI_VENDOR_ID读取32字节
头16字节是vendor，后16字节是device</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1634</x>
      <y>270</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.读出的ventor和device
	不能是0或者（~0），
	否则返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1640</x>
      <y>262</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1652</x>
      <y>278</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1656</x>
      <y>262</y>
      <w>12</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请dev内存</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1662</x>
      <y>277</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>memcpy(dev, temp, sizeof(*dev));
dev-&gt;vendor = l &amp; 0xffff;
dev-&gt;device = (l &gt;&gt; 16) &amp; 0xffff;
dev-&gt;dma_mask = 0xffffffff
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1658</x>
      <y>262</y>
      <w>17</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置dev</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1687</x>
      <y>279</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_setup_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1658</x>
      <y>262</y>
      <w>38</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;170.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1637</x>
      <y>289</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.dev-&gt;slot_name  bus_number:slot:func
	dev-&gt;name		PCI device vendor:device
2.dev-&gt;class被赋值为PCI_CLASS_REVISION初始地址的
	4字节的高3个字节
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1662</x>
      <y>282</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1692</x>
      <y>282</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dev-&gt;hdr_type</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1691</x>
      <y>286</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
NORMAL
class不能为BRIDGE</panel_attributes>
    <additional_attributes>100.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1679</x>
      <y>291</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1675</x>
      <y>296</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1689</x>
      <y>297</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_bases</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1693</x>
      <y>291</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
resource
ram：6，rom：PCI_ROM_ADDRESS</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1702</x>
      <y>296</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>分别从PCI_SUBSYSTEM_VENDOR_ID和
PCI_SUBSYSTEM_ID读取16字节到
dev-&gt;subsystem_vendor和
dev-&gt;subsystem_device
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1693</x>
      <y>291</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1596</x>
      <y>307</y>
      <w>33</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.读取PCI_INTERRUPT_PIN字节，如果是0，
	表示没有中断请求；如果是1~4，则表示
	设备链接在pci接口4根针的其中一个。
	PCI_INTERRUPT_LINE表示被映射到中断控制器
	的哪个引脚，这个一般是由固件设置，因为固件知道
	pci和中断控制器的硬件电路
	如果设备存在中断，
	dev-&gt;irq = irq（LINE的值）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1615</x>
      <y>299</y>
      <w>66</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>640.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1636</x>
      <y>306</y>
      <w>46</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1，遍历ram（howmany，6个）
2.取得ram对应的resource，并对其赋值
	res = &amp;dev-&gt;resource[pos];
	res-&gt;name = dev-&gt;name;
3.向寄存器PCI_BASE_ADDRESS_0 + (pos &lt;&lt; 2)
	读取ram的初始地址（l），然后向其写~0,然后再次读取，
	便是ram的大小（size），最后将初始地址l写进寄存器恢复
4.ram的（sz）大小不能是0或者（~0）
5.初始地址是（~0），则表示地址是0
6.l最低位是1，表示IO,IO的高29位表示初始地址，因为ram大小
	只能是2的整数次幂，所以sz高29位中最低位1，表示其大小
	（pci_size用于pci ram的真实大小）
	l最低位是0，表示memory map，高28位表示初始地址，sz的高28
	位中的最低位1表示其大小（pci_size）；l的第3位表示是否可预取
	（prefetchable）
	其他详情参考P1052
	根据解析，赋值res-&gt;start res-&gt;end res-&gt;flags
7.如果是memory_map,低于1M，64位，下一个寄存器表示初始地址或者
	大小的高32位，此时需要重新更新res-&gt;start res-&gt;end
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1654</x>
      <y>300</y>
      <w>43</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置ram resource</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1686</x>
      <y>307</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>dev-&gt;rom_base_reg = rom;
res = &amp;dev-&gt;resource[PCI_ROM_RESOURCE]
res-&gt;flags = (l &amp; PCI_ROM_ADDRESS_ENABLE) |
			  IORESOURCE_MEM | IORESOURCE_PREFETCH | IORESOURCE_READONLY | IORESOURCE_CACHEABLE;
res-&gt;start = l &amp; PCI_ROM_ADDRESS_MASK;
res-&gt;end = res-&gt;start + sz
res-&gt;name = dev-&gt;name
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1694</x>
      <y>300</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置rom resource</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1700</x>
      <y>286</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
BRIDGE
class要为BRIDGE
ram为2，rom：PCI_ROM_ADDRESS1</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1722</x>
      <y>291</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_bases</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1700</x>
      <y>286</y>
      <w>62</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
CARDBUS
class要是BRIDGE_CARDBUS</panel_attributes>
    <additional_attributes>10.0;10.0;600.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1738</x>
      <y>294</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1741</x>
      <y>290</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1752</x>
      <y>295</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_bases</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1756</x>
      <y>290</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ram：1
rom：无</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1765</x>
      <y>294</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>分别从PCI_CB_SUBSYSTEM_VENDOR_ID和
PCI_CB_SUBSYSTEM_ID读取16字节到
dev-&gt;subsystem_vendor和
dev-&gt;subsystem_device
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1759</x>
      <y>290</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1705</x>
      <y>260</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_name_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1678</x>
      <y>256</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1694</x>
      <y>268</y>
      <w>37</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>遍历pci_vendor_list数据库，查看是否有和dev-&gt;vendor
以及dev-&gt;device相同的项，从而更新dev-&gt;name
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1710</x>
      <y>263</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1738</x>
      <y>223</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_fixup_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1676</x>
      <y>218</y>
      <w>69</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;670.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1755</x>
      <y>231</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_bridge_bases</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1745</x>
      <y>226</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1730</x>
      <y>226</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1720</x>
      <y>230</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_fixup_ghosts</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1710</x>
      <y>237</y>
      <w>38</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果逻辑设备号小于mirror（PCI_DEVFN(16,0)）
	的设备中有一个设备（devfn）与设备（devfn+mirror）
	不是完全相同，就直接返回（或者存在PCI_CLASS_BRIDGE_HOST
	的设备）；否则释放掉所有大于mirror的设备
注：不清楚resource检测的作用，感觉完全没有意义
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1720</x>
      <y>233</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1684</x>
      <y>50</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_##rw##_config_##size</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1682</x>
      <y>41</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>PCI_OP(read, word, u16 *)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1692</x>
      <y>44</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1677</x>
      <y>53</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PCI_##size##_BAD
pos不按规定的对齐</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1658</x>
      <y>59</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>PCIBIOS_BAD_REGISTER_NUMBER
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1692</x>
      <y>59</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;bus-&gt;ops-&gt;rw##_##size
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1692</x>
      <y>53</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1702</x>
      <y>62</y>
      <w>13</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pci_direct_conf1</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1693</x>
      <y>69</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_conf1_read_config_word</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1693</x>
      <y>72</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
找到pci设备地址</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1652</x>
      <y>79</y>
      <w>47</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>outl
0x80000000 | (dev-&gt;bus-&gt;number &lt;&lt; 16) | (dev-&gt;devfn &lt;&lt; 8) | (where &amp; ~3)
0xCF8
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1703</x>
      <y>80</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inw(0xCFC + (where&amp;2))
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1704</x>
      <y>72</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
读取偏移为where&amp;2的地址</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1724</x>
      <y>81</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>PCIBIOS_SUCCESSFUL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1704</x>
      <y>72</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1750</x>
      <y>238</y>
      <w>60</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.pci桥对应的设备要存在
2.bus中的resource指向dev中PCI_BRIDGE_RESOURCES
	及其之后的3个resource
3.赋值pci桥的IO窗口（4KB对齐）
	res-&gt;flags = (io_base_lo &amp; PCI_IO_RANGE_TYPE_MASK) | IORESOURCE_IO;
	res-&gt;start = base;
	res-&gt;end = limit + 0xfff;
	res-&gt;name = child-&gt;name;
4.赋值pci桥的memory map窗口（1MB对齐）
	res-&gt;flags = (mem_base_lo &amp; PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
	res-&gt;start = base;
	res-&gt;end = limit + 0xfffff;
	res-&gt;name = child-&gt;name;
5.赋值pci桥的窗口（最低4位1表示64，0表示32）
	res-&gt;flags = (mem_base_lo &amp; PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM | IORESOURCE_PREFETCH;
	res-&gt;start = base;
	res-&gt;end = limit + 0xfffff;
	res-&gt;name = child-&gt;name;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1765</x>
      <y>234</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1676</x>
      <y>218</y>
      <w>173</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历bus的devices链表中所有的device
如果设备是BRIDGE或者CARDBUS
</panel_attributes>
    <additional_attributes>10.0;10.0;1710.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1839</x>
      <y>223</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_scan_bridge</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1803</x>
      <y>232</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_read_config_dword</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1810</x>
      <y>226</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
PCI_PRIMARY_BUS</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1841</x>
      <y>226</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
buses &amp; 0xffff00
如果次总线号或者子树中的
最大总线号不为0，表示BIOS
已经被对其进行枚举</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1828</x>
      <y>232</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1816</x>
      <y>237</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>第二次遍历时（pass!=0）,直接返回
因为bios处理的pci桥设备会在第一次
遍历时处理完
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1841</x>
      <y>238</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_add_new_bus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1841</x>
      <y>232</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1815</x>
      <y>245</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_alloc_bus
（reference）</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1822</x>
      <y>241</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1834</x>
      <y>246</y>
      <w>43</w>
      <h>22</h>
    </coordinates>
    <panel_attributes> //node加入到parent_bus的children链表中
list_add_tail(&amp;child-&gt;node, &amp;parent-&gt;children);
child-&gt;self = dev;
dev-&gt;subordinate = child;
child-&gt;parent = parent;
child-&gt;ops = parent-&gt;ops;
child-&gt;sysdata = parent-&gt;sysdata;

child-&gt;number = child-&gt;secondary = busnr;
child-&gt;primary = parent-&gt;secondary;
child-&gt;subordinate = 0xff;

child-&gt;resource[i] = &amp;dev-&gt;resource[PCI_BRIDGE_RESOURCES+i]
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1849</x>
      <y>241</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1878</x>
      <y>238</y>
      <w>31</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>child-&gt;primary = buses &amp; 0xFF;
child-&gt;secondary = (buses &gt;&gt; 8) &amp; 0xFF;
child-&gt;subordinate = (buses &gt;&gt; 16) &amp; 0xFF;
child-&gt;number = child-&gt;secondary;

 //如果不是cardbus，这里采用的是深度优先算法
 //cmax是子树中最大的bus号（不论是bios遍历的，还是没遍历的）
cmax = pci_do_scan_bus(child);
 //如果时cardbus，没有桥接
cmax = child-&gt;subordinate

 //更新最大总线号
if (cmax &gt; max) max = cmax;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1841</x>
      <y>232</y>
      <w>45</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1846</x>
      <y>226</y>
      <w>80</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果bios没对pci进行配置
就次总线号和最大子树总线号为0</panel_attributes>
    <additional_attributes>10.0;10.0;780.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1910</x>
      <y>237</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>第一次遍历时（pass=0）,直接返回
第一次只处理bios处理过的pci设备
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1919</x>
      <y>231</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1934</x>
      <y>237</y>
      <w>52</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.将命令寄存器存储，然后向命令寄存器写0，向状态寄存器写全1
	pci_read_config_word(dev, PCI_COMMAND, &amp;cr);
	pci_write_config_word(dev, PCI_COMMAND, 0x0000);
	pci_write_config_word(dev, PCI_STATUS, 0xffff);
2，通过pci_add_new_bus申请child_bus（++max），其中会对主次总线号和
	子树最大总线号赋值，然后在外面进行组装，写入到PCI_PRIMARY_BUS
3.如果不是cardbus，利用pci_do_scan_bus对child进行深度有先的编号
	否则，max += 3（能插入4个cards）
4，然后更新子树的最大总线号，并将其写入寄存器PCI_SUBORDINATE_BUS中
	child-&gt;subordinate = max;
	pci_write_config_byte(dev, PCI_SUBORDINATE_BUS, max);
5.将命令寄存器恢复
	pci_write_config_word(dev, PCI_COMMAND, cr);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1923</x>
      <y>231</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1846</x>
      <y>226</y>
      <w>151</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1490.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1987</x>
      <y>235</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>child-&gt;name
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1713</x>
      <y>188</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_irq_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1694</x>
      <y>181</y>
      <w>27</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1690</x>
      <y>196</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pirq_find_routing_table</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1699</x>
      <y>191</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pirq_table</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1688</x>
      <y>202</y>
      <w>27</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.搜索物理地址0xf0000~0x100000，
	routing_table起始地址是16位对齐
	所以addr+=16
2.检测结构是否符合
	rt-&gt;signature != PIRQ_SIGNATURE ||
    rt-&gt;version != PIRQ_VERSION ||
    rt-&gt;size % 16 ||
    rt-&gt;size &lt; sizeof(struct irq_routing_table)
3.如果条件符合，并且irq_routing_table所
	对应的字节的sum为0irq_routing_table
	中有checksum），返回找到的rt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1698</x>
      <y>199</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1711</x>
      <y>191</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果pirq_table没找到
并且pci_probe &amp; PCI_BIOS_IRQ_SCAN</panel_attributes>
    <additional_attributes>70.0;10.0;180.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1720</x>
      <y>197</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pirq_find_routing_table</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1729</x>
      <y>200</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1717</x>
      <y>204</y>
      <w>27</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1。通过PCIBIOS_GET_ROUTING_OPTIONS
	向bios服务pci_indirect请求，如果返回值正确
	申请irq_routing_table内存，并根据相应的
	返回值赋值
	memset(rt, 0, sizeof(struct irq_routing_table));
	rt-&gt;size = opt.size + sizeof(struct irq_routing_table);
	rt-&gt;exclusive_irqs = map;
	memcpy(rt-&gt;slots, (void *) page, opt.size);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1463</x>
      <y>206</y>
      <w>40</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.遍历0xe0000~0xffff0，查找BIOS32 Service directory，其中	length
	要存在，checksum为0，revision为0，entry要小于0x100000
	将entry转化成虚拟地址之后，赋值给bios32_indirect
2.在check_pcibios中通过bios32_service找到pci服务的entry并转
	化为虚拟地址pci_indirect，然后通过服务PCIBIOS_PCI_BIOS_PRESENT
	检查pci服务是否存在，如果存在返回pci bios服务的封装函数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1484</x>
      <y>200</y>
      <w>6</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1718</x>
      <y>191</y>
      <w>42</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果找到了pirq_table</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1752</x>
      <y>195</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1746</x>
      <y>198</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pirq_peer_trick</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1745</x>
      <y>204</y>
      <w>22</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.遍历pirq_table中所有的irq_info
	将其中存在的bus通过busmap存储
	然后通过pci_scan_bus将没建立
	的bus树建立起来，建立起来之后
	pcibios_last_bus = -1
注：之前只是扫面了0号总线上的
	pci设备，这里是将其他pci树补全
	如果树存在，pci_scan_bus会通过
	pci_bus_exists返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1751</x>
      <y>201</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1781</x>
      <y>199</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pirq_find_router</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1757</x>
      <y>195</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;320.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1770</x>
      <y>205</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_find_slot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1768</x>
      <y>202</y>
      <w>27</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
根据irq_router中的bus和设备号找到dev</panel_attributes>
    <additional_attributes>190.0;10.0;70.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1768</x>
      <y>211</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>遍历pci_devices中的global_list
全局链表，找到bus和逻辑设备号
相同的pirq_router_dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1775</x>
      <y>208</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1786</x>
      <y>202</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1791</x>
      <y>207</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>遍历pirq_routers数组，找到和pirq_table
相同vendor和device的项，这个项中
有操作中断路径互连器的接口
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1756</x>
      <y>195</y>
      <w>74</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1817</x>
      <y>199</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.exclusive_irqs中为1的中断输入线
	pirq_penalty[i] += 100
2.如果是APIC中断控制器，自带router
	所以pirq_table赋为NULL
注：exclusive_irqs位图中为1，表示该中断输入
	应尽量少的共用，所以将其“惩罚量”加100。在路径
	互连时，尽量不选这条中断请求线。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1862</x>
      <y>190</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_fixup_peer_bridges</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1695</x>
      <y>181</y>
      <w>178</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1760.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1851</x>
      <y>199</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.pcibios_last_bus&lt;0表示pirq_peer_trick
	已经遍历过0号总线之外的其他树
2.pcibios_last_bus不能大于0xff，
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1862</x>
      <y>193</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
filter</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1880</x>
      <y>199</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>对于小于pcibios_last_bus的bus，
看其上是否有0~255号设备（查看vendor）
如果有通过pci_scan_bus建立其总线树和
设备
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1871</x>
      <y>193</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1925</x>
      <y>189</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_fixup_irqs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1695</x>
      <y>181</y>
      <w>237</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2350.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1909</x>
      <y>199</y>
      <w>27</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>遍历pci_devices链表中的所有设备，如果
dev-&gt;irq有效（这是bios已经分配好的），
则将相应中断请求线的pirq_penalty++。

注：如果pirq_penalty显示该中断请求要
分配给ISA(大于100，小于100000),但是
在已经分配给pci设备，那么将其pirq_penalty
重置
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1916</x>
      <y>192</y>
      <w>18</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pirq_penalty</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1964</x>
      <y>195</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_lookup_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1933</x>
      <y>192</y>
      <w>40</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历pci_devices，读取PCI_INTERRUPT_PIN
如果有中断（pin不为0），但是没连接到中断控制器的
中断请求线上（dev-&gt;irq为0）</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1942</x>
      <y>203</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pirq_get_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1946</x>
      <y>198</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1937</x>
      <y>210</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>遍历pirq_table中slot的元素（所有中断设备的信息）
如果发现bus和相应的设备号和dev相同的，返回
对应的irq_info
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1947</x>
      <y>206</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1970</x>
      <y>208</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes> //link表示和互连器连接的线号
pirq = info-&gt;irq[pin].link;
 //mask表示可以连接到中断控制器的哪个引脚
mask = info-&gt;irq[pin].bitmap;
mask &amp;= pcibios_irq_mask
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1970</x>
      <y>198</y>
      <w>8</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2001</x>
      <y>200</y>
      <w>41</w>
      <h>53</h>
    </coordinates>
    <panel_attributes>1.如果没分配中断请求线（!newirq）,并且
	要求分配中断号；如果发现mask中可以被
	使用，并且pirq_penalty最小的中断号
	通过request_irq申请中断号（后面会free，实际
	只是通过register_irq_proc注册procfs。
	另外这里请求空的中断处理函数，如果能成功返回，说明之后申请中断处理函数
	也可以顺利申请（没有action或者SA_SHIRQ））
	newirq = i
2.如果link的高4位为F,表示路径连接器和中断控制
	器通过硬连接，其低四位便是中断控制器的请求线号
	irq = pirq &amp; 0xf
	msg = "Hardcoded"
3.如果不是硬链接，通过pirq_router.get获取该路径连接器的
	线是否连接到中断控制器，如果!0，表示已连接
	irq = r-&gt;get
	msg = "Found";
4.如果上述2个条件均不满足，但是被分配了newirq，通过r-&gt;set
	（不能是VGA）将路径连接器和中断控制器的newirq号请求线连接
	如果成功，eisa_set_level_irq将0x4d0 + (irq &gt;&gt; 3)（port）
	读进来，并将irq &amp; 7位置上后，写进port
	msg = "Assigned";
	irq = newirq;
5.如果最后irq还是为0，表示没分配中断请求线给dev
	如果该dev只允许唯一的中断请求线newirq
	msg = "Guessed";
	irq = newirq;
	否则，直接返回0
6.遍历pci_devices中的其他设备，如果该设备连接到相同的路径
	连接器的相同通道（link相同），则为该设备分配中断控制器
	的请求线
	//这里的dev2包含dev，所以这里设置了dev.irq
	dev2-&gt;irq = irq;
	pirq_penalty[irq]++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1970</x>
      <y>197</y>
      <w>39</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
assign=0表示尚未连接中断请求线的dev
之后在说，先处理已经连接的</panel_attributes>
    <additional_attributes>10.0;20.0;370.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2078</x>
      <y>191</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_resource_survey</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1696</x>
      <y>181</y>
      <w>395</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;3930.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2046</x>
      <y>199</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_allocate_bus_resources</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2055</x>
      <y>194</y>
      <w>35</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为bios中已经分配的pci桥
resource建立树结构（conflict除外）</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2043</x>
      <y>207</y>
      <w>30</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.遍历父节点的所有子节点（父节点包含root）
	找到每个bus对应的pci桥（dev = bus-&gt;self）
2.遍历pci桥的bridge资源（要存在!r-&gt;start），
	通过pci_find_parent_resource讯在pci桥父bus
	上包含该resource的总线的parent_resource
3.通过request_resource将pci桥的resource注册
	到父bus的resource树中
4.将pci桥的resource遍历完之后，pcibios_allocate_bus_resources
	递归将其子gus上的资源注册至resource树中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2056</x>
      <y>202</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2048</x>
      <y>225</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_find_parent_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2057</x>
      <y>222</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2044</x>
      <y>231</y>
      <w>33</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.找到设备所在的bus（dev-&gt;bus）
2.bus的resource要存在
3.start存在，且dev的resource要在bus相应
	的resource范围内
4.bus的resource（r）要和dev的resource（res）
	是IO寻址还是Mem寻址要是一样的
	IORESOURCE_IO | IORESOURCE_MEM
5.如果预取的符号也是一致的（IORESOURCE_PREFETCH）
	这个bus resource就是要找的父resource
6.如果预取符号不一致，但是dev的resource可预取
	但是父bus的resource不可预取时，暂存这个resource
	如果没有更好的就将其返回。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2056</x>
      <y>228</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2081</x>
      <y>200</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_allocate_resources</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2088</x>
      <y>194</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
0</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2073</x>
      <y>208</y>
      <w>25</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.将PCI_COMMAND寄存器读出
2.遍历所有的ram resource，
	该resource不能连接到树中（r-&gt;parent为NULL）
	resource被分配总线地址（r-&gt;start不为0）	
3.已生效的resource(disable=0，
	command中相应的标志置上)在第
	一次访问时(pass=0)通过pci_find_parent_resource
	在父总线上找到父resource，然后
	通过request_resource将dev的resource
	连接到resource中；
	没生效的resource（disable=1，command
	中相应的标志没置上），将在第二次访问
	的时候将其连接到resource中；
	如果dev的resource与父resource矛盾，
	将其分配的总线地址清除
	r-&gt;end -= r-&gt;start;
	r-&gt;start = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2091</x>
      <y>203</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历pci_devices所有设备</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2077</x>
      <y>205</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ram</panel_attributes>
    <additional_attributes>150.0;20.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2091</x>
      <y>205</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
rom</panel_attributes>
    <additional_attributes>10.0;20.0;180.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2100</x>
      <y>208</y>
      <w>25</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>r-&gt;flags &amp;= ~PCI_ROM_ADDRESS_ENABLE;
pci_write_config_dword(dev, dev-&gt;rom_base_reg, reg &amp; ~PCI_ROM_ADDRESS_ENABLE)
注：在第一次扫描时，将rom关闭
（在初始化时由BIOS或者设备驱动
程序使用），但是resource还是存在
再次需要时，可通过驱动程序将其打开
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2102</x>
      <y>200</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_allocate_resources</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2088</x>
      <y>194</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
1</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2127</x>
      <y>200</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_assign_resources</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2088</x>
      <y>194</y>
      <w>48</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;460.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2137</x>
      <y>203</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2126</x>
      <y>208</y>
      <w>30</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.遍历pci_devices所有设备
2.class要存在且不是PCI_CLASS_BRIDGE_HOST
ram地址空间[0，6)
3.PCI_CLASS_STORAGE_IDE设备（硬盘）的前4区间
	VGA设备的IO地址，这些地址已经被使用
	所以不需要分配
4.如果没被分配总线地址（!r-&gt;start &amp;&amp; r-&gt;end），
	通过pci_assign_resource分配总线地址
5.如果pci_probe的PCI_ASSIGN_ROMS置上
	将其bios分配的地址清除
	r-&gt;end -= r-&gt;start;
	r-&gt;start = 0;
	然后通过pci_assign_resource重新分配
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2131</x>
      <y>232</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_assign_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2139</x>
      <y>229</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2127</x>
      <y>239</y>
      <w>29</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.计算resource的size，和起始分配地址
	size = res-&gt;end - res-&gt;start + 1;
	min = (res-&gt;flags &amp; IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;
2.通过pci_assign_bus_resource申请可预取
（IORESOURCE_PREFETCH）符号相同的地址空间，
如果没有成功，并且该resource可预取
再次通过pci_assign_bus_resource分配
可预取符号不同的地址空间
（可预取的res能安排不可预取的area，但是不可预取的res不能安排可预取的area）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2138</x>
      <y>235</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2127</x>
      <y>256</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_assign_bus_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2137</x>
      <y>253</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2111</x>
      <y>263</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.resource要存在
2.type_mask规定的flag要相同
3.bus的resource要求预取时，
	dev的resource必须时可预取的
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2115</x>
      <y>259</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历bus的4个resource空间</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2137</x>
      <y>263</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>allocate_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2135</x>
      <y>259</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2130</x>
      <y>270</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2131</x>
      <y>266</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
查看子树链表中间的区域
看是否能容纳该resource</panel_attributes>
    <additional_attributes>130.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2117</x>
      <y>276</y>
      <w>41</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.调整end，如果child没有，则指向bus的end
	如果有child，end指向第一个resource的start
	另外end不能大于max
2，调整start，开始指向bus的start，但是不能小于min
	并将start对size取整
3.alignf在对start或者end做调整，这里pcibios_align_resource
	中处理IORESOURCE_IO中不能申请start从0x100~0x400的地址
	（以免和接口卡地址冲突），将start调整
4.判断start到end的距离是否能容纳resource
	new-&gt;start &lt; new-&gt;end &amp;&amp; new-&gt;end - new-&gt;start + 1 &gt;= size
	如果能容纳：
	new-&gt;end = new-&gt;start + size - 1;
	return 0;
5.如果不能容纳（!this），但是已经遍历到了最后，表示该bus已经没空间
	容纳该resource，return -EBUSY
6.如果不能容纳，但是还没遍历到最后，就调整到下一个空闲空间
	new-&gt;start = this-&gt;end + 1;
	this = this-&gt;sibling;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2135</x>
      <y>273</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2149</x>
      <y>270</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__request_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2138</x>
      <y>266</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果找到了足够的空间容纳resource
就将其注册至资源树中
</panel_attributes>
    <additional_attributes>70.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2162</x>
      <y>256</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_update_resource</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2140</x>
      <y>253</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2163</x>
      <y>263</y>
      <w>32</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>ram:
new = res-&gt;start | (res-&gt;flags &amp; PCI_REGION_FLAG_MASK);
reg = PCI_BASE_ADDRESS_0 + 4*resource;

PCI_ROM_RESOURCE:
new = res-&gt;start | (res-&gt;flags &amp; PCI_REGION_FLAG_MASK);
res-&gt;flags |= PCI_ROM_ADDRESS_ENABLE;
new |= PCI_ROM_ADDRESS_ENABLE;
reg = dev-&gt;rom_base_reg;

最后写入寄存器：
pci_write_config_dword(dev, reg, new);
然后在读取出来，检查和写进去的地址是否一致
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2172</x>
      <y>259</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1843</x>
      <y>162</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_fixup_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1831</x>
      <y>153</y>
      <w>23</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
遍历pci_devices所有设备
对pcibios_fixups和pci_fixups规定的
PCI_FIXUP_FINAL进行修复</panel_attributes>
    <additional_attributes>30.0;10.0;190.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1748</x>
      <y>38</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_find_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1749</x>
      <y>47</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_find_subsys</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1755</x>
      <y>41</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1736</x>
      <y>56</y>
      <w>40</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.从from遍历device（当from为NULL时，从pci_devices）
	如果其vendor，device，subsystem_vendor，subsystem_device
	相同，就返回dev.否则就遍历其global_list.next
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1755</x>
      <y>50</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1793</x>
      <y>37</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_find_class</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1779</x>
      <y>46</y>
      <w>40</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.从from遍历device（当from为NULL时，从pci_devices）
	如果其dev-&gt;class相同，就返回dev.否则就遍历其global_list.next
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1799</x>
      <y>40</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1835</x>
      <y>37</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_enable_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1821</x>
      <y>45</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_enable_resources</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1830</x>
      <y>40</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
资源激活</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1798</x>
      <y>53</y>
      <w>44</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.读取PCI_COMMAND
2.遍历dev[0,6)的resource，
	如果!r-&gt;start &amp;&amp; r-&gt;end，表示没被分配总线地址
	如果6个资源中有IORESOURCE_IO，则将cmd的IO enable
	如果IORESOURCE_MEM，则将cmd中的MEMORY enable
	如果ram被分配总线地址，也将PCI_COMMAND_MEMORY enable
3.如果发现cmd和old_cmd不一致，将cmd写入到PCI_COMMAND中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1821</x>
      <y>48</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1849</x>
      <y>46</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pcibios_enable_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1842</x>
      <y>40</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将路径连接器和中断控制器相连
（BIOS没设置的irq）</panel_attributes>
    <additional_attributes>30.0;10.0;170.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1843</x>
      <y>54</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.读出PCI_INTERRUPT_PIN，pin不能为0
2.pcibios_lookup_irq连接中断控制器（assign
	为1，表示将BIOS没设置的也给设置），这里在遍历dev2时
	将dev.irq置上
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1858</x>
      <y>49</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2203</x>
      <y>171</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2198</x>
      <y>177</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>partition_setup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2180</x>
      <y>186</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>device_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2183</x>
      <y>194</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>chr_dev_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2187</x>
      <y>180</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2186</x>
      <y>189</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2165</x>
      <y>202</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_register_chrdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2193</x>
      <y>200</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memory_devfs_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2174</x>
      <y>197</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
向字符设备注册MEM_MAJOR
name：mem
fops：memory_fops</panel_attributes>
    <additional_attributes>160.0;10.0;45.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2185</x>
      <y>197</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
向devfs注册mem的各个节点</panel_attributes>
    <additional_attributes>60.0;10.0;130.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2202</x>
      <y>203</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2192</x>
      <y>207</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>遍历list，通过devfs_register
向devfs注册节点
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>65</x>
      <y>201</y>
      <w>63</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.互斥操作，系统总线加锁：xchg，lock
2.内存路障，会自动将cache中内容写入到内存中：
	1.系统总线加锁
	2.iret，cpuid，sfence，GDTR,LDTR,IDTR等指令调用
注：mb/rmb是对lock或者sfence的封装
	wmb是空指令，因为intel保证写操作的“处理器序”，gcc不会跨这个指令优化

3.保证多个cpu的cache一致
	1.snooping机制会使如果监测到系统总线写内存，将会把内存中的数据同步到各个cpu的cache中
	2.如果更新了页表，软件会通过flush_tlb刷新tlb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>93</x>
      <y>238</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_tlb_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>98</x>
      <y>232</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>74</x>
      <y>245</y>
      <w>51</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.mm的cpu_vm_mask中计入了进程运行的cpu，将除了本cpu
	的cpu_mask提出出来（在switch_mm中）
2.如果现在运行的就是当前mm（active_mm==mm），先改变当前cpu的tlb
	1.如果是用户进程，通过__flush_tlb_one将cr3提出出来
		然后重新装入，会导致整个TLB被遗弃
	2.如果是内核线程（TLBSTATE_LAZY，在schedule中通过enter_lazy_tlb置上），
		通过leave_mm将cpu_vm_mask中当前cpu的mask清掉
注：1.__exit_mm也会调用enter_lazy_tlb使得当前cpu中tlb即使被改变也不会被更新
	2.flush_tlb_page一般是改变用户层内存映射时会调用，所以不用本cpu的内核线程
		，如果需要更新内核内存映射（vmalloc）是使用flush_tlb_all
	3.如果是进程切换，会调用switch_mm，将cpu_tlbstate中active_mm替换成将要运行的的mm
		state切换成TLBSTATE_OK。如果是内核线程切换成进程时，如果发现mm被改变（cpu_vm_mask再leave_mm
		中被清掉），会通过local_flush_tlb刷新tlb
3.再通过flush_tlb_others改变cpu_mask中cpu的tlb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>98</x>
      <y>241</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>91</x>
      <y>268</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>flush_tlb_others</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>96</x>
      <y>264</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>77</x>
      <y>275</y>
      <w>41</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.cpumask要存在，要通知的cpu要在cpu_online_map中，不能含有本cpu
2.要通知的mm要存在
3.通过tlbstate_lock将下面这段保护。
4.将mm，地址va，cpumask赋给全局变量flush_mm，flush_va,flush_cpumask
5.通过send_IPI_mask向cpumask中的cpu发送中断
6.while等待flush_cpumask被中断处理完
7.清除flush_mm，flush_va，并释放锁
注：1.每个cpu最多只有一个在这段代码中
	2.因为while等待，在其他cpu中断处理期间（中断中没申请锁），本cpu也不会释放锁
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>96</x>
      <y>271</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>62</x>
      <y>315</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_invalidate_interrupt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>57</x>
      <y>322</y>
      <w>32</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.测试flush_cpumask中当前cpu的标志是否置上
2.如果当前运行的mm（cpu_tlbstate.active_mm）
  是要被刷新的mm，并且是进程（TLBSTATE_OK），通过
  local_flush_tlb重载cr3，更新整个tlb（FLUSH_ALL）
  或者通过__flush_tlb_one刷新单个虚拟页面
3.通过ack_APIC_irq向APIC_EOI写0，回应中断
4.将flush_cpumask中当前cpu的标志清掉
注：如果是pgd发生改变，会调用flush_tlb_mm，传参是FLUSH_ALL
	要求把所有的tlb全部废除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>71</x>
      <y>318</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>106</x>
      <y>315</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_reschedule_interrupt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>102</x>
      <y>322</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过ack_APIC_irq向APIC_EOI写0，回应中断
注：1.中断来源是其他cpu通过smp_send_reschedule发送
	2.这只是使cpu产生中断，如果当前进程need_resched
	会在中断返回时发生调度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>116</x>
      <y>318</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>91</x>
      <y>293</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>send_IPI_mask</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>96</x>
      <y>289</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>81</x>
      <y>300</y>
      <w>34</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过apic_wait_icr_idle等待APIC空闲
2.通过apic_write_around将要发送的cpu_mask
	（__prepare_ICR2准备好数据）写入ICR2寄存器
3.通过apic_write_around将发送的向量vector（通过__prepare_ICR
	准备数据），写入到ICR寄存器
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>95</x>
      <y>296</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>70</x>
      <y>309</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>100</x>
      <y>309</y>
      <w>17</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>884</x>
      <y>121</y>
      <w>359</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3570.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1448</x>
      <y>129</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1415</x>
      <y>138</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_boot_cpus</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1479</x>
      <y>138</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_commence</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1420</x>
      <y>132</y>
      <w>36</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
启动其他cpu</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1453</x>
      <y>132</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1447</x>
      <y>139</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_threads_ready=1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1452</x>
      <y>132</y>
      <w>3</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1411</x>
      <y>144</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_boot_cpu</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1416</x>
      <y>141</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1396</x>
      <y>152</y>
      <w>45</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.通过fork_by_hand创建其他cpu的idle进程（CLONE_PID表示公用一个pid）
2.设置cpu，idle，stack
	//cpu
	idle-&gt;processor = cpu;
	x86_cpu_to_apicid[cpu] = apicid;
	x86_apicid_to_cpu[apicid] = cpu;
	//idle
	idle-&gt;has_cpu = 1; 
	idle-&gt;thread.eip = (unsigned long) start_secondary;//idle运行的ip
	//将cpu从主cpu的task链表中删除，成为次cpu的idle_task
	del_from_runqueue(idle);
	unhash_process(idle);
	init_tasks[cpu] = idle;
	//次cpu启动的ip
	start_eip = setup_trampoline()
	//stack
	stack_start.esp = (void *) (1024 + PAGE_SIZE + (char *)idle)
3.将init_deasserted置0，将start_eip分成两部分写入物理地址0x469和0x467处用于系统的热启动
4.将发送的cpu号放在ICR2，状态和控制信息放在ICR,等待APIC_ICR_BUSY被清掉
	1..初始化完成后，将init_deasserted置1
	2.其中将start_eip发至次cpu用于启动，发送成功之后，将cpu_callout_map置上
	3.检查次cpu发送的cpu_callin_map位标志，如果收到成功返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1415</x>
      <y>147</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1380</x>
      <y>192</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup_trampoline</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1385</x>
      <y>187</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1383</x>
      <y>195</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
因为次cpu启动地址要页对齐
连接的trampoline_data不能页对齐
所以申请内存trampoline_base中执行</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1378</x>
      <y>199</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>trampoline_data</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1366</x>
      <y>206</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.将cs和ds设置相同
2.将bx设置为1
3.加在idt，gdt，其中gdt是gdt_table的物理地址
4.通过lmsw将pe置1，进入保护模式
5.到地址1M处(startup_32)执行，__KERNEL_CS对应gdt基地址是0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1382</x>
      <y>202</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2501</x>
      <y>154</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_secondary</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2506</x>
      <y>150</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
smp_init-&gt;do_boot_cpu</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2489</x>
      <y>161</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cpu_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2495</x>
      <y>157</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为进程调度做准备</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2505</x>
      <y>161</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_callin</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2508</x>
      <y>157</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2500</x>
      <y>168</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.等待主cpu将次cpu的APIC初始化后将init_deasserted置1
2.将cpu在cpu_online_map中的标志置1
3.2s内检测主cpu是否在发送ip完成之后将cpu_callout_map标志位置上
......
n.将cpu_callin_map中标志置上，用于主cpu从do_boot_cpu中返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2511</x>
      <y>164</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2524</x>
      <y>162</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_commenced
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2509</x>
      <y>157</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
while等待被置上</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2543</x>
      <y>162</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>local_flush_tlb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2509</x>
      <y>157</y>
      <w>42</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
刷新tlb</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2558</x>
      <y>162</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cpu_idle</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2510</x>
      <y>156</y>
      <w>54</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;520.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1479</x>
      <y>146</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>smp_commenced=1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1485</x>
      <y>141</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通知次cpu开始执行</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>648</x>
      <y>139</y>
      <w>242</w>
      <h>55</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
构建iomem_resource和ioport_resource的resource树</panel_attributes>
    <additional_attributes>10.0;10.0;2400.0;530.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>873</x>
      <y>192</y>
      <w>50</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.申请iomem_resource
	1.通过probe_roms申请rom的resource
		1.申请bios的rom resource（rom_resources[0]）
		2.如果0xC0000~0xc7fff之间有Video ROM（romsignature），申请rom_resources[1]
		注：这里0xE0000应该有问题
		3.如果0xC8000~0xE0000有resource（romsignature而且checksum不为0），申请Extension ROM（放在rom_resources[roms]）
		4.如果0xE0000有resource（romsignature），申请65535byte rom（放在rom_resources[roms]）
	2.遍历e820数组，利用alloc_bootmem_low申请resource，在iomem_resource申请，并在该resource
		下申请code_resource和data_resource
	3.在iomem_resource下申请vram_resource
2.申请ioport_resource（standard_io_resources下的所有resource）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>715</x>
      <y>135</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>parse_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>721</x>
      <y>121</y>
      <w>164</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
解析boot传来的cmd
在checksetup遍历数组__setup_start，查看名字相同的解析函数
这个数组在init.h中通过宏__setup定义</panel_attributes>
    <additional_attributes>1620.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>759</x>
      <y>141</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cpu_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>753</x>
      <y>138</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>753</x>
      <y>148</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果已经被初始化（cpu_initialized），空转，但是能相应中断
2.设置eflag
3.设置TSS(set_tss_desc),ldt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>764</x>
      <y>144</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1403</x>
      <y>132</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fork_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>883</x>
      <y>121</y>
      <w>526</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
mempages的一半用于创建线程和进程的task_struct</panel_attributes>
    <additional_attributes>10.0;10.0;5240.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1419</x>
      <y>131</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>page_cache_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>883</x>
      <y>121</y>
      <w>545</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请page_hash_table</panel_attributes>
    <additional_attributes>10.0;10.0;5430.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2253</x>
      <y>130</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cpu_idle</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>884</x>
      <y>123</y>
      <w>1377</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
进入之前current-&gt;need_resched = 1</panel_attributes>
    <additional_attributes>10.0;10.0;13750.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2544</x>
      <y>170</y>
      <w>40</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.通过init_idle设置sched_data
	sched_data-&gt;curr = current;
	sched_data-&gt;last_schedule = get_cycles();
2.设置优先级和时间片：
	current-&gt;nice = 20;
	current-&gt;counter = -100;
3.while死循环
	1.选择需要执行的idle进程（default_idle）
	2.如果不需要need_resched，才执行idle
主：主cpu会在进入cpu_idle之前置上，所以之后会执行init，
	次cpu则会进入idle，从而safe_halt，直到中断唤醒硬件
	3.如果需要need_resched，schedule
	4.醒来之后通过check_pgt_cache检查是否要释放多余的pgd，pte页面
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2563</x>
      <y>165</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1917</x>
      <y>148</y>
      <w>313</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>3110.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1912</x>
      <y>154</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1888</x>
      <y>160</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1893</x>
      <y>157</y>
      <w>27</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建sk_cachep</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1906</x>
      <y>161</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1907</x>
      <y>157</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建skbuff_head_cache</panel_attributes>
    <additional_attributes>110.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1921</x>
      <y>162</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>register_filesystem(&amp;sock_fs_type);
sock_mnt = kern_mount(&amp;sock_fs_type);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1917</x>
      <y>157</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建sockfs</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1975</x>
      <y>155</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>start_context_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1983</x>
      <y>148</y>
      <w>247</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>2450.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1974</x>
      <y>160</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kernel_thread
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1978</x>
      <y>157</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
第二个内核线程</panel_attributes>
    <additional_attributes>60.0;20.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1974</x>
      <y>166</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>context_thread</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1979</x>
      <y>163</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1979</x>
      <y>169</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1956</x>
      <y>172</y>
      <w>42</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过daemonize退出父进程mm，fs，files，并复用current的
	fs，files，使其变为守护线程
2.设置属性
	strcpy(curtask-&gt;comm, "keventd");
	keventd_running = 1;
	keventd_task = curtask;
3.通过siginitsetinv将blocked中的SIGCHLD清掉
	并重新设置SIGCHLD的k_sigaction
4.死循环：
	1.TASK_INTERRUPTIBLE，加入等待队列context_task_wq
	2.如果tq_context中有任务，TASK_RUNNING
	3.schedule
	4.醒来之后，执行tq_context，唤醒context_task_done
	5.如果有人发信号signal_pending，通过waitpid等待同一进程组的进程
		有人zombie或者stopped，然后通过flush_signals将信号队列中清空
		并重新recalc_sigpending
注：在schedule_task中向tq_context链表中添加routine
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2330</x>
      <y>153</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>mount_root</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2227</x>
      <y>148</y>
      <w>110</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1080.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2316</x>
      <y>158</y>
      <w>63</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.通过devfs_make_root解析root_device_name（但是好像没用，因为dest是局部变量）
2.通过devfs_find_handle在devfs根据路径（ROOT_DEVICE_NAME），或者设备号（路径为NULL时）找到devfs中的dentry
	最后合成设备号ROOT_DEV
3.通过bdget获取bdev数据结构，通过de结构中之前的注册赋值bd_op
	bdev-&gt;bd_op = devfs_get_ops (handle)
	并通过devfs_generate_path生成在devfs中的路径
4.如果root_mountflags的MS_RDONLY没置上，以读写权限通过blkdev_get去打开设备（这里有可能更换ops）
	如果不行（EROFS），再将root_mountflags的MS_RDONLY，并以读权限通过blkdev_get打开设备
5.通过get_super去super_blocks链表中查看是否有super，如果有，获取fs_type直接去安装
	如果没有，遍历file_systems，以链表中的各个文件系统模式去读取super，获取成功直接去安装
6.如果设备存在路径（path_start&gt;=0）,通过devfs_mk_symlink创建一个root的连接指向设备
	不管有没有路径，都会通过add_vfsmnt创建mnt
7.替换current的root，pwd，因为init进程是所有进程的根，所以mnt就是所有进程的根
	set_fs_root(current-&gt;fs, vfsmnt, sb-&gt;s_root);
	set_fs_pwd(current-&gt;fs, vfsmnt, sb-&gt;s_root);
注；安装跟设备核心是有对跟设备的操作函数
	linux0.11是直接在rd_init中指定的（跟设备号是rd的主设备号）
	linux2.4.0是在init_call时跟设备在注册时安装置devfs中，然后再根据在devfs中的路径去寻找跟设备的操作函数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2336</x>
      <y>156</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2382</x>
      <y>189</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devfs_mk_symlink</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2374</x>
      <y>196</y>
      <w>55</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.name，link不存在，返回EINVAL
2.通过search_for_entry获取要name的路径对应的de，如果不存在，返回ENOMEM，如果存在通过handle返回
3.对root的de赋值
	de-&gt;mode = S_IFLNK | S_IRUGO | S_IXUGO;
    de-&gt;info = info;
    de-&gt;show_unreg = ( (boot_options &amp; OPTION_SHOW)
		       || (flags &amp; DEVFS_FL_SHOW_UNREG) ) ? TRUE : FALSE;
    de-&gt;hide = (flags &amp; DEVFS_FL_HIDE) ? TRUE : FALSE;
4.如果de之前被link（registered），不能被重复link
5.将root（连接节点）和link（实际节点）连接
	de-&gt;registered = TRUE;
	newname = kmalloc//没内存时将其从树中删除，并释放（如果是之前就有(is_new)就不释放）
	 de-&gt;u.symlink.linkname = newname;
    memcpy (de-&gt;u.symlink.linkname, link, linklength);
    de-&gt;u.symlink.linkname[linklength] = '\0';
    de-&gt;u.symlink.length = linklength;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2363</x>
      <y>186</y>
      <w>27</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建一个root指向link</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2387</x>
      <y>192</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2422</x>
      <y>149</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>free_initmem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2235</x>
      <y>141</y>
      <w>194</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将init段（__init_begin~__init_end）的函数指针释放</panel_attributes>
    <additional_attributes>10.0;10.0;1920.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2442</x>
      <y>144</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过open，dup打开标准输入，输出，错误（/dev/console）
2.通过execve去执行init（一般/bin/sh会成功）
注：1.linux0.11是创建一个2号进程执行shell，而linux2.4.0直接执行execve执行shell（shell进程就是init进程，execve不会返回）
	2.内核中的syscall是通过宏_syscall0()，_syscall1()，syscall2()等
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2235</x>
      <y>141</y>
      <w>219</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2170.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2658</x>
      <y>139</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_reboot</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2648</x>
      <y>142</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
LINUX_REBOOT_CMD_RESTART</panel_attributes>
    <additional_attributes>160.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2639</x>
      <y>146</y>
      <w>32</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过notifier_call_chain调用reboot_notifier_list链表中
	注册的需要在reboot时执行的函数
注：通过函数register_reboot_notifier注册，优先级从高到低
2.通过machine_restart重引导
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2648</x>
      <y>158</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>machine_restart</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2653</x>
      <y>153</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2636</x>
      <y>165</y>
      <w>38</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过smp_send_stop使每个cpu停止local APIC
	通过disable_IO_APIC停止外部APIC
2.如果在引导时没定义"reboot="(!reboot_thru_bios),硬启动
3.如果有定义，通过machine_real_restart重启
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2654</x>
      <y>161</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2646</x>
      <y>175</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>machine_real_restart</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2652</x>
      <y>172</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2633</x>
      <y>181</y>
      <w>40</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.通过CMOS_WRITE向8f写0，关中断和NMI
2.将cr3指向swapper_pg_dir
	1.swapper_pg_dir中系统空间部分赋值到低地址前1G空间，
	2.因为在之后会去0~4k这段地址作为指令，所以必须使其指向pte指向物理地址的0~4k
		pg0[0] = _PAGE_RW | _PAGE_PRESENT//后面分析这个好像没办法保证
	注：1.进程0一直用这个页目录，
		2.pg0的物理地址是0x00102000，在setup_arch中因为下面这句而reserve
		reserve_bootmem(HIGH_MEMORY, (PFN_PHYS(start_pfn) +
			 bootmap_size + PAGE_SIZE-1) - (HIGH_MEMORY));
			所以在paging_init-&gt;pagetable_init中为swapper_pg_dir申请系统页面时不会
			申请到pg0作为pte，所以这里对pg0进行赋值根本没办法影响到页表
3.在0x472处存reboot_mode，等待bios启动时取
注：reboot_mode在reboot_setup设置，热启动是0x1234（自检），冷启动是0（不用自检）
4.将代码real_mode_switch和code(jump_to_bios)复制到0x1000 - sizeof (real_mode_switch) - 100处
	然后设置号idt gdt，将段寄存器设置为0x10，最后通过ljmp跳到复制代码处执行（$0x0008表示是段寄存器中的第1项，基地址是0）
	注：复制代码执行：
		1.将cr0和cr3的页面映射关闭
		2.如果cr0的0x60000000置上，通过invd将高速缓存作废
		3.向cr0写0x10，进入实地址模式
		4.通过ljmp跳转到0xFFFF0(段地址是0xFFFF,偏移是0)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2652</x>
      <y>178</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>0</x>
      <y>356</y>
      <w>1</w>
      <h>0</h>
    </coordinates>
    <panel_attributes>1.父目录要是S_ISDIR
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3</x>
      <y>356</y>
      <w>3</w>
      <h>1</h>
    </coordinates>
    <panel_attributes>1.遍历parent的子节点链表parent-&gt;u.dir.first
2.根据namelen和name滤出对应的devfs_entry
3.如果在链表中没有找到devfs_entry，返回NULL
4.如果找到了，但是不是S_ISLNK，或者是link，
	但是不要求traverse_symlink，直接返回找到的
	devfs_entry
5.如果需要根据link找到实体（traverse_symlink），
	使用search_for_entry在parent中找curr-&gt;u.symlink.linkname
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
</diagram>
