<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram program="umlet" version="14.2">
  <zoom_level>1</zoom_level>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>99</x>
      <y>521</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>net_dev_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>88</x>
      <y>528</y>
      <w>43</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>1.通过dev_proc_init向procfs注册：
	1.proc_net下创建dev文件，操作为dev_seq_fops
	2.proc_net下创建softnet_stat文件，操作为softnet_seq_fops
	3.proc_net下创建wireless文件，操作为wireless_seq_fops
2.通过netdev_sysfs_init注册net_class
3.初始化数组链表：ptype_base，dev_name_head，dev_index_head
4.初始化cpu的接收队列
	queue = &amp;per_cpu(softnet_data, i);
	skb_queue_head_init(&amp;queue-&gt;input_pkt_queue);
	queue-&gt;completion_queue = NULL;
	INIT_LIST_HEAD(&amp;queue-&gt;poll_list);
	set_bit(__LINK_STATE_START, &amp;queue-&gt;backlog_dev.state);
	queue-&gt;backlog_dev.weight = weight_p;
	queue-&gt;backlog_dev.poll = process_backlog;
	atomic_set(&amp;queue-&gt;backlog_dev.refcnt, 1);
5.通过netdev_dma_register注册dma
6.标识设备层初始化完成
	dev_boot_phase = 0
7.注册软中断
	open_softirq(NET_TX_SOFTIRQ, net_tx_action, NULL);
	open_softirq(NET_RX_SOFTIRQ, net_rx_action, NULL);
8.通过hotcpu_notifier注册回调函数（响应热插拔）
9.通过dst_init初始化目的路由缓存
10.通过dev_mcast_init创建dev_mcast文件，dev_mc_seq_fops
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>104</x>
      <y>524</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>93</x>
      <y>573</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>netdev_sysfs_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>86</x>
      <y>580</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>class_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>92</x>
      <y>576</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
net_class</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>74</x>
      <y>587</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.初始化链表children，devices，interfaces，初始化
	信号量cls-&gt;sem（置1）
2.设置cls-&gt;subsys.kset.kobj的name为cls-&gt;name
3.cls-&gt;subsys.kset.kobj.kset=class_subsys.kset
注：static decl_subsys(class, &amp;ktype_class, NULL)定义了变量class_subsys
4.调用subsystem_register初始化cls-&gt;subsys
5.通过add_class_attrs根据class_attrs创建file
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>91</x>
      <y>583</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>67</x>
      <y>603</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>subsystem_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>74</x>
      <y>598</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>45</x>
      <y>616</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.初始化cls-&gt;subsys.rwsem,(值为0，并初始化信号量的wait_lock,wait_list)
2.通过kset_init初始化cls-&gt;subsys.kset（主要是增加obj.kref的计数）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>59</x>
      <y>610</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>subsystem_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>68</x>
      <y>606</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>59</x>
      <y>613</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>81</x>
      <y>610</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kset_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>74</x>
      <y>606</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>86</x>
      <y>617</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kobject_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>87</x>
      <y>613</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>73</x>
      <y>623</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.kobj要存在，并且kref引用
2.kobj-&gt;k_name = kobj-&gt;name，name要存在
3.kobj-&gt;parent不存在，parent指向kobj-&gt;kset-&gt;kobj
	并且将kobj加入到kobj.kset的链表中
4.通过create_dir创建dir
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>91</x>
      <y>620</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>80</x>
      <y>635</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_dir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>85</x>
      <y>632</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>70</x>
      <y>641</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过sysfs_create_dir给kobj创建dir
2.如果创建成功（!error）,通过populate_dir查看
	kobj的type，并且根据type.default_attrs利用sysfs_create_file
	创建file
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>85</x>
      <y>638</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>65</x>
      <y>651</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sysfs_create_dir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>69</x>
      <y>647</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>54</x>
      <y>656</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.寻找parent
	1.如果kobj-&gt;parent存在，即为kobj-&gt;parent-&gt;dentry
	2.否则为sysfs_mount-&gt;mnt_sb-&gt;s_root
2.通过create_dir在parent下创建dir
3.kobj-&gt;dentry = dentry
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>69</x>
      <y>654</y>
      <w>4</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>61</x>
      <y>667</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_dir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>66</x>
      <y>663</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>50</x>
      <y>674</y>
      <w>34</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.通过lookup_one_len在hash，parent中寻找dir，如果
	没找到，在创建一个
2.通过sysfs_dirent_exist检查子文件中是否有名字相同的文件
3.如果不存在，通过sysfs_make_dirent为kobj创建文件
4.通过sysfs_create给dentry创建inode
5.增加p-&gt;d_inode.i_nlink的计数，并且
	(*d)-&gt;d_op = &amp;sysfs_dentry_ops;
		d_rehash(*d);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>65</x>
      <y>670</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>15</x>
      <y>688</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sysfs_make_dirent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>0</x>
      <y>694</y>
      <w>30</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.通过sysfs_new_dirent申请sd，并初始化：
	memset(sd, 0, sizeof(*sd));
	atomic_set(&amp;sd-&gt;s_count, 1);
	atomic_set(&amp;sd-&gt;s_event, 1);
	INIT_LIST_HEAD(&amp;sd-&gt;s_children);
	list_add(&amp;sd-&gt;s_sibling, &amp;parent_sd-&gt;s_children);//加入到父目录链表
	sd-&gt;s_element = element;//kobj
2.初始化sd的文件属性
	sd-&gt;s_mode = mode;
	sd-&gt;s_type = type;//SYSFS_DIR
	sd-&gt;s_dentry = dentry
3.设置dentry
	dentry-&gt;d_fsdata = sysfs_get(sd);
	dentry-&gt;d_op = &amp;sysfs_dentry_ops;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>22</x>
      <y>685</y>
      <w>40</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>380.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>15</x>
      <y>691</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>73</x>
      <y>689</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sysfs_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>68</x>
      <y>696</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sysfs_new_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>74</x>
      <y>685</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>72</x>
      <y>692</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>83</x>
      <y>696</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_dir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>79</x>
      <y>692</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>62</x>
      <y>702</y>
      <w>22</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.通过new_inode申请inode，并加入到sysfs_sb链表中
2.初始化inode
	inode-&gt;i_blocks = 0;
	inode-&gt;i_mapping-&gt;a_ops = &amp;sysfs_aops;
	inode-&gt;i_mapping-&gt;backing_dev_info = &amp;sysfs_backing_dev_info;
	inode-&gt;i_op = &amp;sysfs_inode_operations;
3.通过set_default_inode_attr设置inode的mode，i_uid，i_gid
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>69</x>
      <y>699</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>85</x>
      <y>703</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>inode-&gt;i_op = &amp;configfs_dir_inode_operations;
inode-&gt;i_fop = &amp;configfs_dir_operations;
inode-&gt;i_nlink++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>88</x>
      <y>699</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>91</x>
      <y>651</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>populate_dir</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>93</x>
      <y>658</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sysfs_create_file</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>89</x>
      <y>647</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>96</x>
      <y>654</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>94</x>
      <y>664</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sysfs_add_file</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>98</x>
      <y>661</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
type=SYSFS_KOBJ_ATTR</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>42</x>
      <y>689</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sysfs_dirent_exist</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>31</x>
      <y>695</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.检查父目录的d_fsdata.s_children链表(s_sibling)
	连接，通过sysfs_get_name获取子文件的名称，然后和当前要创建的文件比较，如果存在
	返回EEXIST
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>46</x>
      <y>685</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>45</x>
      <y>692</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>86</x>
      <y>671</y>
      <w>36</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.通过sysfs_dirent_exist检查子文件中是否有名字相同的文件
2.如果不存在通过sysfs_make_dirent创建sd：
	sd-&gt;s_element = element;//attr
	sd-&gt;s_mode = mode;
	sd-&gt;s_type = type;//SYSFS_KOBJ_ATTR
	sd-&gt;s_dentry = dentry//NULL
注：attr在这里并没有dentry和inode，在sysfs_lookup中被赋值
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>96</x>
      <y>667</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>113</x>
      <y>574</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hotcpu_notifier
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>114</x>
      <y>581</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_cpu_notifier</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>120</x>
      <y>577</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>114</x>
      <y>588</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>raw_notifier_chain_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>121</x>
      <y>584</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>124</x>
      <y>591</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
cpu_chain</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>116</x>
      <y>596</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>notifier_chain_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>111</x>
      <y>603</y>
      <w>29</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.按照优先级从大到小的顺序加入到链表中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>124</x>
      <y>599</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>97</x>
      <y>566</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>107</x>
      <y>566</y>
      <w>14</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>276</x>
      <y>515</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_init_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>277</x>
      <y>522</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_register_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>285</x>
      <y>518</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
e100_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>277</x>
      <y>529</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__pci_register_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>285</x>
      <y>525</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>265</x>
      <y>536</y>
      <w>40</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.初始化device_driver
	drv-&gt;driver.name = drv-&gt;name;e100_driver
	drv-&gt;driver.bus = &amp;pci_bus_type;
	drv-&gt;driver.owner = owner;//this_module
	drv-&gt;driver.kobj.ktype = &amp;pci_driver_kobj_type;
	drv-&gt;driver.multithread_probe = pci_multithread_probe;
2.初始化pci dynids
	spin_lock_init(&amp;drv-&gt;dynids.lock);
	INIT_LIST_HEAD(&amp;drv-&gt;dynids.list);
3.通过driver_register注册device_driver
4.通过pci_create_newid_file为drv创建new_id的属性
注：static DRIVER_ATTR(new_id, S_IWUSR, NULL, store_new_id);
	定义的变量是driver_attr_new_id
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>284</x>
      <y>532</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>262</x>
      <y>561</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>driver_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>268</x>
      <y>557</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>250</x>
      <y>566</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.初始化drv-&gt;klist_devices
2.初始化drv-&gt;unloaded
3.通过bus_add_driver将drv加入到bus的sysfs中
	并且将drv和dev关联
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>266</x>
      <y>564</y>
      <w>3</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>256</x>
      <y>576</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bus_add_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>261</x>
      <y>572</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>245</x>
      <y>583</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.设置device_driver的kobj，并通过kobject_register注册
	kobject_set_name(&amp;drv-&gt;kobj, "%s", drv-&gt;name)
	drv-&gt;kobj.kset = &amp;bus-&gt;drivers;
注：pci_bus_type在pci_driver_init中被注册时，会对bus-&gt;drivers进行初始化和注册
2.通过driver_attach遍历driver链表，关联设备和driver
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>261</x>
      <y>579</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>249</x>
      <y>595</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kobject_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>246</x>
      <y>602</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过kobject_init初始化kobj
2.通过kobject_add为kobj创建dir并为其属性创建文件
3.通过kobject_uevent创建uevent
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>252</x>
      <y>613</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kobject_uevent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>257</x>
      <y>608</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
KOBJ_ADD</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>251</x>
      <y>620</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kobject_uevent_env</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>256</x>
      <y>616</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>254</x>
      <y>591</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>254</x>
      <y>598</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>280</x>
      <y>602</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bus_for_each_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>277</x>
      <y>595</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>driver_attach</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>268</x>
      <y>591</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>283</x>
      <y>598</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
__driver_attach</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>273</x>
      <y>610</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过klist_iter_init_node设置遍历器klist_iter
	i-&gt;i_klist = k;//其中有操作链表的方法
	i-&gt;i_head = &amp;k-&gt;k_list;//链表头
	i-&gt;i_cur = n;//开始遍历的klist_node，这里会增加计数，在遍历的时候会递减
2.通过next_device利用iter遍历链表，通过传入的fn操作device
注：相比于2.4.0，在list_entry上又封装了一层klist_node
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>282</x>
      <y>605</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>283</x>
      <y>623</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__driver_attach</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>289</x>
      <y>619</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>280</x>
      <y>630</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>driver_probe_device</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>288</x>
      <y>626</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
（当前drv，设备链表中的设备）</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>272</x>
      <y>637</y>
      <w>35</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.设备要注册了（dev-&gt;is_registered）
2.通过drv-&gt;bus-&gt;match查看设备和驱动是否匹配
3.通过really_probe将dev和drv关联
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>280</x>
      <y>647</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>really_probe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>265</x>
      <y>654</y>
      <w>36</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.增加probe_count计数
2.关联设备和驱动
	dev-&gt;driver = drv
3.通过driver_sysfs_add在sysfs中相关联
4.调用dev-&gt;bus-&gt;probe或者drv-&gt;probe初始化设备
5.通过driver_bound将dev（挂入到drv的链表
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>285</x>
      <y>650</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>258</x>
      <y>683</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sysfs_create_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>246</x>
      <y>690</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果要连接的节点kobj为NULL,则链接为sysfs_mount-&gt;mnt_sb-&gt;s_root
	否则为kobj-&gt;dentry
2.通过sysfs_dirent_exist检查kobj目录下是否存在和要创建的link name相同的文件
3.通过sysfs_add_link在kobj先创建link指向target
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>261</x>
      <y>668</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>driver_sysfs_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>250</x>
      <y>675</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.通过sysfs_create_link在sysfs的drv目录中创建一个link指向dev
	也在dev中创建一个link（“driver”）指向drv
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>256</x>
      <y>702</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sysfs_add_link</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>246</x>
      <y>709</y>
      <w>27</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.申请sysfs_symlink
2.申请name空间：
	sl-&gt;link_name = kmalloc(strlen(name) + 1, GFP_KERNEL)
	strcpy(sl-&gt;link_name, name)
3.设置指向的节点
	sl-&gt;target_kobj = kobject_get(target);
4.通过sysfs_make_dirent创建link 文件
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>261</x>
      <y>705</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>261</x>
      <y>697</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>262</x>
      <y>686</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>264</x>
      <y>671</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>263</x>
      <y>679</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>286</x>
      <y>674</y>
      <w>34</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.通过klist_node_attached检查dev是否挂入到driver链表中
2.通过blocking_notifier_call_chain通过bus中的bus_notifier链表
	dev的BUS_NOTIFY_BOUND_DRIVER事件
3.通过klist_add_tail将dev（通过knode_driver）挂入到drv的链表klist_devices中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>290</x>
      <y>668</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>driver_bound</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>295</x>
      <y>671</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>267</x>
      <y>664</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>286</x>
      <y>664</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>286</x>
      <y>633</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>285</x>
      <y>643</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>321</x>
      <y>683</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drv-&gt;probe
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>322</x>
      <y>690</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_probe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>325</x>
      <y>678</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>327</x>
      <y>686</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
e100_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>287</x>
      <y>696</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_etherdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>291</x>
      <y>693</y>
      <w>39</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
申请net_device结构</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>286</x>
      <y>704</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_netdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>291</x>
      <y>699</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
set_up=ether_setup</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>274</x>
      <y>710</y>
      <w>35</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.申请net_device和private_data的空间
2.dev指向32字节对齐的文职
	dev = (struct net_device *)
		(((long)p + NETDEV_ALIGN_CONST) &amp; ~NETDEV_ALIGN_CONST);
	dev-&gt;padded = (char *)dev - (char *)p;
3.设置dev private_data的指针
	dev-&gt;priv = netdev_priv(dev);
4.通过传入的参数setup启动dev
5.strcpy(dev-&gt;name, name);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>291</x>
      <y>707</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>281</x>
      <y>729</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>setup
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>279</x>
      <y>736</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ether_setup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>285</x>
      <y>725</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>285</x>
      <y>732</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>259</x>
      <y>743</y>
      <w>39</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>dev-&gt;change_mtu		= eth_change_mtu;
dev-&gt;hard_header	= eth_header;
dev-&gt;rebuild_header 	= eth_rebuild_header;
dev-&gt;set_mac_address 	= eth_mac_addr;
dev-&gt;hard_header_cache	= eth_header_cache;
dev-&gt;header_cache_update= eth_header_cache_update;
dev-&gt;hard_header_parse	= eth_header_parse;

dev-&gt;type		= ARPHRD_ETHER;
dev-&gt;hard_header_len 	= ETH_HLEN;
dev-&gt;mtu		= ETH_DATA_LEN;
dev-&gt;addr_len		= ETH_ALEN;
dev-&gt;tx_queue_len	= 1000;	/* Ethernet wants good queues */	
dev-&gt;flags		= IFF_BROADCAST|IFF_MULTICAST;

memset(dev-&gt;broadcast, 0xFF, ETH_ALEN);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>277</x>
      <y>739</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化net_device</panel_attributes>
    <additional_attributes>70.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>321</x>
      <y>667</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;bus-&gt;probe
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>321</x>
      <y>675</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_device_probe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>294</x>
      <y>664</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>326</x>
      <y>670</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在pci_scan_device中被赋值为
pci_bus_type</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>310</x>
      <y>702</y>
      <w>36</w>
      <h>38</h>
    </coordinates>
    <panel_attributes> //初始化net_device
netdev-&gt;open = e100_open;
netdev-&gt;stop = e100_close;
netdev-&gt;hard_start_xmit = e100_xmit_frame;
netdev-&gt;get_stats = e100_get_stats;
netdev-&gt;set_multicast_list = e100_set_multicast_list;
netdev-&gt;set_mac_address = e100_set_mac_address;
netdev-&gt;change_mtu = e100_change_mtu;
netdev-&gt;do_ioctl = e100_do_ioctl;
SET_ETHTOOL_OPS(netdev, &amp;e100_ethtool_ops);
netdev-&gt;tx_timeout = e100_tx_timeout;
netdev-&gt;watchdog_timeo = E100_WATCHDOG_PERIOD;
netdev-&gt;poll = e100_poll;
netdev-&gt;weight = E100_NAPI_WEIGHT;
netdev-&gt;poll_controller = e100_netpoll;
strncpy(netdev-&gt;name, pci_name(pdev), sizeof(netdev-&gt;name) - 1);
 //设置private_data
nic = netdev_priv(netdev);
nic-&gt;netdev = netdev;
nic-&gt;pdev = pdev;
nic-&gt;msg_enable = (1 &lt;&lt; debug) - 1;
 //通过pci_set_drvdata设置device的driver_data
 dev-&gt;driver_data = data;//netdev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>327</x>
      <y>693</y>
      <w>3</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>327</x>
      <y>693</y>
      <w>35</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>10.0;10.0;330.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>347</x>
      <y>700</y>
      <w>29</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.分配resource，分配irq，do_fixup
	pci_enable_device,pci_request_regions
2.netdev-&gt;class_dev.dev=pdev-&gt;dev
3.进一步设置nic
	nic-&gt;csr = ioremap//映射IORESOURCE_MEM到虚拟内存
	e100_get_defaults(nic);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>378</x>
      <y>700</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>strcpy(netdev-&gt;name, "eth%d");
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>328</x>
      <y>693</y>
      <w>58</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>10.0;10.0;560.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>403</x>
      <y>700</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_netdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>327</x>
      <y>693</y>
      <w>83</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>10.0;10.0;810.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>385</x>
      <y>708</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_alloc_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>390</x>
      <y>703</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果dev-&gt;name中有'%'
</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>371</x>
      <y>717</y>
      <w>32</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.遍历net_device链表dev_base，按照name的格式
	查找dev的名称，如果样式相同，将用过的i通过inuse
	标记
	然后通过find_first_zero_bit找inuse中没使用的i
2.通过__dev_get_by_name检查到dev_name_hash中没有对应的名称
	将组装的名称赋给dv-&gt;name。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>388</x>
      <y>711</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>487</x>
      <y>707</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_netdevice</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>408</x>
      <y>703</y>
      <w>87</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>10.0;10.0;850.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>417</x>
      <y>715</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_valid_name</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>422</x>
      <y>710</y>
      <w>72</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>700.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>414</x>
      <y>722</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.不能是'\0'
2.长度不能超过IFNAMSIZ
3.不能是'.'或者'..'
4.name中不能包含'/'或者空格
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>421</x>
      <y>718</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>431</x>
      <y>716</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>dev-&gt;ifindex = dev_new_index()
dev-&gt;iflink = dev-&gt;ifindex;
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>439</x>
      <y>710</y>
      <w>55</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
检查dev_index_hash没被使用的idx
</panel_attributes>
    <additional_attributes>530.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>454</x>
      <y>716</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;features
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>458</x>
      <y>710</y>
      <w>37</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>471</x>
      <y>716</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>netdev_register_sysfs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>477</x>
      <y>710</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>449</x>
      <y>723</y>
      <w>25</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.class_dev-&gt;kobj.kset = &amp;class_obj_subsys.kset
	class_dev-&gt;class = &amp;net_class;
	class_dev-&gt;class_data = net;
	class_dev-&gt;groups = groups; //net-&gt;sysfs_groups
	strlcpy(class_dev-&gt;class_id, net-&gt;name, BUS_ID_SIZE);
	*groups++ = &amp;netstat_group;
	*groups++ = &amp;wireless_group;
注：class_obj_subsys通过宏static decl_subsys(class_obj, &amp;ktype_class_device, &amp;class_uevent_ops);定义
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>461</x>
      <y>719</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置net-&gt;class_dev
</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>483</x>
      <y>723</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>class_device_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>480</x>
      <y>719</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>478</x>
      <y>730</y>
      <w>49</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.通过kobject_add为class_dev-&gt;kobj创建文件
	parent在class_dev-&gt;parent存在时为class_dev-&gt;parent-&gt;kobj
	否则为class_dev-&gt;class-&gt;subsys.kset.kobj
2.通过sysfs_create_link在class_dev-&gt;kobj中创建属性指向parent_class
	名称为"subsystem"
3.创建attr
	1.通过class_device_create_file在class_dev-&gt;kobj下创建
	class_dev-&gt;uevent_attr.attr，方法存储在attr的上一层
	2.如果有主设备号，再次通过class_device_create_file创建文件
	class_dev-&gt;devt_attr = attr
	3.通过class_device_add_attrs创建class_dev指向class的attr到class_dev
4.在class_dev-&gt;kobj创建link（"device"）指向class_dev-&gt;dev
5.通过class_device_add_groups在class_dev-&gt;kobj下创建group的文件夹
	及在文件夹下相应的属性文件
6.通过make_deprecated_class_device_links在class_dev-&gt;dev中创建一个link
	指向class_dev（class：class_dev）
7.通过kobject_uevent添加uevent到class_dev-&gt;kobj
8.将class_dev（node）添加到parent_class的children链表中
9.执行parent_class-&gt;interfaces的add方法，将class_dev加入
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>490</x>
      <y>726</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>529</x>
      <y>724</y>
      <w>36</w>
      <h>23</h>
    </coordinates>
    <panel_attributes> //设置net_dev状态
dev-&gt;reg_state = NETREG_REGISTERED //注册完成
set_bit(__LINK_STATE_PRESENT, &amp;dev-&gt;state)//设备可用
 //初始化设备排队规则
dev_init_scheduler
 //加入dev_base链表
*dev_tail = dev;
dev_tail = &amp;dev-&gt;next;
 //加入name和idx的hash表
hlist_add_head(&amp;dev-&gt;name_hlist, dev_name_hash(dev-&gt;name));
hlist_add_head(&amp;dev-&gt;index_hlist, dev_index_hash(dev-&gt;ifindex));
 //递增net_dev的计数
dev_hold(dev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>573</x>
      <y>725</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>raw_notifier_call_chain</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>494</x>
      <y>710</y>
      <w>86</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通知netdev_chain中对net_dev感兴趣的设备
net_dev注册（NETDEV_REGISTER）
</panel_attributes>
    <additional_attributes>10.0;10.0;840.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>494</x>
      <y>710</y>
      <w>46</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>405</x>
      <y>714</y>
      <w>8</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;init
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>409</x>
      <y>710</y>
      <w>84</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;

</panel_attributes>
    <additional_attributes>820.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>822</x>
      <y>866</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_ioctl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>826</x>
      <y>869</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SIOCSIFFLAGS</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>821</x>
      <y>875</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devinet_ioctl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>821</x>
      <y>883</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_change_flags</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>826</x>
      <y>878</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SIOCSIFFLAGS</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>826</x>
      <y>886</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
IFF_UP被打开</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>821</x>
      <y>891</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>793</x>
      <y>899</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果dev-&gt;flags的IFF_UP置上，表示设备已经被打开
2.如果dev-&gt;state的__LINK_STATE_PRESENT置上
	表示设备还没被初始化。

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>805</x>
      <y>894</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>823</x>
      <y>900</y>
      <w>30</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>set_bit(__LINK_STATE_START, &amp;dev-&gt;state)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>826</x>
      <y>894</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>856</x>
      <y>900</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;open
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>826</x>
      <y>894</y>
      <w>36</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;340.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>855</x>
      <y>907</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>860</x>
      <y>903</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
e100_probe</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>379</x>
      <y>514</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_cleanup_module</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>378</x>
      <y>522</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_unregister_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>387</x>
      <y>517</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
e100_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>389</x>
      <y>531</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_free_dynids</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>368</x>
      <y>530</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>driver_unregister</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>373</x>
      <y>525</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>386</x>
      <y>525</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>383</x>
      <y>539</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.遍历pci_driver的dynids链表，将链表中的dynid
	脱链，并通过kfree释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>394</x>
      <y>534</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>349</x>
      <y>537</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>bus_remove_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>368</x>
      <y>537</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait_for_completion</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>357</x>
      <y>533</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>367</x>
      <y>533</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
等待drv-&gt;unloaded done</panel_attributes>
    <additional_attributes>60.0;10.0;100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>337</x>
      <y>544</y>
      <w>35</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.通过remove_bind_files清除供热插拔的file（bind/unbind）
2.通过driver_remove_attrs移除bus-&gt;drv_attrs对应的文件
3.通过klist_remove将drv从bus的链表中删除（knode_bus）
4.利用driver_detach将drv和dev解绑定
5.通过module_remove_driver移除module和driver的link关系
6.kobject_unregister移除kobj
7.put_bus(drv-&gt;bus)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>355</x>
      <y>540</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>346</x>
      <y>559</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>driver_detach</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>352</x>
      <y>555</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>333</x>
      <y>566</y>
      <w>37</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.遍历drv上的klist_devices链表上的dev
2.如果dev.driver是drv,通过__device_release_driver
	将dev和drv解绑定
3.通过put_device释放dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>342</x>
      <y>577</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__device_release_driver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>333</x>
      <y>584</y>
      <w>36</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.移除sysfs的关系
	driver_sysfs_remove(dev);
	sysfs_remove_link(&amp;dev-&gt;kobj, "driver");
2.将dev从drv的链表中断开
	klist_remove(&amp;dev-&gt;knode_driver);
3.通知dev-&gt;bus-&gt;bus_notifier dev被BUS_NOTIFY_UNBIND_DRIVER
4.通过dev-&gt;bus-&gt;remove或者drv-&gt;remove移除dev
5.dev-&gt;driver = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>351</x>
      <y>562</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>350</x>
      <y>573</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>350</x>
      <y>580</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>343</x>
      <y>601</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;bus-&gt;remove
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>349</x>
      <y>597</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>342</x>
      <y>608</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_device_remove</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>348</x>
      <y>604</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pci_bus_type</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>342</x>
      <y>622</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_remove</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>343</x>
      <y>615</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>drv-&gt;remov
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>348</x>
      <y>611</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>347</x>
      <y>618</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
e100_driver</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>349</x>
      <y>611</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>356</x>
      <y>615</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pci_dev-&gt;driver = NULL
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>335</x>
      <y>629</y>
      <w>29</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.unregister_netdev注销net_dev
2.通过e100_free释放私有数据nic
3.通过iounmap释放drv的io映射（nic-&gt;csr）
4.通过free_netdev释放net_dev
5.通过pci_release_regions和pci_disable_device
	释放dev的资源和irq
6.dev-&gt;driver_data =NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>346</x>
      <y>625</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>342</x>
      <y>644</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unregister_netdev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>348</x>
      <y>640</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>339</x>
      <y>652</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>unregister_netdevice</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>369</x>
      <y>651</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rtnl_unlock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>345</x>
      <y>647</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>348</x>
      <y>647</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>335</x>
      <y>659</y>
      <w>33</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.将dev从name和idx的hash表中删除，并且从dev_base的链表中删除
2.dev-&gt;reg_state = NETREG_UNREGISTERING;
3.通过dev_shutdown关闭dev的队列
4.通过raw_notifier_call_chain通知netdev_chain链表中dev 
	NETDEV_UNREGISTER的事件
5.dev_mc_discard释放dev的组播
6.利用net_set_todo将dev加入到net_todo_list链表中（todo_list）
7.通过dev_put释放dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>346</x>
      <y>655</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>380</x>
      <y>657</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>netdev_run_todo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>375</x>
      <y>654</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>375</x>
      <y>664</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.将链表net_todo_list取出，并遍历其上的net_dev
2.netdev_unregister_sysfs将class_dev对应的sysfs
	注销
3.netdev_wait_allrefs等待dev-&gt;refcnt为0
4.dev-&gt;destructor
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>387</x>
      <y>660</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>892</x>
      <y>900</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_mc_upload</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>873</x>
      <y>900</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;flags |= IFF_UP
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>827</x>
      <y>894</y>
      <w>73</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
更新组播地址列表</panel_attributes>
    <additional_attributes>10.0;10.0;710.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>827</x>
      <y>894</y>
      <w>216</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化流量控制的排队规则</panel_attributes>
    <additional_attributes>10.0;10.0;2140.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1108</x>
      <y>905</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>raw_notifier_call_chain</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>827</x>
      <y>894</y>
      <w>292</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
通知netdev_chain dev NETDEV_UP事件</panel_attributes>
    <additional_attributes>10.0;10.0;2900.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>791</x>
      <y>924</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>linkwatch_fire_event</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>782</x>
      <y>931</y>
      <w>36</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果dev-&gt;state没有__LINK_STATE_LINKWATCH_PENDING事件，直接返回
2.如果linkwatch_flags中LW_SE_USED没置上，优先使用
	singleevent，否则通过kmalloc申请lw_event
3.通过dev_hold递增net_dev的索引，
	event-&gt;dev = dev
4.将event挂入到lweventlist链表末端
5.如果linkwatch_work队列没被调度（LW_RUNNING）
	通过schedule_delayed_work调度它。（linkwatch_nextevent
	记录下一次调度的时刻点，如果delay&gt;1hz，极有可能是负值）
注：DECLARE_DELAYED_WORK(linkwatch_work, linkwatch_event)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>798</x>
      <y>927</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>791</x>
      <y>951</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>schedule_delayed_work</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>800</x>
      <y>947</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>800</x>
      <y>954</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
keventd_wq</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>793</x>
      <y>958</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>queue_delayed_work</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>786</x>
      <y>965</y>
      <w>28</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果delay=0，直接调用queue_work
2.如果wort.data的WORK_STRUCT_PENDING置上
	需要将其加入到timer
	1.通过set_wq_data设置work.data（wq |WORK_STRUCT_PENDING | 原来work.data中的第1位）
	2.设置timer
		timer-&gt;expires = jiffies + delay;
		timer-&gt;data = (unsigned long)dwork;
		timer-&gt;function = delayed_work_timer_fn;
	3.通过add_timer将timer加入到闹钟
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>799</x>
      <y>961</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>793</x>
      <y>984</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>queue_work</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>798</x>
      <y>980</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>792</x>
      <y>991</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__queue_work</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>797</x>
      <y>987</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果WORK_STRUCT_PENDING没置上</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>787</x>
      <y>998</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //设置work.data
set_wq_data(work, cwq); 
 //将work加入cwq
list_add_tail(&amp;work-&gt;entry, &amp;cwq-&gt;worklist);
cwq-&gt;insert_sequence++;
 //唤醒cwq的more_work链表
wake_up(&amp;cwq-&gt;more_work);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>797</x>
      <y>994</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>210</x>
      <y>264</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_basic_setup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>193</x>
      <y>272</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_workqueues</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>200</x>
      <y>267</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>172</x>
      <y>280</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hotcpu_notifier</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>198</x>
      <y>281</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>create_workqueue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>171</x>
      <y>275</y>
      <w>38</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
注册优先级为0的函数workqueue_cpu_callback到cpu_chain
排序是优先级从大到小</panel_attributes>
    <additional_attributes>290.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>199</x>
      <y>275</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
keventd_wq</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>198</x>
      <y>289</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__create_workqueue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>204</x>
      <y>284</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>182</x>
      <y>297</y>
      <w>37</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.申请wq和wq-&gt;cpu_wq的数据结构
	wq-&gt;name = name
2.通过create_workqueue_thread初始化cpu_wq
	在每个核上创建线程worker_thread
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>203</x>
      <y>292</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>195</x>
      <y>309</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>worker_thread
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>201</x>
      <y>304</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>194</x>
      <y>329</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>run_workqueue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>185</x>
      <y>317</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.将所有的signal bloced，并且设置SIGCHLD
	（do_notify_parent）
2.	如果没要求停止thread（kthread_should_stop），
	添加wait到cwq-&gt;more_work中，醒来之后run_workqueue
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>200</x>
      <y>312</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>199</x>
      <y>325</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>180</x>
      <y>336</y>
      <w>38</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.递归深度不能超过3（cwq-&gt;run_depth++）
2.遍历cwq-&gt;worklist
	1.将work通过list_del_init从链表中删除
	2.如果NOAUTOREL没置上，通过work_release将work的
		PENDING清除
	3.执行work-&gt;func
	4.唤醒work_done链表
		cwq-&gt;remove_sequence++;
		wake_up(&amp;cwq-&gt;work_done)
3.cwq-&gt;run_depth--
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>199</x>
      <y>332</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>192</x>
      <y>356</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>work-&gt;func
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>197</x>
      <y>352</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>193</x>
      <y>363</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>linkwatch_event</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>198</x>
      <y>359</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
linkwatch_fire_event</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>198</x>
      <y>366</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>187</x>
      <y>370</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.设置等待事件，并清除LW_RUNNING
	linkwatch_nextevent = jiffies + HZ;
2.执行linkwatch_run_queue
3.rtnl_unlock销毁net_todo_list上的net_dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>194</x>
      <y>381</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>linkwatch_run_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>200</x>
      <y>377</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>182</x>
      <y>388</y>
      <w>38</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.通过list_replace_init将链表lweventlist取出
2.遍历event链表：
	1.如果遍历到singleevent，不能将其释放，而是将linkwatch_flags
		LW_SE_USED清掉
	2.遍历到其他event，通过kfree将其释放
	3.清除dev.state的__LINK_STATE_LINKWATCH_PENDING事件
	4.rfc2863_policy
	5.如果IFF_UP置上
		1.如果信号没丢失通过dev_activate激活设备，如果丢失设备
			通过dev_deactivate将设备关闭
		2.通过netdev_state_change通知netdev_chain通知NETDEV_CHANGE事件
			并发送RTM_NEWLINK
		3.通过dev_put释放对dev的引用
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>201</x>
      <y>384</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>107</x>
      <y>1099</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inetdev_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>29</x>
      <y>1113</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过kzalloc申请in_device内存空间，并
	初始化in_dev-&gt;rcu_head
	in_dev-&gt;cnf=ipv4_devconf_dflt
	in_dev-&gt;cnf.sysctl = NULL;
	in_dev-&gt;dev = dev;
	in_dev-&gt;arp_parms=neigh_parms_alloc(dev, &amp;arp_tbl)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>66</x>
      <y>1118</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_hold(dev)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>82</x>
      <y>1117</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_sysctl_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>85</x>
      <y>1102</y>
      <w>31</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为arp_parms注册参数</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>101</x>
      <y>1117</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>in_dev_hold(in_dev)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>119</x>
      <y>1117</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>devinet_sysctl_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>113</x>
      <y>1102</y>
      <w>20</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
为ip注册相关参数</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>139</x>
      <y>1117</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_init_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>160</x>
      <y>1116</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_up</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>182</x>
      <y>1116</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;ip_ptr=in_dev
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>113</x>
      <y>1102</y>
      <w>77</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将net_dev和in_device关联</panel_attributes>
    <additional_attributes>10.0;10.0;750.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>114</x>
      <y>1102</y>
      <w>52</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果网络设备被打开（IFF_UP），启用组播</panel_attributes>
    <additional_attributes>10.0;10.0;500.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>115</x>
      <y>1102</y>
      <w>32</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化IGMP</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>108</x>
      <y>1102</y>
      <w>9</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>71</x>
      <y>1102</y>
      <w>45</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>43</x>
      <y>1102</y>
      <w>72</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>700.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>124</x>
      <y>1157</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_addr_onlink</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>118</x>
      <y>1164</y>
      <w>29</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.遍历in_dev的ifa_list链表，如果dst和local
	都是ifa的子网，返回1，否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>130</x>
      <y>1160</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>163</x>
      <y>1154</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inetdev_by_index</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>154</x>
      <y>1161</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>in_device1.通过__dev_get_by_index在hash表dev_index_head
	中通过ifindex找到net_dev
2.通过in_dev_get获取net_dev中的
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>168</x>
      <y>1157</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>199</x>
      <y>1154</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_ifa_byprefix</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>205</x>
      <y>1157</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>189</x>
      <y>1161</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.遍历in_device的ifa_list链表中的主ip，找到掩码
	ifa_mask和子网相同的ifa
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>29</x>
      <y>1178</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_rtm_newaddr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>18</x>
      <y>1185</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过rtm_to_ifaddr利用netlink头nlmsghdr，获取
	netlink的地址结构
2.通过__inet_insert_ifa将地址插入到in_device的ifa_list
	链表中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>35</x>
      <y>1181</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>18</x>
      <y>1196</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rtm_to_ifaddr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>40</x>
      <y>1197</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__inet_insert_ifa</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23</x>
      <y>1192</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>41</x>
      <y>1192</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1</x>
      <y>1203</y>
      <w>35</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.通过nlmsg_parse验证netlink的合法性，并将所有nlattr
	放到tb中
注：netlink=nlmsghdr + ifaddrmsg + n* nlattr（其长度由nla_len确定）
2.通过nlmsg_data获取in_ifaddr指针ifm
3.通过__dev_get_by_index获取ifm指向的net_dev
4.通过__in_dev_get_rtnl获取net_dev中的in_device
5.通过inet_alloc_ifa申请in_ifaddr，并初始化其rcu_head
6.通过in_dev_hold增加in_device的计数
7.初始化ifa
	ifa-&gt;ifa_prefixlen = ifm-&gt;ifa_prefixlen;
	ifa-&gt;ifa_mask = inet_make_mask(ifm-&gt;ifa_prefixlen);
	ifa-&gt;ifa_flags = ifm-&gt;ifa_flags;
	ifa-&gt;ifa_scope = ifm-&gt;ifa_scope;
	ifa-&gt;ifa_dev = in_dev;
	ifa-&gt;ifa_local = nla_get_be32(tb[IFA_LOCAL]);
	ifa-&gt;ifa_address = nla_get_be32(tb[IFA_ADDRESS]);
	ifa-&gt;ifa_broadcast
	ifa-&gt;ifa_anycast
	ifa-&gt;ifa_label
注：nlattr并不是32字节，而是由nla_len确定
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>23</x>
      <y>1199</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>37</x>
      <y>1204</y>
      <w>36</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.要添加的ifa的本地地址（ifa_local）要存在，否则通过inet_free_ifa
	将ifa释放
2.遍历in_device的ifa_list链表
	1.链表中主ip的ifa_scope是按照从大到小的顺序排列
	2.之后排列的是从ip（IFA_F_SECONDARY），从ip和主ip的本地地址不能相同，
	但是发送范围ifa_scope要相同，
注：从ip是ifa_mask相同，目的地址在同一网段
3.通过rtmsg_ifa发送skb消息
4.通过blocking_notifier_call_chain通知NETDEV_UP事件
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>45</x>
      <y>1200</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>94</x>
      <y>1178</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_del_ifa</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>94</x>
      <y>1185</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__inet_del_ifa</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>99</x>
      <y>1181</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>86</x>
      <y>1192</y>
      <w>34</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果要删的是主ip，遍历链表
	1.如果do_promote没置上，那么将所有从ip删除，并发消息rtmsg_ifa和通知inetaddr_chain
	2.否则记录第一个从ip是promote
注：按照__inet_insert_ifa，主ip的scope是按照从大到小排列，不应该存在ifa1-&gt;ifa_scope &lt;= ifa-&gt;ifa_scope
	但是__inet_del_ifa本身会导致顺序问题，但是应该可以将last_prim设置成二重指针ifap
2.将要删除的主ip从链表中删除，并发送消息rtmsg_ifa和通知inetaddr_chain
	*ifap = ifa1-&gt;ifa_next;
3.如果存在promote，说明不要求删除删除所有的从ip
	1.将promote链入到主ip
	2.设置promote为主ip，并发消息rtmsg_ifa和通知inetaddr_chain
	3.通过fib_add_ifaddr调整和promote相关的从ip
4.如果destroy置上，则将ifa通过inet_free_ifa释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>99</x>
      <y>1188</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>794</x>
      <y>915</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>netif_carrier_off</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>799</x>
      <y>910</y>
      <w>65</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>630.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>797</x>
      <y>918</y>
      <w>32</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果dev.state的__LINK_STATE_NOCARRIER
没置上</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>866</x>
      <y>913</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_up</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>861</x>
      <y>910</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>930</x>
      <y>922</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>request_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>872</x>
      <y>916</y>
      <w>66</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
nic-&gt;pdev-&gt;irq
e100_intr</panel_attributes>
    <additional_attributes>10.0;10.0;640.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>930</x>
      <y>929</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_intr
bg=red
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>934</x>
      <y>925</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>935</x>
      <y>932</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果dev.state的__LINK_STATE_START置上
但是__LINK_STATE_RX_SCHED没置上</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>922</x>
      <y>941</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_disable_irq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>926</x>
      <y>937</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
禁止e100中断</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>937</x>
      <y>941</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__netif_rx_schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>935</x>
      <y>937</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>932</x>
      <y>948</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.递增net_dev计数
2.将dev(poll_list)加入到cpu的softnet_data
	链表中
3.dev-&gt;quota = dev-&gt;weight（quota&lt;0时，递增weight）
4.__raise_softirq_irqoff打开软件中断NET_RX_SOFTIRQ
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>943</x>
      <y>944</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>136</x>
      <y>571</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>open_softirq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>119</x>
      <y>566</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>943</x>
      <y>957</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
net_dev_init</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>938</x>
      <y>961</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>net_rx_action</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>132</x>
      <y>578</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>softirq_vec[nr].data = data;
	softirq_vec[nr].action = action;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>141</x>
      <y>574</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>930</x>
      <y>967</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果网络设备的总配额（budget）用完，或者在软中断中
	超过了10ms，跳出软中断
2.遍历cpu的poll_list，取出收到包的设备，
	1.如果dev-&gt;quota用完，将dev挂到poll_list的最后面，并更新其quota
	2.如果没用完，通过dev-&gt;poll轮询
	3.如果没数据处理，通过dev_put释放net_dev
	4.如果还有数据处理，同样将dev放在poll_list最后，并递增quota，
		下次软中断进来，将有quota去处理dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>943</x>
      <y>964</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>938</x>
      <y>991</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_poll</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>939</x>
      <y>984</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;poll
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>944</x>
      <y>980</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>943</x>
      <y>987</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
e100_probe</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>927</x>
      <y>998</y>
      <w>44</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.通过e100_rx_clean读取收到的报文，并传给上层
2.通过e100_tx_clean释放已发送的报文
3.如果rx和tx都没数据处理，或者！__LINK_STATE_START，返回0
	1.将dev从poll_list中删除
	2.清除__LINK_STATE_RX_SCHED标志
	3.置上e100中断（e100_enable_irq）
注：即使rx没数据，但是rx start receiver,也需要重新分配quota
4.如果还有数据处理，更新配额，返回1
	*budget -= work_done;
	netdev-&gt;quota -= work_done;
注：1.如果是利用backlog_dev是在e100_rx申请skb
		data数据来自myNextRxDesc-&gt;descr.buf
		其他数据来自e100_rx对skb数据分析
	2.如果是net_poll dev是在e100_rx_alloc_list申请skb
		data数据来自硬件dma
		其他数据来自e100_rx_indicate对skb数据分析
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>943</x>
      <y>994</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>903</x>
      <y>1029</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_rx_clean</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>907</x>
      <y>1022</y>
      <w>35</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
rx_to_clean参考
e100_rx_alloc_list</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>944</x>
      <y>1028</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_tx_clean</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>944</x>
      <y>1022</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>946</x>
      <y>987</y>
      <w>46</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
net_dev_init</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>983</x>
      <y>991</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>process_backlog</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>988</x>
      <y>994</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>976</x>
      <y>998</y>
      <w>37</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.循环处理skb	
	1.通过__skb_dequeue将skb从input_pkt_queue
	2.通过netif_receive_skb传递到上层或者转发
	3.通过dev_put释放skb中的dev，并统计处理skb的数量work
	4.退出条件：
		1.如果input_pkt_queue中没有skb，跳到job_done
			//更新配额
			backlog_dev-&gt;quota -= work;
			*budget -= work;
			//将虚拟网络设备backlog从poll_list中删除
			list_del(&amp;backlog_dev-&gt;poll_list);
			//清除dev.state的__LINK_STATE_RX_SCHED
			netif_poll_enable
		2.如果配额达到限制或者软中断中停留超过10ms，更新配额，返回-1
			backlog_dev-&gt;quota -= work;
			*budget -= work;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>987</x>
      <y>1027</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>netif_receive_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>992</x>
      <y>1023</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>978</x>
      <y>1034</y>
      <w>32</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.如果是NAPI,通过netpoll接收，不在传递协议栈处理（NET_RX_DROP）
2.如果要求设置时间戳（!skb-&gt;tstamp.off_sec），通过net_timestamp
	设置事件戳
3.如果input_dev没被设置
	skb-&gt;input_dev = skb-&gt;dev
4.skb_bond处理bonding
5.数据包的数量
	__get_cpu_var(netdev_rx_stat).total++;
6.mac长度
	skb-&gt;h.raw = skb-&gt;nh.raw = skb-&gt;data;
	skb-&gt;mac_len = skb-&gt;nh.raw - skb-&gt;mac.raw
7.遍历链表ptype_all，如果存在其中协议的ptype-&gt;dev
	和接收skb的dev相同,通过deliver_skb传递skb
8.通过桥转发报文handle_bridge
9.遍历hash表ptype_base
	1.找到ptype-&gt;type和protocol相同，dev相同的packet_type
	2.deliver_skb处理skb
	3.通过pt_prev-&gt;func处理最后一个packet_type
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>992</x>
      <y>1030</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>997</x>
      <y>1067</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ptype-&gt;func
bg=red
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1000</x>
      <y>1063</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>977</x>
      <y>1067</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>deliver_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>983</x>
      <y>1063</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>969</x>
      <y>1074</y>
      <w>27</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.递增skb-&gt;users的计数
2.pt_prev-&gt;func将skb通过套接口传给上层
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>981</x>
      <y>1070</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>576</x>
      <y>732</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>notifier_call_chain</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>581</x>
      <y>728</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
cpu_chain</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>578</x>
      <y>739</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>nb-&gt;notifier_call
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>584</x>
      <y>735</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>585</x>
      <y>742</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
net_dev_init
（事件：CPU_DEAD）</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>584</x>
      <y>747</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_cpu_callback</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>574</x>
      <y>754</y>
      <w>34</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果不是CPU_DEAD，返回NOTIFY_OK
2.将原来cpu的softnet_data.completion_queue
	链接到新cpu的sd-&gt;completion_queue之后
3.output_queue也做同样的动作
4.通过raise_softirq_irqoff唤醒软中断（不在中断中，通过wakeup_softirqd唤醒）
5.原来cpu中的input_pkt_queue链表中的skb，__skb_dequeue脱链，
	然后通过netif_rx链接到新cpu的input_pkt_queue中
6.返回NOTIFY_OK
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>589</x>
      <y>750</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>539</x>
      <y>750</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_init_scheduler</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>534</x>
      <y>757</y>
      <w>30</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.初始化排队规则
	dev-&gt;qdisc = &amp;noop_qdisc;
	dev-&gt;qdisc_sleeping = &amp;noop_qdisc;
	INIT_LIST_HEAD(&amp;dev-&gt;qdisc_list);
2.通过dev_watchdog_init初始化软件狗
	timer-&gt;entry.next = NULL;
	timer-&gt;base = __raw_get_cpu_var(tvec_bases);
	dev-&gt;watchdog_timer.data = (unsigned long)dev;
	dev-&gt;watchdog_timer.function = dev_watchdog;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>545</x>
      <y>753</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>515</x>
      <y>679</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qdisc_lookup_ops</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>506</x>
      <y>686</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.遍历链表qdisc_base，如果kind和id相同，返回q
	如果没找到，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>520</x>
      <y>682</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>977</x>
      <y>952</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qdisc_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>963</x>
      <y>958</y>
      <w>37</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.分配Qdisc和私有数据ops-&gt;priv_size的空间
2.Qdisc开始位置要32字节对其，多出来的长度是padded
3.初始化Qdisc
	INIT_LIST_HEAD(&amp;sch-&gt;list);
	skb_queue_head_init(&amp;sch-&gt;q);
	sch-&gt;ops = ops;
	sch-&gt;enqueue = ops-&gt;enqueue;
	sch-&gt;dequeue = ops-&gt;dequeue;
	sch-&gt;dev = dev;
	dev_hold(dev);
	sch-&gt;stats_lock = &amp;dev-&gt;queue_lock;
	atomic_set(&amp;sch-&gt;refcnt, 1);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>982</x>
      <y>955</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1018</x>
      <y>933</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qdisc_create_dflt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1012</x>
      <y>940</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过qdisc_alloc分配Qdisc
2.sch-&gt;parent = parentid
3.通过ops-&gt;init初始化Qdisc
4.如果初始化失败，通过qdisc_destroy
	释放Qdisc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1023</x>
      <y>936</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>982</x>
      <y>949</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>527</x>
      <y>644</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qdisc_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>514</x>
      <y>651</y>
      <w>36</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.通过qdisc_lookup_ops在qdisc_base中查看是否有id相同的Qdisc_ops
2.如果没有找到但是id又存在，通过request_module请求模块
	并利用qdisc_lookup_ops再次在链表中寻找，
	1.如果还没找到返回ENOENT
	2.如果找到了，先释放ops-&gt;owner，并要求重试EAGAIN
3.如果找到了
	1.通过qdisc_alloc分配Qdisc
	2.分配sch-&gt;handle，
		1.如果是TC_H_INGRESS，表示输入规则
			sch-&gt;flags |= TCQ_F_INGRESS;
			handle = TC_H_MAKE(TC_H_INGRESS, 0);
		2.如果是0，表示内核自动分配（qdisc_alloc_handle）
			从0x80000000U到0xFFFFFFFF，并且dev-&gt;qdisc_list链表中不存在
	3.ops-&gt;init，如果成功将其加入到qdisc_list链表中
		list_add_tail(&amp;sch-&gt;list, &amp;dev-&gt;qdisc_list);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>531</x>
      <y>647</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>519</x>
      <y>675</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>538</x>
      <y>679</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qdisc_alloc_handle</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>543</x>
      <y>675</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>543</x>
      <y>682</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>539</x>
      <y>686</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qdisc_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>538</x>
      <y>693</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__qdisc_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>543</x>
      <y>689</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>529</x>
      <y>700</y>
      <w>33</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.遍历链表dev-&gt;qdisc_list，找到q-&gt;handle与其相同的Qdisc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>542</x>
      <y>696</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1036</x>
      <y>904</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_activate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1020</x>
      <y>911</y>
      <w>48</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果设备没安装有效的排队规则（dev-&gt;qdisc_sleeping == &amp;noop_qdisc）
	1.如果存在tx_queue_len，通过qdisc_create_dflt创建排队规则（ops=pfifo_fast_ops）
		并将排队规则链入到dev-&gt;qdisc_list
	2.如果tx_queue_len为0，则指定规则是noqueue_qdisc，这个规则不存在enqueue，所有会直接发送
	3.dev-&gt;qdisc_sleeping = qdisc;
2.如果__LINK_STATE_NOCARRIER没置上，延迟排队规则的安装
3.安装排队规则
	dev-&gt;qdisc, dev-&gt;qdisc_sleeping
4.如果有有效的排队规则，打开软件狗
	dev-&gt;trans_start = jiffies;
	dev_watchdog_up(dev);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1041</x>
      <y>907</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1023</x>
      <y>929</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1048</x>
      <y>933</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_watchdog_up</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1053</x>
      <y>929</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1046</x>
      <y>940</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__netdev_watchdog_up</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1053</x>
      <y>936</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1041</x>
      <y>947</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果设置了timeout时间（tx_timeout）
	1.如果watchdog_timeo无效（小于0），则设置为5s
	2.通过mod_timer更改watchdog_timer的通知时间，
		成功之后增加dev引用 dev_hold(dev)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1054</x>
      <y>943</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>566</x>
      <y>644</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qdisc_graft</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>555</x>
      <y>649</y>
      <w>36</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果是根Qdisc（!parent），通过dev_graft_qdisc指定根排队规则
	1.如果是输入规则TCQ_F_INGRESS，指定的是old
	2.其他规则，则是new
2.如果有parent，
	1.将类标识符classid，通过parent-&gt;ops-&gt;cl_ops.get转化为内部标识符
	2.调用cops-&gt;graft，将排队规则绑定到类中
	3.如果成功绑定
		new-&gt;parent = classid
	4.通过cops-&gt;put释放内部标识符
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>570</x>
      <y>647</y>
      <w>3</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>569</x>
      <y>667</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_graft_qdisc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>574</x>
      <y>664</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>555</x>
      <y>673</y>
      <w>42</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果网络设备被打开（IFF_UP），dev_deactivate将其排队规则
	设置为空规则。
2.如果是输入规则（TCQ_F_INGRESS）
	1.如果之前存在qdisc_ingress，初始化输入规则
		qdisc_reset(oqdisc);
		dev-&gt;qdisc_ingress = NULL;
	2.否则：
		dev-&gt;qdisc_ingress = qdisc;
3.如果是输出规则
	1.如果旧的规则（dev-&gt;qdisc_sleeping）存在，qdisc_reset初始化
		输出规则
	2.dev-&gt;qdisc_sleeping = qdisc;//如果为NULl,即为noop_qdisc
		dev-&gt;qdisc = &amp;noop_qdisc;
4.如果设备开启（IFF_UP），应用刚安装的排队规则
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>573</x>
      <y>670</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1010</x>
      <y>960</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pfifo_fast_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1001</x>
      <y>967</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.获取qdisc的私有信息qdisc_priv
2.通过skb_queue_head_init初始化私有信息
	中的3个skb头
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1015</x>
      <y>963</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>549</x>
      <y>583</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tc_modify_qdisc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>538</x>
      <y>589</y>
      <w>41</w>
      <h>52</h>
    </coordinates>
    <panel_attributes>1.根据设备号tcm_ifindex利用__dev_get_by_index在
	hash表中查找net_dev
2.如果tcm-&gt;tcm_parent存在
	1.如果是输入根排队规则，q = dev-&gt;qdisc_sleeping
	2.输出根排队规则，q = dev-&gt;qdisc_ingress
	3.如果是其他排队，qdisc_lookup在qdisc_list链表中
		查找排队，并在得到排队的qdisc_leaf
	4.如果找到的handle为0，则q=NULL
	5.如果没找到q，或者tcm_handle为0，或者q和指定的handle不一致
		1.如果tcm_handle不为0
			1.如果找到q，但是不允许NLM_F_REPLACE，返回EEXIST
			2.如果tcm_handle低16位不为0，返回EINVAL
			3.通过qdisc_lookup在链表qdisc_list查找tcm_handle，如果
				不存在，create_n_graft--&gt;5
			4.如果存在，如果NLM_F_EXCL，返回EEXIST
			5.如果算法名称不同，返回EINVAL
			6.出现回环，返回ELOOP
			7.增加q-&gt;refcnt，graft--&gt;6
		2.如果为0
			1.如果q不存在，create_n_graft--&gt;5
			2.否则经检查后，create_n_graft--&gt;5
3.如果不存在，通过qdisc_lookup在链表中查找tcm_handle
4.修改q
	1.q不能为NULL
	2.NLM_F_EXCL不能置上
	3.算法名称要相同
	4.通过qdisc_change修改q
	5.如果成功，qdisc_notify，并返回
5.创建新的qdisc
	1.NLM_F_CREATE要置上
	2.qdisc_create创建q
6.利用qdisc_graft替换p--clid
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>553</x>
      <y>586</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>532</x>
      <y>640</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>553</x>
      <y>640</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>620</x>
      <y>577</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tc_ctl_tclass</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>606</x>
      <y>584</y>
      <w>39</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.根据设备号tcm_ifindex利用__dev_get_by_index在
	hash表中查找net_dev
2.如果parent不是TC_H_ROOT
	1.如果parent和handle的major不同，返回EINVAL，否则qid不变
	2.如果handle的major不为0，qid为handle的major
	3.如果parent_major为0（handle_major为0），qid = dev-&gt;qdisc_sleeping-&gt;handle
	4.如果parent_major不为0（handle_major为0），qid是parent_major
	5.将pid的高16位补齐
3.如果是TC_H_ROOT
	1.如果handle_major为0，表示qid = dev-&gt;qdisc_sleeping-&gt;handle
	2.否则qid为handle_major
4.通过qdisc_lookup寻找qid对应的qdisc
5.获取class对应的id
6.通过cops-&gt;get获取类
7.依照nlmsg_type操作类
	1.RTM_NEWTCLASS，
		1.NLM_F_EXCL置上，返回EEXIST
		2.cops-&gt;change
	2.RTM_DELTCLASS：cops-&gt;delete，tclass_notify
	3.RTM_GETTCLASS：tclass_notify
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>625</x>
      <y>580</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1085</x>
      <y>392</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>902</x>
      <y>395</y>
      <w>191</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot/udp_prot/raw_prot</panel_attributes>
    <additional_attributes>1890.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>896</x>
      <y>402</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>proto_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>885</x>
      <y>410</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果alloc_slab置上，就申请以下cache
	prot-&gt;slab  prot-&gt;rsk_prot-&gt;slab  prot-&gt;twsk_prot-&gt;twsk_slab
2.将prot(node)挂入到proto_list链表中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>900</x>
      <y>405</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>921</x>
      <y>404</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_register</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>925</x>
      <y>395</y>
      <w>167</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_family_ops</panel_attributes>
    <additional_attributes>1650.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>918</x>
      <y>411</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>net_families[ops-&gt;family] = ops
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>927</x>
      <y>407</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>946</x>
      <y>404</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_add_protocol</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>951</x>
      <y>395</y>
      <w>141</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
icmp_protocol/udp_protocol/tcp_protocol/igmp_protocol</panel_attributes>
    <additional_attributes>1390.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>943</x>
      <y>411</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_protos[hash] = prot
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>952</x>
      <y>407</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>969</x>
      <y>404</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_register_protosw</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>976</x>
      <y>395</y>
      <w>117</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inetsw_array</panel_attributes>
    <additional_attributes>1150.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>968</x>
      <y>411</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.将inet_protosw插入inetsw[p-&gt;type]
2.如果链表中存在和其protocol相同的，
	只要不是INET_PROTOSW_PERMANENT
	置上，就将其替换，否则打印错误
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>977</x>
      <y>407</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2088</x>
      <y>224</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_cmsg_recv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2094</x>
      <y>227</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2078</x>
      <y>230</y>
      <w>37</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.查看inet-&gt;cmsg_flags
	1.如果IP_PKTINFO,通过ip_cmsg_recv_pktinfo接收目的地址，
		网络设备，源地址到msg.msg_control
	2.如果IP_TTL,ip_cmsg_recv_ttl接收ip头部的ttl到msg.msg_control
	3.如果IP_TOS,ip_cmsg_recv_tos接收ip头部的tos到msg.msg_control
	4.如果IP_RECVOPTS,ip_cmsg_recv_opts接收ip头部的ip选项到msg.msg_control
	5.如果IP_RETOPTS,ip_cmsg_recv_retopts接收ip头部的未处理过的ip选项到msg.msg_control
	5.如果IP_PASSSEC,ip_cmsg_recv_security接收有关安全的信息到msg.msg_control
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1120</x>
      <y>1243</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_getpeer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1106</x>
      <y>1250</y>
      <w>37</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.通过lookup在avl树peer_root中查找目的地址daddr，
	并将路径存放在stack中
注:stack在做avl平衡时会有用
2.如果找到了inet_peer，递增计数p-&gt;refcnt，并且
	通过unlink_from_unused将p从unused list中
	删除，最后返回p
3.如果没找到，并且create为0，返回NULL
4.如果create存在，
	1.首先通过kmem_cache_alloc申请inet_peer
	2.初始化inet_peer
		n-&gt;v4daddr = daddr;
		atomic_set(&amp;n-&gt;refcnt, 1);
		atomic_set(&amp;n-&gt;rid, 0);
		n-&gt;ip_id_count = secure_ip_id(daddr);
		n-&gt;tcp_ts_stamp = 0;
	3.上锁之后，再次通过lookup在avl树中查找，因为上锁自旋
		过程中可能被加到avl中
	4.如果还是没找到，通过link_to_pool将其加入到avl中，并且
		利用stack记录的路径做平衡
	5.递增peer_total++;，并检查其是否超过限制inet_peer_threshold
		如果超过了，利用cleanup_once清除lru的inet_peer
	6.返回inet_peer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1125</x>
      <y>1246</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1151</x>
      <y>1299</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_putpeer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1143</x>
      <y>1306</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.递减p-&gt;refcnt，如果p-&gt;refcnt为0
	将p加入到链表尾端inet_peer_unused_tailp
	并更新p-&gt;dtime = (__u32)jiffies;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1117</x>
      <y>1289</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cleanup_once</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1122</x>
      <y>1285</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1107</x>
      <y>1296</y>
      <w>32</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.取出inet_peer_unused_head
	1.如果在链表中停留超过了ttl，将其从链表中删除
		inet_peer_unused_head和inet_peer_unused_tailp
		做出相应的更改
	2.递增p-&gt;refcnt，以免在unlink_from_pool前将p释放
	3.unlink_from_pool将p从avl树中删除，并重新平衡avl
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1122</x>
      <y>1292</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1100</x>
      <y>404</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1091</x>
      <y>395</y>
      <w>18</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1242</x>
      <y>411</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_initpeers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1105</x>
      <y>407</y>
      <w>145</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1430.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1239</x>
      <y>418</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_timer(&amp;peer_periodic_timer)
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1247</x>
      <y>414</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1243</x>
      <y>425</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>peer_check_expire</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1248</x>
      <y>421</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1248</x>
      <y>428</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1243</x>
      <y>431</y>
      <w>31</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.确定要释放的时间ttl
	1.如果peer_total超过了限制，ttl就为inet_peer_minttl
	2.否则就以inet_peer_maxttl计算ttl
2.利用cleanup_once依次清除链表中时间大于ttl的inet_peer
	直到没有大于ttl，或者产生了时间中断
3.最后设置timer的时间
	1.如果peer_total超过了限制，选取最小时间inet_peer_gc_mintime
	2.否则，利用inet_peer_gc_maxtime计算
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1415</x>
      <y>401</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_add_pack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1090</x>
      <y>395</y>
      <w>331</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ip_packet_type</panel_attributes>
    <additional_attributes>10.0;10.0;3290.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1408</x>
      <y>408</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果type是ETH_P_ALL，将其加入到链表ptype_all
	并且netdev_nit++
3.否则加入到hash表ptype_base中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1420</x>
      <y>404</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1002</x>
      <y>1070</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ip_packet_type</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>998</x>
      <y>1074</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_rcv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>828</x>
      <y>923</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_rx_alloc_list</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>835</x>
      <y>916</y>
      <w>38</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化接收单元rx</panel_attributes>
    <additional_attributes>360.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>861</x>
      <y>924</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_alloc_cbs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>868</x>
      <y>916</y>
      <w>16</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化发送单元cb</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>893</x>
      <y>924</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_start_receiver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>871</x>
      <y>916</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;300.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>820</x>
      <y>930</y>
      <w>27</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.nic-&gt;ru_running = RU_UNINITIALIZED;
2.通过kcalloc申请nic-&gt;params.rfds.count个
	rx给nic-&gt;rxs数组
3.遍历数组rxs，将数组中的元素通过循环链表组织
	并通过e100_rx_alloc_skb初始化每个rx
4.nic-&gt;rx_to_use = nic-&gt;rx_to_clean = nic-&gt;rxs;
	nic-&gt;ru_running = RU_SUSPENDED;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>833</x>
      <y>926</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>824</x>
      <y>946</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_rx_alloc_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>830</x>
      <y>942</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>815</x>
      <y>953</y>
      <w>29</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.通过netdev_alloc_skb申请rx-&gt;skb
2.初始化skb
	1.data的前NET_IP_ALIGN字节留出来
	2.rx-&gt;skb-&gt;data=nic-&gt;blank_rfd //e100_get_defaults中设置了cb_el
	3.rx-&gt;dma_addr=rx-&gt;skb-&gt;data
3.初始化dma序列
	prev_rfd = (struct rfd *)rx-&gt;prev-&gt;skb-&gt;data
	prev_rfd-&gt;link=rx-&gt;dma_addr//物理地址链表
	prev_rfd-&gt;command &amp;= ~cpu_to_le16(cb_el) //去除最后一个的标记
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>829</x>
      <y>949</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>851</x>
      <y>931</y>
      <w>34</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.nic-&gt;cuc_cmd = cuc_start
2.通过pci_alloc_consistent在dma区域申请数组
	nic-&gt;cbs（数组数量：nic-&gt;params.cbs.count）
	nic-&gt;cbs_dma_addr记录数组的物理地址
3.将数组中nic-&gt;cbs中的元素通过循环链表组织
	//每个cb的dma物理地址
	cb-&gt;dma_addr = nic-&gt;cbs_dma_addr + i * sizeof(struct cb);
	//dma通过循环链表链接,link指向的是物理地址，next指向的是虚拟地址
	cb-&gt;link = cpu_to_le32(nic-&gt;cbs_dma_addr +
		((i+1) % count) * sizeof(struct cb));
	cb-&gt;skb = NULL;
4.nic-&gt;cb_to_use = nic-&gt;cb_to_send = nic-&gt;cb_to_clean = nic-&gt;cbs;
	nic-&gt;cbs_avail = count;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>867</x>
      <y>927</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>899</x>
      <y>927</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>887</x>
      <y>931</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.nic-&gt;rxs数组要存在
2.nic-&gt;ru_running不能为RU_SUSPENDED
3.如果rx-&gt;skb存在，通过e100_exec_cmd发送ruc_start
	命令，接收数据到rx-&gt;dma_addr
	nic-&gt;ru_running = RU_RUNNING
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>983</x>
      <y>1081</y>
      <w>50</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果skb不是该节点接收(PACKET_OTHERHOST)，直接丢弃skb
2.如果skb_share_check检测是shared，需要clone一个skb
	因为之后需要对skb进行变更
3.通过pskb_may_pull在skb的headlen的空间内变更出iphdr
	长度的空间
3.头部长度不能小于20字节（iph-&gt;ihl &lt; 5），并且只能是ipv4（iph-&gt;version != 4）
4.通过pskb_may_pull在skb的headlen的空间内变更出iph-&gt;ihl*4
	长度的空间
5.通过ip_fast_csum计算ip头部的checksum
6.得到skb的总长度（iph-&gt;tot_len），不能大于skb.len，并且不能小于头部长度
	（iph-&gt;ihl*4）
7.通过pskb_trim_rcsum将skb中大于tot_len的部分去掉。
8.初始化skb.cb，之后存放ip的头部选项
9.ip_rcv_finish完成ip数据报的输入
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1002</x>
      <y>1077</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1001</x>
      <y>1108</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_rcv_finish</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1006</x>
      <y>1104</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>988</x>
      <y>1115</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果没为skb指定路由缓存（skb-&gt;dst == NULL），则通过
	ip_route_input查找输入路由缓存
2.如果ip_rcv_options接收ip选项储出错，释放skb，返回
3.dst_input接收skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1006</x>
      <y>1111</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>985</x>
      <y>1126</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_route_input</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>989</x>
      <y>1122</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>972</x>
      <y>1134</y>
      <w>38</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.通过源，目的地址以及网络设备计算hash，遍历
	rt_hash_table，看是否能找到源，目的地址，网络设备
	相同，输出设备（oif == 0），mark == skb-&gt;mark
	以及fl4_tos == tos相同的项
	如果有，返回0，表示正常收到
	rth-&gt;u.dst.lastuse = jiffies;
	dst_hold(&amp;rth-&gt;u.dst);
	rth-&gt;u.dst.__use++;
	skb-&gt;dst = (struct dst_entry*)rth;
2.如果没有，递增RT_CACHE_STAT_INC(in_hlist_search)
3.如果目的地址是多播地址MULTICAST
	1.通过__in_dev_get_rcu获取in_device
	2.通过ip_check_mc检查是否被本机接收
	3.如果被本机接收，通过ip_route_input_mc查找路由,并返回
	4.否则返回EINVAL
4.否则通过ip_route_input_slow查找路由
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1101</x>
      <y>411</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_rt_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1105</x>
      <y>407</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1100</x>
      <y>418</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_fib_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1105</x>
      <y>414</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1072</x>
      <y>425</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib_hash_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1076</x>
      <y>421</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ip_fib_local_table/ip_fib_main_table
RT_TABLE_LOCAL/RT_TABLE_MAIN</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1063</x>
      <y>432</y>
      <w>30</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果hash和alias的cache没被创建，通过
	kmem_cache_create创建cache fn_hash_kmem
	和fn_alias_kmem
2.申请内存fib_table和fn_hash
3.初始化fib_table
	tb-&gt;tb_id = id;
	tb-&gt;tb_lookup = fn_hash_lookup;
	tb-&gt;tb_insert = fn_hash_insert;
	tb-&gt;tb_delete = fn_hash_delete;
	tb-&gt;tb_flush = fn_hash_flush;
	tb-&gt;tb_select_default = fn_hash_select_default;
	tb-&gt;tb_dump = fn_hash_dump;
	//将fib_table尾端的fn_hash结构初始化
	memset(tb-&gt;tb_data, 0, sizeof(struct fn_hash));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1077</x>
      <y>428</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>934</x>
      <y>514</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_rtm_newroute</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>895</x>
      <y>538</y>
      <w>34</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.nlmsg_validate验证配置的有效性
	1.总长度nlh-&gt;nlmsg_len不能小于头部+消息的长度
	2.attr的长度符合规则
2.根据传进来的而消息设置cfg
	rtm = nlmsg_data(nlh);
	cfg-&gt;fc_dst_len = rtm-&gt;rtm_dst_len;
	cfg-&gt;fc_tos = rtm-&gt;rtm_tos;
	cfg-&gt;fc_table = rtm-&gt;rtm_table;//fib_table的id
	cfg-&gt;fc_protocol = rtm-&gt;rtm_protocol;
	cfg-&gt;fc_scope = rtm-&gt;rtm_scope;
	cfg-&gt;fc_type = rtm-&gt;rtm_type;
	cfg-&gt;fc_flags = rtm-&gt;rtm_flags;
	cfg-&gt;fc_nlflags = nlh-&gt;nlmsg_flags;

	cfg-&gt;fc_nlinfo.pid = NETLINK_CB(skb).pid;
	cfg-&gt;fc_nlinfo.nlh = nlh;
3.根据传进来的属性attr的type设置cfg
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>939</x>
      <y>517</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>922</x>
      <y>521</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.根据rtm_to_fib_config将消息以及attr设置cfg
2.通过fib_new_table根据id查找fib_table
3.调用tb-&gt;tb_insert，将cfg插入到fib_table中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>909</x>
      <y>531</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rtm_to_fib_config</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>913</x>
      <y>534</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>914</x>
      <y>527</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>937</x>
      <y>531</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib_new_table</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>942</x>
      <y>527</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>942</x>
      <y>534</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>962</x>
      <y>534</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fib_hash_init</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>956</x>
      <y>531</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tb-&gt;tb_insert
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>950</x>
      <y>527</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>960</x>
      <y>538</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fn_hash_insert</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>961</x>
      <y>545</y>
      <w>43</w>
      <h>81</h>
    </coordinates>
    <panel_attributes>1.目的地址的掩码长度(cfg-&gt;fc_dst_len)不能超过32
2.查看该长度内是否存在fz，如果没有通过fn_new_zone
	申请一个
3.配置信息中目的地址的主机号要为0，并得到掩码
	key = fz_key(cfg-&gt;fc_dst, fz)
4.通过fib_create_info创建fib_info
5.hash表可能发生了变化，通过fn_rehash_zone更改new_divisor
	并且利用fz_hash_alloc重新申请hash表替换之前的hash
6.通过fib_find_node在hash表fz-&gt;fz_hash中查找f-&gt;fn_key
	相同的fib_node
7.如果fib_node找到，通过fib_find_alias查找出优先级
	大于设定的fib_alias
8.如果找到的fib_alias和fi的优先级相同（tos和prio）
	1.如果配置信息中NLM_F_EXCL置上，不要创建直接返回
	2.如果NLM_F_REPLACE置上，将fa刷新，并刷新路由
		缓存表
			fi_drop = fa-&gt;fa_info;
			fa-&gt;fa_info = fi;
			fa-&gt;fa_type = cfg-&gt;fc_type;
			fa-&gt;fa_scope = cfg-&gt;fc_scope;
			state = fa-&gt;fa_state;
			fa-&gt;fa_state &amp;= ~FA_S_ACCESSED;
			fib_hash_genid++;
			fib_release_info(fi_drop);
			rt_cache_flush(-1);
	3.遍历之后的链表，
		1.如果找到fa_type，fa_scope，fa_info
		完全相同的，不需要进行任何操作
		2.如果存在不同，但是存在NLM_F_APPEND，将其替换
9.创建
	1.如果NLM_F_CREATE没置上，直接返回
	2.通过kmem_cache_alloc申请fa和fib_node
		INIT_HLIST_NODE(&amp;new_f-&gt;fn_hash);
		INIT_LIST_HEAD(&amp;new_f-&gt;fn_alias);
		new_f-&gt;fn_key = key;
		f = new_f;
	3.初始化fa
		new_fa-&gt;fa_info = fi;
		new_fa-&gt;fa_tos = tos;
		new_fa-&gt;fa_type = cfg-&gt;fc_type;
		new_fa-&gt;fa_scope = cfg-&gt;fc_scope;
		new_fa-&gt;fa_state = 0;	
	4.将fib_node插入到fz-&gt;fz_hash中，将fa插入到9步之前设定的fa之后
		fib_hash_genid++
	5.刷新fz中路由项的数目，并刷新路由缓存表
		fz-&gt;fz_nent++;
		rt_cache_flush
	6.rtmsg_fib通知感兴趣的进程
注：1.fib_table最尾端有一个fz的数组（已用的构成链表）
	2.fz中有一个hash表fz_hash存储fib_node
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>965</x>
      <y>541</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>945</x>
      <y>630</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fn_new_zone</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>934</x>
      <y>637</y>
      <w>31</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.通过kzalloc申请fn_zone
2.fz-&gt;fz_divisor //目的地址的掩码长度不是0即为16
						//是0即为1
	fz-&gt;fz_hashmask = (fz-&gt;fz_divisor - 1);
	//申请fz_divisor个hlist_head
	fz-&gt;fz_hash = fz_hash_alloc(fz-&gt;fz_divisor)
	fz-&gt;fz_order = z
	fz-&gt;fz_mask			//目的地址掩码
3.申请fz_hash的hash head数组
3.将fz加入到链表table-&gt;fn_zone_list中，在
	链表中的排序是从大到小（目的地址的掩码长度）
4.table-&gt;fn_zones[z] = fz;
	fib_hash_genid++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>949</x>
      <y>633</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>974</x>
      <y>630</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib_create_info</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>968</x>
      <y>637</y>
      <w>35</w>
      <h>59</h>
    </coordinates>
    <panel_attributes>1.配置的寻址范围不能超过该路由类型（cfg-&gt;fc_type）的真实寻址范围，
注：fc_scope越小，其寻址范围越大
2.如果fib_info_cnt已经不小于fib_hash_size，需要
	扩展fib_hash_size
	1.申请新的new_info_hash和new_laddrhash
	2.清0两个hash，然后通过fib_hash_move将旧的hash移到新的
		hash(fib_info_hash和fib_info_laddrhash)中，并且
		更新fib_hash_size
3.申请fi，及其跳转信息fib_nh（next_hoop）
	fib_info_cnt++
4.初始化fi
	fi-&gt;fib_protocol = cfg-&gt;fc_protocol;
	fi-&gt;fib_flags = cfg-&gt;fc_flags;
	fi-&gt;fib_priority = cfg-&gt;fc_priority;
	fi-&gt;fib_prefsrc = cfg-&gt;fc_prefsrc;
	fi-&gt;fib_nhs = nhs;
	nh-&gt;nh_parent = fi;//设置跳转信息数组
5.如果要求设置路由度量值（cfg-&gt;fc_mx)）,attr中的值
	fi-&gt;fib_metrics[type - 1] = nla_get_u32(nla);
6.如果定义了cfg-&gt;fc_mp，通过fib_get_nhs根据fc_mp
	对数组fi.fib_nh赋值，否则通过cfg的其他参数进行赋值
7.cfg-&gt;fc_scope不能高于RT_SCOPE_HOST
8.查看cfg-&gt;fc_scope
	1.如果要配置成本地地址（RT_SCOPE_HOST）
		nh-&gt;nh_scope = RT_SCOPE_NOWHERE;
		nh-&gt;nh_dev = dev_get_by_index(fi-&gt;fib_nh-&gt;nh_oif);
	2.如果配置成其他路由范围，通过fib_check_nh设置
9.判断首选ip源地址fi-&gt;fib_prefsrc
10.将fi信息链接到hash表中
	1.如果通过fib_find_info在hash表fib_info_hash中找到了fi
		释放申请的fi
	2.递增fi-&gt;fib_treeref++（fib_node对info的引用），以及
		fi-&gt;fib_clntref（路由查找成功而增加的引用）
	3.将fi加入到fib_info_hash，fib_info_laddrhash（fib_prefsrc hash）
		hash表中
	4.将fi下的nh链接到hash表fib_info_devhash中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>980</x>
      <y>633</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>932</x>
      <y>538</y>
      <w>26</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果id是0，选用RT_TABLE_MAIN
2.通过fib_get_table在fib_table_hash中查找fib_table
3.如果找到，即返回fib_table，如果没有
	利用fib_hash_init新建一个fib_table
4.将新建的fib_table插入到fib_table_hash
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1012</x>
      <y>629</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib_find_alias</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1005</x>
      <y>636</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历链表（这里是f-&gt;fn_alias），
	1.找到fa_tos相同，但是fib_priority比设置优先级大的
	2.找到fa_tos比设定小的
注：是否意味着fa_tos小，优先级越大
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1018</x>
      <y>632</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>950</x>
      <y>625</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>979</x>
      <y>625</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>986</x>
      <y>625</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1094</x>
      <y>426</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>register_netdevice_notifier(&amp;fib_netdev_notifier);
register_inetaddr_notifier(&amp;fib_inetaddr_notifier);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1104</x>
      <y>421</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1101</x>
      <y>434</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib_netdev_event</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1106</x>
      <y>430</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fib_netdev_notifier</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1094</x>
      <y>441</y>
      <w>26</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.当NETDEV_UNREGISTER，fib_disable_ip
	清除网络功能信息和相关功能（传参为2）
2.如果in_dev不存在,直接返回
3.如果NETDEV_UP，通过fib_add_ifaddr
	将in_device中的地址加入fib
	并通过rt_cache_flush刷新
4.如果NETDEV_DOWN，fib_disable_ip
	清除网络功能信息和相关功能（传参为0）
5.如果NETDEV_CHANGEMTU，NETDEV_CHANGE
	通过rt_cache_flush刷新路由表
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1107</x>
      <y>437</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1113</x>
      <y>430</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fib_inetaddr_notifier</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1122</x>
      <y>434</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib_inetaddr_event</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1121</x>
      <y>442</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果是添加本地地址（NETDEV_UP），通过fib_add_ifaddr
	添加到RT_TABLE_LOCAL中，并通过rt_cache_flush
	延时刷新路由缓存
2.	如果删除本地地址（NETDEV_DOWN），
	通过fib_del_ifaddr将地址从RT_TABLE_LOCAL
	中删除，如果ifa-&gt;ifa_dev-&gt;ifa_list链表
	删除完，通过fib_disable_ip（传参1）停止
	ARP功能。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1127</x>
      <y>437</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1086</x>
      <y>461</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib_add_ifaddr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1091</x>
      <y>458</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1087</x>
      <y>464</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1071</x>
      <y>467</y>
      <w>36</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果是从属ip(IFA_F_SECONDARY),通过inet_ifa_byprefix
	在ifa_list链表中查找mask相同的主ip，如果没找到，直接返回
2.通过fib_magic添加在RT_TABLE_LOCAL中一条输入到本地的路由表项
3.如果dev启动（IFF_UP）
	1.如果存在广播地址（ifa_broadcast），并且不为255.255.255.255
	添加广播地址路由表项
	2.如果网段不为0，不是从属地址，掩码长度小于32
		1.如果是回环设备，添加到RT_TABLE_LOCAL
			否则添加到RT_MIN_TABLE
		2.如果掩码长度小于31，向RT_TABLE_LOCAL中添加两条
			路由表项
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1126</x>
      <y>456</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib_del_ifaddr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1132</x>
      <y>451</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1121</x>
      <y>463</y>
      <w>36</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.如果是主ip，通过
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1131</x>
      <y>459</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1079</x>
      <y>488</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib_magic</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1083</x>
      <y>484</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>989</x>
      <y>1129</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>896</x>
      <y>1168</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_route_input_mc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>901</x>
      <y>1160</y>
      <w>82</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>800.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>994</x>
      <y>1163</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_route_input_slow</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1001</x>
      <y>1160</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1118</x>
      <y>115</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_alloc_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1109</x>
      <y>123</y>
      <w>30</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.通过kmem_cache_alloc向sock_inode_cachep
	申请socket_alloc
2.初始化其中的socket
	init_waitqueue_head(&amp;ei-&gt;socket.wait);
	ei-&gt;socket.fasync_list = NULL;
	ei-&gt;socket.state = SS_UNCONNECTED;
	ei-&gt;socket.flags = 0;
	ei-&gt;socket.ops = NULL;
	ei-&gt;socket.sk = NULL;
	ei-&gt;socket.file = NULL;
3.返回其中的inode
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1124</x>
      <y>118</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1389</x>
      <y>0</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_socketcall</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1380</x>
      <y>7</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过copy_from_user从用户空间复制参数
注：nargs中记录socket调用中参数的个数
2.如果要求对参数审计，通过audit_socketcall
	建立audit_aux_data_socketcall数据结构，并将
	参数复制进去，挂入到current-&gt;audit_context链表中
3.通过参数call，调用响应的socket接口
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1394</x>
      <y>3</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1165</x>
      <y>28</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_socket</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1169</x>
      <y>16</y>
      <w>217</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_SOCKET</panel_attributes>
    <additional_attributes>2150.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1148</x>
      <y>35</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1176</x>
      <y>36</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_map_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1153</x>
      <y>31</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1171</x>
      <y>31</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1147</x>
      <y>41</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__sock_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1152</x>
      <y>38</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1137</x>
      <y>48</y>
      <w>34</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.family和type要在返回内
	0&lt;=family&lt;NPROTO
	0&lt;=type&lt;SOCK_MAX
2.如果是ipv4协议（PF_INET），传输类型是SOCK_PACKET
	就将协议转化成PF_PACKET
3.security_socket_create对创建socket做检查
4.通过sock_alloc申请socket和inode
	sock-&gt;type = type
5.如果net_families还没加载，通过request_module加载
6.获取net_families[family]，并递增pf-&gt;owner
	调用pf-&gt;create对sock初始化，并创建sk,inet
7.递增sock-&gt;ops-&gt;owner的计数
8.security_socket_post_create安全检查
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1152</x>
      <y>44</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>282</x>
      <y>297</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>257</x>
      <y>304</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>260</x>
      <y>300</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>270.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>273</x>
      <y>305</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>276</x>
      <y>300</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建cache
skbuff_head_cache
skbuff_fclone_cache</panel_attributes>
    <additional_attributes>110.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>288</x>
      <y>306</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_inodecache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>307</x>
      <y>307</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_filesystem</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>286</x>
      <y>300</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
初始化链表sock_fs_type.fs_supers
并将sock_fs_type挂入到链表file_systems中</panel_attributes>
    <additional_attributes>10.0;10.0;270.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>286</x>
      <y>300</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>327</x>
      <y>308</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kern_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>286</x>
      <y>300</y>
      <w>50</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>328</x>
      <y>316</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vfs_kern_mount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>332</x>
      <y>311</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>318</x>
      <y>323</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.mnt = alloc_vfsmnt(name)
2.type-&gt;get_sb(type, flags, name, data, mnt)
3.mnt-&gt;mnt_mountpoint = mnt-&gt;mnt_root;
	mnt-&gt;mnt_parent = mnt;
	return mnt;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>333</x>
      <y>319</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>321</x>
      <y>336</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>type-&gt;get_sb
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>326</x>
      <y>332</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>325</x>
      <y>339</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sock_fs_type</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>320</x>
      <y>343</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sockfs_get_sb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>324</x>
      <y>346</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sockfs_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>318</x>
      <y>350</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>get_sb_pseudo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1119</x>
      <y>94</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>new_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1125</x>
      <y>73</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1129</x>
      <y>70</y>
      <w>20</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1115</x>
      <y>80</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过new_inode申请inode和socket
2.通过SOCKET_I获取sock
3.初始化inode
	inode-&gt;i_mode = S_IFSOCK | S_IRWXUGO;
	inode-&gt;i_uid = current-&gt;fsuid;
	inode-&gt;i_gid = current-&gt;fsgid;

	get_cpu_var(sockets_in_use)++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1128</x>
      <y>76</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1124</x>
      <y>90</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1118</x>
      <y>101</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>alloc_inode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1123</x>
      <y>97</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1115</x>
      <y>108</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes> sb-&gt;s_op-&gt;alloc_inode
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1122</x>
      <y>104</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1122</x>
      <y>111</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sockfs_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1155</x>
      <y>81</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1155</x>
      <y>74</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pf-&gt;create
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1160</x>
      <y>70</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1160</x>
      <y>77</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_init
inet_family_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1147</x>
      <y>88</y>
      <w>34</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>1.sock-&gt;state = SS_UNCONNECTED;
2.查找inetsw链表，查找其中protocol不是IPPROTO_IP
	的inet_protosw（不能是RAW）
3.如果规定了capability，当前进程需要有answer-&gt;capability
4.sock-&gt;ops = answer-&gt;ops;//inet_init-&gt;inetsw_array中定义
	（inet_stream_ops，inet_dgram_ops，inet_sockraw_ops）
3.通过sk_alloc申请sk （tcp_prot，udp_prot）
	sk-&gt;sk_family = family
	sk-&gt;sk_prot = sk-&gt;sk_prot_creator = prot
注：申请的是tcp_sock，udp_sock，是inet_sock的子类
	inet_sock是sk的子类
4.初始化sk，inet
	sk-&gt;sk_no_check=answer-&gt;no_check
	inet-&gt;is_icsk //标志answer-&gt;flags中INET_PROTOSW_ICSK是否置上，标识面向连接
	inet-&gt;num = protocol //SOCK_RAW
	inet-&gt;hdrincl = 1 //IPPROTO_RAW，自己构建ip首部
	inet-&gt;pmtudisc
	inet-&gt;id = 0

	sock_init_data(sock, sk);

	sk-&gt;sk_destruct	   = inet_sock_destruct;
	sk-&gt;sk_family	   = PF_INET;
	sk-&gt;sk_protocol	   = protocol;
	sk-&gt;sk_backlog_rcv = sk-&gt;sk_prot-&gt;backlog_rcv;

	inet-&gt;uc_ttl	= -1;//单播ttl
	inet-&gt;mc_loop	= 1;//组播是否发向回路的标志
	inet-&gt;mc_ttl	= 1;//组播ttl
	inet-&gt;mc_index	= 0;//组播本地接口索引
	inet-&gt;mc_list	= NULL;//组播组链表
	atomic_inc(&amp;sk-&gt;sk_prot-&gt;socks)
5.sk-&gt;sk_prot-&gt;init
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1159</x>
      <y>84</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1156</x>
      <y>140</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;init
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1161</x>
      <y>136</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1156</x>
      <y>146</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_init_sock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1159</x>
      <y>143</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1147</x>
      <y>152</y>
      <w>32</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>tp-&gt;snd_cwnd = 2;//tcp_sock
sk-&gt;sk_state = TCP_CLOSE;
sk-&gt;sk_write_space = sk_stream_write_space;
sock_set_flag(sk, SOCK_USE_WRITE_QUEUE);

icsk-&gt;icsk_af_ops = &amp;ipv4_specific;
sk-&gt;sk_sndbuf = sysctl_tcp_wmem[1];
sk-&gt;sk_rcvbuf = sysctl_tcp_rmem[1];
atomic_inc(&amp;tcp_sockets_allocated);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1160</x>
      <y>149</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1173</x>
      <y>43</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.在sock_alloc_fd中利用get_unused_fd和
	get_empty_filp分别申请文件描述符fd和
	file结构
2.通过sock_attach_fd将sock和file关联，并
	初始化file
3.通过fd_install将file和fd关联
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1181</x>
      <y>39</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1181</x>
      <y>56</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_attach_fd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1186</x>
      <y>52</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1173</x>
      <y>63</y>
      <w>32</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>file-&gt;f_path.dentry = d_alloc(sock_mnt-&gt;mnt_sb-&gt;s_root
file-&gt;f_path.dentry-&gt;d_op = &amp;sockfs_dentry_operations
file-&gt;f_path.dentry-&gt;d_flags &amp;= ~DCACHE_UNHASHED;
d_instantiate(file-&gt;f_path.dentry, SOCK_INODE(sock));//dentry和inode关联
file-&gt;f_path.mnt = mntget(sock_mnt);
file-&gt;f_mapping = file-&gt;f_path.dentry-&gt;d_inode-&gt;i_mapping;
file-&gt;f_op = SOCK_INODE(sock)-&gt;i_fop = &amp;socket_file_ops;
file-&gt;f_mode = FMODE_READ | FMODE_WRITE;
file-&gt;f_flags = O_RDWR;
file-&gt;f_pos = 0;

sock-&gt;file = file;
file-&gt;private_data = sock;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1186</x>
      <y>59</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1247</x>
      <y>28</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_bind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1252</x>
      <y>16</y>
      <w>138</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_BIND</panel_attributes>
    <additional_attributes>1360.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1240</x>
      <y>35</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过sockfd_lookup_light利用fd找到sock
2.通过move_addr_to_kernel将地址移到内核栈中
3.move_addr_to_kernel对bind做安全检查
4.sock-&gt;ops-&gt;bind将sock和地址绑定
5.fput_light根据fput_needed看是否put file
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1252</x>
      <y>31</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1229</x>
      <y>49</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sockfd_lookup_light</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1235</x>
      <y>44</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1222</x>
      <y>56</y>
      <w>27</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.通过fget_light获取file
	1.如果只有一个进程使用files，
		就不用增加file的计数
		直接使用fcheck_files通过fd获取file
	2.否则，通过fcheck_files获取file之后，
		通过atomic_inc_not_zero增加file的计数，
		并表示之后file需要put（fput_needed）
2.通过sock_from_file利用file获取sock
	1.如果f_op是socket_file_ops，返回private_data
	2.否则通过file中的inode，利用SOCKET_I获取sock
		并将sock-&gt;file = file;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1232</x>
      <y>52</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1256</x>
      <y>48</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;bind
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1260</x>
      <y>44</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1261</x>
      <y>51</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops
inet_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1257</x>
      <y>56</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_bind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1257</x>
      <y>63</y>
      <w>38</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>1.如果sk-&gt;sk_prot-&gt;bind有定义，则直接采用其bind
	（目前只有RAW有）
2.传进的地址长度不能小于sockaddr_in
3.通过inet_addr_type确认ip地址的类型
4.如果sysctl_ip_nonlocal_bind没置上
	并且inet-&gt;freebind没置上
	并且绑定的ip地址不为0
	并且不是RTN_LOCAL，RTN_MULTICAST，RTN_BROADCAST中的任何一种
	就直接退出
5，获取端口号addr-&gt;sin_port
7.进程要有CAP_NET_BIND_SERVICE能力，才能绑定小于PROT_SOCK的端口
8.sk.sk_state要是TCP_CLOSE，并且inet.num（端口号）要不存在
9.inet-&gt;rcv_saddr = inet-&gt;saddr = addr-&gt;sin_addr.s_addr
10.如果是多播或者广播的ip
	inet-&gt;saddr = 0;
11.通过sk-&gt;sk_prot-&gt;get_port bind相应的port
12.设置本地端口，目的地址，目的端口，释放sk-&gt;sk_dst_cache
	inet-&gt;sport = htons(inet-&gt;num);
	inet-&gt;daddr = 0;
	inet-&gt;dport = 0;
	sk_dst_reset(sk);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1263</x>
      <y>59</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1216</x>
      <y>99</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_addr_type</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1221</x>
      <y>97</y>
      <w>42</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>400.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1202</x>
      <y>107</y>
      <w>35</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果是ZERONET或者BADCLASS，即为广播地址RTN_BROADCAST
2.如果是MULTICAST，即为多播地址
3.否则在ip_fib_local_table中搜索ip的类型
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1219</x>
      <y>102</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1275</x>
      <y>101</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;get_port
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1282</x>
      <y>97</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1237</x>
      <y>108</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_get_port</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1242</x>
      <y>104</y>
      <w>39</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1284</x>
      <y>104</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
udp_prot</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1279</x>
      <y>109</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_v4_get_port</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1216</x>
      <y>115</y>
      <w>39</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.如果port没指定（是0），遍历hash表hashinfo-&gt;bhash，如果
	该port没被使用(tb-&gt;port != rover),就选择，否则fail
2.如果指定了port，同样遍历hash表hashinfo-&gt;bhash，看是否能
	找到，如果没找到tb_not_found，否则找到了tb_found
3.tb_found，tb-&gt;owners要不是空，否则tb_not_found
	在以下情况下能绑定port
	1.sk-&gt;sk_reuse &gt; 1
	2.tb-&gt;fastreuse &gt; 0，并且sk_reuse存在，sk_state不是TCP_LISTEN
	3.否则通过bind_conflict查看是否核owner冲突
4.tb_not_found：
	1.如果没有tb，通过inet_bind_bucket_create申请tb
	2.如果tb-&gt;owners为空
		1.如果sk_reuse，并且不处于TCP_LISTEN
			tb-&gt;fastreuse = 1
		2.否则：tb-&gt;fastreuse = 0
	3.不为空，fastreuse存在，并且（sk_reuse为0，或者TCP_LISTEN）
		tb-&gt;fastreuse = 0
5.inet_bind_hash完成port注册
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1241</x>
      <y>111</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_hashinfo</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1229</x>
      <y>149</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_bind_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1234</x>
      <y>145</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1219</x>
      <y>156</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>inet_sk(sk)-&gt;num = snum;
 //sk(sk_bind_node)加入到owners链表
sk_add_bind_node(sk, &amp;tb-&gt;owners);
inet_csk(sk)-&gt;icsk_bind_hash = tb;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1234</x>
      <y>152</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1326</x>
      <y>16</y>
      <w>73</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_LISTEN</panel_attributes>
    <additional_attributes>710.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1322</x>
      <y>28</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_listen</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1313</x>
      <y>35</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过sockfd_lookup_light根据fd获取sock
2.backlog最大只能是sysctl_somaxconn
3.security_socket_listen安全检查
4.sock-&gt;ops-&gt;listen监听网络
5.fput_light根据fput_needed查看是否put file
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1327</x>
      <y>31</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1312</x>
      <y>49</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;listen
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1317</x>
      <y>44</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1312</x>
      <y>56</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_listen</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1314</x>
      <y>52</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops</panel_attributes>
    <additional_attributes>70.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1309</x>
      <y>63</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.sock.state要处于SS_UNCONNECTED或者SOCK_STREAM
	其中一个
2.sk-&gt;sk_state要处于TCPF_CLOSE或者TCPF_LISTEN
3.如果sk_state不处于TCP_LISTEN，利用inet_csk_listen_start
	监听网络
4.sk-&gt;sk_max_ack_backlog = backlog
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1318</x>
      <y>59</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1319</x>
      <y>76</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_csk_listen_start</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1325</x>
      <y>72</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1310</x>
      <y>83</y>
      <w>39</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.通过reqsk_queue_alloc为icsk-&gt;icsk_accept_queue
	申请listen_sock
2.初始化sk
	sk-&gt;sk_max_ack_backlog = 0;
	sk-&gt;sk_ack_backlog = 0;
	inet_csk_delack_init(sk);
3.sk-&gt;sk_state = TCP_LISTEN
4.通过sk-&gt;sk_prot-&gt;get_port申请port，如果成功（返回0）
	inet-&gt;sport = htons(inet-&gt;num);
	sk_dst_reset(sk);
	sk-&gt;sk_prot-&gt;hash(sk);
注：1.inet_connection_sock是tcp_sock的父类
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1325</x>
      <y>79</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1317</x>
      <y>110</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reqsk_queue_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1324</x>
      <y>104</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1308</x>
      <y>116</y>
      <w>32</w>
      <h>12</h>
    </coordinates>
    <panel_attributes> //listen_sock中有nr_table_entries个request_sock
lopt = __vmalloc
lopt-&gt;max_qlen_log //nr_table_entries的长度
lopt-&gt;hash_rnd
queue-&gt;rskq_accept_head = NULL;
lopt-&gt;nr_table_entries = nr_table_entries;
queue-&gt;listen_opt = lopt;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1319</x>
      <y>113</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1341</x>
      <y>110</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;hash
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1337</x>
      <y>104</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1326</x>
      <y>137</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果sk.sk_state处于TCP_LISTEN，并且传参中listen_possible
	置上，把sk.sk_node链接到hashinfo-&gt;listening_hash
2.否则链接进hashinfo-&gt;ehash.chain中
3.sock_prot_inc_use(sk-&gt;sk_prot);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1342</x>
      <y>117</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1346</x>
      <y>113</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1347</x>
      <y>120</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_hashinfo</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1342</x>
      <y>124</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1347</x>
      <y>127</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
!= TCP_CLOSE</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1342</x>
      <y>130</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__inet_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1344</x>
      <y>133</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1398</x>
      <y>16</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_ACCEPT</panel_attributes>
    <additional_attributes>80.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1394</x>
      <y>22</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_accept</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1384</x>
      <y>29</y>
      <w>36</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.通过sockfd_lookup_light利用fd找到sock
2.通过sock_alloc申请newsock，并初始化
	newsock-&gt;type = sock-&gt;type;
	newsock-&gt;ops = sock-&gt;ops;
	__module_get(newsock-&gt;ops-&gt;owner)
3.通过sock_alloc_fd申请fd和file，通过sock_attach_fd
	关联sock和file
4.security_socket_accept安全检查
5.sock-&gt;ops-&gt;accept等待接收client连接
6.如果用户要求返回client的地址（upeer_sockaddr）
	通过newsock-&gt;ops-&gt;getname获取地址，并通过
	move_addr_to_user复制到用户空间
7.通过fd_install将fd和file关联
8.security_socket_post_accept安全检查
9.fput_light根据fput_needed查看是否put file
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1398</x>
      <y>25</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1375</x>
      <y>59</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;accept
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1408</x>
      <y>60</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>newsock-&gt;ops-&gt;getname
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1380</x>
      <y>53</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1415</x>
      <y>53</y>
      <w>4</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1376</x>
      <y>66</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_accept</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1413</x>
      <y>67</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_getname</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1379</x>
      <y>62</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1416</x>
      <y>63</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1374</x>
      <y>73</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过sk1-&gt;sk_prot-&gt;accept接收client端
	的connect信息，并获取新的server sk2
2.通过sock_graft将sk2和newsock关联
3.newsock-&gt;state = SS_CONNECTED
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1381</x>
      <y>69</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1376</x>
      <y>93</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_csk_accept</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1375</x>
      <y>85</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk1-&gt;sk_prot-&gt;accept
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1381</x>
      <y>80</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1380</x>
      <y>88</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1392</x>
      <y>84</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_graft</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1396</x>
      <y>80</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1389</x>
      <y>90</y>
      <w>21</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.关联sk和newsock
	sk-&gt;sk_sleep = &amp;parent-&gt;wait;
	parent-&gt;sk = sk;
	sk-&gt;sk_socket = parent;
2.security_sock_graft安全检查
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1397</x>
      <y>87</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1380</x>
      <y>102</y>
      <w>36</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.sk-&gt;sk_state要是TCP_LISTEN
2.如果icsk-&gt;icsk_accept_queue的
	rskq_accept_head为空
	1.根据O_NONBLOCK标志定义sk的等待时间timeo
	2.如果timeout，返回EAGAIN
	3.通过inet_csk_wait_for_connect等待
		client连接
3.如果接收到client端连接，通过reqsk_queue_get_child
	获取新的serve sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1382</x>
      <y>96</y>
      <w>6</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1376</x>
      <y>122</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_csk_wait_for_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1414</x>
      <y>123</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reqsk_queue_get_child</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1382</x>
      <y>116</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1397</x>
      <y>116</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1413</x>
      <y>128</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过reqsk_queue_remove从rskq_accept_head
	链表中获取req（通过dl_next连接）
2.通过sk_acceptq_removed递减sk-&gt;sk_ack_backlog
3.通过__reqsk_free释放req
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1422</x>
      <y>126</y>
      <w>3</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1382</x>
      <y>128</y>
      <w>30</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.申明wait（定义private为current）
2.死循环
	1.通过prepare_to_wait_exclusive将wait挂入到链表
		sk-&gt;sk_sleep，并设置进程的状态为TASK_INTERRUPTIBLE
	2.通过reqsk_queue_empty检查rskq_accept_head
		还是空，就通过schedule_timeout调度进程
	3.醒来之后：
		1.检查rskq_accept_head不为空，退出循环
		2.如果还是为空
			1.如果sk的状态不在TCP_LISTEN，返回EINVAL
			2.如果signal_pending，返回EINVAL
			3.如果timeout，返回EAGAIN
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1386</x>
      <y>125</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1411</x>
      <y>74</y>
      <w>32</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.sin-&gt;sin_family = AF_INET
2.如果设置了peer
	1.dport要存在
	2.在peer为1时，sk_state不能为TCPF_CLOSE，TCPF_SYN_SENT
	3.sin-&gt;sin_port = inet-&gt;dport;
		sin-&gt;sin_addr.s_addr = inet-&gt;daddr;
3.如果没设置peer
	1.sin-&gt;sin_addr.s_addr //rcv_saddr存在即为rcv_saddr
								//否则为saddr
	2.sin-&gt;sin_port = inet-&gt;sport;
4.清0 pad （sin-&gt;sin_zero）
5.*uaddr_len = sizeof(*sin)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1419</x>
      <y>70</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1408</x>
      <y>16</y>
      <w>72</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_CONNECT</panel_attributes>
    <additional_attributes>10.0;10.0;700.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1471</x>
      <y>27</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1459</x>
      <y>33</y>
      <w>34</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过sockfd_lookup_light根据fd找到sock
2.move_addr_to_kernel将connect的地址移至内核中
3.security_socket_connect安全检查
4.sock-&gt;ops-&gt;connect连接serve
5.fput_light根据fput_needed put file
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1476</x>
      <y>30</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1463</x>
      <y>53</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_stream_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1470</x>
      <y>46</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;connect
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1475</x>
      <y>42</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1469</x>
      <y>49</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops</panel_attributes>
    <additional_attributes>70.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1477</x>
      <y>49</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1485</x>
      <y>52</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_dgram_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1459</x>
      <y>60</y>
      <w>29</w>
      <h>46</h>
    </coordinates>
    <panel_attributes>1.如果connect的是AF_UNSPEC，通过
	sk-&gt;sk_prot-&gt;disconnect并根据结果置
	sock-&gt;state，直接返回
2.查看sock-&gt;state的状态
	1.SS_CONNECTED，返回EISCONN
	2.SS_CONNECTING，跳到3
	3.SS_UNCONNECTED
		1.不能是TCP_CLOSE，否则返回EISCONN
		2.利用sk-&gt;sk_prot-&gt;connect
		3.sock-&gt;state = SS_CONNECTING
		4.EINPROGRESS，跳到3
3.根据O_NONBLOCK，确定timeout时间
4.如果sk_state中TCPF_SYN_SENT或者
	TCPF_SYN_RECV置上
	1.如果timeout为0，直接返回
	2.如果不为0，通过inet_wait_for_connect等待
	TCPF_SYN_SENT或者TCPF_SYN_RECV
	被清掉
	3.根据还剩timeout的时间确定醒来过后，
		是否重进
	4.如果是signalpending，直接返回
5.如果sk_state是TCP_CLOSE，根据sk_err
	置返回值，并且：
	sock-&gt;state = SS_UNCONNECTED;
	if (sk-&gt;sk_prot-&gt;disconnect(sk, flags))
		sock-&gt;state = SS_DISCONNECTING;
6.sock-&gt;state = SS_CONNECTED;
	err = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1470</x>
      <y>56</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1442</x>
      <y>109</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;disconnect
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1463</x>
      <y>109</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;connect
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1494</x>
      <y>110</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_wait_for_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1450</x>
      <y>105</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1467</x>
      <y>105</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1477</x>
      <y>105</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1471</x>
      <y>112</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1470</x>
      <y>116</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1463</x>
      <y>122</y>
      <w>28</w>
      <h>51</h>
    </coordinates>
    <panel_attributes>1.地址长度不能小于sockaddr_in
2.sin_family要是ipv4（AF_INET）
3.设置nexthop和daddr
4.通过ip_route_connect寻找路由缓存项
5.路由缓存项不能是多播或者广播
6.如果没启用源路由选项（net-&gt;opt-&gt;srr）
	daddr = rt-&gt;rt_dst
7.如果没设置源地址inet-&gt;saddr
	inet-&gt;saddr = rt-&gt;rt_src
8.inet-&gt;rcv_saddr = inet-&gt;saddr
9.如果时间戳和目的地址被用过(不清楚为什么？)，初始化相关成员
	tp-&gt;rx_opt.ts_recent	   = 0;
	tp-&gt;rx_opt.ts_recent_stamp = 0;
	tp-&gt;write_seq		   = 0;
10.如果启用了sysctl_tw_recycle，并且从对方收到
	时间戳，利用对方的时间戳来初始化tp-&gt;rx_opt.ts_recent_stamp
	和tp-&gt;rx_opt.ts_recent
11.设置目的端口，目的地址，ip选项长度，对端mss上线
	inet-&gt;dport = usin-&gt;sin_port;
	inet-&gt;daddr = daddr;
	inet_csk(sk)-&gt;icsk_ext_hdr_len = inet-&gt;opt-&gt;optlen;
	tp-&gt;rx_opt.mss_clamp = 536
12.tcp_set_state将sk设置为TCP_SYN_SENT
13.inet_hash_connect指定端口号
14.如果源，目的端口发生了变化通过ip_route_newports查找
15.sk-&gt;sk_gso_type = SKB_GSO_TCPV4;
	sk_setup_caps(sk, &amp;rt-&gt;u.dst);
16.如果tp-&gt;write_seq为0，通过secure_tcp_sequence_number
	为其构造初始序号，并设置id
	inet-&gt;id = tp-&gt;write_seq ^ jiffies;
17.通过tcp_connect构造并发送syn
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1475</x>
      <y>119</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1494</x>
      <y>117</y>
      <w>28</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.申明wait（有private）
2.通过prepare_to_wait将wait挂入到
	sk-&gt;sk_sleep，并且将进程的状态设置
	成TASK_INTERRUPTIBLE（因为private）
3.如果sk_state的TCPF_SYN_SENT或者
	TCPF_SYN_RECV存在
	1.通过schedule_timeout调度进程
	2.醒来之后，如果因为signal_pending或者
		timeout，退出循环
	3.如果不是，则通过prepare_to_wait继续
		挂入到sk-&gt;sk_sleep，继续循环
4.将task状态设置为TASK_RUNNING，如果
	wait.task_list不为空，通过list_del_init
	将wait删除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1502</x>
      <y>113</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1528</x>
      <y>1299</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_do_rcv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1513</x>
      <y>1306</y>
      <w>42</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.如果sk_state在TCP_ESTABLISHED，通过tcp_rcv_established
	接收正常报文
2.skb的长度不能小于tcp首部的长度（skb-&gt;h.th-&gt;doff）
	并且tcp_checksum_complete检查checksum通过
3.如果sk_state处在TCP_LISTEN状态，通过tcp_v4_hnd_req
	接收ack，如果接收的nsk和sk不一致，链接建立成功
	通过tcp_child_process初始化子sk
4.否则通过tcp_rcv_state_process处理，如果返回1，则会通过
	tcp_v4_send_reset向对方发送一个rst
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1534</x>
      <y>1302</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1369</x>
      <y>1350</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_rcv_established</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1537</x>
      <y>1326</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_hnd_req</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1605</x>
      <y>1327</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_child_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1733</x>
      <y>1327</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_rcv_state_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1376</x>
      <y>1320</y>
      <w>153</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1510.0;10.0;550.0;280.0;10.0;300.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1526</x>
      <y>1320</y>
      <w>21</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1529</x>
      <y>1320</y>
      <w>84</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;820.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1547</x>
      <y>1320</y>
      <w>195</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
返回1，reset</panel_attributes>
    <additional_attributes>10.0;10.0;1930.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1671</x>
      <y>1330</y>
      <w>70</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TCP_LISTEN</panel_attributes>
    <additional_attributes>680.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1661</x>
      <y>1338</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果是ack，返回1
2.如果是rst，将skb丢弃并返回
3.如果是syn，通过icsk-&gt;icsk_af_ops-&gt;conn_request
	接收
	1.如果失败，返回1
	2，如果成功，释放skb，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1666</x>
      <y>1350</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>icsk-&gt;icsk_af_ops-&gt;conn_request
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1674</x>
      <y>1347</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1675</x>
      <y>1353</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ipv4_specific</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1667</x>
      <y>1357</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_conn_request</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1656</x>
      <y>1364</y>
      <w>40</w>
      <h>78</h>
    </coordinates>
    <panel_attributes>1.如果skb的目的地址是广播或者组播（RTCF_BROADCAST |
	RTCF_MULTICAST）,返回0
2.如果通过inet_csk_reqsk_queue_is_full检查接收队列满
	并且TCP_SKB_CB(skb)-&gt;when为0（总成立），如果启用
	cookies（sysctl_tcp_syncookies），设置want_cookie
	否则直接返回
注：listen_opt-&gt;qlen 左移max_qlen_log位后，还有值，说明
	queue_is_full
3.如果接收请求sk_ack_backlog超过了sk_max_ack_backlog，并且
	只要有一个握手过程没有重传（listen_opt-&gt;qlen_young＞１）
	直接返回
(４).通过reqsk_alloc向tcp_request_sock_ops中的slab申请req
	并且req-&gt;rsk_ops = tcp_request_sock_ops
５.清除tcp选项tmp_opt，并设置初始值
	tmp_opt.mss_clamp = 536;
	tmp_opt.user_mss  = tcp_sk(sk)-&gt;rx_opt.user_mss;
	最后通过tcp_parse_options解析tcp头部选项
6.如果want_cookie，清除已解析的tcp选项
7.如果标识收到了时间戳（saw_tstamp），但是收到的时间戳（rcv_tsval）为0
		tmp_opt.saw_tstamp = 0;
		tmp_opt.tstamp_ok  = 0;
（8）.tcp_openreq_init根据tmp_opt初始化req
	req-&gt;rcv_wnd = 0;		/* So that tcp_send_synack() knows! */
	tcp_rsk(req)-&gt;rcv_isn = TCP_SKB_CB(skb)-&gt;seq; //接收序列号
	req-&gt;mss = rx_opt-&gt;mss_clamp;
	req-&gt;ts_recent = rx_opt-&gt;saw_tstamp ? rx_opt-&gt;rcv_tsval : 0;
	ireq-&gt;tstamp_ok = rx_opt-&gt;tstamp_ok;
	ireq-&gt;sack_ok = rx_opt-&gt;sack_ok;
	ireq-&gt;snd_wscale = rx_opt-&gt;snd_wscale;//发送方的滑动窗口扩大因子
	ireq-&gt;wscale_ok = rx_opt-&gt;wscale_ok; //是否支持滑动窗口扩大
	ireq-&gt;acked = 0;
	ireq-&gt;ecn_ok = 0;
	ireq-&gt;rmt_port = skb-&gt;h.th-&gt;source; //源地址
（9）.ireq-&gt;loc_addr = daddr;
	ireq-&gt;rmt_addr = saddr;
	ireq-&gt;opt = tcp_v4_save_options(sk, skb);//复制ip 选项
10.如果不需要want_cookie，通过TCP_ECN_create_request看是否
	打开拥塞通知
	inet_rsk(req)-&gt;ecn_ok = 1
10.如果want_cookie
		1.通过syn_flood_warning每60s报告可能收到synflood攻击
		2.同时通过cookie_v4_init_sequence生成服务端的初始序列号isn
	否则，如果没有isn
		1.检查PAWS
		2.如果受到synflood攻击，丢弃
		3.通过tcp_v4_init_sequence得到isn
（11）.tcp_rsk(req)-&gt;snt_isn = isn; //发送序列号
（12）.通过tcp_v4_send_synack发送syn+ack给client
（13）.如果want_cookie，根据序列号确定三次握手，不需要req
	否则通过inet_csk_reqsk_queue_hash_add将其挂入hash表
	listen_sock.syn_table中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1673</x>
      <y>1360</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
创建req加入到listern_sock的hash中</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1680</x>
      <y>1445</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_csk_reqsk_queue_hash_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1683</x>
      <y>1441</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1675</x>
      <y>1453</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reqsk_queue_hash_req</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1701</x>
      <y>1453</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_csk_reqsk_queue_added</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1683</x>
      <y>1448</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1696</x>
      <y>1448</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1671</x>
      <y>1460</y>
      <w>22</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>req-&gt;expires = jiffies + timeout;
req-&gt;retrans = 0;
req-&gt;sk = NULL;
 //链入hash表
req-&gt;dl_next = lopt-&gt;syn_table[hash]
lopt-&gt;syn_table[hash] = req
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1683</x>
      <y>1456</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1697</x>
      <y>1460</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过reqsk_queue_added递增
	lopt-&gt;qlen_young++;
	lopt-&gt;qlen++;
2.如果之前qlen是0，inet_csk_reset_keepalive_timer
	设置连接超时时间，如果timer被修改，需要sock_hold
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1710</x>
      <y>1456</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1651</x>
      <y>1446</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_send_synack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1658</x>
      <y>1441</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1629</x>
      <y>1441</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1621</x>
      <y>1446</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_csk_route_req</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1641</x>
      <y>1453</y>
      <w>28</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果dst不存在，通过inet_csk_route_req查找到req的路由
2.通过tcp_make_synack构建syn +ack 的skb
3.通过tcp_v4_check生成tcp checksum
4.通过ip_build_and_send_pkt生成ip数据报
	并发送
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1654</x>
      <y>1449</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1633</x>
      <y>1465</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_make_synack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1652</x>
      <y>1465</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_build_and_send_pkt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1640</x>
      <y>1461</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1652</x>
      <y>1461</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1613</x>
      <y>1472</y>
      <w>39</w>
      <h>55</h>
    </coordinates>
    <panel_attributes>1.通过sock_wmalloc强制（传参为1）申请skb
注：强制申请是指：即使sk申请skb（sk_wmem_alloc）
	超过了sk_sndbuf也申请
2.通过skb_reserve预留MAX_TCP_HEADER空间（tcp，ip，mac）
3.设置skb发送的路由
	skb-&gt;dst = dst_clone(dst)
4.计算tcp首部的长度，选项包括mss，时间戳，窗口
	扩大因子，sack（选择应答）
5.初始化tcp首部
	skb-&gt;h.th = th = (struct tcphdr *) skb_push(skb, tcp_header_size)
	memset(th, 0, sizeof(struct tcphdr));
	th-&gt;syn = 1;
	th-&gt;ack = 1;
	TCP_ECN_make_synack(req, th);
	th-&gt;source = inet_sk(sk)-&gt;sport;  //源端口号
	th-&gt;dest = ireq-&gt;rmt_port;	//目的端口
	TCP_SKB_CB(skb)-&gt;seq = tcp_rsk(req)-&gt;snt_isn;
	TCP_SKB_CB(skb)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;seq + 1;
	TCP_SKB_CB(skb)-&gt;sacked = 0;
	skb_shinfo(skb)-&gt;gso_segs = 1;
	skb_shinfo(skb)-&gt;gso_size = 0;
	skb_shinfo(skb)-&gt;gso_type = 0;
	th-&gt;seq = htonl(TCP_SKB_CB(skb)-&gt;seq);//发送序列号
	th-&gt;ack_seq = htonl(tcp_rsk(req)-&gt;rcv_isn + 1);//回应序列号=接收序列号+1
6.如果接收rcv_wnd为0，通过tcp_select_initial_window
	设置合适的值
	th-&gt;window = htons(req-&gt;rcv_wnd)
7.设置发送时间， 及选项
	TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;
	tcp_syn_build_options
8.初始化checksum，并生成首部长度
	skb-&gt;csum = 0;
	th-&gt;doff = (tcp_header_size &gt;&gt; 2);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1636</x>
      <y>1468</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1531</x>
      <y>1333</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过inet_csk_search_req在listen_sock
	的syn_table表中查找对应的req
2.如果找到，通过tcp_check_req检查是否是ack
	如果是，则链接建立
3.否则通过inet_lookup_established在ehash中
	查找inet_sk或者inet_twsk中目的地址和目的端口
	相同的项
4.如果找到了，
	1.其状态不在TCP_TIME_WAIT，返回nsk
	2.否则返回null
5.如果还没找到，如果cookies打开，rst，syn都没置上
	ack置上，通过cookie_v4_check检查其序列号是否
	满足计算出来的hash
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1543</x>
      <y>1329</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1524</x>
      <y>1345</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_csk_search_req</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1509</x>
      <y>1351</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.遍历hash表lopt-&gt;syn_table，找到
	目的地址，端口，原地址，family（ipv4）
	相同的req返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1531</x>
      <y>1342</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1525</x>
      <y>1348</y>
      <w>8</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1545</x>
      <y>1345</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_check_req</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1549</x>
      <y>1342</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1539</x>
      <y>1351</y>
      <w>41</w>
      <h>63</h>
    </coordinates>
    <panel_attributes>1.如果有tcp首部选项（doff&gt;tcphdr）
	通过tcp_parse_options解析选项
	如果接收到时间戳（saw_tstamp），通过
	tcp_paws_check检查接收paws（序列号不能
	回环，通过时间戳检查）
2.如果接收到的是重复的syn（序列号和上次相同），
	并且paws检查通过，重发syn+ack
	req-&gt;rsk_ops-&gt;rtx_syn_ack
3.如果是ack，但是序列号不是发送序列号(snt_isn) + 1
	就直接返回sk（表示ack失败）
4.如果paws检查没通过，并且不在tcp_in_window中
	1.如果rst没置上，通过req-&gt;rsk_ops-&gt;send_ack
		发送ack
	2.如果是paws没通过，增加net_statistics[]计数
	3.返回NULL
5.如果收到时间戳（saw_tstamp），并且收到的序列号不大于
	之前收到的（注意：这里paws通过了）
	req-&gt;ts_recent = tmp_opt.rcv_tsval
6.如果收到的序列号和之前的相同
	flg &amp;= ~TCP_FLAG_SYN
7.如果收到了syn或者rst
	1.如果rst没置上，那么通过req-&gt;rsk_ops-&gt;send_reset
		复位另一端
	注：之前已经收到了syn，这里再次收到发送rst
	2.通过inet_csk_reqsk_queue_drop将req从hash表中删除
		如果此时listen_sock并递减qlen_young，qlen，如果减至0
		删除sk.timer,最后释放req
8.如果ack没置上，直接返回NULL

注：这里收到正确的ack
9.如果TCP_DEFER_ACCEPT（rskq_defer_accept)时
	end_seq如果等于rcv_isn + 1，表示正确接受ack
	inet_rsk(req)-&gt;acked = 1
	return NULL
注：TCP_DEFER_ACCEPT表示无需接收ack，req直接进入accept队列
10.通过inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock获取sk
11.如果child没找到，返回NULL(可能置ack)
	如果找到了，通过inet_csk_reqsk_queue_unlink和
	inet_csk_reqsk_queue_removed将其从hash中删除
	并通过inet_csk_reqsk_queue_add加入到链表icsk_accept_queue中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1550</x>
      <y>1348</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
将req从hash移到icsk_accept_queue</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1494</x>
      <y>1424</y>
      <w>24</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.接收的时间戳（rcv_tsval），要大于上次
	接收的时间戳ts_recent
注：ts_recent：接收到上次ack中对应的序号的包中的时间戳
2.如果当前时间（xtime.tv_sec）超过记录时间
	戳 24天
注：timestamps按1ms加1,2^31 就是24.85天
3.如果要求复位（rst），当前时间要超过记录时间的
	TCP_PAWS_MSL
4.上述情况paws都通过，否则不通过
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1501</x>
      <y>1418</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_paws_check</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1505</x>
      <y>1421</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1505</x>
      <y>1413</y>
      <w>41</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1555</x>
      <y>1420</y>
      <w>29</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1557</x>
      <y>1413</y>
      <w>15</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1570</x>
      <y>1427</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_syn_recv_sock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1568</x>
      <y>1423</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ipv4_specific</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1567</x>
      <y>1434</y>
      <w>29</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.通过sk_acceptq_is_full检查sk_ack_backlog
	是否到达了限制，如果超过了，直接返回NULL
2.如果dst不存在，通过inet_csk_route_req寻找路由
3.通过tcp_create_openreq_child复制sk，并初始化
	newinet-&gt;daddr	      = ireq-&gt;rmt_addr;
	newinet-&gt;rcv_saddr    = ireq-&gt;loc_addr;
	newinet-&gt;saddr	      = ireq-&gt;loc_addr;
	newinet-&gt;opt	      = ireq-&gt;opt;
	newinet-&gt;mc_index     = inet_iif(skb);
	newinet-&gt;mc_ttl	      = skb-&gt;nh.iph-&gt;ttl;
	//设置mtu，mss
	tcp_mtup_init(newsk);
	tcp_sync_mss(newsk, dst_mtu(dst));
	newtp-&gt;advmss = dst_metric(dst, RTAX_ADVMSS);
	tcp_initialize_rcv_mss(newsk);
4.__inet_hash将nsk链入到ehash中（因为状态是TCP_SYN_RECV），
	__inet_inherit_port将其链入icsk_bind_hash中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1579</x>
      <y>1466</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_create_openreq_child</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1573</x>
      <y>1473</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过inet_csk_clone复制sk
2.初始化
	newtp = tcp_sk(newsk);
	newtp-&gt;pred_flags = 0;
	newtp-&gt;rcv_nxt = treq-&gt;rcv_isn + 1;
	newtp-&gt;snd_nxt = newtp-&gt;snd_una = newtp-&gt;snd_sml = treq-&gt;snt_isn + 1;
	newtp-&gt;snd_cwnd = 2;
	newtp-&gt;snd_cwnd_cnt = 0;
	newicsk-&gt;icsk_ca_ops = &amp;tcp_init_congestion_ops
	newtp-&gt;rcv_wup = treq-&gt;rcv_isn + 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1586</x>
      <y>1469</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1571</x>
      <y>1486</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_csk_clone</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1576</x>
      <y>1482</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1562</x>
      <y>1493</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过sk_clone复制sk，并初始化
2.newsk-&gt;sk_state = TCP_SYN_RECV;
	inet_sk(newsk)-&gt;dport = inet_rsk(req)-&gt;rmt_port;
	newsk-&gt;sk_write_space = sk_stream_write_space;
	newicsk-&gt;icsk_retransmits = 0;
	newicsk-&gt;icsk_backoff	  = 0;
	newicsk-&gt;icsk_probes_out  = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1575</x>
      <y>1489</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1576</x>
      <y>1506</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_clone</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1580</x>
      <y>1502</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1568</x>
      <y>1512</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过sk_alloc申请nsk
2.通过sock_copy将sk中的数据复制到nsk
	并初始化nsk
	atomic_set(&amp;newsk-&gt;sk_refcnt, 2);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1578</x>
      <y>1509</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1568</x>
      <y>1522</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1572</x>
      <y>1519</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1560</x>
      <y>1529</y>
      <w>26</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果定义了prot-&gt;slab，通过kmem_cache_alloc
	申请sock的空间（这里是tcp_sock），
	否则通过kmalloc申请prot-&gt;obj_size的空间
2.如果定义了zero_it
	memset(sk, 0, prot-&gt;obj_size);
	sk-&gt;sk_family = family;
	sk-&gt;sk_prot = sk-&gt;sk_prot_creator = prot;
	sock_lock_init(sk);
3.通过security_sk_alloc安全检查
4.通过try_module_get递增prot-&gt;owner
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1571</x>
      <y>1525</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1576</x>
      <y>1430</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1587</x>
      <y>1462</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1531</x>
      <y>1419</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>req-&gt;rsk_ops-&gt;rtx_syn_ack
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1538</x>
      <y>1413</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1531</x>
      <y>1426</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_send_synack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1538</x>
      <y>1422</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_request_sock_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1976</x>
      <y>1314</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_send_ack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1981</x>
      <y>1310</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1969</x>
      <y>1321</y>
      <w>36</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>1.清零tcp头
	memset(&amp;rep.th, 0, sizeof(struct tcphdr));
	memset(&amp;arg, 0, sizeof(arg));
	arg.iov[0].iov_base = (unsigned char *)&amp;rep;
	arg.iov[0].iov_len  = sizeof(rep.th);
2.如果之前收到时间戳(ts)
	rep.opt[0] = htonl((TCPOPT_NOP &lt;&lt; 24) | (TCPOPT_NOP &lt;&lt; 16) |
				   (TCPOPT_TIMESTAMP &lt;&lt; 8) |
				   TCPOLEN_TIMESTAMP);
		rep.opt[1] = htonl(tcp_time_stamp);
		rep.opt[2] = htonl(ts);
		arg.iov[0].iov_len += TCPOLEN_TSTAMP_ALIGNED;
注：nop + nop + kind=8 + len=10 + jiffies + ts_recent
3.填充tcp头
	rep.th.dest    = th-&gt;source;
	rep.th.source  = th-&gt;dest;
	rep.th.doff    = arg.iov[0].iov_len / 4;
	rep.th.seq     = htonl(seq);
	rep.th.ack_seq = htonl(ack);
	rep.th.ack     = 1;
	rep.th.window  = htons(win);
4.计算tcp伪头部的checksum
	arg.csum = csum_tcpudp_nofold
	arg.csumoffset = offsetof(struct tcphdr, check) / 2;
5.通过ip_send_reply发送ack报文
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1982</x>
      <y>1317</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1594</x>
      <y>1419</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>req-&gt;rsk_ops-&gt;send_reset
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1595</x>
      <y>1426</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_send_reset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1602</x>
      <y>1422</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_request_sock_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1576</x>
      <y>1413</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1590</x>
      <y>1333</y>
      <w>38</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果没被用户进程占用!sock_owned_by_user（通过inode
	引用），通过tcp_rcv_state_process处理nsk，如果nsk的
	状态从TCP_SYN_RECV变到其他状态，通过parent-&gt;sk_data_ready
	去接收
2.否则通过sk_add_backlog将skb加入到sk_backlog尾端
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1609</x>
      <y>1330</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1790</x>
      <y>1357</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_replace_ts_recent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1796</x>
      <y>1352</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1782</x>
      <y>1364</y>
      <w>29</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.如果有时间戳(saw_tstamp),如果seq不超过
	rcv_wup（预期下一个收到的seq）
	收到的时间戳（rcv_tsval）超过了ts_recent
	或者本地时间(xtime.tv_sec)超过了24天
2.如果满足了上述条件，通过tcp_store_ts_recent
	更新tsrecent:
	tp-&gt;rx_opt.ts_recent = tp-&gt;rx_opt.rcv_tsval;
	tp-&gt;rx_opt.ts_recent_stamp = xtime.tv_sec;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1797</x>
      <y>1360</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1826</x>
      <y>1412</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_ack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1829</x>
      <y>1407</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1820</x>
      <y>1419</y>
      <w>39</w>
      <h>60</h>
    </coordinates>
    <panel_attributes>1.应答的序号ack不能超过snd_nxt
2.收到的ack如果小于snd_una（之前已经收到的ack）
	跳到old_ack
3.如果存在sysctl_tcp_abc，表示需要abc
	1.如果小于TCP_CA_CWR，增加字节数为回应的字节数
		tp-&gt;bytes_acked += ack - prior_snd_una;
	2.如果处于TCP_CA_Loss
		tp-&gt;bytes_acked += min(ack - prior_snd_una, tp-&gt;mss_cache);
注：abc(Appropriate Byte Counting),表示不再是通过
	ack的次数递增拥塞窗口，而是通过ack的字节数来增加，
	详情查看https://switch-router.gitee.io/blog/tcp-abc/
	
4.如果快启动（!FLAG_SLOWPATH）,并且
	应答序号在窗口左边界(snd_una)之后
	tp-&gt;snd_wl1 =ack_seq//记录造成窗口更新的ack序号
	tp-&gt;snd_una = ack;//更新左窗口
	flag |= FLAG_WIN_UPDATE;
	tcp_ca_event//通知CA_EVENT_FAST_ACK
5.如果是慢路径
	1.如果seq和ack_seq不同，表示有数据
		flag |= FLAG_DATA
	2.通过tcp_ack_update_window进行窗口更新
	3.如果是选择性应答sacked,通过tcp_sacktag_write_queue
		标记重传队列
	4.通过TCP_ECN_rcv_ecn_echo查看是否设置了ece（拥塞）标志
		flag |= FLAG_ECE
	5.tcp_ca_event//通知CA_EVENT_SLOW_ACK
6.清除err_soft和设置时间戳
	sk-&gt;sk_err_soft = 0;
	tp-&gt;rcv_tstamp = tcp_time_stamp;
7.如果没有待ack的数据(!tp-&gt;packets_out)，跳到no_queue
8.tcp_packets_in_flight获取正在网络上传输的包数量prior_in_flight
9.通过tcp_clean_rtx_queue删除已经确认的段
10.如果需要frto算法(frto_counter)，通过tcp_process_frto处理
11.如果ack存疑(tcp_ack_is_dubious)
	1.如果有FLAG_DATA_ACKED，并且检测需要调整拥塞窗口(tcp_may_raise_cwnd)，通过tcp_cong_avoid调整
	2.通过tcp_fastretrans_alert迁移拥塞状态
12.否则，在FLAG_DATA_ACKED时，通过tcp_cong_avoid调整拥塞窗口
13，如果有数据被ack或sack，并且sack重复，通过dst_confirm确认输出右路是有效的
14.no_queue：
	1.icsk-&gt;icsk_probes_out = 0
	2.如果没有要发送的包，通过tcp_ack_probe探测
15.old_ack：
	如果又被sacked的包，通过tcp_sacktag_write_queue处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1830</x>
      <y>1415</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1802</x>
      <y>1485</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_ack_update_window</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1813</x>
      <y>1478</y>
      <w>19</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1793</x>
      <y>1491</y>
      <w>31</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.获取tcp头部的窗口nwin
2.如果不是syn，利用选项中的扩大因子snd_wscale
	将nwin扩大
3.tcp_may_update_window检查是否应该更新窗口
	如果需要更新窗口：
	1.flag |= FLAG_WIN_UPDATE;
		tp-&gt;snd_wl1 =ack_seq
	2.如果窗口的右边界更新：
		tp-&gt;snd_wnd = nwin
		//设置pred_flags
		tp-&gt;pred_flags = 0;
		tcp_fast_path_check(sk, tp);
		//如果到达了最大窗口
		tp-&gt;max_window = nwin;
		//mss和mtu和win有关，当win更新时，需要更新mss
		tcp_sync_mss(sk, inet_csk(sk)-&gt;icsk_pmtu_cookie);
4.更新窗口左边界
	tp-&gt;snd_una = ack
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1808</x>
      <y>1488</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1774</x>
      <y>1523</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_may_update_window</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1783</x>
      <y>1520</y>
      <w>15</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1761</x>
      <y>1530</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果窗口的左边界更新（ack&gt;snd_una或者
	应答序号ack_seq超过了之前窗口更新记录的snd_wl1）
2.窗口的右边界更新（ack_seq == tp-&gt;snd_wl1 &amp;&amp; nwin &gt; tp-&gt;snd_wnd）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1774</x>
      <y>1526</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1599</x>
      <y>1345</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>parent-&gt;sk_data_ready
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1605</x>
      <y>1341</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1609</x>
      <y>1348</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sock_init_data</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1605</x>
      <y>1352</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_def_readable</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1602</x>
      <y>1359</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.唤醒sk-&gt;sk_sleep和sk-&gt;sk_socket-&gt;fasync_list
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1611</x>
      <y>1355</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1404</x>
      <y>176</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_hash_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1410</x>
      <y>172</y>
      <w>66</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>640.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1392</x>
      <y>182</y>
      <w>32</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>1.如果没指定端口号（!inet_sk(sk)-&gt;num）
	1.通过inet_sk_port_offset选定一个offset开始遍历
	hash表hashinfo.bhash
	2.查找hash表中是否有相同port的tb，如果有：
		1.tb-&gt;fastreuse检查是否能被复用
		2.__inet_check_established检查是否是动态绑定的端口
		在time_wait的时候被复用
		3.如果经过上述检查能被复用，转到1.4
		4.否则遍历下一个port
	3.如果hash表中没有相同的port，通过inet_bind_bucket_create创建
		并转向1.4
	4.ok
		1.更新遍历port的偏移量hint
		2.通过inet_bind_hash将sk和port关联，并挂入hash中
		3.如果sk.sk_node还没链入到hash表中（sk_unhashed）
			inet_sk(sk)-&gt;sport = htons(port);
			__inet_hash(hinfo, sk, 0);//根据sk的状态链入到hash表中
		4.如果是复用time_wait(tw)的port，需要将其套接口删除
			inet_twsk_deschedule(tw, death_row);
 			inet_twsk_put(tw);
2.如果指定了端口
	1.如果sk是tb.owner中的唯一一个，通过__inet_hash将其挂入到
		hashinfo中
	2.否则通过__inet_check_established检查
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1408</x>
      <y>179</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_death_row</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1427</x>
      <y>226</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_bind_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1419</x>
      <y>222</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1420</x>
      <y>233</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>inet_sk(sk)-&gt;num = snum
sk_add_bind_node(sk, &amp;tb-&gt;owners)//sk_bind_node挂入到链表tb-&gt;owners
inet_csk(sk)-&gt;icsk_bind_hash = tb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1433</x>
      <y>229</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1376</x>
      <y>226</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__inet_check_established</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1386</x>
      <y>222</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1369</x>
      <y>233</y>
      <w>28</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.查找TIME-WAIT socket （head+hinfo-&gt;ehash_size）
	的hash表，如果满足INET_TW_MATCH
	1.通过twsk_unique检查sk是否可用，如果可用，跳到unique
	2.否则跳到not_unique
2.查找established(head)，通过INET_MATCH查看是否匹配
	如果匹配上了，直接跳到not_unique
注：head是hashinfo.ehash
3.unique
	1.初始化sk和port的关系
		inet-&gt;num = lport;
		inet-&gt;sport = htons(lport);
		sk-&gt;sk_hash = hash;
		__sk_add_node(sk, &amp;head-&gt;chain);
		sock_prot_inc_use(sk-&gt;sk_prot);
	2.如果在 TIME-WAIT中查找到port
		1.如果要求返回tw，即返回
		2.否则将sk释放
			inet_twsk_deschedule(tw, death_row)
			inet_twsk_put(tw)
	3.返回0
4.not_unique，返回EADDRNOTAVAIL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1383</x>
      <y>229</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1399</x>
      <y>227</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_bind_bucket_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1408</x>
      <y>222</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1398</x>
      <y>234</y>
      <w>21</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.通过kmem_cache_alloc向
	hinfo-&gt;bind_bucket_cachep
	申请tb
2.初始化tb，并挂入bhash中
	tb-&gt;port      = snum;
	tb-&gt;fastreuse = 0;
	INIT_HLIST_HEAD(&amp;tb-&gt;owners);
	hlist_add_head(&amp;tb-&gt;node, &amp;head-&gt;chain)
注：bhash中是已经注册的port(tb)
	ehash中时建立连接的sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1407</x>
      <y>230</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1494</x>
      <y>176</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1475</x>
      <y>172</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1492</x>
      <y>182</y>
      <w>39</w>
      <h>46</h>
    </coordinates>
    <panel_attributes>1.通过tcp_connect_init初始化sk
2.通过alloc_skb_fclone申请skb及data
	并通过skb_reserve预留tcp head的空间
3.设置syn报文的相关字段
	TCP_SKB_CB(buff)-&gt;flags = TCPCB_FLAG_SYN; //设置syn
	TCP_ECN_send_syn(sk, tp, buff);//设置拥塞标志CWR，ece
	TCP_SKB_CB(buff)-&gt;sacked = 0;
	skb_shinfo(buff)-&gt;gso_segs = 1;
	skb_shinfo(buff)-&gt;gso_size = 0;
	skb_shinfo(buff)-&gt;gso_type = 0;
	buff-&gt;csum = 0;
	tp-&gt;snd_nxt = tp-&gt;write_seq;
	TCP_SKB_CB(buff)-&gt;seq = tp-&gt;write_seq++;//设置序号
	TCP_SKB_CB(buff)-&gt;end_seq = tp-&gt;write_seq;
4.发送skb
	TCP_SKB_CB(buff)-&gt;when = tcp_time_stamp;
	tp-&gt;retrans_stamp = TCP_SKB_CB(buff)-&gt;when;//设置发送的时间戳
	skb_header_release(buff);
	__skb_queue_tail(&amp;sk-&gt;sk_write_queue, buff);//将skb放入发送队列尾
	sk_charge_skb(sk, buff);//更新sk中数据的长度
	tp-&gt;packets_out += tcp_skb_pcount(buff);
	tcp_transmit_skb(sk, buff, 1, GFP_KERNEL);//发送skb
5.更新发送序号
	tp-&gt;snd_nxt = tp-&gt;write_seq;
	tp-&gt;pushed_seq = tp-&gt;write_seq;
6.设置发送超时时间
	inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
				  inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1499</x>
      <y>179</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1516</x>
      <y>231</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_csk_reset_xmit_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1520</x>
      <y>227</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1515</x>
      <y>238</y>
      <w>29</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.设置的超时时间when不能超过max_when
2.如果是重发或者窗口探测（ICSK_TIME_RETRANS，ICSK_TIME_PROBE0）
	icsk-&gt;icsk_pending = what;
	icsk-&gt;icsk_timeout = jiffies + when;
	sk_reset_timer（&amp;icsk-&gt;icsk_retransmit_timer）
3.如果是延迟应答(ICSK_TIME_DACK)
	icsk-&gt;icsk_ack.pending |= ICSK_ACK_TIMER;
	icsk-&gt;icsk_ack.timeout = jiffies + when;
	sk_reset_timer（ &amp;icsk-&gt;icsk_delack_timer）
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1527</x>
      <y>234</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1528</x>
      <y>258</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_reset_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1524</x>
      <y>265</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过mod_timer将timer加入计时
2.如果返回0，说明timer之前不在闹钟中
	如果返回1，说明之前就在
3.所以返回0时，增加sk的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1533</x>
      <y>254</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1532</x>
      <y>261</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1742</x>
      <y>1330</y>
      <w>15</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TCP_SYN_SENT</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1736</x>
      <y>1338</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.通过tcp_rcv_synsent_state_process处理syn+ack
	当返回值不小于0时，返回tcp_v4_do_rcv中发送rst
2.tcp_urg处理紧急指针
3.释放skb
4.tcp_data_snd_check查看是否有数据发送
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1740</x>
      <y>1353</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_rcv_synsent_state_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1751</x>
      <y>1346</y>
      <w>7</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1746</x>
      <y>1356</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1764</x>
      <y>1503</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_state_change
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1765</x>
      <y>1510</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_def_wakeup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1770</x>
      <y>1506</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sock_init_data</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1770</x>
      <y>1513</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1764</x>
      <y>1517</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.通过wake_up_interruptible_all唤醒
	sk-&gt;sk_sleep中等待的进程
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1737</x>
      <y>1502</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_send_ack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1742</x>
      <y>1505</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1729</x>
      <y>1509</y>
      <w>31</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.sk的状态不能在TCP_CLOSE
2.通过alloc_skb申请skb，如果无法申请到内存，设置延时应答
	inet_csk_schedule_ack(sk);
	inet_csk(sk)-&gt;icsk_ack.ato = TCP_ATO_MIN;
	inet_csk_reset_xmit_timer(sk, ICSK_TIME_DACK,
				  TCP_DELACK_MAX, TCP_RTO_MAX);
3.设置skb参数
	skb_reserve(buff, MAX_TCP_HEADER);//预留tcp头部空间
	buff-&gt;csum = 0;
	TCP_SKB_CB(buff)-&gt;flags = TCPCB_FLAG_ACK;//ack
	TCP_SKB_CB(buff)-&gt;sacked = 0;
	skb_shinfo(buff)-&gt;gso_segs = 1;
	skb_shinfo(buff)-&gt;gso_size = 0;
	skb_shinfo(buff)-&gt;gso_type = 0;
4.设置seq和时间戳，并发送skb
	TCP_SKB_CB(buff)-&gt;seq = TCP_SKB_CB(buff)-&gt;end_seq = tcp_acceptable_seq(sk, tp);
	TCP_SKB_CB(buff)-&gt;when = tcp_time_stamp;
	tcp_transmit_skb(sk, buff, 0, GFP_ATOMIC);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1734</x>
      <y>1360</y>
      <w>41</w>
      <h>138</h>
    </coordinates>
    <panel_attributes>1.如果ack置上：
	1.应答序号ack_seq要和snd_nxt记录的相同
	2.如果受到了时间戳，需要在(tp-&gt;retrans_stamp,tcp_time_stamp)之间
	如果上述两种情况不满足，需要返回1，使得调用者发送rst
	3.如果rst置上，tcp_reset重置sk，并丢弃skb
	4.如果syn没置上，返回1，使得调用者发送rst
	5.TCP_ECN_rcv_synack更新ip中的拥塞标志ECN
	6.记录窗口更新的序列号
		tp-&gt;snd_wl1 = TCP_SKB_CB(skb)-&gt;seq
	7.tcp_ack处理应答ack
	8.更新期望接收的序号
		tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;seq + 1;
		tp-&gt;rcv_wup = TCP_SKB_CB(skb)-&gt;seq + 1;
	9.更新窗口
		tp-&gt;snd_wnd = ntohs(th-&gt;window);
		tcp_init_wl(tp, TCP_SKB_CB(skb)-&gt;ack_seq, TCP_SKB_CB(skb)-&gt;seq);//记录窗口变动时对方的seq
	10.如果没有窗口扩大选项(wscale_ok)
		tp-&gt;rx_opt.snd_wscale = tp-&gt;rx_opt.rcv_wscale = 0;
		tp-&gt;window_clamp = min(tp-&gt;window_clamp, 65535U);
	11.如果收到时间戳saw_tstamp：
		tp-&gt;rx_opt.tstamp_ok	   = 1;
		tp-&gt;tcp_header_len =
			sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;//更新tcp头部长度
		tp-&gt;advmss	    -= TCPOLEN_TSTAMP_ALIGNED;//更新mss
		tcp_store_ts_recent(tp);//更新ts_resent
	12.如果没收到时间戳
		tp-&gt;tcp_header_len = sizeof(struct tcphdr);
	13.如果设置了选择应答
		tp-&gt;rx_opt.sack_ok |= 2;
	14.初始化mtu，mss
		tcp_mtup_init(sk);
		tcp_sync_mss(sk, icsk-&gt;icsk_pmtu_cookie);
		tcp_initialize_rcv_mss(sk);
	15.建立连接
		tp-&gt;copied_seq = tp-&gt;rcv_nxt;
		tcp_set_state(sk, TCP_ESTABLISHED);
	16.进一步初始化
		icsk-&gt;icsk_af_ops-&gt;rebuild_header(sk);
		tcp_init_metrics(sk);
		tcp_init_congestion_control(sk);
		tp-&gt;lsndtime = tcp_time_stamp;
		tcp_init_buffer_space(sk);
	17.如果SOCK_KEEPOPEN置上，通过inet_csk_reset_keepalive_timer设置保活定时器
	18.如果不要求窗口扩大(!snd_wscale)，通过__tcp_fast_path_on设置
		tp-&gt;pred_flags，否则tp-&gt;pred_flags为0
	19.如果sk不处于SOCK_DEAD状态，通过sk-&gt;sk_state_change
		和sk_wake_async唤醒同步和异步等待进程
	20.如果延迟发送ack(sk_write_pending || rskq_defer_accept || pingpong)
		inet_csk_schedule_ack(sk);
		icsk-&gt;icsk_ack.lrcvtime = tcp_time_stamp;
		icsk-&gt;icsk_ack.ato	 = TCP_ATO_MIN;
		tcp_incr_quickack(sk);
		tcp_enter_quickack_mode(sk);
		//设置延时应答的时钟
		inet_csk_reset_xmit_timer(sk, ICSK_TIME_DACK,
					  TCP_DELACK_MAX, TCP_RTO_MAX);
		__kfree_skb(skb);
		return 0; //只有返回值&gt;0才会返送rst
	21.否则通过tcp_send_ack发送ack，并返回-1
2.如果没有ack
	1.如果rst或者收到时间戳时tcp_paws_check不能通过，直接丢弃
	2.如果收到syn
		1.tcp_set_state(sk, TCP_SYN_RECV);
	注；这种同时发送syn的情况，不需要两者在listern状态，但是
		两者所用的sk都是原来的，不是像sever端一样新生成的
		2.如果收到了时间戳saw_tstamp
			tp-&gt;rx_opt.tstamp_ok = 1;
			tcp_store_ts_recent(tp);//更新ts_recent
			tp-&gt;tcp_header_len =
				sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;
		3.如果没有收到时间戳
			tp-&gt;tcp_header_len = sizeof(struct tcphdr);
		4.更新与其收到的序号
			 tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;seq + 1;
			 tp-&gt;rcv_wup = TCP_SKB_CB(skb)-&gt;seq + 1;
		5.更新窗口
			tp-&gt;snd_wnd    = ntohs(th-&gt;window);
			tp-&gt;snd_wl1    = TCP_SKB_CB(skb)-&gt;seq;
			tp-&gt;max_window = tp-&gt;snd_wnd;
		6.如果对方的ece和CWR没置上，说明不显示通知拥塞
		7.更新mtu
			tcp_mtup_init(sk);
			tcp_sync_mss(sk, icsk-&gt;icsk_pmtu_cookie);
			tcp_initialize_rcv_mss(sk);
		8.tcp_send_synack发送syn+ack后，丢弃skb返回。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1741</x>
      <y>1497</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1764</x>
      <y>1497</y>
      <w>6</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1406</x>
      <y>16</y>
      <w>215</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_SENDMSG</panel_attributes>
    <additional_attributes>10.0;10.0;2130.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1613</x>
      <y>24</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_sendmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1603</x>
      <y>32</y>
      <w>37</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果flags的MSG_CMSG_COMPAT置上，则通过get_compat_msghdr
	将msg复制到内核，否则通过copy_from_user将msg复制到内核
	注：get_compat_msghdr是将指针转化成32位
2.通过sockfd_lookup_light利用fd找到sock
3.iov数组长度不能超过UIO_MAXIOV，如果其长度超过了UIO_FASTIOV
	通过sock_kmalloc重新申请一个内存区间
4.如果MSG_CMSG_COMPAT置上，就通过verify_compat_iovec将iov数组
	复制到内核，否则通过verify_iovec复制
	注：这里只复制了iov的指向用户的指针，并没有复制真正的数据
5.msg_controllen不能超过INT_MAX
6.如果MSG_CMSG_COMPAT，通过cmsghdr_from_user_compat_to_kern
	将msg_control复制到msg_sys中，否则通过copy_from_user复制
7.msg_sys.msg_flags = flags//如果O_NONBLOCK置上，则将其MSG_DONTWAIT置上
8.通过sock_sendmsg发送msg
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1619</x>
      <y>27</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1599</x>
      <y>59</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1604</x>
      <y>55</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1589</x>
      <y>65</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.要申请的长度和申请之后的长度(sk_omem_alloc+size)
	不能超过sysctl_optmem_max
2.sk_omem_alloc+=size
3.kmalloc申请内存区间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1601</x>
      <y>62</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1624</x>
      <y>59</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_sendmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1628</x>
      <y>55</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1618</x>
      <y>65</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.初始化栈内存iocb
2.通过__sock_sendmsg发送msg
3.如果iocb被排队，通过wait_on_sync_kiocb
	等待iocb-&gt;ki_users被清掉
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1629</x>
      <y>62</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1624</x>
      <y>76</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__sock_sendmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1630</x>
      <y>71</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1616</x>
      <y>83</y>
      <w>28</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.初始化iocb中的si
	si-&gt;sock = sock;
	si-&gt;scm = NULL;
	si-&gt;msg = msg;
	si-&gt;size = size;
2.通过security_socket_sendmsg做安全检查
3.通过sock-&gt;ops-&gt;sendmsg发送msg
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1630</x>
      <y>79</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1622</x>
      <y>98</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;sendmsg
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1629</x>
      <y>94</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1624</x>
      <y>105</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_sendmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1629</x>
      <y>101</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops
inet_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1612</x>
      <y>112</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果没有申请port（!inet_sk(sk)-&gt;num），通过
	inet_autobind自动申请一个port
2.采用sk-&gt;sk_prot-&gt;sendmsg发送msg
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1629</x>
      <y>108</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1613</x>
      <y>122</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_autobind</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1617</x>
      <y>118</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1612</x>
      <y>129</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;get_port
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1617</x>
      <y>125</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1617</x>
      <y>132</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1612</x>
      <y>136</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_get_port</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1649</x>
      <y>123</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;sendmsg
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1635</x>
      <y>118</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1655</x>
      <y>126</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1623</x>
      <y>132</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
udp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1625</x>
      <y>136</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_v4_get_port</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1616</x>
      <y>143</y>
      <w>32</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果没指定port（!sum），从port_rover开始
	遍历hash表udp_hash：
	1.如果对应port的hash是空，跳到1.4
	2.如果没有空的，找到hash边表中最短的
	3.找出这个最短的链表hash值所对应的port
		查看是否有没被使用的，如果没有，fail
	4.*port_rover = snum = result;
2.如果指定了port，遍历hash表，查看有没有和该port
	矛盾的项，如果有，fail
3.inet_sk(sk)-&gt;num = snum;
4.如果sk没被连接到hash中，通过sk_add_node将其连接
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1630</x>
      <y>139</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1655</x>
      <y>130</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_sendmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1560</x>
      <y>257</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_stream_wait_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1569</x>
      <y>260</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1558</x>
      <y>264</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果sock_error，返回err
2.如果不在TCPF_SYN_SENT或者TCPF_SYN_RECV
	返回EPIPE
3.如果没定义超时时间，EAGAIN
4.如果signal_pending，根据timeo确定返回值
5.否则通过sk_wait_event睡眠等待
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1596</x>
      <y>257</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_current_mss</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1590</x>
      <y>264</y>
      <w>38</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.如果要做分段（large_allowed），并且sk允许分段（sk_can_gso）
	并且不处于urg_mode，
	doing_tso = 1
注：带外数据（MSG_OOB）不允许gso
2.如果从dst-&gt;metrics中存储最新的mtu和icsk_pmtu_cookie
	不一致，通过tcp_sync_mss更新mss
3.如果要发送sack(eff_sacks)
	mss_now-=tp-&gt;rx_opt.eff_sacks * TCPOLEN_SACK_PERBLOCK
4.如果要求做tso
	1.最大是65535-tcp（首部+选项）-ip（首部+选项）
	2.不能超过窗口的一半
	3.不能低于68U - tp-&gt;tcp_header_len
	4.发送的长度是对mss_now取整
		xmit_size_goal -= (xmit_size_goal % mss_now);
5.tp-&gt;xmit_size_goal = xmit_size_goal
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1602</x>
      <y>260</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1574</x>
      <y>322</y>
      <w>35</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.mss_now=mtu-ip头部-tcp头部
2.mss_now不能超过tp-&gt;rx_opt.mss_clamp
3.mss_now-=ip选项
4.mss_now不能小于48（20tcp头+20tcp选项+8data）
5.mss_now-=tcp头部
注：
1.icsk-&gt;icsk_af_ops在tcp_v4_init_sock中被初始化成ipv4_specific
	其net_header_len为ip报文头的长度
2.icsk-&gt;icsk_ext_hdr_len为ip选项的长度
3.tp-&gt;tcp_header_len - sizeof(struct tcphdr)为tcp选项的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1589</x>
      <y>291</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_sync_mss</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1594</x>
      <y>294</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1580</x>
      <y>298</y>
      <w>33</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果search_high&gt;pmtu
	icsk-&gt;icsk_mtup.search_high = pmtu;
2.通过tcp_mtu_to_mss计算mtu对应的mss
3.mss_now不能超过窗口的一半长度
4.存储对方发送的mtu
	icsk-&gt;icsk_pmtu_cookie = pmtu;
5.如果icsk_mtup.enabled，mss_now不能超过search_low(mtu)对应的mss
6.tp-&gt;mss_cache = mss_now
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1585</x>
      <y>315</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_mtu_to_mss</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1591</x>
      <y>318</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1591</x>
      <y>311</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1594</x>
      <y>288</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1639</x>
      <y>256</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_stream_alloc_pskb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1632</x>
      <y>263</y>
      <w>33</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.确定头部的长度sk-&gt;sk_prot-&gt;max_header
注：这个值在tcp_prot中是MAX_TCP_HEADER
	应该是tcp头部最大长度+ip头部最大长度
2.通过alloc_skb_fclone申请数据区(头部+data_size)
注：这里的skb是clone的
3.如果申请到skb：
	1.skb-&gt;truesize += mem
	2.通过sk_stream_wmem_schedule检查申请的内存
		是否超过了限制，如果没超过通过skb_reserve
		预留出头部的空间
	3.否则释放skb
4.如果没申请到，通过enter_memory_pressure通知sk
	然后通过sk_stream_moderate_sndbuf调整sk_sndbuf
	并返回NULL.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1646</x>
      <y>259</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1676</x>
      <y>256</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>select_size</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1668</x>
      <y>263</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.默认长度是mss_cache
2.如果可以分段（NETIF_F_SG）
	1.如果硬件能支持对应的协议分段（sk_can_gso）
		将长度设置为0
	2.如果data+skb的长度超过了一个页面，将其设置为page-skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1681</x>
      <y>259</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1728</x>
      <y>256</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait_for_memory
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1733</x>
      <y>259</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1720</x>
      <y>262</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果有复制数据，通过tcp_push将数据发出
2.通过sk_stream_wait_memory等待
3.醒来后，更新mss和本次skb发送的长度
	mss_now = tcp_current_mss(sk, !(flags&amp;MSG_OOB));
	size_goal = tp-&gt;xmit_size_goal;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1700</x>
      <y>275</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_push</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1705</x>
      <y>271</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1688</x>
      <y>282</y>
      <w>32</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果有数据要发送（sk_send_head）
	1.取出sk_write_queue中最新排入的skb
	2.如果MSG_MORE没置上，或者forced_push
		通过tcp_mark_push将push标记，要求接收方尽快处理
	3.通过tcp_mark_urg标记紧急指针
	4.通过__tcp_push_pending_frames发送skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1704</x>
      <y>278</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1689</x>
      <y>295</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_mark_push</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1695</x>
      <y>292</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1688</x>
      <y>302</y>
      <w>29</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>TCP_SKB_CB(skb)-&gt;flags |= TCPCB_FLAG_PSH;
tp-&gt;pushed_seq = tp-&gt;write_seq;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1694</x>
      <y>298</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1676</x>
      <y>295</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>forced_push</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1681</x>
      <y>292</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1662</x>
      <y>301</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.write_seq在(pushed_seq+窗口一半)
	的后面
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1675</x>
      <y>298</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1715</x>
      <y>295</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_mark_urg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1709</x>
      <y>292</y>
      <w>14</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1718</x>
      <y>301</y>
      <w>25</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果是带外数据MSG_OOB
	tp-&gt;urg_mode = 1;
	tp-&gt;snd_up = tp-&gt;write_seq;
	TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_URG;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1720</x>
      <y>298</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1743</x>
      <y>295</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__tcp_push_pending_frames</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1712</x>
      <y>292</y>
      <w>37</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1745</x>
      <y>301</y>
      <w>27</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果队列中有skb可以发(sk_send_head)
	1.通过tcp_write_xmit将队列中的skb发送
	2.如果没发送成功tcp_check_probe_timer
		检查probe_timer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1753</x>
      <y>298</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1741</x>
      <y>311</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_write_xmit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1747</x>
      <y>308</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1721</x>
      <y>316</y>
      <w>40</w>
      <h>45</h>
    </coordinates>
    <panel_attributes>1.sk的状态不能是TCP_CLOSE
2.通过tcp_mtu_probe发送路径mtu，如果成功，sent_pkts = 1
3.取sk-&gt;sk_send_head循环发送
	1.通过tcp_init_tso_segs获取发送的段
	2.通过tcp_cwnd_test检查拥塞窗口，如果没有窗口，退出循环
	注：snd_cwnd以mss为单位
	3.通过tcp_snd_wnd_test检查滑动窗口，没有窗口，退出循环
	注：snd_wnd以byte为单位
	3.如果只发送一个段(tso_segs = 1),通过tcp_nagle_test
	检查是否需要nagle算法，如果需要则返回0，退出循环；否则返回1
	继续发送
	注：只有是队列中最后一个skb(tcp_skb_is_last)，才有可能
	实行nagle算法
	4.如果有多个段，通过tcp_tso_should_defer查看分段是否延迟
		如果是，就暂时不发送，退出循环
	5.如果发送的分段超过1个
		1.通过tcp_window_allows检查窗口（滑动窗口和拥塞窗口的最小值）
		注：这里检查分段是否能一起发出
		2.发送的长度如果没超过limit， skb-&gt;len对mss向下取整
	6.如果skb.len超过了limit，通过tso_fragment对其分段
	7.设置时间戳
		TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;
	8.通过tcp_transmit_skb发送skb
	9.通过update_send_head调整sk_send_head
4.如果最后有数据发送，通过tcp_cwnd_validate进行拥塞窗口的确认
5.如果没数据发出，网络上没数据(!packet_out)或者队列没数据发送
	都视为有数据发出(return 0)
注：发送检查：nagle，cwnd，win
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1743</x>
      <y>314</y>
      <w>4</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1643</x>
      <y>364</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_init_tso_segs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1649</x>
      <y>360</y>
      <w>79</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>770.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1631</x>
      <y>371</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过tcp_skb_pcount得到skb的分段
2.如果暂时没段（!tso_segs），或者分段传输
	(tso_segs &gt; 1  &amp;&amp;  tcp_skb_mss(skb) != mss_now)
	通过tcp_set_skb_tso_segs重新设置分段，并重新获取
	其分段tcp_skb_pcount
注；tcp_skb_mss是分段的长度gso_size
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1647</x>
      <y>367</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1637</x>
      <y>384</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_set_skb_tso_segs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1644</x>
      <y>380</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1625</x>
      <y>391</y>
      <w>42</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果skb的总长度(skb-&gt;len)不超过mss，或者底层不能做分段(!sk_can_gso)
	skb_shinfo(skb)-&gt;gso_segs = 1;
	skb_shinfo(skb)-&gt;gso_size = 0;
	skb_shinfo(skb)-&gt;gso_type = 0;
2.否则
	skb_shinfo(skb)-&gt;gso_segs = factor;//skb-&gt;len对mss取整，然后对mss取模
	skb_shinfo(skb)-&gt;gso_size = mss_now;
	skb_shinfo(skb)-&gt;gso_type = sk-&gt;sk_gso_type;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1644</x>
      <y>387</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1672</x>
      <y>364</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_cwnd_test</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1677</x>
      <y>360</y>
      <w>52</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>500.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1666</x>
      <y>371</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果发送的是fin(TCPCB_FLAG_FIN)，允许其发送
2.通过tcp_packets_in_flight计算正在网络上传输的packet
注：已经发送的(packets_out)-收到ack的(left_out)+重传的(retrans_out)
3.如果in_flight &lt; cwnd，返回窗口大小(cwnd - in_flight)
4.否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1677</x>
      <y>367</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1740</x>
      <y>363</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_nagle_test</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1743</x>
      <y>360</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1741</x>
      <y>369</y>
      <w>29</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果TCP_NAGLE_PUSH置上，就立即发送
2.如果urg_mode，或者TCPCB_FLAG_FIN，立即发送
3.如果nagle检查没通过，立即发送
4.否则需要nagle算法
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1746</x>
      <y>366</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1747</x>
      <y>381</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_nagle_check</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1752</x>
      <y>377</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1739</x>
      <y>387</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.发送长度len小于mss
2.TCP_NAGLE_CORK置上，或者
	没有nonagle，已经发出去包(packets_out),最近窗口内有发small packet(tcp_minshall_check)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1752</x>
      <y>384</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1772</x>
      <y>363</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_tso_should_defer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1749</x>
      <y>360</y>
      <w>30</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1772</x>
      <y>370</y>
      <w>36</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.如果发送的是fin，直接发出
2.如果sk的拥塞状态不是TCP_CA_Open，立即发出
3.如果之前deffer(tp-&gt;tso_deferred),现在发送的时间超过之前1tick
	就立即发出
4.通过tcp_packets_in_flight统计网络上正在发送的包
5.计算剩余滑动窗口大小
	send_win = (tp-&gt;snd_una + tp-&gt;snd_wnd) - TCP_SKB_CB(skb)-&gt;seq;
6.计算剩余拥塞窗口大小
	cong_win = (tp-&gt;snd_cwnd - in_flight) * tp-&gt;mss_cache;
7.计算拥塞窗口和滑动窗口的最小值limit
8.	如果limit的大小超过了65535，立即发送
9.如果limit足够大，立即发送
10.记录deffered发送的时间
	tp-&gt;tso_deferred = 1 | (jiffies&lt;&lt;1)
	return 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1780</x>
      <y>366</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1815</x>
      <y>362</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tso_fragment</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1753</x>
      <y>359</y>
      <w>69</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
切分的长度是len</panel_attributes>
    <additional_attributes>10.0;20.0;670.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1810</x>
      <y>370</y>
      <w>40</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.如果有数据在data中(skb-&gt;len != skb-&gt;data_len)，通过tcp_fragment分段
2.通过sk_stream_alloc_pskb申请skb
3.通过sk_charge_skb更新sk中数据长度信息
	sk-&gt;sk_wmem_queued   += skb-&gt;truesize;
	sk-&gt;sk_forward_alloc -= skb-&gt;truesize;
4.skb信息分段
	buff-&gt;truesize += nlen;
	skb-&gt;truesize -= nlen;
	TCP_SKB_CB(buff)-&gt;seq = TCP_SKB_CB(skb)-&gt;seq + len;
	TCP_SKB_CB(buff)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;end_seq;
	TCP_SKB_CB(skb)-&gt;end_seq = TCP_SKB_CB(buff)-&gt;seq;
	flags = TCP_SKB_CB(skb)-&gt;flags;
	TCP_SKB_CB(skb)-&gt;flags = flags &amp; ~(TCPCB_FLAG_FIN|TCPCB_FLAG_PSH);
	TCP_SKB_CB(buff)-&gt;flags = flags;
	TCP_SKB_CB(buff)-&gt;sacked = 0;
	buff-&gt;ip_summed = skb-&gt;ip_summed = CHECKSUM_PARTIAL;
5.通过skb_split进行skb数据分段
6.通过tcp_set_skb_tso_segs重新设置skb和buff的gso_segs
7.通过skb_header_release将buff标记为nohdr
8.通过__skb_append将buff插入到skb之后
注：tcp_fragment有对data段进行复制，tso_fragment没复制data段
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1821</x>
      <y>365</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1817</x>
      <y>407</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_split</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1823</x>
      <y>403</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1805</x>
      <y>414</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果在data数据段内，通过skb_split_inside_header分段
2.如果在frag内，通过skb_split_no_header分段
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1821</x>
      <y>410</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1796</x>
      <y>422</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_split_inside_header</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1823</x>
      <y>422</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_split_no_header</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1806</x>
      <y>418</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1828</x>
      <y>418</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1786</x>
      <y>429</y>
      <w>32</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.复制data段中len~pos之后的数据到skb1中
	memcpy(skb_put(skb1, pos - len), skb-&gt;data + len, pos - len)
2.复制frags
	skb_shinfo(skb1)-&gt;frags[i] = skb_shinfo(skb)-&gt;frags[i];
3.更新skb和skb1中的信息
	skb_shinfo(skb1)-&gt;nr_frags = skb_shinfo(skb)-&gt;nr_frags;
	skb_shinfo(skb)-&gt;nr_frags  = 0;
	skb1-&gt;data_len		   = skb-&gt;data_len;
	skb1-&gt;len		   += skb1-&gt;data_len;
	skb-&gt;data_len		   = 0;
	skb-&gt;len		   = len;
	skb-&gt;tail		   = skb-&gt;data + len;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1803</x>
      <y>425</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1821</x>
      <y>429</y>
      <w>31</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.新分段的skb只用frags
	skb_shinfo(skb)-&gt;nr_frags = 0;
	skb1-&gt;len		  = skb1-&gt;data_len = skb-&gt;len - len;
	skb-&gt;len		  = len;
	skb-&gt;data_len		  = len - pos;
2.遍历skb所有的frags
	1.如果长度(pos + size)没超过要分段的长度：
		skb_shinfo(skb)-&gt;nr_frags++;
	2.如果超过了：
		1.skb_shinfo(skb1)-&gt;frags[k] = skb_shinfo(skb)-&gt;frags[i];
		2.如果这个frag中还需要分段(pos &lt; len)
			get_page(skb_shinfo(skb)-&gt;frags[i].page);
			skb_shinfo(skb1)-&gt;frags[0].page_offset += len - pos;
			skb_shinfo(skb1)-&gt;frags[0].size -= len - pos;
			skb_shinfo(skb)-&gt;frags[i].size	= len - pos;
			skb_shinfo(skb)-&gt;nr_frags++;
		3.k++
	3.pos += size;
4.skb_shinfo(skb1)-&gt;nr_frags = k;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1829</x>
      <y>425</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1915</x>
      <y>362</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>update_send_head</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1913</x>
      <y>369</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.更新sk_send_head，如果发送队列发送完，设置其为NULL
	sk-&gt;sk_send_head = skb-&gt;next;
2.tp-&gt;snd_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
3.tcp_packets_out_inc更新发出去的帧packet_out
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1921</x>
      <y>365</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1917</x>
      <y>380</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_packets_out_inc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1924</x>
      <y>376</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1912</x>
      <y>386</y>
      <w>37</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.tp-&gt;packets_out += tcp_skb_pcount(skb);//以包个数为单位
2.如果之前没发包，通过inet_csk_reset_xmit_timer重置
	ICSK_TIME_RETRANS
注：之前没发包，update_send_head设置ICSK_TIME_RETRANS，否则在收到ack，
	在tcp_clean_rtx_queue--&gt;tcp_ack_packets_out中重置
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1924</x>
      <y>383</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1754</x>
      <y>360</y>
      <w>169</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1670.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1715</x>
      <y>363</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_snd_wnd_test</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1722</x>
      <y>360</y>
      <w>10</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1703</x>
      <y>371</y>
      <w>34</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果skb的长度超过了mss，重新更新end_seq
2.end_seq不能超过滑动窗口(tp-&gt;snd_una + tp-&gt;snd_wnd)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1720</x>
      <y>366</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1954</x>
      <y>360</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_cwnd_validate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1945</x>
      <y>367</y>
      <w>31</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.网络上传输的包(packets_out)如果超过了拥塞窗口(snd_cwnd)
	tp-&gt;snd_cwnd_used = 0;
	tp-&gt;snd_cwnd_stamp = tcp_time_stamp;
2.否则拥塞窗口没满
	1.当packet_out超过snd_cwnd_used
		tp-&gt;snd_cwnd_used = tp-&gt;packets_out;
	2.当和上一次更新snd_cwnd_stamp超过了icsk_rto
		通过tcp_cwnd_application_limited更新拥塞窗口
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1960</x>
      <y>363</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1952</x>
      <y>385</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_cwnd_application_limited</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1950</x>
      <y>392</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果sk处于TCP_CA_Open，并且senbuf没满(!SOCK_NOSPACE)
	1.如果用的拥塞窗口win_used小于snd_cwnd
		tp-&gt;snd_ssthresh = tcp_current_ssthresh(sk);//当前限值和3/4snd_cwnd最大值
		tp-&gt;snd_cwnd = (tp-&gt;snd_cwnd + win_used) &gt;&gt; 1;//snd_cwnd和win_used的平均值
	2.tp-&gt;snd_cwnd_used = 0
2.tp-&gt;snd_cwnd_stamp = tcp_time_stamp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1961</x>
      <y>381</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1961</x>
      <y>388</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1868</x>
      <y>362</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_transmit_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1755</x>
      <y>359</y>
      <w>207</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;20.0;2050.0;10.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1752</x>
      <y>360</y>
      <w>123</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1210.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1854</x>
      <y>369</y>
      <w>40</w>
      <h>88</h>
    </coordinates>
    <panel_attributes>1.查看拥塞算法是否需要rtt采样rtt_sample，如果需要，则通过
	__net_timestamp进行采样
	skb-&gt;tstamp.off_sec  = stamp-&gt;tv_sec;
	skb-&gt;tstamp.off_usec = stamp-&gt;tv_usec;
2.如果需要对skb克隆
	1.如果skb已经被克隆skb_cloned，通过pskb_copy复制skb
注：查看克隆，查看其skb-&gt;cloned ，并且其share_info不止一个skb使用
	2.否则通过skb_clone克隆skb
	3.如果没克隆成功，返回ENOBUFS
3.调整tcp头部长度tcp_header_size
	1.如果是syn
		1.初始长度
			tcp_header_size = sizeof(struct tcphdr) + TCPOLEN_MSS;
		2.如果sysctl_tcp_timestamps置上，需要有timestamp选项
			tcp_header_size += TCPOLEN_TSTAMP_ALIGNED;
			sysctl_flags |= SYSCTL_FLAG_TSTAMPS;
		3.如果sysctl_tcp_window_scaling，则有窗口扩大选项
			tcp_header_size += TCPOLEN_WSCALE_ALIGNED;
			sysctl_flags |= SYSCTL_FLAG_WSCALE;
		4.如果sysctl_tcp_sack，
			1.sysctl_flags |= SYSCTL_FLAG_SACK;
			2.如果不需要timestamp
				tcp_header_size += TCPOLEN_SACKPERM_ALIGNED;
	2.不是syn，但是需要sack选项(eff_sacks)
		tcp_header_size = tp-&gt;tcp_header_len;
		tcp_header_size += (TCPOLEN_SACK_BASE_ALIGNED +
				    (tp-&gt;rx_opt.eff_sacks *
				     TCPOLEN_SACK_PERBLOCK));
	3.其他情况
		tcp_header_size = tp-&gt;tcp_header_len;
4.如果tcp_packets_in_flight没有待确认的包，初始化拥塞控制
	tcp_ca_event(sk, CA_EVENT_TX_START)
5.通过skb_push得到head中初始地址th
	skb-&gt;h.th = th;
	skb_set_owner_w(skb, sk);
	th-&gt;source		= inet-&gt;sport;
	th-&gt;dest		= inet-&gt;dport;
	th-&gt;seq			= htonl(tcb-&gt;seq);
	th-&gt;ack_seq		= htonl(tp-&gt;rcv_nxt);
	*(((__be16 *)th) + 6)	= htons(((tcp_header_size &gt;&gt; 2) &lt;&lt; 12) |
					tcb-&gt;flags);
	th-&gt;window //syn时是tp-&gt;rcv_wnd，否则通过tcp_select_window确定窗口大小
	th-&gt;check		= 0;//checksum
	th-&gt;urg_ptr		= htons(tp-&gt;snd_up-tcb-&gt;seq);send_up是紧急指针位置，在urg_mode时设置
	th-&gt;urg			= 1;
6.如果是syn，通过tcp_syn_build_options构建选项，
7.否则通过tcp_build_and_update_options构建选项，并根据TCP_ECN_send设置拥塞通知
8.icsk-&gt;icsk_af_ops-&gt;send_check计算checksum
9.如果发送ack，通过tcp_event_ack_sent通知延时确认模块
10.如果有负载(skb-&gt;len != tcp_header_size),tcp_event_data_sent
	处理拥塞窗口和延迟应答
11.通过icsk-&gt;icsk_af_ops-&gt;queue_xmit发送skb给ip
12.发送失败，进入tcp_enter_cwr
13.通过net_xmit_eval解析错误
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1873</x>
      <y>365</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1751</x>
      <y>471</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pskb_copy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1741</x>
      <y>478</y>
      <w>31</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.通过alloc_skb申请skb
2.通过skb_reserve预留头部的空间(data-head)
3.通过skb_put将skb-&gt;len - skb-&gt;data_len压到data中
	memcpy(n-&gt;data, skb-&gt;data, n-&gt;len)
4.初始化skb信息
	n-&gt;csum	     = skb-&gt;csum;
	n-&gt;ip_summed = skb-&gt;ip_summed;
	n-&gt;truesize += skb-&gt;data_len;
	n-&gt;data_len  = skb-&gt;data_len;
	n-&gt;len	     = skb-&gt;len;
5.如果有frags，增加page的索引
	skb_shinfo(n)-&gt;frags[i] = skb_shinfo(skb)-&gt;frags[i];
	get_page(skb_shinfo(n)-&gt;frags[i].page);
	skb_shinfo(n)-&gt;nr_frags = i;
6.如果有frag_list，增加其链表中skb的引用
	skb_shinfo(n)-&gt;frag_list = skb_shinfo(skb)-&gt;frag_list;
	skb_clone_fraglist(n);
7.通过copy_skb_header复制skb中的信息
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1755</x>
      <y>474</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1782</x>
      <y>471</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_select_window</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1775</x>
      <y>478</y>
      <w>32</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.通过tcp_receive_window获取当前的接收窗口大小
	win = tp-&gt;rcv_wup + tp-&gt;rcv_wnd - tp-&gt;rcv_nxt
注：rcv_nxt可能因为延迟应答，比rcv_wup大
2.通过__tcp_select_window决定新的窗口大小
3.因为窗口右边界不能左移，所以new_win不能小于cur_win
注：当free_space小于mss时，可能出现这种情况
4.更新窗口
	tp-&gt;rcv_wnd = new_win;
	tp-&gt;rcv_wup = tp-&gt;rcv_nxt;
5.发送的窗口值不能超过tcp最大窗口的限制
	(MAX_TCP_WINDOW或者65535U &lt;&lt; tp-&gt;rx_opt.rcv_wscale)
6.考虑到窗口扩大因子
	new_win &gt;&gt;= tp-&gt;rx_opt.rcv_wscale;
7.如果新窗口是0，禁止fast path
	tp-&gt;pred_flags = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1788</x>
      <y>474</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1774</x>
      <y>505</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__tcp_select_window</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1764</x>
      <y>511</y>
      <w>35</w>
      <h>29</h>
    </coordinates>
    <panel_attributes>1.确定窗口的free_space，full_space
	free_space=sk-&gt;sk_rcvbuf - atomic_read(&amp;sk-&gt;sk_rmem_alloc)
	full_space=min(tp-&gt;window_clamp,sk-&gt;sk_rcvbuf)
注：tcp_win_from_space表示窗口相对rcvbuf的缩小量
2.mss不能超过full_space
3.如果free_space低于full_space的一半
	1.icsk-&gt;icsk_ack.quick = 0
	2.如果设置了tcp_memory_pressure
		tp-&gt;rcv_ssthresh = min(tp-&gt;rcv_ssthresh, 4U*tp-&gt;advmss);
	3.如果free_space小于mss，直接返回0
4.free_space不能超过tp-&gt;rcv_ssthresh
注：tp-&gt;rcv_ssthresh当前接收窗口限值，snd_ssthresh才是慢启动限值
	window_clamp是最大接收窗口限值
5.如果设置了tp-&gt;rx_opt.rcv_wscale，将free_space向上取整
6.如果free_space相对于tp-&gt;rcv_wnd减少的空间小于mss
	直接使用tp-&gt;rcv_wnd
7.否则直接使用free_space对mss向下取整
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1780</x>
      <y>508</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1780</x>
      <y>502</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1903</x>
      <y>468</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_event_ack_sent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1895</x>
      <y>476</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_event_ack_sent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1915</x>
      <y>476</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_csk_clear_xmit_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1911</x>
      <y>471</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ICSK_TIME_DACK</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1902</x>
      <y>471</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1894</x>
      <y>482</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果存在icsk-&gt;icsk_ack.quick
	1.如果发出的段pkts，超过了quick
		icsk-&gt;icsk_ack.quick = 0;
		icsk-&gt;icsk_ack.ato   = TCP_ATO_MIN;
	2.否则：
		icsk-&gt;icsk_ack.quick -= pkts
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1901</x>
      <y>479</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1938</x>
      <y>466</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_event_data_sent</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1935</x>
      <y>473</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果有icsk-&gt;icsk_rto时间没有发送数据
	通过tcp_cwnd_restart重启拥塞窗口
2.tp-&gt;lsndtime = now
3.如果now - icsk-&gt;icsk_ack.lrcvtime&lt;icsk-&gt;icsk_ack.ato
	icsk-&gt;icsk_ack.pingpong = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1945</x>
      <y>469</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1972</x>
      <y>471</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_queue_xmit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1969</x>
      <y>465</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>icsk-&gt;icsk_af_ops-&gt;queue_xmit
valign=center
bg=red</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1978</x>
      <y>468</y>
      <w>11</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ipv4_specific</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2027</x>
      <y>463</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_enter_cwr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2022</x>
      <y>469</y>
      <w>30</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.tp-&gt;prior_ssthresh = 0;
	tp-&gt;bytes_acked = 0;
2.如果之前状态低于TCP_CA_CWR
	tp-&gt;undo_marker = 0;
	tp-&gt;snd_ssthresh = inet_csk(sk)-&gt;icsk_ca_ops-&gt;ssthresh(sk);
	tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd,
			   tcp_packets_in_flight(tp) + 1U);
	tp-&gt;snd_cwnd_cnt = 0;
	tp-&gt;high_seq = tp-&gt;snd_nxt;
	tp-&gt;snd_cwnd_stamp = tcp_time_stamp;
	TCP_ECN_queue_cwr(tp);
	tcp_set_ca_state(sk, TCP_CA_CWR);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2032</x>
      <y>466</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1756</x>
      <y>456</y>
      <w>110</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1080.0;10.0;600.0;100.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1788</x>
      <y>456</y>
      <w>78</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>760.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1883</x>
      <y>456</y>
      <w>28</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1884</x>
      <y>456</y>
      <w>61</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;590.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1885</x>
      <y>456</y>
      <w>94</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;920.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1884</x>
      <y>456</y>
      <w>151</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
snd_ssthresh减半
snd_cwnd(网络上的包+1)</panel_attributes>
    <additional_attributes>10.0;10.0;1490.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1778</x>
      <y>276</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_stream_wait_memory</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1745</x>
      <y>271</y>
      <w>43</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;410.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1773</x>
      <y>283</y>
      <w>41</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>1.通过sk_stream_memory_free检查是否有空闲空间
	sk-&gt;sk_wmem_queued &lt; sk-&gt;sk_sndbuf
	如果有，通过net_random随机选取等待时间
2.循环等待
	1.set_bit(SOCK_ASYNC_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);
	2.通过prepare_to_wait将wait加入到sk-&gt;sk_sleep链表中
	3.如果sk_err，或者sk_shutdown &amp; SEND_SHUTDOWN，返回EPIPE
	4.如果没设置等待时间，返回EAGAIN
	5.如果signal_pending，根据设置的等待时间设置返回值
	6.clear_bit(SOCK_ASYNC_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);
	7.如果sk_stream_memory_free，并且等待时间用完，退出循环
	7.set_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);
		sk-&gt;sk_write_pending++;
	8.sk_wait_event当条件不成立时，schedule_timeout
	9.醒来之后
		1.sk-&gt;sk_write_pending--;
		2.更新等待时间
			vm_wait -= current_timeo
			current_timeo -= vm_wait
			*timeo_p = current_timeo
3.退出循环后，通过finish_wait设置task run,并且将wait脱链
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1786</x>
      <y>279</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1824</x>
      <y>255</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_entail</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1814</x>
      <y>262</y>
      <w>32</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.初始化参数
	skb-&gt;csum    = 0;
	tcb-&gt;seq     = tcb-&gt;end_seq = tp-&gt;write_seq;//初始序号
	tcb-&gt;flags   = TCPCB_FLAG_ACK;  //send_msg会发ack
	tcb-&gt;sacked  = 0;
2.skb_header_release(skb); //释放对skb.data的引用
	__skb_queue_tail(&amp;sk-&gt;sk_write_queue, skb);
	sk_charge_skb(sk, skb)//更新sk_wmem_queued，sk_forward_alloc
3.如果发送队列中没skb
	sk-&gt;sk_send_head = skb;
4.如果tp-&gt;nonagle的TCP_NAGLE_PUSH置上，则将其清掉
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1829</x>
      <y>258</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1858</x>
      <y>257</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_tailroom</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1851</x>
      <y>263</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果	存在frag(data_len)，返回0
2.否则返回skb-&gt;end - skb-&gt;tail
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1863</x>
      <y>260</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1882</x>
      <y>256</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_add_data</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1879</x>
      <y>263</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果skb-&gt;ip_summed是CHECKSUM_NONE
	通过csum_and_copy_from_user将iov复制到tail中
	并且计算skb-&gt;csum
2.通过copy_from_user将iov复制到tail中
3.如果复制失败，通过__skb_trim将skb.len恢复
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1887</x>
      <y>259</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1650</x>
      <y>137</y>
      <w>40</w>
      <h>115</h>
    </coordinates>
    <panel_attributes>1.通过sock_sndtimeo确定其等待时间timeo
2.如果sk的状态不在TCPF_ESTABLISHED或者TCPF_CLOSE_WAIT（被动关闭连接）
	通过sk_stream_wait_connect等待连接
3.清除异步sock队列满的标志
	clear_bit(SOCK_ASYNC_NOSPACE
4.通过tcp_current_mss指定发送的长度(xmit_size_goal)和当前的mss
	size_goal = tp-&gt;xmit_size_goal;
5.如果报错sk_err或者SEND_SHUTDOWN，do_error
6.循环处理数据msg-&gt;msg_iovlen
	1.循环处理iov中存在的数据(iov-&gt;iov_len)
		1.如果没有待发送的skb(!sk_send_head),或者skb中没有多余空间容纳数据
			(copy = size_goal - skb-&gt;len) &lt;= 0，那么就开一个新的skb
			1.通过sk_stream_memory_free查看队列中的data长度(sk_wmem_queued)是否超过了限制(sk_sndbuf)
				如果超过了，跳到wait_for_sndbuf，醒来之后继续循环
			2.通过sk_stream_alloc_pskb申请skb,其申请的data长度是select_size
			3.如果没申请到skb，跳到wait_for_memory，醒来之后继续循环
			4.如果硬件计算checksum(NETIF_F_ALL_CSUM)
				skb-&gt;ip_summed = CHECKSUM_PARTIAL;
			5.通过skb_entail将skb加入到队列尾
			6.更新此次skb发送的数据量
				copy = size_goal;
		2.要复制的数据copy不能超过iov_len
		3.如果skb.data中能放数据（skb_tailroom），通过skb_add_data
			最多复制skb_tailroom的数据到skb.data
		4.如果skb_tailroom中没空间
			1.sk_sndmsg_page和sk_sndmsg_off中缓存着发送方frag中操作的page和off
			2.通过skb_can_coalesce检查缓存的sk_sndmsg_page和sk_sndmsg_off
				是否是发送方frag中操作的page和off，并且该frag没满
					merge = 1
			3.如果不能再frag中添加数据
				1.因为frags达到了最大MAX_SKB_FRAGS
				2.因为不支持frags(聚散io NETIF_F_SG)
				这两种情况通过tcp_mark_push将之前数据标志位push，提醒peer尽快处理，然后跳转到6.1.1.1
				3.如果是sk_sndmsg_page满了：
					put_page(page);
					TCP_PAGE(sk) = page = NULL;
					off = 0;
				4.如果之前没有申请page
					off = 0
			4.复制的长度不能超过 PAGE_SIZE - off
			5.通过sk_stream_wmem_schedule查看sk是否还能申请内存
				如果不能，跳到wait_for_memory
			6.如果没有page容纳数据，通过sk_stream_alloc_page申请内存
				如果申请不到，跳到wait_for_memory
			7.通过skb_copy_to_page将iov复制到page中，如果出错，do_error
			8.如果要求merge到frag中，
				skb_shinfo(skb)-&gt;frags[i - 1].size +=copy;
			9.否则通过skb_fill_page_desc将page挂入到frags中
				1.如果之前有sk_sndmsg_page，直接get_page增加page引用
				2.如果没有，并且此次没将page空间占满
					get_page(page);
					TCP_PAGE(sk) = page;
			10.TCP_OFF(sk) = off + copy;
		5.如果之前没复制数据(copied)，将skb的push清掉
		6.更新信息
			tp-&gt;write_seq += copy;
			TCP_SKB_CB(skb)-&gt;end_seq += copy;//tcb-&gt;seq已经在skb_entai中设置过
			skb_shinfo(skb)-&gt;gso_segs = 0;
			from += copy;
			copied += copy;
		7.如果iov复制完成，跳出循环，out
		8.如果skb的长度没满mss，或者是带外数据MSG_OOB，继续循环
		9.通过forced_push检测是否要将skb的push置上
			1.如果需要，通过tcp_mark_push将push置上，并通过
				__tcp_push_pending_frames发送sk_send_head
			2.如果队列中只有这一个skb，通过tcp_push_one将skb发出
		10.继续循环
		11.wait_for_sndbuf，将SOCK_NOSPACE置上
		12.wait_for_memory
7.out，如果有复制数据，通过tcp_push将数据发出，返回发送的字节数
8.do_error,如果有复制数据就退出，没有就处理完err后退出
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1637</x>
      <y>290</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_stream_wmem_schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1645</x>
      <y>286</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1631</x>
      <y>297</y>
      <w>28</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果申请的size小于sk-&gt;sk_forward_alloc，
	表示sk有空闲内存供其申请，返回1
2.如果上述不成立，通过sk_stream_mem_schedule
	查看sk是否还能申请到内存
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1644</x>
      <y>293</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1637</x>
      <y>308</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_stream_mem_schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1646</x>
      <y>304</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1624</x>
      <y>315</y>
      <w>40</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.amt对page向上取整
2.sk-&gt;sk_forward_alloc += amt * SK_STREAM_MEM_QUANTUM; //byte为单位
	atomic_add(amt, sk-&gt;sk_prot-&gt;memory_allocated);//page为单位
3.如果memory_allocated没超过sysctl_mem[0]，
	清掉memory_pressure，并返回1
4.memory_allocated超过了sysctl_mem[2]，通过enter_memory_pressure
	通知sk，并进入suppress_allocation
5.memory_allocated超过了sysctl_mem[1]，也执行enter_memory_pressure
6.kind置上，表示读
	在sk_rmem_alloc不超过sysctl_rmem[0]才返回1
	kind没置上，表示写
	sk_wmem_queued不超过sysctl_wmem[0]，返回1
7.如果memory_pressure没置上，返回1
8.如果sk的所有内存(sockets_allocated,sk_wmem_queued,
	sk_rmem_alloc,sk_forward_alloc)加起来没超过sysctl_mem[2]，返回1
9.suppress_allocation
	1.如果是写(!kind)
		1.通过sk_stream_moderate_sndbuf调整sndbuf
		2.sk_wmem_queued+size超过了sk_sndbuf，说明可能是因为写导致的pressure
			所以之前sk_stream_memory_free检查sk_wmem_queued没超过sk_sndbuf
			所以这里返回1
	2.退回sk计量的内存
		sk-&gt;sk_forward_alloc -= amt * SK_STREAM_MEM_QUANTUM;
		atomic_sub(amt, sk-&gt;sk_prot-&gt;memory_allocated);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1644</x>
      <y>311</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1924</x>
      <y>256</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_stream_alloc_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1917</x>
      <y>262</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过alloc_pages申请1页
2.如果没申请到，通过enter_memory_pressure
	并通过sk_stream_moderate_sndbuf调整sndbuf
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1930</x>
      <y>259</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1958</x>
      <y>256</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_copy_to_page</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1951</x>
      <y>262</y>
      <w>29</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果ip_summed是CHECKSUM_NONE，通过
	csum_and_copy_from_user复制数据到page
	并计算skb-&gt;csum
2.否则通过copy_from_user直接将数据复制到page
3.调整skb的信息
	skb-&gt;len	     += copy;
	skb-&gt;data_len	     += copy;
	skb-&gt;truesize	     += copy;
	sk-&gt;sk_wmem_queued   += copy;
	sk-&gt;sk_forward_alloc -= copy;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1963</x>
      <y>259</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2000</x>
      <y>256</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_push_one</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1989</x>
      <y>262</y>
      <w>34</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.通过tcp_init_tso_segs初始化分段信息
2.通过tcp_snd_test检查nagle，拥塞窗口，滑动窗口
3.如果窗口允许发送
	1.如果发送段超过1个
		1.通过tcp_snd_test检查所有的段中有多少可以发送，然后向下对mss取整
	2..如果超过了限制，通过tso_fragment对skb分段
	3.TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;
	4.tcp_transmit_skb发送skb
	5.如果发送成功update_send_head更新sk_send_head
		并通过tcp_cwnd_validate重新验证拥塞窗口
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2004</x>
      <y>259</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1567</x>
      <y>251</y>
      <w>95</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>930.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1600</x>
      <y>251</y>
      <w>65</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>630.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1644</x>
      <y>251</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1675</x>
      <y>251</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1677</x>
      <y>251</y>
      <w>59</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;570.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1679</x>
      <y>251</y>
      <w>154</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1520.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1686</x>
      <y>251</y>
      <w>203</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2010.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1686</x>
      <y>251</y>
      <w>244</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2420.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1688</x>
      <y>251</y>
      <w>278</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2760.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1687</x>
      <y>251</y>
      <w>320</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3180.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1815</x>
      <y>472</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_syn_build_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1823</x>
      <y>456</y>
      <w>43</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;160.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1809</x>
      <y>479</y>
      <w>34</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.报告本段的mss
	*ptr++ = htonl((TCPOPT_MSS &lt;&lt; 24) | (TCPOLEN_MSS &lt;&lt; 16) | mss);
2.如果要发时间戳
	1.如果需要延迟应答sack
		*ptr++ = htonl((TCPOPT_SACK_PERM &lt;&lt; 24) | (TCPOLEN_SACK_PERM &lt;&lt; 16) |
				       (TCPOPT_TIMESTAMP &lt;&lt; 8) |TCPOLEN_TIMESTAMP);
	2.否则
		*ptr++ = htonl((TCPOPT_NOP &lt;&lt; 24) | (TCPOPT_NOP &lt;&lt; 16) |
				       (TCPOPT_TIMESTAMP &lt;&lt; 8) |TCPOLEN_TIMESTAMP);
	3.添加时间戳和回显
		*ptr++ = htonl(tstamp);		/* TSVAL */
		*ptr++ = htonl(ts_recent);	/* TSECR *
3.如果只需要延迟应答
	*ptr++ = htonl((TCPOPT_NOP &lt;&lt; 24) | (TCPOPT_NOP &lt;&lt; 16) |
			       (TCPOPT_SACK_PERM &lt;&lt; 8) | TCPOLEN_SACK_PERM);
4.如果需要窗口扩大因子
	*ptr++ = htonl((TCPOPT_NOP &lt;&lt; 24) |
			       (TCPOPT_WINDOW &lt;&lt; 16) | (TCPOLEN_WINDOW &lt;&lt; 8) |
			       (wscale));
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1822</x>
      <y>475</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1864</x>
      <y>470</y>
      <w>22</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_build_and_update_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1873</x>
      <y>456</y>
      <w>5</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1852</x>
      <y>477</y>
      <w>39</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.如果需要时间戳(tstamp_ok)
	*ptr++ = htonl((TCPOPT_NOP &lt;&lt; 24) |(TCPOPT_NOP &lt;&lt; 16) |
			       (TCPOPT_TIMESTAMP &lt;&lt; 8) |TCPOLEN_TIMESTAMP);
		*ptr++ = htonl(tstamp);//时间戳
		*ptr++ = htonl(tp-&gt;rx_opt.ts_recent);//回显
2.如果需要延迟应答(eff_sacks)
	*ptr++ = htonl((TCPOPT_NOP  &lt;&lt; 24) |(TCPOPT_NOP  &lt;&lt; 16) |
			       (TCPOPT_SACK &lt;&lt;  8) |(TCPOLEN_SACK_BASE + (tp-&gt;rx_opt.eff_sacks *
						     TCPOLEN_SACK_PERBLOCK)));
	//sp如果在dsack时指向duplicate_sack，否则指向selective_acks
	*ptr++ = htonl(sp[this_sack].start_seq);
	*ptr++ = htonl(sp[this_sack].end_seq);
	//如果dsack置上
	tp-&gt;rx_opt.dsack = 0;
	tp-&gt;rx_opt.eff_sacks--;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1872</x>
      <y>473</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1833</x>
      <y>1485</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_sacktag_write_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1829</x>
      <y>1478</y>
      <w>17</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1826</x>
      <y>1492</y>
      <w>39</w>
      <h>201</h>
    </coordinates>
    <panel_attributes>1.如果选择性应答的包(sacked_out)是0，因为faskets_out
	是根据sacked_out来的，所以：
	tp-&gt;fackets_out = 0
2.暂存fackets_out
	prior_fackets = tp-&gt;fackets_out;
3.循环读取tcp选项中的sack
	1.只有在第1个sack的end_seq增加，其他sack都没变的时候，flag=1，快路径
		否则flag=0，慢路径
	2.存储seq到cache
		tp-&gt;recv_sack_cache[i].start_seq = start_seq;
		tp-&gt;recv_sack_cache[i].end_seq = end_seq;
	3.检查重复的sack（只检查第一个sack）
		1.如果sack的start_seq已经被应答(在ack之前)
			dup_sack = 1;
			tp-&gt;rx_opt.sack_ok |= 4;
		2.如果sack不止一个，并且第一个sack和第二个sack有重复的部分
			dup_sack = 1;
			tp-&gt;rx_opt.sack_ok |= 4;
		注：1.RFC规定只能有一个dsack，记录这第一个dup_sack的段
			2.这里有可能是因为网络重发包导致的，所以这里只递减一个(有可能之后的全部dsack，但是这里只减一个)
		3.如果是重复应答(dup_sack)，undo_marker &lt;end_seq&lt;prior_snd_una
			tp-&gt;undo_retrans--;
		注：undo_marker为超时重传记录的una
			undo_retrans减到0，表示之前的重传是不必要的，重新调整拥塞窗口
			
		4.如果ack在已经回复的prior_snd_una之前一个窗口max_window
			返回0，不做处理
4.如果flag为1，表示只有第一个sack end_seq变化，所以num_sacks = 1;
  如果flag为0，对tcp头部选项的sack进行冒泡排序(最多只有4个sack)
  tp-&gt;fastpath_skb_hint = NULL;//清除快速路径
5.重置flag，再次遍历sack
	1.如果有快速路径
		skb = tp-&gt;fastpath_skb_hint;//从上一次遍历开始
		fack_count = tp-&gt;fastpath_cnt_hint;
	如果是慢路径
		skb = sk-&gt;sk_write_queue.next;//对队列头开始
		fack_count = 0;
	2.如果对high_seq做了应答(end_seq在其之后)
		flag |= FLAG_DATA_LOST;
	注：high_seq记录的是Loss和Recorvery时，记录的snd_nxt
	因为重复应答或者超时，所以才Recorvery或者Loss,如果应答了
	此时的snd_nxt，说明之前的包可能存在丢失
	3.沿着skb遍历链表，直到遍历到sk_write_queue
		1.更新快速路径
			tp-&gt;fastpath_skb_hint = skb;
			tp-&gt;fastpath_cnt_hint = fack_count;
		2.如果链表中skb的seq在sack end_seq之后，说明该skb没被
			sack应答，直接退出循环
		注：因为重传时保持顺序的，所以这里直接退出循环
		3.如果sack的段包含skb的段，in_sack置上
		4.如果skb分为多段，并且skb一部分在sack内(!sack  &amp;&amp; skb.end_seq&gt;start_seq)
			1.如果skb的前半部分不在sack内，pkt_len记录其不在sack的长度
			2.如果skb的前半部在sack内，pkt_len记录其在sack的长度
			3.通过tcp_fragment对skb分段，并获取新分段
		注：经分段后，in_sack代表这最新skb是否在sack内(in_sack在这里被改动过)
			之后的分段会当作另一个skb对sack进行验证
		5.更新快速应答
			fack_count += pcount;
		6.获取skb的计分板(注意这里时发送的skb)
		7.如果重复应答dup_sack，并且重传(TCPCB_RETRANS)的skb在sack内,tp-&gt;undo_retrans--
		注：因为收到了dup_sack，之前的重传有可能是乱序导致的，所以这里偏保守的，将所有被应答的重传是不必要的
		8.如果被应答了(skb.endseq在窗口una前)
			1.scoreboard记录了R |S,并且dsack（表示之前被sacked，现在又被dsack），表示乱序
				reord = min(fack_count, reord);//fack_count记录者包结束的点
			2.如果在之前的prior_fackets之前，之前没被sack，也没被重发，现在才被sack，所以乱序
				reord = min(fack_count, reord);
			3.因为skb已经被应答，所以continue
		9.如果skb被重发，但是应答的sack的end_seq在重发包的next之后，可能重发包
			丢失(如果检查重发包的丢失，用sack的start_seq不是更准确吗)
		注：1.TCP_SKB_CB(skb)-&gt;ack_seq在tcp_retransmit_skb中被设置为
				tp-&gt;snd_nxt，正常发送的时候并没有设置
			2.这里遍历的skb的条件：
				1.在prior_snd_una之后，因为其还在queue中，所以在窗口左边界之后
				2.在sack的end_seq之前，之前有过判断，不在遍历的sack之前就退出
				3.在两个sack对应的hole中间，因为fastpath_skb_hint记录了上一个
					sack遍历的最后一个skb，最新的sack是从这个开始的
				4.因为之前做了分段，所以此时的skb要么完全在sack内，要么完全不在
		10.如果不在sack内，继续遍历下一个skb
		11.如果之前没被sack
			1.重发(也就是R | S置上)，如果同时也被标记为lost
				TCP_SKB_CB(skb)-&gt;sacked &amp;= ~(TCPCB_LOST|TCPCB_SACKED_RETRANS);//清除 R|L
				tp-&gt;lost_out -= tcp_skb_pcount(skb);//因为被acked，所以将lost清掉
				tp-&gt;retrans_out -= tcp_skb_pcount(skb);//将重传也清掉
				tp-&gt;retransmit_skb_hint = NULL;
				注：如果没被标记为lost，现在被sack可能是之前发的，所以不做处理
			2.如果没被重发，
					1.应答的包(因为之前的判断了不是insack，就继续下一个skb)在之前
						prior_fackets之前，说明skb被延迟
						reord = min(fack_count, reord);
					2.如果之前被标记为lost，恢复之前的标志
						TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_LOST;
						tp-&gt;lost_out -= tcp_skb_pcount(skb);
						tp-&gt;retransmit_skb_hint = NULL;
			3.标记被sack	
				TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_SACKED_ACKED;
				flag |= FLAG_DATA_SACKED;
				tp-&gt;sacked_out += tcp_skb_pcount(skb);
			4.更新facket_out
				tp-&gt;fackets_out = fack_count
		12.如果有被sacked，并且现在是dupsack，skb也被重发，说明乱序
			reord = min(fack_count, reord);
		13.如果dupsack，并且被标记为重发，（这里skb insack），表示skb被错误重发(和5.3.7对应)
			TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_SACKED_RETRANS;
			tp-&gt;retrans_out -= tcp_skb_pcount(skb);
			tp-&gt;retransmit_skb_hint = NULL;
6.如果检测到丢包(lost_retrans),并且处于Recovery
	1.从头遍历sk_write_queue中的skb
	2.skb要在新的窗口左边界tp-&gt;snd_una到lost_retrans之间
	3.如果被重发，并且lost_retrans在skb重发时的snd_next之后，
	并且是IsFack，或者lost_retrans在snd_next+reordering*mss_cache之后，超过了之前乱序的长度
		1.清除重发
			TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_SACKED_RETRANS;
			tp-&gt;retrans_out -= tcp_skb_pcount(skb);
			tp-&gt;retransmit_skb_hint = NULL;
		2.如果之前lost和sack都没被标记
			tp-&gt;lost_out += tcp_skb_pcount(skb);
			TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST;
			flag |= FLAG_DATA_SACKED;
	注：这里的lost_retrans记录的是sack的endseq，如果是start_seq不是更好吗,这个在第三个条件可以解答吗？
7.更新不在网络上传输的包数量
	tp-&gt;left_out = tp-&gt;sacked_out + tp-&gt;lost_out;
8.如果在facket之前出现了乱序，并且不处于loss，通过tcp_update_reordering更新乱序的长度
注：1.收到的TCP_SKB_CB(ack_skb)-&gt;sacked在tcp_parse_options
	中记录的是sack指针的偏移
	2.发送的sacked用于记分板
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1842</x>
      <y>1488</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1842</x>
      <y>1478</y>
      <w>37</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;350.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1834</x>
      <y>1696</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_update_reordering</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1842</x>
      <y>1692</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1827</x>
      <y>1703</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果乱序的长度比之前大
	tp-&gt;reordering = min(TCP_MAX_REORDERING, metric);
2.清除fack
	tp-&gt;rx_opt.sack_ok &amp;= ~2;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1840</x>
      <y>1699</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1871</x>
      <y>1485</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_clean_rtx_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1867</x>
      <y>1492</y>
      <w>40</w>
      <h>73</h>
    </coordinates>
    <panel_attributes>1.循环从sk_write_queue取skb，直到最新要发送的skb sk_send_head
	1.如果skb的end_seq还没被ack
		1.如果skb被分段，并且部分被ack，通过tcp_tso_acked处理
		2.退出skb队列的遍历
	注:只遍历被ack的skb
	2.如果没置syn	
			acked |= FLAG_DATA_ACKED;
			++pkts_acked;
		如果置上了syn
			acked |= FLAG_SYN_ACKED;
			tp-&gt;retrans_stamp = 0;
	3.如果skb之前做了mtu probe，通过tcp_mtup_probe_success
		更新窗口信息
	4.如果被sacked
		1.如果被重传
			tp-&gt;retrans_out -= tcp_skb_pcount(skb);
			acked |= FLAG_RETRANS_DATA_ACKED;
			seq_rtt = -1;
		2.否则，当seq_rtt &lt; 0
			seq_rtt = now - scb-&gt;when;//记录正确传输的seq
			skb_get_timestamp(skb, &amp;tv);
		3.如果之前被sacked过
			tp-&gt;sacked_out -= tcp_skb_pcount(skb)
		4.如果之前lost
			tp-&gt;lost_out -= tcp_skb_pcount(skb);
		5.如果skb的urg置上，并且tp.urg_mode，指向的紧急指针在
			skb之后
			tp-&gt;urg_mode = 0
	5.如果没sacked，说明skb是被正常收到，如果之前没记录seq_rtt
		seq_rtt = now - scb-&gt;when;
		skb_get_timestamp(skb, &amp;tv);
	6.通过tcp_dec_pcount_approx递减其fackets_out
	注:通过tcp_sacktag_write_queue可知fackets_out记录这sack的最高seq的skb
	7.通过tcp_packets_out_dec递减其packets_out
	8.通过__skb_unlink将skb从sk_write_queue队列中移除
	9.通过sk_stream_free_skb释放skb
	10.通过clear_all_retrans_hints清除所有的hint
2.如果syn或者data被应答
	1.通过tcp_ack_update_rtt更新rtt和rto
	2.通过tcp_ack_packets_out更新重传定时器
	3.如果不是重传段，通过icsk-&gt;icsk_ca_ops-&gt;rtt_sample进行rtt采样
	4.通过icsk-&gt;icsk_ca_ops-&gt;pkts_acked进行拥塞算法的处理
3.返回rtt和acked
	seq_rtt_p = seq_rt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1878</x>
      <y>1488</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1873</x>
      <y>1569</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_tso_acked</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1868</x>
      <y>1577</y>
      <w>34</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>1.tcp_trim_head将前面的窗口左边界前的数据区域清空
2.通过计算skb段的改变，计算其ack的包的数量packets_acked
3.如果ack满mss
	1.acked |= FLAG_DATA_ACKED;
	2.如果之前被sacked
		1.如果被重发过
			tp-&gt;retrans_out -= packets_acked;//调整重发包的数目
			acked |= FLAG_RETRANS_DATA_ACKED;
			*seq_rtt = -1;
		2.如果没被重发，并且之前也没有rtt时间内应答的skb，记录
			*seq_rtt = now - scb-&gt;when
		3.如果被sacked
			tp-&gt;sacked_out -= packets_acked;
		4.如果lost
			tp-&gt;lost_out -= packets_acked
		5.如果被设置为urg，但是紧急指针的seq已应答
			tp-&gt;urg_mode = 0;
	3.如果没被sacked，记录被按时应答的计时
		*seq_rtt = now - scb-&gt;when
	4.更新其facked
		tp-&gt;fackets_out -= dval
	5.更新tp-&gt;packets_out -= packets_acked
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1879</x>
      <y>1572</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1874</x>
      <y>1616</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_trim_head</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1868</x>
      <y>1623</y>
      <w>32</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果skb是被cloned，并且被多次引用，通过
	pskb_expand_head进行写时复制。
2.如果要清空的长度小于headlen，通过__skb_pull
	直接移动data指针，并调整skb-&gt;len -= len;
3.否则通过__pskb_trim_head来清空
4.调整skb的计数
	TCP_SKB_CB(skb)-&gt;seq += len;
	skb-&gt;ip_summed = CHECKSUM_PARTIAL;
	skb-&gt;truesize	     -= len;
	sk-&gt;sk_wmem_queued   -= len;
	sk-&gt;sk_forward_alloc += len;
	sock_set_flag(sk, SOCK_QUEUE_SHRUNK);
5.如果skb被分段，通过tcp_set_skb_tso_segs将其重新
	分段
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1879</x>
      <y>1619</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1873</x>
      <y>1651</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pskb_expand_head</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1868</x>
      <y>1659</y>
      <w>33</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.skb不能被多个user使用(skb_shared)
2.通过kmalloc申请新的data size和skb_shared_info
3.复制head~tail的内容到data+nhead，即在data前预留nhead的空间
4.将skb_shared_info复制到data尾端，即在data后预留ntail的空间
5.通过get_page和skb_clone_fraglist增加skb_shared_info
	中page和skb的计数
6.通过skb_release_data释放原来skb对page和skb的引用
注：是在skb没被clone，或者clone了但是只有一个引用时候，才会真正的释放
7.计算head所在的位置相对于原来的偏移off，然后
	重新计算skb内的指针
	skb-&gt;head     = data;
	skb-&gt;end      = data + size;
	skb-&gt;data    += off;
	skb-&gt;tail    += off;
	skb-&gt;mac.raw += off;
	skb-&gt;h.raw   += off;
	skb-&gt;nh.raw  += off;
	skb-&gt;cloned   = 0;
	skb-&gt;nohdr    = 0;
	atomic_set(&amp;skb_shinfo(skb)-&gt;dataref, 1);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1879</x>
      <y>1654</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1905</x>
      <y>1651</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__pskb_trim_head</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1910</x>
      <y>1654</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1903</x>
      <y>1659</y>
      <w>25</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.遍历skb的nr_frags
	1.将整个frag都在len长度内的frag通过put_page释放，并调整要释放的长度
	2.将之后的frag挪移到索引0开始的位置
	3.通过调整page_offset和size，将frag内在释放区域的数据释放
2.调整skb的计数
	skb_shinfo(skb)-&gt;nr_frags = k;
	skb-&gt;tail = skb-&gt;data;
	skb-&gt;data_len -= len;
	skb-&gt;len = skb-&gt;data_len;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1878</x>
      <y>1646</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1896</x>
      <y>1646</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1879</x>
      <y>1613</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1950</x>
      <y>1570</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_stream_free_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1947</x>
      <y>1577</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>sock_set_flag(sk, SOCK_QUEUE_SHRUNK);
sk-&gt;sk_wmem_queued   -= skb-&gt;truesize;
sk-&gt;sk_forward_alloc += skb-&gt;truesize;
__kfree_skb(skb);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1958</x>
      <y>1573</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1986</x>
      <y>1569</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>clear_all_retrans_hints</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1985</x>
      <y>1575</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>tp-&gt;lost_skb_hint = NULL;
	tp-&gt;scoreboard_skb_hint = NULL;
	tp-&gt;retransmit_skb_hint = NULL;
	tp-&gt;forward_skb_hint = NULL;
	tp-&gt;fastpath_skb_hint = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1994</x>
      <y>1572</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2015</x>
      <y>1568</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_ack_update_rtt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2010</x>
      <y>1575</y>
      <w>28</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果收到时间戳，并且正确回显(rcv_tsecr)
	通过tcp_ack_saw_tstamp估算rtt和设置rto
2.否则，存在seq_rtt时，通过tcp_ack_no_tstamp
	估算rtt和rto
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2021</x>
      <y>1571</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2011</x>
      <y>1587</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_ack_saw_tstamp</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2005</x>
      <y>1594</y>
      <w>24</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.通过tcp_rtt_estimator利用时间戳信息估算rtt
2.通过tcp_set_rto设置rto
3.重置backoff
	inet_csk(sk)-&gt;icsk_backoff = 0;
4.tcp_bound_rto限制rto
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2015</x>
      <y>1590</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2034</x>
      <y>1587</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_ack_no_tstamp</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2040</x>
      <y>1590</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2032</x>
      <y>1594</y>
      <w>24</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.相比tcp_ack_saw_tstamp的区别
	1.不能是重传应答
	2.没使用时间戳
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2018</x>
      <y>1583</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2032</x>
      <y>1583</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2050</x>
      <y>1568</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_ack_packets_out</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2044</x>
      <y>1576</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果网络上没包，通过inet_csk_clear_xmit_timer
	将重传定时器清除
2.否则重新计时重传定时器为rto
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2059</x>
      <y>1571</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1876</x>
      <y>1564</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1901</x>
      <y>1564</y>
      <w>159</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1570.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1893</x>
      <y>1564</y>
      <w>64</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1895</x>
      <y>1564</y>
      <w>98</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;960.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1896</x>
      <y>1564</y>
      <w>126</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1240.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1912</x>
      <y>1486</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_ack_is_dubious</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1847</x>
      <y>1478</y>
      <w>74</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;720.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1908</x>
      <y>1493</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果接收ack重复(没收到data，窗口没更新，并且没被acked)
2.如果被通知拥塞(sacked 或者ece)
3.如果不处于TCP_CA_Open
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1919</x>
      <y>1489</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1947</x>
      <y>1484</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_may_raise_cwnd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1855</x>
      <y>1478</y>
      <w>100</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;980.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1942</x>
      <y>1491</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.没置ece，或者拥塞窗口没达到限制snd_ssthresh
2.并且不处于TCPF_CA_Recovery或者TCPF_CA_CWR
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1954</x>
      <y>1487</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1590</x>
      <y>363</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_mtu_probe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1576</x>
      <y>369</y>
      <w>43</w>
      <h>94</h>
    </coordinates>
    <panel_attributes>1.下述情况直接返回-1
	1.路径mtu没被启用(!icsk-&gt;icsk_mtup.enabled)
	2.已经探测到路径mtu(probe_size)
	3.拥塞不处于open状态
	4.拥塞窗口小于11
	5.下一个发送段要发送sack(eff_sack)
2.用2mss作为路径mtu的探测值，但是不能超过其限值search_high
	否则，返回-1
3.取发送对列中（sk_send_head）的skb，如果队列中的skb的长度
	不超过probe_size，返回-1
4.窗口的大小要是probe_size的2倍，因为3中遍历了probe_size大小的skb
	然后这里要求seq + probe_size不超过窗口的右边界
	1.如果超过了，但是窗口大小就小于probe_size，返回-1
	2.超过了，但是窗口大小大于probe_size，这里可能是因为skb没被ack，返回0，等待发送
5.网络上正在传输的包（tcp_packets_in_flight），不能超过拥塞窗口2个mss
	1.如果是网络上没包，返回-1
	2.否则返回0等待
6.通过sk_stream_alloc_skb申请skb，数据大小为probe_size，并通过
	sk_charge_skb更新sk内内存的申请信息
7.将新申请的skb放在队列头：
	skb = sk-&gt;sk_send_head;
	__skb_insert(nskb, skb-&gt;prev, skb, &amp;sk-&gt;sk_write_queue);
	sk-&gt;sk_send_head = nskb;
8.初始化nskb的tcp头部信息
	TCP_SKB_CB(nskb)-&gt;seq = TCP_SKB_CB(skb)-&gt;seq;
	TCP_SKB_CB(nskb)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;seq + probe_size;
	TCP_SKB_CB(nskb)-&gt;flags = TCPCB_FLAG_ACK;
	TCP_SKB_CB(nskb)-&gt;sacked = 0;
	nskb-&gt;csum = 0;
	nskb-&gt;ip_summed = skb-&gt;ip_summed;
9.复制skb中的数据到新的skb
	1.如果之前有做校验（ip_summed），通过skb_copy_bits将数据复制到
		通过skb_put申请的尾端空间
	2.否则通过skb_copy_and_csum_bits复制数据并重新校验
	3.如果将skb中的数据复制完，nskb完全集成skb的flag，并将skb移除
		TCP_SKB_CB(nskb)-&gt;flags |= TCP_SKB_CB(skb)-&gt;flags;
		__skb_unlink(skb, &amp;sk-&gt;sk_write_queue);
		sk_stream_free_skb(sk, skb);
	4.否则
		1.不能集成skb的fin和push标志
			TCP_SKB_CB(nskb)-&gt;flags |= TCP_SKB_CB(skb)-&gt;flags &amp;
			                           ~(TCPCB_FLAG_FIN|TCPCB_FLAG_PSH);
		2.如果没有frag，通过skb_pull释放data内的数据，如果没计算checksum
			通过csum_partial重新计算
		3.如果有，通过__pskb_trim_head释放，并通过tcp_set_skb_tso_segs
			对skb重新分段
			TCP_SKB_CB(skb)-&gt;seq += copy
		注：__pskb_trim_head这里应该有bug，在4.4.0中，先释放data内的数据
5.tcp_init_tso_segs初始化nskb的分段，并设置
	TCP_SKB_CB(nskb)-&gt;when = tcp_time_stamp
6.通过tcp_transmit_skb发送skb
	1.递减拥塞窗口tp-&gt;snd_cwnd--
	2.update_send_head
	3.icsk-&gt;icsk_mtup.probe_size = tcp_mss_to_mtu(sk, nskb-&gt;len);
		tp-&gt;mtu_probe.probe_seq_start = TCP_SKB_CB(nskb)-&gt;seq;
		tp-&gt;mtu_probe.probe_seq_end = TCP_SKB_CB(nskb)-&gt;end_seq;
	4.返回1
7.出错，返回-1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1595</x>
      <y>366</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1576</x>
      <y>466</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_copy_bits</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1566</x>
      <y>473</y>
      <w>33</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.off+len不能超过skb的总长度skb-&gt;len，
	这里用减法是为了防止越界
2.查看data段是否有数据需要复制，复制之后调整off
3.查看nr_frags是否有数据复制，通过kmap_skb_frag
	申请页面，并将数据复制到页面
4.查看frag_list是否有数据需要复制，通过skb_copy_bits
	递归进行复制
注：off:skb复制数据的其实点，从skb.data开始算
	start:skb data内的所有数据的结束位置
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1580</x>
      <y>469</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1906</x>
      <y>1569</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_mtup_probe_success</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1889</x>
      <y>1564</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1581</x>
      <y>462</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2168</x>
      <y>1284</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_err</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2173</x>
      <y>1287</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
type=ICMP_DEST_UNREACH
code=ICMP_FRAG_NEEDED</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2165</x>
      <y>1292</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_pmtu_discovery</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2155</x>
      <y>1299</y>
      <w>36</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.sk不处于TCP_LISTEN状态，因为这个不能做路径mtu
2.__sk_dst_check检查路由缓存不能为空
3.dst-&gt;ops-&gt;update_pmtu更新路由缓存项度量值
4.如果mtu小于路径mtu返回的 dst_mtu(dst)，并且包设
	值的是不可分割ip_dont_fragment，标记错误
	sk-&gt;sk_err_soft = EMSGSIZE
5.如果pmtudisc要求不可分割，并且缓存值(icsk_pmtu_cookie)
	大于路径mtu返回的值dst_mtu
	1.tcp_sync_mss利用det_mtu同步mss
	2.tcp_simple_retransmit进行重发
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2168</x>
      <y>1295</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1904</x>
      <y>1577</y>
      <w>39</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.tp-&gt;prior_ssthresh = tcp_current_ssthresh(sk);//保存窗口限制
	tp-&gt;snd_cwnd = tp-&gt;snd_cwnd *						
		       tcp_mss_to_mtu(sk, tp-&gt;mss_cache) /
		       icsk-&gt;icsk_mtup.probe_size;	//以probe_size为单位，重新计算snd_cwnd
	tp-&gt;snd_cwnd_cnt = 0;
	tp-&gt;snd_cwnd_stamp = tcp_time_stamp;
	tp-&gt;rcv_ssthresh = tcp_current_ssthresh(sk);//接收窗口的限值
2.icsk-&gt;icsk_mtup.search_low = icsk-&gt;icsk_mtup.probe_size;//更新mss的最低值
	icsk-&gt;icsk_mtup.probe_size = 0;
	tcp_sync_mss(sk, icsk-&gt;icsk_pmtu_cookie);//更新mss
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1914</x>
      <y>1572</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2166</x>
      <y>1319</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_simple_retransmit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2169</x>
      <y>1315</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2153</x>
      <y>1326</y>
      <w>38</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.遍历重传队列(sk_write_queue~sk_send_head)，如果skb的长度
	超过了mss，并且没被sacked
	1.如果被重发，
		TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_SACKED_RETRANS;//清除重发标志
		tp-&gt;retrans_out -= tcp_skb_pcount(skb);//递减被重发的包
	2.如果没被标记为lost
		TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST //标记为lost
		tp-&gt;lost_out += tcp_skb_pcount(skb);//递增丢包的计数
		lost = 1;
2.通过clear_all_retrans_hints清除所有hint
3.如果没检查到包lost，直接return，不做处理
4.通过tcp_sync_left_out更新sacked_out和left_out
5.如果不处于TCP_CA_Loss，将拥塞状态改为loss
	tp-&gt;high_seq = tp-&gt;snd_nxt;
	tp-&gt;snd_ssthresh = tcp_current_ssthresh(sk);
	tp-&gt;prior_ssthresh = 0;
	tp-&gt;undo_marker = 0;
	tcp_set_ca_state(sk, TCP_CA_Loss);
6.通过tcp_xmit_retransmit_queue重发
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2168</x>
      <y>1322</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2148</x>
      <y>1362</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_sync_left_out</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2142</x>
      <y>1369</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.sacked_out不能超过tp-&gt;packets_out - tp-&gt;lost_out
2.没被正常ack的
	tp-&gt;left_out = tp-&gt;sacked_out + tp-&gt;lost_out
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2153</x>
      <y>1365</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2154</x>
      <y>1357</y>
      <w>9</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2176</x>
      <y>1362</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_xmit_retransmit_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2181</x>
      <y>1357</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2185</x>
      <y>1365</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2170</x>
      <y>1369</y>
      <w>37</w>
      <h>56</h>
    </coordinates>
    <panel_attributes>1.如果存在retransmit_skb_hint，从retransmit_skb_hint开始遍历
	否则从sk_write_queue开始遍历
2.如果存在lost_out
	1.从1选的skb开始遍历
		1.保存
			tp-&gt;retransmit_skb_hint = skb;
			tp-&gt;retransmit_cnt_hint = packet_cnt;
		2.如果网络上的包超过了拥塞窗口，直接返回
		3.如果skb被标记为lost
			1.如果R |S 都没置上
				1.通过tcp_retransmit_skb发送skb，发送成功将retransmit_skb_hint
					清空，并返回
				2.如果skb是sk_write_queue的首个skb，通过inet_csk_reset_xmit_timer
					重置重发定时器ICSK_TIME_RETRANS
			2.累计packet_cnt，如果超过了lost_out，退出循环
注；这里是发标记为lost的skb，下面重发没有任何标记的skb，保持网络上包的总数不变(重发recorvery阶段需要发的skb)
3.不处于TCP_CA_Recovery状态，直接返回
4.如果没有被sacked(sack_ok),直接返回
5.如果有其他要发送的skb（tcp_may_send_now）,直接返回
6.如果存在forward_skb_hint，从forward_skb_hint开始遍历
	否则从sk_write_queue开始遍历
7.遍历skb~sk_send_head，
	1.保存
		tp-&gt;forward_cnt_hint = packet_cnt;
		tp-&gt;forward_skb_hint = skb;
	2.如果foward的skb超过了fackets_out，说明没有空闲的容纳
		foward，直接退出
	3.如果网络上传输的超过了拥塞窗口snd_cwnd，直接退出
	4.如果skb R | S |L中又被置上的，直接退出，因为该重发
		的在之前已经被重发
	5.通过tcp_retransmit_skb重发，成功之后，清除forward_skb_hint
		并退出循环
	6.失败后，如果是sk_write_queue中第一个skb，通过inet_csk_reset_xmit_timer
		重置重发定时器ICSK_TIME_RETRANS
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2180</x>
      <y>1428</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_retransmit_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2186</x>
      <y>1424</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2161</x>
      <y>1435</y>
      <w>42</w>
      <h>65</h>
    </coordinates>
    <panel_attributes>1.清空probe_size
2.如果申请的sk_wmem_alloc超过了min(sk_sndbuf,5/4 sk_wmem_queued)
	返回EAGAIN
	注：1/4的sk_wmem_queued用来做其他工作
3.如果seq没超了snd_una
	1.如果end_seq也没超过snd_una，说明skb已经被应答，不应该重发，所以出错
	2.通过tcp_trim_head将被应答的部分清空，如果失败，返回ENOMEM
4.如果skb在滑动窗口外（可能是接受方收缩了窗口），返回EAGAIN
5.如果skb的长度超过了mss，通过tcp_fragment对skb分段
注：路径mtu已经在之前同步了mss
6.如果启用了sysctl_tcp_retrans_collapse，通过tcp_retrans_try_collapse
	合并两个相邻的包：
	1.不是syn
	2.长度小于1/2mss
	3.next也是重传的skb
	4.两个skb都没有frags
	5.都没有被分段
7.通过icsk_af_ops-&gt;rebuild_header(sk)查询路由
8.如果skb有payload，并且fin，并且skb的payload已经被
	完全应答（3中没filter una==end_seq-1的情况）
	通过pskb_trim将payload清空
		TCP_SKB_CB(skb)-&gt;seq = TCP_SKB_CB(skb)-&gt;end_seq - 1;
		skb_shinfo(skb)-&gt;gso_segs = 1;
		skb_shinfo(skb)-&gt;gso_size = 0;
		skb_shinfo(skb)-&gt;gso_type = 0;
		skb-&gt;ip_summed = CHECKSUM_NONE;
		skb-&gt;csum = 0;
9.重发skb
	TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;
	err = tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);
10.如果发送成功
	1.tp-&gt;total_retrans++
	2.标记skb重发
		TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_RETRANS;
		tp-&gt;retrans_out += tcp_skb_pcount(skb);
	3.如果是第一次重发，打下时间戳
		tp-&gt;retrans_stamp = TCP_SKB_CB(skb)-&gt;when;
	4.tp-&gt;undo_retrans++;
	5.记下重发时的snd_nxt,检查重发段是否丢失
		TCP_SKB_CB(skb)-&gt;ack_seq = tp-&gt;snd_nxt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2184</x>
      <y>1431</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1422</x>
      <y>1209</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_rcv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1426</x>
      <y>1212</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1303</x>
      <y>1300</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pskb_may_pull</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1294</x>
      <y>1307</y>
      <w>36</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果长度小于skb_headlen，返回1，表示data段存在len长度
2.如果长度超过了skb-&gt;len，返回0
3.通过__pskb_pull_tail将len-skb_headlen(skb)的长度复制到
	data段，如果成功返回tail的指针，否则返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1308</x>
      <y>1303</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1298</x>
      <y>1318</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__pskb_pull_tail</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1304</x>
      <y>1314</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1283</x>
      <y>1325</y>
      <w>36</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.如果data段不够容纳delta的容量，或者skb clone，通过
	pskb_expand_head复制并扩充tail~end的长度
2.通过skb_copy_bits复制skb中frags的数据到tail~end
3.如果没有frag_list，直接取pull_pages将小于delta长度
	的frags释放
4.遍历frags，查看delta是否完全覆盖了frags，如果没完全覆盖
	跳到pull_pages，否则取释放frag_list
5.如果还存在eat
	1.循环遍历frag_list
		1.如果skb的长度小于剩下要释放的长度eat，就吃掉整个skb
		2.如果只能吃掉部分
			1.如果是skb_shared，通过skb_clone复制一个skb，insp记录第一个完整的skb
			2.通过pskb_pull递归的释放eat的长度，如果失败，返回NULL
			3.退出循环
	2.释放frag_list中的skb直到insp
	3.如果clone，将没释放的部分clone连接到链表frag_list中
6.pull_pages：释放frags中的数据，并调整i到k
7.调整数据信息
	skb_shinfo(skb)-&gt;nr_frags = k;
	skb-&gt;tail     += delta;
	skb-&gt;data_len -= delta;
8.返回tail指针
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1299</x>
      <y>1321</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1292</x>
      <y>1364</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pskb_pull</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1283</x>
      <y>1371</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果释放的长度超过了skb.len，返回NULL
2.否则通过__pskb_pull释放长度len
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1292</x>
      <y>1378</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__pskb_pull</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1295</x>
      <y>1367</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1297</x>
      <y>1375</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1284</x>
      <y>1385</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果长度超过了data的区域，通过__pskb_pull_tail
	将frag中的数据len-skb_headlen(skb)复制data
2.释放掉data段中长度len
	skb-&gt;len -= len
3.返回data的指针
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1297</x>
      <y>1381</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1298</x>
      <y>1360</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1350</x>
      <y>1299</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__inet_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1334</x>
      <y>1307</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__inet_lookup_established</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1365</x>
      <y>1307</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__inet_lookup_listener</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1341</x>
      <y>1302</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1357</x>
      <y>1302</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1330</x>
      <y>1313</y>
      <w>28</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.首先遍历ehash中是否有对应的sk
注：saddr和daddr在inet_sk中是紧挨着的
	dport和sport也是一样
2.再次遍历time_wait的ehash[ehash_size]
	查看是否有对应的sk
3.如果两次遍历中找到了sk，通过sock_hold
	递增sk的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1342</x>
      <y>1310</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1360</x>
      <y>1313</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.遍历hash表listening_hash
	1.如果hash表中只有一个sk，并且port和addr和
		skb中的目的地址相同，是PF_INET，并且sk_bound_dev_if
		为空，直接hold sk
	2.否则通过inet_lookup_listener_slow取查询sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1373</x>
      <y>1310</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1362</x>
      <y>1326</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_lookup_listener_slow</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1371</x>
      <y>1322</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1356</x>
      <y>1333</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.遍历head中的sk
	1.port相同，addr相同，sk_bound_dev_if相同
	2.如果PF_INET，直接找到，如果没有，找到第一个。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1369</x>
      <y>1329</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1412</x>
      <y>1215</y>
      <w>47</w>
      <h>63</h>
    </coordinates>
    <panel_attributes>1.要是单独发给本机的（pkt_type!=PACKET_HOST），否则释放skb，返回
2.通过pskb_may_pull查看skb的data是否有tcp头部的长度，如果没有，将
	其从frags复制到data
3.头部长度(4*doff)不能小于sizeof(struct tcphdr)
4.再次通过pskb_may_pull看是否能将doff * 4拉入到data段
5.如果ip_summed不是CHECKSUM_UNNECESSARY，通过tcp_v4_checksum_init
	对checksum进行初始化和check
6.初始化skb
	th = skb-&gt;h.th;
	TCP_SKB_CB(skb)-&gt;seq = ntohl(th-&gt;seq);
	TCP_SKB_CB(skb)-&gt;end_seq = (TCP_SKB_CB(skb)-&gt;seq + th-&gt;syn + th-&gt;fin +
				    skb-&gt;len - th-&gt;doff * 4);
	TCP_SKB_CB(skb)-&gt;ack_seq = ntohl(th-&gt;ack_seq);
	TCP_SKB_CB(skb)-&gt;when	 = 0;
	TCP_SKB_CB(skb)-&gt;flags	 = skb-&gt;nh.iph-&gt;tos;
	TCP_SKB_CB(skb)-&gt;sacked	 = 0;
7.通过__inet_lookup在hash表tcp_hashinfo中查找sk
8.如果没找到sk，跳到no_tcp_socket
9.如果sk处于TCP_TIME_WAIT，跳到do_time_wait
10.通过xfrm4_policy_check检查策略数据库，失败丢弃skb
11.nf_reset重置net_filter
12.检查skb是否能通过sk_filter，如果通过了才能放行，否则丢弃skb
13.skb-&gt;dev = NULL;
14.如果sk没被user锁住。通过tcp_prequeue或者tcp_v4_do_rcv接收skb
15.否则通过sk_add_backlog接收
16.sock_put释放sk，并返回
17.no_tcp_socket：
	1.xfrm4_policy_check检查数据库
	2.如果头部长度检查和checksum通过，通过tcp_v4_send_reset
		发送rst
	3.释放skb，返回0
18.do_time_wait
	1.通过xfrm4_policy_check检查，如果失败，inet_twsk_put释放tw，并丢弃skb
	2.首部检查和checksum检查，如果失败，inet_twsk_put释放tw，并丢弃skb
	3.tcp_timewait_state_process处理skb
		1.如果TCP_TW_SYN，重新连接。通过inet_lookup_listener查找listening_hash
			1.如果找到，通过inet_twsk_deschedule释放tw的关系（bhash，ehash，timer）
			最后通过inet_twsk_put释放tw
			2.替换sk，跳到9重新建立连接
			3如果没找到，跳到18.3.2
		2.如果是TCP_TW_ACK，tcp_v4_timewait_ack发送ack
		3.TCP_TW_RST，发送rst
		4.TCP_TW_SUCCESS，丢弃skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1594</x>
      <y>360</y>
      <w>131</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1290.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1448</x>
      <y>1297</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_prequeue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1440</x>
      <y>1303</y>
      <w>34</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果没开启sysctl_tcp_low_latency，并且用户正在读取
	数据（tp-&gt;ucopy.task）
	1.通过__skb_queue_tail将skb连接到队列tp-&gt;ucopy.prequeue
		tp-&gt;ucopy.memory += skb-&gt;truesize
	2.如果ucopy.memory超过了sk_rcvbuf
		1.循环通过__skb_dequeue取出prequeue中的skb，利用
			sk-&gt;sk_backlog_rcv处理
		2.tp-&gt;ucopy.memory = 0
	3.否则，在prequeue只有一个skb时，通过wake_up_interruptible
		唤醒sk_sleep,如果不需要ack，重置ICSK_TIME_DACK
	4.返回1，表示接收完成
2.返回0，表示没被接收
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1454</x>
      <y>1300</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1747</x>
      <y>1302</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_add_backlog</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1737</x>
      <y>1308</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果sk_backlog.tail没置上skb，说明队列中没skb
	sk-&gt;sk_backlog.head = sk-&gt;sk_backlog.tail = skb;
2.否则直接加入到tail之后
	sk-&gt;sk_backlog.tail-&gt;next = skb;
	sk-&gt;sk_backlog.tail = skb;
3.skb-&gt;next = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1754</x>
      <y>1305</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1411</x>
      <y>16</y>
      <w>970</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_SETSOCKOPT</panel_attributes>
    <additional_attributes>10.0;10.0;9060.0;30.0;9680.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2374</x>
      <y>19</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_setsockopt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2366</x>
      <y>26</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过sockfd_lookup_light找到sock
2.security_socket_setsockopt安全检查
3.如果level是SOL_SOCKET，调用sock_setsockopt
	否则调用sock-&gt;ops-&gt;setsockopt
4.fput_light释放sock
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2379</x>
      <y>22</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2338</x>
      <y>40</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_setsockopt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2343</x>
      <y>35</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SOL_SOCKET</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2344</x>
      <y>43</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SO_ATTACH_FILTER</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2327</x>
      <y>47</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.长度optlen要是sizeof(struct sock_fprog)
2.通过copy_from_user将sock_fprog从用户空间复制
3.sk_attach_filter安装filter
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2339</x>
      <y>56</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_attach_filter</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2345</x>
      <y>52</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2332</x>
      <y>63</y>
      <w>28</w>
      <h>23</h>
    </coordinates>
    <panel_attributes>1.要安装的filter数组fprog-&gt;filter不能为空
2.通过sock_kmalloc申请容器sk_filter和其中
	filter数组的空间
3.通过copy_from_user将filter数组从用户空间
	复制到fp-&gt;insns，如果失败，就通过sock_kfree_s
	释放之前的空间
4.初始化sk_filter
	atomic_set(&amp;fp-&gt;refcnt, 1);
	fp-&gt;len = fprog-&gt;len;
5.通过sk_chk_filter检查是否filter的长度超限
	或者filter中是否有未知指令
6.如果成功，将的的fp更换old_fp
7.如果old_fp存在，通过sk_filter_release将其
	释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2343</x>
      <y>59</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1402</x>
      <y>1299</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_filter</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1393</x>
      <y>1306</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.security_sock_rcv_skb进行安全检查
2.通过sk_run_filter取出sk_filter中的filter数组执行
3.通过pskb_trim将skb  pkt_len之后的数据释放掉
注：sk_run_filter是filter的解释器，就像解释执行汇编
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1408</x>
      <y>1302</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1402</x>
      <y>1316</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pskb_trim</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1406</x>
      <y>1313</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1407</x>
      <y>1319</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1403</x>
      <y>1323</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__pskb_trim</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1402</x>
      <y>1326</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果有datalen</panel_attributes>
    <additional_attributes>60.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1399</x>
      <y>1330</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>___pskb_trim</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1414</x>
      <y>1330</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__skb_trim</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1410</x>
      <y>1326</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1413</x>
      <y>1337</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>skb-&gt;len  = len;
skb-&gt;tail = skb-&gt;data + len
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1420</x>
      <y>1333</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1388</x>
      <y>1337</y>
      <w>23</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果skb_cloned，通过pskb_expand_head
	做写时复制
2.如果要保存的len在data内，直接到drop_pages
	把所有的frags释放掉
3.否则找到对应frag，将其之后的释放
4.如果要保存的len到了frag_list，通过pskb_trim
	递归释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1403</x>
      <y>1333</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1806</x>
      <y>1523</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_fast_path_check</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1812</x>
      <y>1520</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1796</x>
      <y>1530</y>
      <w>28</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.out_of_order_queue为空
2.可以被接收(rcv_wnd不为0)
3.sk_rmem_alloc&lt;sk_rcvbuf
4.没有带外数据(！urg_data)
5.上述4中情况满足，通过tcp_fast_path_on
	置pred_flags
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1811</x>
      <y>1526</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1803</x>
      <y>1543</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_fast_path_on</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1802</x>
      <y>1549</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__tcp_fast_path_on</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1808</x>
      <y>1539</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1808</x>
      <y>1546</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1798</x>
      <y>1555</y>
      <w>24</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.pred_flags=tcp_header_len &lt;&lt; 26
	| TCP_FLAG_ACK
	|  snd_wnd
注：tcp_header_len丢掉了低２位，从２８位开始
	pred_flags和tcp头部格式相同
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1808</x>
      <y>1552</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1326</x>
      <y>1356</y>
      <w>42</w>
      <h>102</h>
    </coordinates>
    <panel_attributes>1.如果tcp头部的第4个word和pred_flags相同(不考虑push)
	并且skb.seq正是预期接收的rcv_nxt，执行快速路径
	1.如果头部长度tcp_header_len是时间戳的长度
		1.如果选项不是时间戳，跳到slow_path
		2.给时间戳赋值
			tp-&gt;rx_opt.saw_tstamp = 1;
			++ptr; 
			tp-&gt;rx_opt.rcv_tsval = ntohl(*ptr);
			++ptr;
			tp-&gt;rx_opt.rcv_tsecr = ntohl(*ptr);
		3.如果收到的回显时间戳，如果比之前收到(ts_recent)的小
			paws不通过，跳到slow_path
	2.如果skb的长度&lt;=tcp_header_len
		1.如果是等于，没有payload，所以不需要更新rcv_nxt
			1.如果长度是时间戳的长度，并且rcv_nxt和rcv_wup相同(
				收到的所有数据都已经ack，因为rcv_wup是在发送数据时，
				更新window时更新的)，通过tcp_rcv_established存储
				ts_recent=rcv_tsval
			注:这里隐含了skb.seq和rcv_wup相同，因为rcv_wup之前的已经全部应答
				并且之前已经做了paws的确认。更新ts_recent的条件是收到了seq为rcv_wup
				即预期的seq
			2.tcp_ack处理skb
			3.__kfree_skb释放skb
			4.tcp_data_snd_check检查是否有发送数据并检查内存
			5.返回0
		注：此时没对ack的发送做处理
		2.如果是小于，就直接丢弃
	3.如果大于，即有payload
		1.如果所有的数据都被读取(copied_seq=rcv_nxt),并且有足
			够的空间供skb(ucopy.len&gt;len - tcp_header_len)
			1.通过tcp_dma_try_early_copy用dma复制
			2.如果上层等待的task(ucopy.task)是当前进程,并且sk被锁住
				(sock_owned_by_user),并且dma没有copy(!copied_early)
				1.通过__set_current_state将状态设置为TASK_RUNNING
				2.通过tcp_copy_to_iovec将skb的数据复制到iov中
			3.如果有复制数据到用户空间
				1.如果收到了timestamp，并且所有的数据就被应答(rcv_nxt==rcv_wup)
					通过tcp_store_ts_recent更新ts_recent
				2.通过tcp_rcv_rtt_measure_ts更新接收方的rtt
				3.通过__skb_pull将head_len的长度从skb的data段移除
				4.tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
			4.如果有dma复制(copied_early)，通过tcp_cleanup_rbuf
				处理应答
		2.如果没复制数据到用户空间(!eaten)
			1.tcp_checksum_complete_user检查checksum
			2.如果带有timestamp，并且没有待应答的包（rcv_nxt==rcv_wup）
				通过tcp_store_ts_recent存储ts_recent
			3.通过tcp_rcv_rtt_measure_ts测量接受方的rtt
			4.如果skb要的内存超过了sk预期(sk_forward_alloc),跳到
				step5执行慢速路径
			5.通过__skb_pull将head从skb中移除，并通过__skb_queue_tail
				将skb加入到sk_receive_queue队尾
			6.sk_stream_set_owner_r将skb和sk建立关系
			7.设置预期接收skb
				tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq
		3.tcp_event_data_recv处理延迟确认
		4.如果应答的seq超过了窗口左边界，通过tcp_ack处理应答
			并通过tcp_data_snd_check发送
			如果没有延迟应答(!inet_csk_ack_scheduled),跳到6
		5.__tcp_ack_snd_check处理延时确认或者快速确认
		6.如果是dma复制到用户空间，通过__skb_queue_tail将skb连接到sk_async_wait_queue队尾
			如果普通复制到用户空间，释放skb
			如果挂入到sk_receive_queue，通过sk_data_ready通知sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1345</x>
      <y>1353</y>
      <w>34</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
快速路径</panel_attributes>
    <additional_attributes>320.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1166</x>
      <y>1472</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_data_snd_check</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1150</x>
      <y>1479</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_push_pending_frames</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1176</x>
      <y>1480</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_check_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1159</x>
      <y>1475</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1172</x>
      <y>1475</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1150</x>
      <y>1486</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__tcp_push_pending_frames</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1158</x>
      <y>1482</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1184</x>
      <y>1483</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1173</x>
      <y>1487</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.如果SOCK_QUEUE_SHRUNK置上，表示有send的skb的ack
	sendbuf有被释放空间
	1.sock_reset_flag(sk, SOCK_QUEUE_SHRUNK）
	2.如果sock的SOCK_NOSPACE置上，通过
		tcp_new_space申请新的内存
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1180</x>
      <y>1500</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_new_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1171</x>
      <y>1507</y>
      <w>31</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果需要扩展sendbuf(tcp_should_expand_sndbuf)
	1.需要的长度时2*max（snd_cwnd，reordering+1）
	2.如果长度超过了sendbuf，才更新sendbuf，
		但不能超过sysctl_tcp_wmem[2]
	3.tp-&gt;snd_cwnd_stamp = tcp_time_stamp
2.sk-&gt;sk_write_space扩展buf
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1185</x>
      <y>1503</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1195</x>
      <y>1520</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_write_space
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1185</x>
      <y>1516</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1193</x>
      <y>1527</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_stream_write_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1200</x>
      <y>1523</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_v4_init_sock</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1184</x>
      <y>1534</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果空闲的space超过了sk-&gt;sk_wmem_queued / 2
	1.将SOCK_NOSPACE清掉
	2.如果有sk_sleep，通过wake_up_interruptible唤醒
	3.如果有fasync_list，且不是SEND_SHUTDOWN，
		通过sock_wake_async唤醒
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1201</x>
      <y>1530</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1161</x>
      <y>1520</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_should_expand_sndbuf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1169</x>
      <y>1516</y>
      <w>18</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1156</x>
      <y>1527</y>
      <w>27</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.以下情况不expand
	1.SOCK_SNDBUF_LOCK锁上
	2.tcp_memory_pressure 或者
		tcp_memory_allocated超过sysctl_tcp_mem[0]
	3.网络上的skb数量窗口了拥塞窗口
2.其他情况expand
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1169</x>
      <y>1523</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1185</x>
      <y>1495</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1228</x>
      <y>1471</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_copy_to_iovec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1216</x>
      <y>1479</y>
      <w>36</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果不需要做checksum，通过skb_copy_datagram_iovec复制
	否则通过skb_copy_and_csum_datagram_iovec复制
2.复制完成，调整rcvbuf
	tp-&gt;ucopy.len -= chunk;
	tp-&gt;copied_seq += chunk
	tcp_rcv_space_adjust
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1234</x>
      <y>1474</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1246</x>
      <y>1495</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_rcv_space_adjust</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1239</x>
      <y>1501</y>
      <w>29</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.如果之前没被设置rcvq_space.time，跳到new_measure
2.如果距离上一次收到小于1/8rtt，或者之前测量的rtt为0
	直接返回
注：这里是接收方预测的rtt，和tcp_rtt_estimator预测
	发送方不一样
3.new_space是2倍的user复制的长度(copied_seq-seq)
	如果其超过了tp-&gt;rcvq_space.space
	1.tp-&gt;rcvq_space.space = space
	2.如果设置了sysctl_tcp_moderate_rcvbuf，并
		且SOCK_RCVBUF_LOCK没被锁住，
		1.如果new_space超过了sk_rcvbuf，但不能超过sysctl_tcp_rmem[2]
			sk-&gt;sk_rcvbuf = space//new_space数据区128字节对其
			tp-&gt;window_clamp = new_clamp //new_space
4.更新
	tp-&gt;rcvq_space.seq = tp-&gt;copied_seq;
	tp-&gt;rcvq_space.time = tcp_time_stamp;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1253</x>
      <y>1498</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1214</x>
      <y>1493</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_copy_datagram_iovec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1208</x>
      <y>1499</y>
      <w>30</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.分别复制data，frags，和frag_list的数据到iov
	基本操作是memcpy_toiovec
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1221</x>
      <y>1496</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1214</x>
      <y>1506</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memcpy_toiovec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1219</x>
      <y>1503</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1212</x>
      <y>1512</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过copy_to_user从内核中复制数据iov_len
	到iov中，如果iov_len复制完，iov++(这里
	有可能出现数组越界，直到copy_to_user返回
	EFAULT)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1221</x>
      <y>1509</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1376</x>
      <y>1353</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
慢速路径</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1223</x>
      <y>1489</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1244</x>
      <y>1489</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1306</x>
      <y>1471</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_event_data_recv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1298</x>
      <y>1478</y>
      <w>34</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.通过inet_csk_schedule_ack设置ICSK_ACK_SCHED
	表示发送ack
2.通过tcp_measure_rcv_mss重新计算接收到的mss
3.通过tcp_rcv_rtt_measure预估rtt

4.如果没设置ato
	tcp_incr_quickack(sk);
	icsk-&gt;icsk_ack.ato = TCP_ATO_MIN;
5.如果距上次收到skb的时间低于TCP_ATO_MIN/2
	icsk-&gt;icsk_ack.ato = (icsk-&gt;icsk_ack.ato &gt;&gt; 1) + TCP_ATO_MIN / 2
	如果这个时间低于ato
	icsk-&gt;icsk_ack.ato = (icsk-&gt;icsk_ack.ato &gt;&gt; 1) + m;//不能大于icsk_rto
	如果这个时间大于icsk_rto
	tcp_incr_quickack(sk);
	sk_stream_mem_reclaim(sk)
6.icsk-&gt;icsk_ack.lrcvtime = now;
7.TCP_ECN_check_ce检查拥塞状态
8.如果是超过128字节的大数据传输，
	tcp_grow_window扩展拥塞窗口
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1314</x>
      <y>1474</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1310</x>
      <y>1516</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_rcv_rtt_measure</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1301</x>
      <y>1523</y>
      <w>28</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果之前没有采样(rcv_rtt_est.time == 0)
	跳到4进行采样
2.如果收到的rcv_nxt，没达到了预期的采样seq
	(rcv_rtt_est.seq)，直接返回
3.如果达到预期接收的seq，通过tcp_rcv_rtt_update
	更新，最后一个参数是1，表示不做细微调整
4.采样
	tp-&gt;rcv_rtt_est.seq = tp-&gt;rcv_nxt + tp-&gt;rcv_wnd;
	tp-&gt;rcv_rtt_est.time = tcp_time_stamp;
注：1.发送方不可能rtt时间内发送接收方的通告窗口的长度，接收方通过这个时间预测rtt
	2.当发送方没多少数据发送时，接收方可能因为收不到数据，而过多预测rtt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1313</x>
      <y>1519</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1303</x>
      <y>1544</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_rcv_rtt_update</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1310</x>
      <y>1540</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1299</x>
      <y>1551</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>注：1.rcv_rtt_est.rtt记录的数据是sample的8倍
	2.win_dep为0时，需要微调，微调是根据
		rcv_rtt_est.rtt的1/8进行微调
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1309</x>
      <y>1547</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1346</x>
      <y>1471</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_rcv_rtt_measure_ts</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1339</x>
      <y>1477</y>
      <w>36</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.在收到时间戳(rcv_tsecr)，并且skb的长度超过了mss(这时网络稳定)
	1.通过tcp_rcv_rtt_update更新rtt，0表示需要进行微调
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1355</x>
      <y>1474</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1271</x>
      <y>1470</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_cleanup_rbuf</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1260</x>
      <y>1476</y>
      <w>33</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果ICSK_ACK_SCHED
	1.如果延迟应答blocked
	2.或者有mss的帧没被应答
	3.或者上层有复制数据，并且处于ICSK_ACK_PUSHED2,并且没有sk_rmem_alloc
		或者上层有复制数据，处于ICSK_ACK_PUSHED，但是!pingpong,并且没有sk_rmem_alloc
	上述三种情况，发送ack
2.如果上层复制了数据，但是没RCV_SHUTDOWN
	1.如果接收窗口低于限值的一半，也低于接收缓冲区的一半
		发送ack
3.通过tcp_send_ack发送ack
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1276</x>
      <y>1473</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1389</x>
      <y>1397</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1279</x>
      <y>1572</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_prune_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1307</x>
      <y>1572</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_stream_set_owner_r</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1301</x>
      <y>1578</y>
      <w>30</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>skb-&gt;sk = sk;
skb-&gt;destructor = sk_stream_rfree;
atomic_add(skb-&gt;truesize, &amp;sk-&gt;sk_rmem_alloc);
sk-&gt;sk_forward_alloc -= skb-&gt;truesize;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1315</x>
      <y>1575</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1345</x>
      <y>1572</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_fin</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1372</x>
      <y>1572</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_ofo_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1395</x>
      <y>1572</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_sack_remove</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1422</x>
      <y>1571</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_enter_quickack_mode</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1417</x>
      <y>1579</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过tcp_incr_quickack修改quick
2.退出交互模式
	icsk-&gt;icsk_ack.pingpong = 0;
	icsk-&gt;icsk_ack.ato = TCP_ATO_MIN;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1432</x>
      <y>1574</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1424</x>
      <y>1591</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_incr_quickack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1429</x>
      <y>1586</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1414</x>
      <y>1598</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.初始化quickack的包个数 rcv_wnd/(2*mss)
注：quick是一半的接收窗口
2.quickack为0时，将其设置为2
3.如果icsk-&gt;icsk_ack.quick有增加，更新quick
	但是不能超过TCP_MAX_QUICKACKS
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1427</x>
      <y>1594</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1459</x>
      <y>1570</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>TCP_ECN_check_ce</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1450</x>
      <y>1578</y>
      <w>34</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果ecn_flags要求做拥塞控制(TCP_ECN_OK)
	1.INET_ECN_is_ce在skb中检查到INET_ECN_CE
		tp-&gt;ecn_flags |= TCP_ECN_DEMAND_CWR;
	注：检查ip层的ce标志，如果置上，设置ece标志，要求发送端进行拥塞控制
	2.如果INET_ECN_is_not_ect中检查到skb的INET_ECN_NOT_ECT
		tcp_enter_quickack_mode进入quickack模式
注：1.这里是收到乱序帧的时候调用，另外这个函数还在tcp_event_data_recv
	中有调用，不管是快速路径还是慢速路径，都是收到了预期帧时调用
	2.接收方发送的ack中因为TCP_ECN_send含有ece标志，
		发送方收到ack后，在tcp_ack中通过tcp_fastretrans_alert
		处理ece，进行拥塞控制
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1467</x>
      <y>1573</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1375</x>
      <y>1400</y>
      <w>41</w>
      <h>163</h>
    </coordinates>
    <panel_attributes>1.如果没有payload(seq=end_seq),直接释放skb
2.通过__skb_pull释放skb中头部的空间(th-&gt;doff*4)
3.TCP_ECN_accept_cwr处理发送端的cwr
注：cwr说明发送端做了拥塞处理，所以将接收方的
	TCP_ECN_DEMAND_CWR清除
4.dsack表示要发送重复应答，设置eff_sacks为num_sacks,4 - tstamp_ok
	的最小值，并清除dsack

注：处理预期skb
5.如果是预期的skb(seq==rcv_nxt)
	1.通过tcp_receive_window检查窗口，如果没有跳到out_of_window
	2.如果等待数据(ucopy.task)的是当前进程，
	并且没有数据等待用户复制(copied_seq=rcv_nxt)
	并且用户存在空间容纳数据(ucopy.len)
	并且被锁住(sock_owned_by_user)
	并且没有带外数据处理(!urg_data)
		1.复制长度是skb-&gt;len和ucopy.len的最小值
		2.通过__set_current_state设置状态为TASK_RUNNING
		3.通过skb_copy_datagram_iovec复制数据到用户空间
			tp-&gt;ucopy.len -= chunk;
			tp-&gt;copied_seq += chunk;
			eaten(skb整个复制，并且不是fin)
			tcp_rcv_space_adjust
	3.如果没将skb整个复制
		1.如果没复制skb
			1.如果申请的内存(sk_rmem_alloc)超过了限制(sk_rcvbuf)
				或者通过sk_stream_rmem_schedule申请不到sk_forward_alloc时，
			通过tcp_prune_queue对queue进行调整，并重新通过
			sk_stream_rmem_schedule看是否能申请到sk_forward_alloc
		2.sk_stream_set_owner_r建立skb和sk的关系，并通过
			__skb_queue_tail将skb加入到sk_receive_queue队尾
	4.更新rcv_nxt
		tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq
	5.如果skb有payload，通过tcp_event_data_recv处理延迟确认
	6.tcp_fin处理fin
	7.如果out_of_order_queue不为空，
		1.通过tcp_ofo_queue查看是否可以将out_of_order_queue
			中数据放入到sk_receive_queue
		2.如果out_of_order_queue为空，
			pingpong = 0
	8.如果存在num_sacks，通过tcp_sack_remove看是否能移除sack
	9.通过tcp_fast_path_check更新pred_flags
	10.如果数据被复制到用户空间，释放skb
		否则在sk没有SOCK_DEAD的情况下，通过sk_data_ready通知进程
		然后直接返回
		
注：下面是处理乱序的skb
6.如果skb之前收到过(end_seq&lt;rcv_nxt)
	1.通过tcp_dsack_set设置重复应答
	2.out_of_window
		1.通过tcp_enter_quickack_mode进入quickack模式
		2.并通过inet_csk_schedule_ack将ICSK_ACK_SCHED置上
	3.释放skb，并返回
7.如果skb超出了tcp_receive_window，跳到out_of_window，并返回
8.因为skb乱序，通过tcp_enter_quickack_mode进入quickack模式
9.如果有部分是之前收到的(seq&lt;rcv_nxt&lt;end_seq)，
	1.通过tcp_dsack_set设置重复应答
	2.如果tcp_receive_window检查到没空间容纳数据，跳到out_of_window
	3.否则跳到5.3.1挂入到sk_receive_queue
	注：sk_receive_queue中可能存在重复的seq，因为这里没将skb中重复的部分去除

注：上面是重复应答检查，下面是处理乱序队列
10.TCP_ECN_check_ce查看skb是否需要拥塞处理
11.和5.3.1.1类似，检查sk是否用空间容纳skb
12.tp-&gt;pred_flags = 0;//清除fast_path，乱序队列不为空不能执行快速路径
	inet_csk_schedule_ack(sk);//要求尽快应答
	sk_stream_set_owner_r(skb, sk);//建立skb和sk的关系
13.如果out_of_order_queue为空
	1.如果需要sack(sack_ok)
		tp-&gt;rx_opt.num_sacks = 1;
		tp-&gt;rx_opt.dsack     = 0;
		tp-&gt;rx_opt.eff_sacks = 1;
		tp-&gt;selective_acks[0].start_seq = TCP_SKB_CB(skb)-&gt;seq;
		tp-&gt;selective_acks[0].end_seq =
					TCP_SKB_CB(skb)-&gt;end_seq;
	2.通过__skb_queue_head将skb加入到队列out_of_order_queue中
14.如果out_of_order_queue不为空
	1.从后向前遍历out_of_order_queue队列
	2.如果skb的seq紧接着乱序队列中最后一个skb1的end_seq
		1.通过__skb_append将skb加入到乱序队列中
		2.如果之前没有sack(!num_sacks),或者第一个sack的end_seq没
			紧接着skb的seq，跳到add_sack
		注：这里不用和乱序队列后面的skb比较位置，不用tcp_dsack_extend，所以直接add_sack
		3.否则更新第一个sack的end_seq
			tp-&gt;selective_acks[0].end_seq = end_seq
		4.返回
	3.遍历out_of_order_queue，seq按照从小到大的顺序排列位置
	4.如果没到对首,如果找到的skb1和新skb有重叠的部分(skb1.seq&lt;=seq&lt;skb1.end_seq)
		1.如果skb1完全将skb覆盖
			1.释放skb
			2.tcp_dsack_set设置重复应答
			3.跳到add_sack添加sack
		2.如果只是部分覆盖，通过tcp_dsack_set设置重复应答
		3.	如果是skb将skb1覆盖
			skb1 = skb1-&gt;prev//将skb插入到skb1的前面
	5.通过__skb_insert将skb插入到skb1的后面
	6.然后从skb向后遍历，看是否skb能否和后续的skb1合并
		如果skb1能完全合并，__skb_unlink将skb1脱链，通过tcp_dsack_extend将其合并，并通过__kfree_skb将skb1释放
		如果只是能部分合并，tcp_dsack_extend将其两者合并
	注：这里可以看出，乱序队列中不存在seq相同的skb
	7.add_sack：
		在需要sack的情况下（sack_ok），通过tcp_sack_new_ofo_skb添加sack
	注：1.duplicate_sack和selective_acks的数组的内存是紧挨着一起，在发送
			时tcp_build_and_update_options，根据dsack选择发送的头
		2.tcp_sack_new_ofo_skb中收到dsack会通过tcp_sack_extend扩展
			会让这个sack调整到第一个
		3.收到乱序的skb会直接发送ack，所以tcp_sacktag_write_queue中检查到第一个sack
			在diergesack中，会提示dsack
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1284</x>
      <y>1575</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1261</x>
      <y>1578</y>
      <w>39</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.如果申请的sk_rmem_alloc超过了限制sk_rcvbuf
	通过tcp_clamp_window更新其限制
	否则在有内存压力的情况下，更新tp-&gt;rcv_ssthresh
	不超过4*advmss
2.通过tcp_collapse_ofo_queue合并乱序队列中的skb
3.通过tcp_collapse合并从copied_seq~rcv_nxt的skb
4.通过sk_stream_mem_reclaim释放sk的内存
5.如果sk_rmem_alloc小于限制sk_rcvbuf，直接返回0

6.如果out_of_order_queue不为空，通过__skb_queue_purge
	释放乱序队列中所有skb，并通过tcp_sack_reset
	重置sack，之后利用sk_stream_mem_reclaim回收内存
7.如果sk_rmem_alloc小于限制sk_rcvbuf，返回0

8.清除快速路径pred_flags，返回-1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1239</x>
      <y>1607</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_clamp_window</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1228</x>
      <y>1614</y>
      <w>32</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.退出快速应答
	icsk-&gt;icsk_ack.quick = 0
2.在sk_rcvbuf没超过sysctl_tcp_rmem[2]
	并且SOCK_RCVBUF_LOCK没置上
	并且没有内存压力
	并且tcp的内存小于限制sysctl_tcp_mem[0]
	将sk_rcvbuf更新为sk_rmem_alloc，但是不能超过
	sysctl_tcp_rmem[2]
3.当sk_rmem_alloc超过sk_rcvbuf
	更新rcv_ssthresh不能超过window_clamp和2*advmss
	的最小值
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1244</x>
      <y>1610</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1301</x>
      <y>1608</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_stream_mem_reclaim</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1299</x>
      <y>1615</y>
      <w>27</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果sk_forward_alloc超过了其限制，
	通过__sk_stream_mem_reclaim将其释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1300</x>
      <y>1622</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__sk_stream_mem_reclaim</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1308</x>
      <y>1611</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1307</x>
      <y>1619</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1298</x>
      <y>1629</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.memory_allocated-=sk_forward_alloc/ SK_STREAM_MEM_QUANTUM
2.sk-&gt;sk_forward_alloc &amp;= SK_STREAM_MEM_QUANTUM - 1
3.如果之前有memory_pressure，但是现在memory_allocated
	低于sysctl_mem[0]
	memory_pressure = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1309</x>
      <y>1625</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1268</x>
      <y>1607</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_collapse_ofo_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1277</x>
      <y>1610</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1272</x>
      <y>1641</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_collapse</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1277</x>
      <y>1637</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1260</x>
      <y>1648</y>
      <w>37</w>
      <h>59</h>
    </coordinates>
    <panel_attributes>1.遍历[head,tail)的所有skb
	1.head~tail区间内，start之前的skb全部释放掉
		__skb_unlink(skb, list);
		__kfree_skb(skb);
		skb = next;
		continue;
	2.找到第一个合并的skb
		1.不能是syn和fin
		2.除数据的部分占了skb很大的空间(tcp_win_from_space(skb-&gt;truesize) &gt; skb-&gt;len)
			有重叠的部分
			数据区不是连续的
	3.如果没找到，更新start
		start = TCP_SKB_CB(skb)-&gt;end_seq;
		skb = skb-&gt;next;
2.如果变脸到tial或者syn或者fin，直接退出
3.当start&lt;end时，不断申请skb
	1.通过alloc_skb申请skb，最多只能是1页，所以
	当数据量大于1页时，会重复循环
	2.初始化
		skb_reserve(nskb, header);
		memcpy(nskb-&gt;head, skb-&gt;head, header);
		nskb-&gt;nh.raw = nskb-&gt;head + (skb-&gt;nh.raw-skb-&gt;head);
		nskb-&gt;h.raw = nskb-&gt;head + (skb-&gt;h.raw-skb-&gt;head);
		nskb-&gt;mac.raw = nskb-&gt;head + (skb-&gt;mac.raw-skb-&gt;head);
		memcpy(nskb-&gt;cb, skb-&gt;cb, sizeof(skb-&gt;cb));
		TCP_SKB_CB(nskb)-&gt;seq = TCP_SKB_CB(nskb)-&gt;end_seq = start;
		__skb_insert(nskb, skb-&gt;prev, skb, list);
		sk_stream_set_owner_r(nskb, sk);
	3.遍历链表，然后将数据复制到nskb
		1.通过skb_copy_bits复制min(size,copy)的数据到nskb
		注：这里如果存在hole,BUG_ON(offset &lt; 0)
		2.如果skb被完全复制
			__skb_unlink(skb, list);
			__kfree_skb(skb);
			//如果是tail syn fin
			return
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1277</x>
      <y>1644</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1244</x>
      <y>1602</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1275</x>
      <y>1602</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1281</x>
      <y>1602</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1366</x>
      <y>1578</y>
      <w>30</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.遍历乱序队列out_of_order_queue
	1.如果skb.seq超过了rcv_nxt，退出循环
	2.如果检查到乱序队列中有在rcv_nxt的部分，
		通过tcp_dsack_extend设置dsack
	注：当end_seq比rcv_nxt小的时候，存储的是rcv_nxt
		和RFC2883描述的不太一样
	3.如果skb完全在rcv_nxt内，释放skb，然后继续循环
	
	4.通过__skb_unlink将skb从乱序队列中脱链
		__skb_queue_tail链入到sk_receive_queue尾端
		tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
	8.如果skb的fin置上，tcp_fin进行处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1378</x>
      <y>1575</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1423</x>
      <y>1393</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_urg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1417</x>
      <y>1400</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果紧急指针置上(th-&gt;urg),通过tcp_check_urg检查urg
2.如果urg_data要求TCP_URG_NOTYET
	1.计算紧急指针的偏移量
	2.如果在skb内，通过skb_copy_bits复制一个字节的数据
		tp-&gt;urg_data = TCP_URG_VALID | tmp
	3.如果sk没有SOCK_DEAD，通过sk_data_ready通知进程
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1427</x>
      <y>1396</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1427</x>
      <y>1414</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_check_urg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1417</x>
      <y>1421</y>
      <w>35</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.根据紧急指针在skb内的偏移，算出紧急指针对应的seq
2.如果紧急指针已经被上层复制，直接返回
3.如果紧急指针之前已经被收到，已经被处理，直接返回
4.已经有urg_data，并且当前指针在tp-&gt;urg_seq之前，直接返回
5.通过sk_send_sigurg通知sk
6.如果上层复制到紧急指针，并且之前有urg_data
	SOCK_URGINLINE没置上，copied_seq!=rcv_nxt
	tp-&gt;copied_seq++;
	如果这个skb只有urg
	__skb_unlink
	__kfree_skb
注：这个条件好像永远成立不了，因为copied_seq&lt;=rcv_nxt
	并且urg_seq = copied_seq，所以urg_seq&lt;rcv_nxt
	根据3可知，urg_seq&gt;=rcv_nxt
7.tp-&gt;urg_data   = TCP_URG_NOTYET;
	tp-&gt;urg_seq    = ptr
	tp-&gt;pred_flags = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1431</x>
      <y>1417</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1432</x>
      <y>1410</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2066</x>
      <y>159</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_recv_urg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2050</x>
      <y>165</y>
      <w>46</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.带外数据不通过正常数据流读取(SOCK_URGINLINE),并且需要有urg_data
	并且没有被读(TCP_URG_READ),否则返回EINVAL
2.如果TCP_CLOSE，并且SOCK_DONE没置上，返回ENOTCONN
3.如果urg_data的TCP_URG_VALID置上
	1.如果MSG_PEEK没被置上，将urg_data设置为TCP_URG_READ
	2.msg-&gt;msg_flags |= MSG_OOB
	3.如果需要读取数据，通过memcpy_toiovec将紧急指针复制到用户
		否则msg-&gt;msg_flags |= MSG_TRUNC
	4.返回长度
4.如果TCP_CLOSE或者RCV_SHUTDOWN，返回0，表示没数据
5.否则返回EAGAIN
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2072</x>
      <y>162</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1307</x>
      <y>1277</y>
      <w>111</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1090.0;10.0;10.0;230.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1355</x>
      <y>1277</y>
      <w>74</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>720.0;10.0;10.0;220.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1407</x>
      <y>1277</y>
      <w>23</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;220.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1428</x>
      <y>1277</y>
      <w>27</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;200.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1439</x>
      <y>1277</y>
      <w>96</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;940.0;220.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1446</x>
      <y>1277</y>
      <w>309</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;3070.0;250.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1173</x>
      <y>1457</y>
      <w>162</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1600.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1233</x>
      <y>1457</y>
      <w>108</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1060.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1275</x>
      <y>1457</y>
      <w>71</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>690.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1314</x>
      <y>1457</y>
      <w>33</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1344</x>
      <y>1457</y>
      <w>13</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;140.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1314</x>
      <y>1509</y>
      <w>6</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1283</x>
      <y>1562</y>
      <w>101</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>990.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1314</x>
      <y>1562</y>
      <w>73</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>710.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1350</x>
      <y>1562</y>
      <w>39</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1378</x>
      <y>1562</y>
      <w>18</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1397</x>
      <y>1562</y>
      <w>8</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1400</x>
      <y>1562</y>
      <w>30</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1407</x>
      <y>1562</y>
      <w>61</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;590.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1388</x>
      <y>1383</y>
      <w>26</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1416</x>
      <y>1383</y>
      <w>12</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1776</x>
      <y>1336</y>
      <w>43</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.通过tcp_fast_parse_options解析tcp头部选项，如果
	saw_tstamp，并且tcp_paws_discard检查paws没通过
	在没置rst的情况下，通过tcp_send_dupack发送ack，并丢弃包
2.如果接收到的seq不在tcp_sequence内，如果rst没置
	通过tcp_send_dupack发送ack，并丢弃包
3.如果rst置上，通过tcp_reset 重置连接，并丢弃包
4.通过tcp_replace_ts_recent更新tsrecent
5.如果收到的是syn，但是收到的不是预期的rcv_nxt，通过tcp_reset
	重置连接
注：之前已经收到了syn，如果不是之前重发的syn，发送rst
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1384</x>
      <y>1358</y>
      <w>43</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.如果skb的长度不足th-&gt;doff，或者tcp_checksum_complete_user
	检查checksum没过，跳到csum_error
2.通过tcp_fast_parse_options解析tcp头部选项，如果有时间戳(saw_tstamp)
	通过tcp_paws_discard检查paws，如果没通过
		1.如果没置rst，通过tcp_send_dupack发送重复应答，并将skb丢弃
3.如果rst置上，通过tcp_reset重置连接，并且丢弃skb
4.tcp_replace_ts_recent在时间戳有效的情况下更新ts_recent
5.如果发的syn，并携带有效数据，通过tcp_reset重置连接，并且返回1
注：下面检查通过之后，真正的处理skb
6.如果ack置上，通过tcp_ack处理应答
7.通过tcp_rcv_rtt_measure_ts估算接收方的rtt
8.tcp_urg处理紧急指针
9.tcp_data_queue处理skb
10.tcp_data_snd_check查看是否有skb发送
11.tcp_ack_snd_check查看是否有ack发送
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1385</x>
      <y>1394</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_data_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1263</x>
      <y>1614</y>
      <w>32</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果out_of_order_queue为空，直接返回
2.遍历乱序队列，找到其中有重叠部分的skb
	1.如果seq&lt;start&lt;end_seq,更新start到seq
		start = TCP_SKB_CB(skb)-&gt;seq
	2.如果seq&lt;end&lt;end_seq，更新end到end_seq
		end = TCP_SKB_CB(skb)-&gt;end_seq
	注：这两者不可能同时成立，因为通过tcp_data_queue可知
		乱序队列中不存在完全包含的两个skb
	3.如果上述两者情况不满足，就是当前skb和前面是完全独立的
		通过tcp_collapse合并从head~skb中start~end的skb
		并开启新的段
		head = skb;
		start = TCP_SKB_CB(skb)-&gt;seq;
		end = TCP_SKB_CB(skb)-&gt;end_seq;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1276</x>
      <y>1518</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_measure_rcv_mss</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1282</x>
      <y>1509</y>
      <w>20</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1269</x>
      <y>1525</y>
      <w>28</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果发送过来的skb的长度超过了rcv_mss，则更新
	icsk-&gt;icsk_ack.rcv_mss = len;
2.否则
	1.如果收到的tcp段的长度超过了TCP_MIN_RCVMSS+header
	或者超过了TCP_MIN_MSS+header 并且特殊标志TCP_REMNANT没置上
		1.len -= tcp_sk(sk)-&gt;tcp_header_len;
			icsk-&gt;icsk_ack.last_seg_size = len;
		2.如果len和上次收到的帧的长度一致
			icsk-&gt;icsk_ack.rcv_mss = len;
			return
	2.如果之前pending的ICSK_ACK_PUSHED置上
		icsk-&gt;icsk_ack.pending |= ICSK_ACK_PUSHED2;
	3.icsk-&gt;icsk_ack.pending |= ICSK_ACK_PUSHED;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1281</x>
      <y>1521</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1339</x>
      <y>1516</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_grow_window</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1333</x>
      <y>1523</y>
      <w>38</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.rcv_ssthresh在不超过window_clamp，tcp_space，并且
	没有内存压力的情况下（!tcp_memory_pressure）,才对拥塞窗口
	rcv_ssthresh做调整
	1.如果其数据(skb.len)超过了其额外的内存开销(tcp_win_from_space(skb-&gt;truesize))
		incr = 2*tp-&gt;advmss;
	2.否则，通过__tcp_grow_window决定其增加值
	3.调整rcv_ssthresh
		tp-&gt;rcv_ssthresh = min(tp-&gt;rcv_ssthresh + incr, tp-&gt;window_clamp);
		inet_csk(sk)-&gt;icsk_ack.quick |= 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1345</x>
      <y>1519</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1344</x>
      <y>1542</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__tcp_grow_window</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1350</x>
      <y>1538</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1351</x>
      <y>1545</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1338</x>
      <y>1548</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.按照rcv_ssthresh/tcp_win_from_space(sysctl_tcp_rmem[2])
	的比例缩小skb-&gt;truesize，如果truesize &lt;= skb-&gt;len
	增加量为2 * inet_csk(sk)-&gt;icsk_ack.rcv_mss
	否则为0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1461</x>
      <y>1394</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_ack_snd_check</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1420</x>
      <y>1383</y>
      <w>50</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;480.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1454</x>
      <y>1400</y>
      <w>38</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果inet_csk_ack_scheduled检测到ICSK_ACK_SCHED
	没置上的话，就直接退出
2.__tcp_ack_snd_check检查是否需要发送ack，传参1表示乱序队列
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1467</x>
      <y>1397</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1464</x>
      <y>1410</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__tcp_ack_snd_check</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1471</x>
      <y>1406</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1454</x>
      <y>1417</y>
      <w>35</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.以下情况通过tcp_send_ack发送ack
	1.有rcv_mss的报文没被ack，并且窗口有扩大
	2.tcp_in_quickack_mode检查到处于quickack模式
	3.如果处理乱序队列时，检查到乱序队列中有skb
2.否则通过tcp_send_delayed_ack延迟发送ack
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1472</x>
      <y>1413</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1463</x>
      <y>1429</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_send_delayed_ack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1471</x>
      <y>1425</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1455</x>
      <y>1436</y>
      <w>37</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.计算ato
	1.获取ato
	2.计算max_ato
		1.最大是0.5s
		2.处于交互模式(pingpong)，或者ICSK_ACK_PUSHED
			设置为TCP_DELACK_MAX
		3.其值不超过rtt
	3.ato不能超过max_ato
2.计算timeout
	1.默认为jiffies + ato
	2.在ICSK_ACK_TIMER的情况下
		1.在blocked或者之前的timeout马上要超时了
			通过tcp_send_ack发送ack
		2.新设置的timeout时间不能超过之前设置的
3.icsk-&gt;icsk_ack.pending |= ICSK_ACK_SCHED | ICSK_ACK_TIMER;
	icsk-&gt;icsk_ack.timeout = timeout;
	sk_reset_timer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1471</x>
      <y>1432</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1996</x>
      <y>21</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_recvmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1411</x>
      <y>16</y>
      <w>592</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_RECVMSG</panel_attributes>
    <additional_attributes>10.0;10.0;5900.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1983</x>
      <y>29</y>
      <w>41</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.如果MSG_CMSG_COMPAT置上，通过get_compat_msghdr
	获取用户空间的参数，否则通过copy_from_user获取
2.通过sockfd_lookup_light利用fd获取sock
3.如果msg_iovlen长度超过了UIO_MAXIOV，返回EMSGSIZE
3.如果msg_iovlen的长度超过了UIO_FASTIOV，需要利用
	sock_kmalloc重新申请内存，如果申请不到返回ENOMEM，
	否则就利用栈中的iovstack
4.如果MSG_CMSG_COMPAT置上，通过verify_compat_iovec复制
	msg_name和iov到内核空间，否则通过verify_iovec复制
5.设置msg_flags
	msg_sys.msg_flags = MSG_CMSG_COMPAT;//MSG_CMSG_COMPAT
	flags |= MSG_DONTWAIT;//O_NONBLOCK

6.通过sock_recvmsg接收msg
7.如果之前msg_name不为空，将addr复制到里面，并且将msg_flags
	清除MSG_CMSG_COMPAT复制到用户空间
8.将msg_control复制到用户空间
9.返回接收的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2001</x>
      <y>24</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1998</x>
      <y>61</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_recvmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2000</x>
      <y>58</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1995</x>
      <y>68</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过init_sync_kiocb初始化iob
2.通过__sock_recvmsg接收msg
3.如果返回EIOCBQUEUED，通过wait_on_sync_kiocb
	等待iocb-&gt;ki_users消失，并返回ki_user_data
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2003</x>
      <y>64</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2009</x>
      <y>78</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__sock_recvmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2008</x>
      <y>75</y>
      <w>9</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2005</x>
      <y>85</y>
      <w>28</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.初始化siocb
	si-&gt;sock = sock;
	si-&gt;scm = NULL;
	si-&gt;msg = msg;
	si-&gt;size = size;
	si-&gt;flags = flags;
2.security_socket_recvmsg做安全检查
3.sock-&gt;ops-&gt;recvmsg接收msg
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2014</x>
      <y>81</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2011</x>
      <y>102</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;recvmsg
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2017</x>
      <y>98</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2017</x>
      <y>105</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops
inet_dgram_ops</panel_attributes>
    <additional_attributes>30.0;10.0;80.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2015</x>
      <y>109</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_common_recvmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2013</x>
      <y>116</y>
      <w>22</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.sk-&gt;sk_prot-&gt;recvmsg接收msg
2.如果正确返回
	msg-&gt;msg_namelen = addr_len
3.返回接收长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2025</x>
      <y>112</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2016</x>
      <y>127</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;recvmsg
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2022</x>
      <y>123</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2008</x>
      <y>130</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2002</x>
      <y>133</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_recvmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1975</x>
      <y>141</y>
      <w>34</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.sk要处于TCP_LISTEN，否则返回ENOTCONN
2.根据nonblock设置等待时间timeout
3.如果要求接收带外数据(MSG_OOB),跳到recv_urg
4.如果MSG_PEEK，将copied_seq复制到peek_seq
5.通过sock_rcvlowat获取退出的最小的target
注：sk_rcvlowat是通过系统调用设置，默认是1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1988</x>
      <y>136</y>
      <w>23</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
环境检查</panel_attributes>
    <additional_attributes>210.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2009</x>
      <y>136</y>
      <w>16</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
循环读取
1.sk_receive_queue
2.prequeue
3.</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2012</x>
      <y>141</y>
      <w>34</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.如果有dma，通过dma_pin_iovec_pages复制
2.遍历读取len长度的msg
	1.如果有urg_data，并且是当前读取的seq
		1.如果有复制数据，退出循环
		2.如果signal_pending，根据timeo返回错误码
	2.循环从sk_receive_queue中取出skb
		1.如果队列中没有skb，退出2.2循环
		2.seq(copied_seq)不应该小于skb.seq(要&gt;=)，
			否则退出2.2循环
		3.算出复制位置在skb中的offset(&gt;=0)
		注：因为存在后面包含前面的skb的一部分
		4.如果有syn(syn算上一个payload，但是不在data段)
			offset--
		5.如果skb内有数据供读取(offset&lt;skb.len),跳到found_ok_skb
		6.如果有fin，跳到found_fin_ok
		7.如果这个skb不满足上述条件，遍历下一个skb

	//sk_receive_queue处理完了之后
	3.如果复制的数据超过了最小的target，并且sk_backlog
		中没数据，退出循环
	注：在tcp_v4_rcv中，如果sk_lock被持有，会通过
		sk_add_backlog加入到sk_backlog中
	4.如果有复制数据，在下面情况下返回读取长度，否则返回相应的错误码
		1.SOCK_DONE //fin
		2.sk_err
		3.RCV_SHUTDOWN
		4.TCP_CLOSE
		5.timeo
		6.signal_pending
	5.通过tcp_cleanup_rbuf查看是否响应应答

	//处理prequeue
	6.如果没有设置延迟，tp-&gt;ucopy.task是当前进程(第一次
		遍历的时候是NULL)
		1.如果没设置tp-&gt;ucopy.task ，并且没置上MSG_TRUNC | MSG_PEEK
			user_recv = current;
			tp-&gt;ucopy.task = user_recv;
			tp-&gt;ucopy.iov = msg-&gt;msg_iov;
		2.tp-&gt;ucopy.len = len
		3.如果prequeue不为空，跳到do_prequeue

	//此时，队列中都没数据
	7.如果复制数据超过了最低值target，通过release_sock处理backlog
		否则通过sk_wait_data等待数据
	8.如果有dma，tp-&gt;ucopy.wakeup = 0
	9.如果之前设置了user_recv
		1.如果有读取数据到用户空间
			len -= chunk;
			copied += chunk;
		2.sk_receive_queue被处理完，但是prequeue还有数据
		3.do_prequeue
			1.tcp_prequeue_process处理prequeue
			2.如果读取数据到用户空间
				len -= chunk;
				copied += chunk;
	10.如果在MSG_PEEK的情况下，peek_seq和copied_seq不等，更新peek_seq
		peek_seq = tp-&gt;copied_seq
	11.继续下次循环

	
found_ok_skb：
	12.查看skb中有多少数据要复制,但是不能超过len(used)
	13.如果有urg_data，并且在这次复制内
		1.如果是第一个字节数据
			1.如果通过正常数据流读取(！SOCK_URGINLINE)
				++*seq;
				offset++;
				used--;
				如果被复制完，跳到skip_copy
		2.否则，只读取到urg
			used = urg_offset
	14.如果MSG_TRUNC没置上
		1.处理dma
		2.通过skb_copy_datagram_iovec将数据复制到用户空间
			如果出错，退出循环
	15.更新
		*seq += used;
		copied += used;
		len -= used;
	16.tcp_rcv_space_adjust调整sk_rcvbuf
	17.skip_copy:
		1.如果有紧急数据urg_data，并且已经被复制，清空urg_data
			并通过tcp_fast_path_check清除pred_flags
		2.如果skb被复制完，继续下次循环
		3.如果有fin，跳到found_fin_ok
		4.如果MSG_PEEK没置上，通过sk_eat_skb将skb脱链并释放
		5.继续下次循环
		6.found_fin_ok：
			1.递增++*seq
			2.如果MSG_PEEK没置上，通过sk_eat_skb将skb脱链并释放
			3.退出循环
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1985</x>
      <y>196</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>release_sock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2014</x>
      <y>195</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_wait_data</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2045</x>
      <y>196</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_prequeue_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2084</x>
      <y>195</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_eat_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2010</x>
      <y>136</y>
      <w>64</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
退出循环后</panel_attributes>
    <additional_attributes>10.0;10.0;620.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2051</x>
      <y>139</y>
      <w>40</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果有置user_recv
	1.如果prequeue不为空，通过tcp_prequeue_process处理，并更新
		len，copied
	2.tp-&gt;ucopy.task = NULL;
		tp-&gt;ucopy.len = 0;
	注：有3个地方处理prequeue?为什么处理这么频繁？
2.处理dma
3.tcp_cleanup_rbuf查看是否发送ack
4.release_sock处理sk_backlog
5.recv_urg:通过tcp_recv_urg处理紧急指针
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2071</x>
      <y>155</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1977</x>
      <y>202</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果sk_backlog中有数据，通过__release_sock
	释放
2.sk-&gt;sk_lock.owner = NULL;
3.通过wake_up唤醒lock的等待队列sk-&gt;sk_lock.wq

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1982</x>
      <y>213</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__release_sock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1990</x>
      <y>199</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1987</x>
      <y>209</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1976</x>
      <y>219</y>
      <w>27</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.取出sk_backlog
2.循环处理sk_backlog
	1.首先释放sk_backlog
	2.循环处理sk_backlog
		1.通过sk-&gt;sk_backlog_rcv处理sk_backlog
			链表中的skb
		2.cond_resched_softirq查看是否需要调度
	3.再次读取sk_backlog，开是否需要循环
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1986</x>
      <y>216</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2009</x>
      <y>201</y>
      <w>31</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.申明wait
2.通过prepare_to_wait将wait加入到sk_sleep
	并将task的状态设置为TASK_INTERRUPTIBLE
3.设置SOCK_ASYNC_WAITDATA
4.sk_wait_event在sk_receive_queue为空的
	情况下，schedule_timeout
5.清除SOCK_ASYNC_WAITDATA
6.通过finish_wait将wait移除队列，并设置TASK_RUNNING
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2018</x>
      <y>198</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2050</x>
      <y>199</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2043</x>
      <y>202</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过__skb_dequeue取出prequeue队列中的
	skb，通过sk-&gt;sk_backlog_rcv处理
2.tp-&gt;ucopy.memory = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2089</x>
      <y>198</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2076</x>
      <y>202</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过__skb_unlink将skb从sk_receive_queue
	中脱链
2.__kfree_skb将skb释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1991</x>
      <y>190</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2020</x>
      <y>190</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2027</x>
      <y>190</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2032</x>
      <y>190</y>
      <w>59</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;570.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1411</x>
      <y>16</y>
      <w>853</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SYS_SHUTDOWN</panel_attributes>
    <additional_attributes>10.0;10.0;8510.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2256</x>
      <y>22</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sys_shutdown</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2260</x>
      <y>25</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2245</x>
      <y>28</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.通过sockfd_lookup_light利用fd找到sock
2.security_socket_shutdown安全检查
3.sock-&gt;ops-&gt;shutdown关闭sock
4.fput_light根据fput_needed看是否释放file
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2253</x>
      <y>38</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;shutdown
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2259</x>
      <y>34</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2260</x>
      <y>41</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops
inet_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2255</x>
      <y>46</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_shutdown</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2260</x>
      <y>49</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2243</x>
      <y>52</y>
      <w>38</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.how的SHUTDOWN_MASK没置上，或者how为0，返回EINVAL
注：how经过++转化
2.如果sock的状态是SS_CONNECTING
	1.如果sk的状态是TCPF_SYN_SENT TCPF_SYN_RECV 
	TCPF_CLOSE，将sock状态转化为SS_DISCONNECTING
	2.否则转化为SS_CONNECTED
3.查看sk的状态
	1.默认情况：
		1.如果TCP_CLOSE，返回ENOTCONN
		2.设置sk-&gt;sk_shutdown
		3.sk-&gt;sk_prot-&gt;shutdown
	2.TCP_LISTEN：
		1.如果是SEND_SHUTDOWN，退出
		2.否则和TCP_SYN_SENT相同
	3.TCP_SYN_SENT
		1.sk-&gt;sk_prot-&gt;disconnect
		2.设置sock-&gt;state
4.sk-&gt;sk_state_change通知sk的等待队列
5.之前lock_sk，这里release_sock，其中处理sk_backlog
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2215</x>
      <y>92</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_shutdown</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2252</x>
      <y>86</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;shutdown
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2258</x>
      <y>83</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2219</x>
      <y>89</y>
      <w>41</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2203</x>
      <y>98</y>
      <w>38</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果仅仅是RCV_SHUTDOWN，直接return
注：因为设置了sock.state，这rcvmsg时会检查这个状态
2.如果sk的状态在TCPF_ESTABLISHED TCPF_SYN_SENT 
	TCPF_SYN_RECV TCPF_CLOSE_WAIT
	1.通过tcp_close_state检查是否发送fin
	2.如果需要发送，通过tcp_send_fin发送fin
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2219</x>
      <y>95</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2206</x>
      <y>112</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_close_state</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2211</x>
      <y>108</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2195</x>
      <y>118</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.根据new_state找到目前sock.state在close
	对应的下一个状态
2.tcp_set_state设置sock的状态
3.返回是否发送fin
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2210</x>
      <y>115</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2236</x>
      <y>112</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_send_fin</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2233</x>
      <y>108</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2239</x>
      <y>115</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2227</x>
      <y>119</y>
      <w>44</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.skb_peek_tail获取sk_write_queue最后一个skb
2.如果没有要发送的skb(!sk_send_head),skb就是最后一个要发送的skb
	TCP_SKB_CB(skb)-&gt;flags |= TCPCB_FLAG_FIN;
	TCP_SKB_CB(skb)-&gt;end_seq++;
	tp-&gt;write_seq++;
3.如果没有要发送的skb
	1.alloc_skb_fclone申请skb
	2.skb_reserve预留tcp头部长度
	3.设置skb
		skb-&gt;csum = 0;
		TCP_SKB_CB(skb)-&gt;flags = (TCPCB_FLAG_ACK | TCPCB_FLAG_FIN);
		TCP_SKB_CB(skb)-&gt;sacked = 0;
		skb_shinfo(skb)-&gt;gso_segs = 1;
		skb_shinfo(skb)-&gt;gso_size = 0;
		skb_shinfo(skb)-&gt;gso_type = 0;
		TCP_SKB_CB(skb)-&gt;seq = tp-&gt;write_seq;
		TCP_SKB_CB(skb)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;seq + 1;
	4.通过tcp_queue_skb将skb加入到队列sk_write_queue
4.通过__tcp_push_pending_frames发送skb，并且将nagle关闭
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1332</x>
      <y>1578</y>
      <w>33</w>
      <h>46</h>
    </coordinates>
    <panel_attributes>1.inet_csk_schedule_ack设置应答
2.sk-&gt;sk_shutdown |= RCV_SHUTDOWN;
	sock_set_flag(sk, SOCK_DONE);
3.查看sk的状态
	1.如果在TCP_SYN_RECV或者TCP_ESTABLISHED状态
		tcp_set_state(sk, TCP_CLOSE_WAIT);
		inet_csk(sk)-&gt;icsk_ack.pingpong = 1;
	2.如果在TCP_CLOSE_WAIT或者TCP_CLOSING，TCP_LAST_ACK
		(之前收到过fin)，忽略
	3.如果是TCP_FIN_WAIT1
		tcp_send_ack(sk);
		tcp_set_state(sk, TCP_CLOSING);
	4.如果是TCP_FIN_WAIT2
		tcp_send_ack(sk);
		tcp_time_wait(sk, TCP_TIME_WAIT, 0);
4.通过__skb_queue_purge将out_of_order_queue中
	的skb全部释放
5.如果收到sack,通过tcp_sack_reset将sack和dack
	初始化
	rx_opt-&gt;dsack = 0;
	rx_opt-&gt;eff_sacks = 0;
	rx_opt-&gt;num_sacks = 0
6.通过sk_stream_mem_reclaim回收sk的内存
7.如果sk的状态不在SOCK_DEAD
	1.通过sk_state_change通知状态改变
	2.如果链接完全关闭(SHUTDOWN_MASK或者TCP_CLOSE)
		通过sk_wake_async通知链接断开(POLL_HUP)
	3.否则sk_wake_async通知可以进行写操作(POLL_IN)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1349</x>
      <y>1575</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1313</x>
      <y>1666</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_twsk_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1301</x>
      <y>1672</y>
      <w>30</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.通过kmem_cache_alloc申请内存空间
2.初始化tw
	tw-&gt;tw_daddr	    = inet-&gt;daddr;
	tw-&gt;tw_rcv_saddr    = inet-&gt;rcv_saddr;
	tw-&gt;tw_bound_dev_if = sk-&gt;sk_bound_dev_if;
	tw-&gt;tw_num	    = inet-&gt;num;
	tw-&gt;tw_state	    = TCP_TIME_WAIT;
	注；这里的tw_state和sk_state是同一个
	tw-&gt;tw_substate	    = state;
	tw-&gt;tw_sport	    = inet-&gt;sport;
	tw-&gt;tw_dport	    = inet-&gt;dport;
	tw-&gt;tw_family	    = sk-&gt;sk_family;
	tw-&gt;tw_reuse	    = sk-&gt;sk_reuse;
	tw-&gt;tw_hash	    = sk-&gt;sk_hash;
	tw-&gt;tw_ipv6only	    = 0;
	tw-&gt;tw_prot	    = sk-&gt;sk_prot_creator;
3.atomic_set(&amp;tw-&gt;tw_refcnt, 1);
	inet_twsk_dead_node_init(tw);//timer链表
	__module_get(tw-&gt;tw_prot-&gt;owner);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1317</x>
      <y>1669</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1337</x>
      <y>1666</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__inet_twsk_hashdance</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1333</x>
      <y>1672</y>
      <w>34</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.将tw(tw_bind_node)加入到bhash
	tw-&gt;tw_tb = icsk-&gt;icsk_bind_hash;
	inet_twsk_add_bind_node(tw, &amp;tw-&gt;tw_tb-&gt;owners);
2.通过__sk_del_node_init将sk从ehash中删除，删除之后
	通过sock_prot_dec_use递减sk_prot的计数
注；这里从ehash中删除，之后收到帧,__inet_lookup再次找到的sk是tw
3.通过inet_twsk_add_node将tw加到hash(ehead + hashinfo-&gt;ehash_size)中
4.递增tw_refcnt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1347</x>
      <y>1669</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1328</x>
      <y>1636</y>
      <w>45</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.如果启用了sysctl_tw_recycle，并且收到了ts_recent_stamp，通过
	icsk-&gt;icsk_af_ops-&gt;remember_stamp记录时间戳到对端
2.如果申请的tw(tw_count)没超过限制,通过inet_twsk_alloc申请tw
3.初始化tw
	tw-&gt;tw_rcv_wscale	= tp-&gt;rx_opt.rcv_wscale;
	tcptw-&gt;tw_rcv_nxt	= tp-&gt;rcv_nxt;
	tcptw-&gt;tw_snd_nxt	= tp-&gt;snd_nxt;
	tcptw-&gt;tw_rcv_wnd	= tcp_receive_window(tp);
	tcptw-&gt;tw_ts_recent	= tp-&gt;rx_opt.ts_recent;
	tcptw-&gt;tw_ts_recent_stamp = tp-&gt;rx_opt.ts_recent_stamp;
4.__inet_twsk_hashdance将tw连接到bhash和ehash中
5.timeout时间最小为3.5rto
6.如果将时间戳配置到peer的信息块，timeout时间设置为3.5rto，否则为60s
7.inet_twsk_schedule启动time_wait定时器
8.inet_twsk_put释放对tw的引用
9.tcp_update_metrics将度量值存储到路由中
10.tcp_done关闭并释放sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1349</x>
      <y>1630</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1343</x>
      <y>1627</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_time_wait</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1371</x>
      <y>1666</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_twsk_schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1369</x>
      <y>1672</y>
      <w>38</w>
      <h>54</h>
    </coordinates>
    <panel_attributes>1.timeo对INET_TWDR_RECYCLE_TICK向上取整，slot
2.通过inet_twsk_del_dead_node查看是否在hash表中
	如果在删除，并递减twdr-&gt;tw_count--
	如果不在，递增tw_refcnt
3.如果slot超过了INET_TWDR_RECYCLE_SLOTS，存储到cells
	1.如果超过了timewait_len，直接挂入到最后一个slot
	2.否则timeo对period向上取整，但是不能超过INET_TWDR_TWKILL_SLOTS - 1
	3.tw-&gt;tw_ttd = jiffies + timeo;
	4.将tw挂入到cells
		slot = (twdr-&gt;slot + slot) &amp; (INET_TWDR_TWKILL_SLOTS - 1);
		list = &amp;twdr-&gt;cells[slot];
	注：twdr-&gt;slot记录当前的slot
4.如果没超过
	1.tw-&gt;tw_ttd = jiffies + (slot &lt;&lt; INET_TWDR_RECYCLE_TICK)
	2.如果之前启动(twcal_hand &lt; 0)
		1.twcal_hand =0
			twcal_jiffie = jiffies
		注：twcal_hand在时间轴上的具体位置，twcal_jiffie指具体时间
		2.设置timer
			twcal_timer.expires = twdr-&gt;twcal_jiffie +
					      (slot &lt;&lt; INET_TWDR_RECYCLE_TICK);
			add_timer(&amp;twdr-&gt;twcal_timer);
	3.如果之前有twcal_timer
		1.如果slot比expires小，通过mod_timer调整twcal_timer为
			当前的slot
		2.确定在twcal_row中的slot
			slot = (twdr-&gt;twcal_hand + slot) &amp; (INET_TWDR_RECYCLE_SLOTS - 1);
	4.确定加入的list
		list = &amp;twdr-&gt;twcal_row[slot];
5.将tw(tw_death_node)加入到时间轴list中
6.递增tw_count
7.如果是第一次，则通过mod_timer启动tw_timer
注：可能没cells，tw_timer也会被启动
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1379</x>
      <y>1669</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1352</x>
      <y>1729</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_twdr_twcal_tick</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1358</x>
      <y>1725</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
twcal_timer expires</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1339</x>
      <y>1737</y>
      <w>34</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.如果没设置twcal_timer(twcal_hand &lt; 0),跳到out
2.遍历twcal_row的所有slot
	1.如果该slot超时，遍历该slot的链表
		__inet_twsk_del_dead_node(tw);
		__inet_twsk_kill(tw, twdr-&gt;hashinfo);
		inet_twsk_put(tw);
		killed++;
	2.如果没超时
		1.记录当前时间(第一个没超时的slot)
			twdr-&gt;twcal_jiffie = j;
			twdr-&gt;twcal_hand = slot;
		2.如果该slot不为空，通过mod_timer调整twcal_timer
			的时间，并跳到out
	3.更新slot和时间j
		j += 1 &lt;&lt; INET_TWDR_RECYCLE_TICK;
		slot = (slot + 1) &amp; (INET_TWDR_RECYCLE_SLOTS - 1);
3.如果所有的slot遍历完成
	twdr-&gt;twcal_hand = -1
注：这里是没设置twcal_timer
4.out
	1.更新tw_count
		tw_count -= killed
	2.如果tw_count为0，通过del_timer将tw_timer删除
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1359</x>
      <y>1732</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1389</x>
      <y>1725</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tw_timer expires</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1397</x>
      <y>1729</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_twdr_hangman</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1382</x>
      <y>1737</y>
      <w>38</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.如果没有任何的timer(tw_count == 0),不做处理
2.inet_twdr_do_twkill_work处理对应的当前slot(twdr-&gt;slot)
	1.如果处理的tw超过了限额INET_TWDR_TWKILL_QUOTA
		1.置上下半部需要处理的slot，并将twkill_work挂入下半部
			twdr-&gt;thread_slots |= (1 &lt;&lt; twdr-&gt;slot);
			schedule_work(&amp;twdr-&gt;twkill_work);
		2.need_timer = 1
	2.如果当前的slot处理完成，并且还有tw_count
		need_timer = 1
3.更新待处理的slot
	twdr-&gt;slot = ((twdr-&gt;slot + 1) &amp; (INET_TWDR_TWKILL_SLOTS - 1))
4.如果need_timer，通过tw_timer设置为period
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1405</x>
      <y>1732</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1378</x>
      <y>1760</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_twdr_do_twkill_work</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1375</x>
      <y>1767</y>
      <w>30</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.遍历当前slot
	1.__inet_twsk_del_dead_node
	2.__inet_twsk_kill(tw, twdr-&gt;hashinfo);
		inet_twsk_put(tw);
		killed++;
	3.如果超过了限额，返回1，退出循环
	4.否则继续遍历，
注：因为这里cells[slot]可能发送变化，所以rescan
2.twdr-&gt;tw_count -= killed
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1386</x>
      <y>1763</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1385</x>
      <y>1757</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1409</x>
      <y>1757</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_death_row
twkill_work</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1409</x>
      <y>1761</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_twdr_twkill_work</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1408</x>
      <y>1768</y>
      <w>30</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果thread_slots的大小超过了cells的slot
	通过twkill_slots_invalid将其无效
2.查看thread_slots有哪些slot有pending的work
	1.通过inet_twdr_do_twkill_work处理slot中的tw
	2.如果还没处理完，看是否需要schedule
	3.醒来之后再次处理
	4.请标记的slot
		twdr-&gt;thread_slots &amp;= ~(1 &lt;&lt; i);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1416</x>
      <y>1764</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1301</x>
      <y>1778</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__inet_twsk_del_dead_node</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1309</x>
      <y>1774</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>310.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1291</x>
      <y>1785</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过__hlist_del从链表中删除te(tw_death_node)
2.通过inet_twsk_dead_node_init将tw_death_node
	初始化
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1308</x>
      <y>1781</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1330</x>
      <y>1778</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__inet_twsk_kill</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1335</x>
      <y>1774</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1325</x>
      <y>1785</y>
      <w>35</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.通过hlist_unhashed检查tw(tw_node)是否在ehash中
	如果不在，直接返回
2.将tw从ehash中删除
	__hlist_del(&amp;tw-&gt;tw_node);
	sk_node_init(&amp;tw-&gt;tw_node);
3.将tw从bhash中删除
	1.	tb = tw-&gt;tw_tb;
		__hlist_del(&amp;tw-&gt;tw_bind_node);
		tw-&gt;tw_tb = NULL;
	2.通过inet_bind_bucket_destroy检查是否需要
		删除tb(链接sk，tb到bhash)
4.通过inet_twsk_put递减tw的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1335</x>
      <y>1781</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1362</x>
      <y>1778</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_twsk_put</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1366</x>
      <y>1774</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1362</x>
      <y>1786</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.递减tw_refcnt
2.通过twsk_destructor销毁sk
3.kmem_cache_free释放tw
4.module_put释放module
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1367</x>
      <y>1781</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1318</x>
      <y>1663</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1345</x>
      <y>1663</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1357</x>
      <y>1663</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1348</x>
      <y>1623</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1323</x>
      <y>1509</y>
      <w>23</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1647</x>
      <y>1330</y>
      <w>93</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
TCP_CLOSE</panel_attributes>
    <additional_attributes>910.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1643</x>
      <y>1336</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>discard
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1743</x>
      <y>1330</y>
      <w>45</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;430.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1823</x>
      <y>1335</y>
      <w>43</w>
      <h>73</h>
    </coordinates>
    <panel_attributes>6.如果收到的是ack
	1.通过tcp_ack处理ack，如果非0表示接收成功
	2.如果sk的状态是TCP_SYN_RECV，并且ack被接收
		1.tcp_set_state(sk, TCP_ESTABLISHED);
			sk-&gt;sk_state_change(sk)
		2.通过sk_wake_async唤醒等待发送数据的进程
		3.更新窗口的左右边界
			tp-&gt;snd_una = TCP_SKB_CB(skb)-&gt;ack_seq; //窗口的左边界
			tp-&gt;snd_wnd = ntohs(th-&gt;window) &lt;&lt;
				      tp-&gt;rx_opt.snd_wscale;
			tp-&gt;snd_wl1=TCP_SKB_CB(skb)-&gt;seq //记录窗口更新时的ack seq
		4.如果有时间戳（saw_tstamp），并且不用平滑rtt(srtt),通过
			tcp_ack_saw_tstamp计算重传超时时间
		5.初始化拥塞控制模块：
			icsk-&gt;icsk_af_ops-&gt;rebuild_header(sk);
			tcp_init_metrics(sk);
			tcp_init_congestion_control(sk);
		6.tp-&gt;lsndtime = tcp_time_stamp;//最近发送数据报的时间
			tcp_mtup_init(sk);//mtu初始化
			tcp_initialize_rcv_mss(sk);
			tcp_init_buffer_space(sk)//tcp首部预测标志
	3.如果sk的状态是TCP_FIN_WAIT1，并且send_buf中的所有数据
		都被ack(snd_una==write_seq)
		1.tcp_set_state(sk, TCP_FIN_WAIT2)
		2.关闭发送
			sk-&gt;sk_shutdown |= SEND_SHUTDOWN
		3.dst_confirm确认路由缓存
		4.如果sk的SOCK_DEAD没置上，通过sk_state_change通知状态变化
		5.SOCK_DEAD置上
			1.如果没设置linger2(linger2&lt;0)，或者收到的skb中有报文
			通过tcp_done关闭sk，并返回1，发送rst
			2.如果timeou的时间(tcp_fin_time)超过了TCP_TIMEWAIT_LEN
				设置sk_timer的时间为tmo - TCP_TIMEWAIT_LEN
			3.如果收到fin，或者lock被占用，设置sk_timer的时间为tmo
			4.其他情况通过tcp_time_wait进入time_wait，丢弃skb并返回
	4.如果sk状态是TCP_CLOSING，send_buf中的所有数据都被ack
		1.通过tcp_time_wait进入time_wait，丢弃skb，并返回
	5.如果是TCP_LAST_ACK，send_buf中的所有数据都被ack
		1.tcp_update_metrics更新路由选项
		2.tcp_done进入tcp_close,并且丢弃skb，并返回
	注：snd_una：发送窗口左边界
		snd_nxt：预计发送的seq
		snd_wnd：发送窗口的大小
		write_seq：用户写的最后一个seq
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1868</x>
      <y>1335</y>
      <w>43</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>7.通过tcp_urg检查紧急指针
8.	查看sk的状态
	1.在TCP_CLOSE_WAIT TCP_CLOSING TCP_LAST_ACK收到没被应答的数据
		不做处理，否则跳到8.2
	2.TCP_FIN_WAIT1 TCP_FIN_WAIT2
		1.如果在RCV_SHUTDOWN情况下，收到报文中有数据，通过tcp_reset
			重置sk，并返回1，发送rst
		2.否则跳到8.3
	3.如果是TCP_ESTABLISHED，通过tcp_data_queue将skb加入队列
9.如果sk状态不是TCP_CLOSE，通过tcp_data_snd_check和
	tcp_ack_snd_check查看是否有data和ack需要发送
10.如果有数据放到queue中，通过__kfree_skb释放skb，并返回0.
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1743</x>
      <y>1330</y>
      <w>88</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;860.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1744</x>
      <y>1330</y>
      <w>136</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1340.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1920</x>
      <y>1302</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_timewait_state_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1450</x>
      <y>1277</y>
      <w>487</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;4850.0;250.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1976</x>
      <y>1300</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_v4_timewait_ack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1455</x>
      <y>1277</y>
      <w>532</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;5300.0;230.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1912</x>
      <y>1309</y>
      <w>41</w>
      <h>71</h>
    </coordinates>
    <panel_attributes>1.如果有选项，并且之前收到时间戳tw_ts_recent_stamp
	1.通过tcp_parse_options解析选项
	2.如果收到时间戳saw_tstamp
		1.用tw中存储的时间戳替换该时间戳
			tmp_opt.ts_recent	= tcptw-&gt;tw_ts_recent;
			tmp_opt.ts_recent_stamp	= tcptw-&gt;tw_ts_recent_stamp;
		2.通过tcp_paws_check检查paws
2.如果tw_substate是TCP_FIN_WAIT2
	1.paws检查没通过，或者skb不在窗口范围内，返回TCP_TW_ACK发送应答
	2.如果收到rst，通过inet_twsk_deschedule删除tw的链接关系，
		并且通过inet_twsk_put释放tw，返回TCP_TW_SUCCESS不做处理
	3.如果收到syn，并且已经收到的段，通过inet_twsk_deschedule删除tw的链接关系，
		并且通过inet_twsk_put释放tw，返回TCP_TW_RST发送rst
	4.如果是之前的段(end_seq&lt;=tw_rcv_nxt),或者之后的段的应答，释放tw，并返回
		TCP_TW_SUCCESS，丢弃skb
	5.如果没受到fin，或者受到了fin，但是还含有数据，通过inet_twsk_deschedule删除tw的链接关系，
		并且通过inet_twsk_put释放tw，返回TCP_TW_RST发送rst
	6.收到正确的fin
		1.更新tw
			tw-&gt;tw_substate	  = TCP_TIME_WAIT;
			tcptw-&gt;tw_rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;
			tcptw-&gt;tw_ts_recent_stamp = xtime.tv_sec;
			tcptw-&gt;tw_ts_recent	  = tmp_opt.rcv_tsval;
		2.如果时间戳有效，并且允许提前2MSL结束，设置超时时间为tw_timeout
			否则设置超时时间为60s
		3.返回TCP_TW_ACK，发送ack
3.如果tw_substate是TIME_WAIT
	1.paws检查通过，并且收到预期的seq（ack或者rst）
		1.如果收到rst，并且sysctl_tcp_rfc1337为0，通过inet_twsk_deschedule删除tw的链接关系，
		并且通过inet_twsk_put释放tw，返回TCP_TW_SUCCESS不做处理
		2.inet_twsk_schedule重新设置tw的timeout时间为60s
		3.如果收到时间戳，更新时间戳信息
			tcptw-&gt;tw_ts_recent	  = tmp_opt.rcv_tsval;
			tcptw-&gt;tw_ts_recent_stamp = xtime.tv_sec;
		4.inet_twsk_put释放tw，并返回TCP_TW_SUCCESS不做处理
	2.如果收到syn，但是没有rst，没有ack，paws检查通过
		序号在tw_rcv_nxt之后，或者受到时间戳后检查有效
		1.计算isn
		2.TCP_SKB_CB(skb)-&gt;when = isn;
		3.返回TCP_TW_SYN，接收syn
	3.如果没收到rst
		1.如果paws没检查通过，或者受到ack，inet_twsk_schedule重新调度tw
			并返回TCP_TW_ACK，发送应答
	4.否则通过inet_twsk_put释放tw，并返回TCP_TW_SUCCESS，忽略skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1931</x>
      <y>1305</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1156</x>
      <y>172</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_init_xmit_timers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1161</x>
      <y>168</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1154</x>
      <y>179</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_csk_init_xmit_timers</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1162</x>
      <y>175</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1115</x>
      <y>189</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_write_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1174</x>
      <y>193</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_delack_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1245</x>
      <y>193</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_keepalive_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1121</x>
      <y>182</y>
      <w>41</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
icsk_retransmit_timer</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1160</x>
      <y>182</y>
      <w>24</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
icsk_delack_timer</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;110.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1163</x>
      <y>182</y>
      <w>92</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
sk_timer
开始于发送syn_ack，并在timer到时自动检测</panel_attributes>
    <additional_attributes>10.0;10.0;900.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1101</x>
      <y>196</y>
      <w>40</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果sk_lock被持有，重置icsk_retransmit_timer为50ms
2.如果sk的状态为TCP_CLOSE，或者有事件(icsk_pending)
3.如果还没到icsk_timeout，重置icsk_retransmit_timer事件为timeout
4.查看timer的事件，并清除icsk-&gt;icsk_pending = 0
	1.如果设置了ICSK_TIME_RETRANS，通过tcp_retransmit_timer重发
	2.如果设置了ICSK_TIME_PROBE0，通过tcp_probe_timer探测
5.通过sk_stream_mem_reclaim回收内存
6.sock_put释放sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1120</x>
      <y>192</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1095</x>
      <y>213</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_retransmit_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1103</x>
      <y>209</y>
      <w>47</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
之前没发包，update_send_head设置ICSK_TIME_RETRANS，
否则在收到ack，在tcp_clean_rtx_queue--&gt;tcp_ack_packets_out中重置</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1127</x>
      <y>214</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_probe_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1120</x>
      <y>209</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
在tcp_ack时，tcp_ack_probe设置
这个函数在获取窗口后也会重置timer</panel_attributes>
    <additional_attributes>90.0;10.0;150.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1080</x>
      <y>220</y>
      <w>41</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>1.如果没有正在发的包packets_out，退出处理
2.如果没有窗口snd_wnd，并且sk的SOCK_DEAD置上，
	并且sk处于TCPF_SYN_SENT或者TCPF_SYN_RECV状态
	1.如果距上一次收到ack的时差超过了TCP_RTO_MAX
		通过tcp_write_err报告，并关闭sk
	2.通过tcp_enter_loss进入loss state
	3.tcp_retransmit_skb重发sk_write_queue中第一个skb
	4.__sk_dst_reset重置路由缓存
3.通过tcp_write_timeout检查是否重传超限，如果超过限制，退出
4.tcp_use_frto检查是否需要用frto，如果需要通过tcp_enter_frto进入frto
	否则通过tcp_enter_loss进入loss
5.通过tcp_retransmit_skb重发sk_write_queue上的报文，成功之后
	1.如果之前没设置icsk_retransmits，将icsk_retransmits设置为1
	2.重新设置ICSK_TIME_RETRANS
	3.退出
6.如果没成功;
	1.icsk-&gt;icsk_backoff++;
		icsk-&gt;icsk_retransmits++;
	2.重新设置ICSK_TIME_RETRANS
	3.如果icsk_retransmits超过了sysctl_tcp_retries1
		__sk_dst_reset重置路由缓存
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1102</x>
      <y>216</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1020</x>
      <y>260</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_enter_loss</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1006</x>
      <y>267</y>
      <w>36</w>
      <h>54</h>
    </coordinates>
    <panel_attributes>1.如果刚进入loss
	（1.icsk_ca_state状态不大于Disorder
		2.拥塞时的包已经全部应答
		3.虽然在TCP_CA_Loss，但是没有icsk_retransmits）
	1.记录当前的阈值tp-&gt;prior_ssthresh
	2.重新计算新的阈值
		tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk)
	3.tcp_ca_event发送CA_EVENT_LOSS
2.更新拥塞窗口
	tp-&gt;snd_cwnd	   = 1;
	tp-&gt;snd_cwnd_cnt   = 0;
	tp-&gt;snd_cwnd_stamp = tcp_time_stamp;
3.对重传变量清0
	tp-&gt;bytes_acked = 0;
	tcp_clear_retrans(tp);
4.如果不清除sack，undo_marker记录窗口左边界，以便在撤销的时候恢复
5.遍历重传队列[sk_write_queue,sk_send_head)
	1.如果之前skb被重传，将undo_marker清空
	2.将skb的TCPCB_SACKED_RETRANS和TCPCB_LOST清空
	3.如果TCPCB_SACKED_ACKED没置上，或者sack需要清空
		TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_SACKED_ACKED;
		TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST;
		tp-&gt;lost_out += tcp_skb_pcount(skb);
	4.如果被sack
		tp-&gt;sacked_out += tcp_skb_pcount(skb);
		tp-&gt;fackets_out = cnt;//记录最后一个被sack的seq
6.通过tcp_sync_left_out计算离开网络的包（sack+lost）
7.reordering不能超过sysctl_tcp_reordering
8.tcp_set_ca_state设置拥塞状态是TCP_CA_Loss
9.记录发生拥塞时的snd_nxt
	tp-&gt;high_seq = tp-&gt;snd_nxt
10.TCP_ECN_queue_cwr设置拥塞标志TCP_ECN_QUEUE_CWR
11.clear_all_retrans_hints清空所有的缓存
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1024</x>
      <y>263</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1050</x>
      <y>261</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_write_timeout</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1078</x>
      <y>261</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_use_frto</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1101</x>
      <y>261</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_enter_frto</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1024</x>
      <y>254</y>
      <w>61</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>590.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1054</x>
      <y>254</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1043</x>
      <y>267</y>
      <w>31</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.如果在TCPF_SYN_SENT或者TCPF_SYN_RECV
	1.如果之前又被重发，通过dst_negative_advice重新路由
	2.计算其最大的重发次数retry_until
2.否则：
	1.如果重发次数超过了sysctl_tcp_retries1
		1.如果做路径mtu
			1.如果路径mtu没开始，置上icsk_mtup.enabled
			2.tcp_sync_mss重新同步mss
		2.dst_negative_advice重新路由
	2.暂定重试次数retry_until为sysctl_tcp_retries2
	3.如果sk的SOCK_DEAD置上
		1.tcp_orphan_retries重新计算重试次数
		2.如果tcp_out_of_resources检测到资源有限，返回1不做重发
3.如果icsk_retransmits超过retry_until，tcp_write_err报告错误
	并返回1，不做重发
4.其他情况返回0，做重发操作
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1056</x>
      <y>264</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1085</x>
      <y>254</y>
      <w>3</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1076</x>
      <y>267</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果启用了frto，有新数据要发，
	发的新数据在窗口内
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1084</x>
      <y>264</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1088</x>
      <y>254</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1100</x>
      <y>267</y>
      <w>33</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.tp-&gt;frto_counter = 1
2.如果刚进入frto
	（1.icsk_ca_state状态不大于Disorder
		2.拥塞时的包已经全部应答
		3.虽然在TCP_CA_Loss，但是没有icsk_retransmits）
	1.记录当前的阈值tp-&gt;prior_ssthresh
	2.重新计算新的阈值
		tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk)
	3.tcp_ca_event发送CA_EVENT_FRTO
3.清除loss状态下的记录
	tp-&gt;retrans_out = 0;
	tp-&gt;undo_marker = tp-&gt;snd_una;
	tp-&gt;undo_retrans = 0;
4.遍历[sk_write_queue,sk_send_head),将skb的TCPCB_RETRANS清除
5.tcp_sync_left_out计算离开网络的报文
6.tcp_set_ca_state设置状态为TCP_CA_Open
7.frto_highmark记录snd_nxt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1107</x>
      <y>264</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1125</x>
      <y>223</y>
      <w>42</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果网络上还有报文传输(packets_out)，或者没有新报文(!sk_send_head)
	1.icsk-&gt;icsk_probes_out = 0;
	2.返回
2.如果SOCK_DEAD置上
	1.tcp_orphan_retries获取最大的重试次数max_probes
	2.通过tcp_out_of_resources检查资源是否超过限制，如果超限返回
3.如果重试次数(icsk_probes_out)超过了max_probes,通过tcp_write_err
	报告错误
4.否则通过tcp_send_probe0重新发送probe
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1134</x>
      <y>217</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1147</x>
      <y>242</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_send_probe0</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1152</x>
      <y>238</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1134</x>
      <y>249</y>
      <w>36</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.通过tcp_write_wakeup发送probe
2.如果网络上有包，或者没有新数据(sk_send_head)
	1.icsk-&gt;icsk_probes_out = 0;
		icsk-&gt;icsk_backoff = 0;
	2.返回
3.如果正确发送或者因为外部无法发送
	1.icsk-&gt;icsk_backoff++
		icsk-&gt;icsk_probes_out++
	2.inet_csk_reset_xmit_timer设置ICSK_TIME_PROBE0
4.如果本地资源有限无法发送
	1.如果之前没设置icsk_probes_out，将icsk_probes_out置1
	2.inet_csk_reset_xmit_timer设置ICSK_TIME_PROBE0为相对小的值
		争抢资源
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1152</x>
      <y>245</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1145</x>
      <y>274</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_write_wakeup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1150</x>
      <y>270</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1135</x>
      <y>281</y>
      <w>43</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.如果sk的状态没有TCP_CLOSE
	1.如果有新数据，并且skb有数据在窗口内
		1.pushed_seq不能低于end_seq
		2.如果只能发送部分的数据
			1.TCP_SKB_CB(skb)-&gt;flags |= TCPCB_FLAG_PSH//这里让fragrament有push
			2.tcp_fragment进行分段
		3.能发全部数据，但是skb包的数目没被确定，通过
			tcp_set_skb_tso_segs确定
		4.TCP_SKB_CB(skb)-&gt;flags |= TCPCB_FLAG_PSH;
			TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;
		5.tcp_transmit_skb发送数据
		6.如果发送成功，update_send_head更新sk_send_head
			snd_nxt，packets_out
		7.返回
	2.如果窗口不能发该数据
		1.如果有紧急指针，并且在(snd_una+1,snd_una+0xFFFF),tcp_xmit_probe_skb
			发送probe(TCPCB_URG置上)
		2.否则tcp_xmit_probe_skb发送(urg不置)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1151</x>
      <y>277</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1149</x>
      <y>314</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_xmit_probe_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1156</x>
      <y>310</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1135</x>
      <y>321</y>
      <w>42</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.alloc_skb申请skb
2.skb_reserve预留出tcp头部的长度
3.设置skb
	skb-&gt;csum = 0;
	TCP_SKB_CB(skb)-&gt;flags = TCPCB_FLAG_ACK;
	TCP_SKB_CB(skb)-&gt;sacked = urgent;
	skb_shinfo(skb)-&gt;gso_segs = 1;
	skb_shinfo(skb)-&gt;gso_size = 0;
	skb_shinfo(skb)-&gt;gso_type = 0;
	//urg发送的是预期的seq，否则发送的旧的seq，都是没长度
	TCP_SKB_CB(skb)-&gt;seq = urgent ? tp-&gt;snd_una : tp-&gt;snd_una - 1;
	TCP_SKB_CB(skb)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;seq;
	TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;
4.tcp_transmit_skb发送skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1155</x>
      <y>317</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1981</x>
      <y>1483</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_ack_probe</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1975</x>
      <y>1490</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果发送的新数据在窗口范围内，重置ICSK_TIME_PROBE0
		icsk-&gt;icsk_backoff = 0;
		inet_csk_clear_xmit_timer(sk, ICSK_TIME_PROBE0)
2.否则inet_csk_reset_xmit_timer设置ICSK_TIME_PROBE0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1986</x>
      <y>1486</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1857</x>
      <y>1478</y>
      <w>130</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
probe时钟的启动和停止都是在这</panel_attributes>
    <additional_attributes>10.0;10.0;1280.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1498</x>
      <y>231</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>TCP_ECN_send_syn</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1504</x>
      <y>227</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1485</x>
      <y>240</y>
      <w>28</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果开启了拥塞通知
	TCP_SKB_CB(skb)-&gt;flags |= TCPCB_FLAG_ECE|TCPCB_FLAG_CWR//要求服务端开启拥塞通知
	tp-&gt;ecn_flags = TCP_ECN_OK//开启客户端的拥塞通知
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1504</x>
      <y>234</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1252</x>
      <y>196</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1232</x>
      <y>255</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_synack_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1217</x>
      <y>269</y>
      <w>38</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>1.如果没有lopt，或者lopt没有req(!qlen)，直接返回
2.算出syn_ack重发的门限值thresh=max_retries-lg(qlen/young)
3.如果有rskq_defer_accept，将其付给max_retries
4.计算遍历syn_table的次数budget
5.遍历syn_table，选择上次结束的点lopt-&gt;clock_hand开始
	1.如果hash不为空
		1.如果req超时
			1.如果syn_ack重发没超限(retrans &lt; thresh或者
			被acked但是重发次数没超过max_retries)，通过
			req-&gt;rsk_ops-&gt;rtx_syn_ack重发syn_ack，如果重发成功
				1.递增retrans，如果是第一次重发，老化req(qlen_young--)
				2.重新设置req-&gt;expires
				3.遍历head的下一个req(req-&gt;dl_next)
			2.如果不能重发
				1.通过inet_csk_reqsk_queue_unlink将req冲链表中删除
				2.通过reqsk_queue_removed递减lopt中req的数量
				3.通过reqsk_free释放req
				4.继续循环下一个，因为req被移出链表，这里自动选取下一个req
		2.如果没超时，遍历链表下一个dl_next
	2.这个hash链表为空，遍历下一个表头
		i = (i + 1) &amp; (lopt-&gt;nr_table_entries - 1)
	3.直到budget用完
6.记录遍历到的表头
	lopt-&gt;clock_hand = i
7.如果还有req(qlen),通过inet_csk_reset_keepalive_timer重新设置keepalive_timer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1227</x>
      <y>262</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_csk_reqsk_queue_prune</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1237</x>
      <y>258</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1236</x>
      <y>265</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1225</x>
      <y>313</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>reqsk_queue_removed</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1218</x>
      <y>320</y>
      <w>30</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.如果req还没被老化(retrans == 0),递减qlen_young
2.递减并返回qlen
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1231</x>
      <y>316</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1232</x>
      <y>309</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1265</x>
      <y>254</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_send_active_reset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1256</x>
      <y>261</y>
      <w>35</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.通过alloc_skb申请skb
2.通过skb_reserve预留tcp头部的长度
3.初始化skb发送的参数
	skb-&gt;csum = 0;
	TCP_SKB_CB(skb)-&gt;flags = (TCPCB_FLAG_ACK | TCPCB_FLAG_RST);
	TCP_SKB_CB(skb)-&gt;sacked = 0;
	skb_shinfo(skb)-&gt;gso_segs = 1;
	skb_shinfo(skb)-&gt;gso_size = 0;
	skb_shinfo(skb)-&gt;gso_type = 0;
	TCP_SKB_CB(skb)-&gt;seq = tcp_acceptable_seq(sk, tp);
	TCP_SKB_CB(skb)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;seq;
	TCP_SKB_CB(skb)-&gt;when = tcp_time_stamp;
4.通过tcp_transmit_skb发送skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1272</x>
      <y>257</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1266</x>
      <y>286</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_acceptable_seq</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1273</x>
      <y>282</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1258</x>
      <y>293</y>
      <w>31</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.如果snd_nxt没超过窗口的边界，返回snd_nxt
2.否则返回窗口的有边界
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1273</x>
      <y>289</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1235</x>
      <y>199</y>
      <w>45</w>
      <h>52</h>
    </coordinates>
    <panel_attributes>1.如果sk_lock已经被持有，重置keep_alive timer为50ms，并跳到out
2.如果sk处于TCP_LISTEN,通过tcp_synack_timer处理监听hash表中的
	req，并跳到out
3.如果sk的状态在TCP_FIN_WAIT2，并且SOCK_DEAD
	1.如果设置了linger2
		1.如果有timeout时间，通过tcp_time_wait进入time_wait，跳到out
		2.否则，通过tcp_send_active_reset发送rst，跳到death，关闭sk
4.如果SOCK_KEEPOPEN没置上，或者sk的状态在TCP_CLOSE，直接跳到out
5.如果网络上有包(packets_out),或者有新数据要发(sk_send_head)
	直接跳到resched，重新设置keepalive_timer

注：这里网络上没包，并且没有新数据
6.如果到上次ack的时间超过了keep_alive_time
	1.如果发送探测的次数(icsk_probes_out)，超过了限制
		1.tcp_send_active_reset发送rst
		2.tcp_write_err报告错误
		3.跳到out
	2.通过tcp_write_wakeup发送探测帧，如果成功
		1.递增icsk_probes_out
		2.确定keep_alive_timer时间
	注：tcp_write_wakeup一定是通过tcp_xmit_probe_skb发送探测帧，因为到这里
		sk_send_head一定为空
	3.如果失败，设置时间为TCP_RESOURCE_PROBE_INTERVAL
7.如果没超过，将剩下时间接着作为keep_alive_timer的时间
8.sk_stream_mem_reclaim回收内存
9.resched：
	1.inet_csk_reset_keepalive_timer设置keep_alive_timer的时间
	2.跳到out
10.death：
	1.tcp_done结束链接
	2.out:
		1.sock_put释放sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1238</x>
      <y>250</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1266</x>
      <y>250</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1614</x>
      <y>1530</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>TCP_ECN_make_synack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1622</x>
      <y>1526</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1603</x>
      <y>1537</y>
      <w>36</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果inet_rsk(req)-&gt;ecn_ok置上，将发送的th-&gt;ece
	置上
注：1.如果客户端发送syn时要求拥塞控制，TCP_ECN_send_syn
	将ece和cwr置上，服务端通过TCP_ECN_create_request检测
	2.如果要求拥塞控制，服务端发送syn_ack时将ece置上，
	但是不置cwr，客户端在TCP_ECN_rcv_synack中检测
	
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1620</x>
      <y>1533</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2016</x>
      <y>1483</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>TCP_ECN_rcv_ecn_echo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2011</x>
      <y>1490</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果不是syn的情况下，要求拥塞，并且收到ece
	表示接收方要求拥塞控制，返回1
2.否则返回0，不做拥塞控制
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2026</x>
      <y>1486</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1856</x>
      <y>1478</y>
      <w>172</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1700.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1460</x>
      <y>230</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_connect_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1465</x>
      <y>233</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1467</x>
      <y>227</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>330.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1450</x>
      <y>237</y>
      <w>32</w>
      <h>45</h>
    </coordinates>
    <panel_attributes>1.根据timestamp确定tp-&gt;tcp_header_len
2.如果有user_mss，将其设置为mss_clamp
注：mss_clamp在tcp_v4_connect中初始化为536
3.tp-&gt;max_window = 0
4.tcp_mtup_init初始化路径mtu
5.tcp_sync_mss确定mss
注：根据路径mtu考虑到mss_clamp，不能低于48，
	不能超过max_window/2,不能小于search_low
6.由路由确定window_clamp，advmss
7.tcp_initialize_rcv_mss初始化rcv_mss
注：advmss，mss_cache，rcv_wnd/2，TCP_MIN_RCVMSS的最小值
	但是要大于TCP_MIN_MSS
8.tcp_select_initial_window初始化窗口，并初始化参数
	tp-&gt;rx_opt.rcv_wscale = rcv_wscale;
	tp-&gt;rcv_ssthresh = tp-&gt;rcv_wnd;
	sk-&gt;sk_err = 0;
	sock_reset_flag(sk, SOCK_DONE);
	tp-&gt;snd_wnd = 0;
	tcp_init_wl(tp, tp-&gt;write_seq, 0);
	tp-&gt;snd_una = tp-&gt;write_seq;
	tp-&gt;snd_sml = tp-&gt;write_seq;
	tp-&gt;rcv_nxt = 0;
	tp-&gt;rcv_wup = 0;
	tp-&gt;copied_seq = 0;
	inet_csk(sk)-&gt;icsk_rto = TCP_TIMEOUT_INIT;
	inet_csk(sk)-&gt;icsk_retransmits = 0;
9.tcp_clear_retrans清除所有重传计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1454</x>
      <y>286</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_select_initial_window</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1443</x>
      <y>294</y>
      <w>44</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.确定接收窗口大小rcv_wnd
注：sk_rcvbuf为基础，不能超过window_clamp，对mss向上取整
2.如果允许sysctl_tcp_window_scaling
	窗口以sysctl_tcp_rmem或者sysctl_rmem_max为基准，不能超过window_clamp
	从而确定rcv_wscale
3.如果mss超过了窗口的基本单位，更新窗口的大小
4.更新window_clamp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1461</x>
      <y>289</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1463</x>
      <y>281</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1703</x>
      <y>1501</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_init_buffer_space</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1711</x>
      <y>1497</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1691</x>
      <y>1509</y>
      <w>37</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果sk_userlocks的SOCK_RCVBUF_LOCK没置上，通过tcp_fixup_rcvbuf
	设置sk_rcvbuf不低于4*advmss
2.同理SOCK_SNDBUF_LOCK没置上，通过tcp_fixup_sndbuf
	设置sk_sndbuf不低于3*mss_clamp
3.tp-&gt;rcvq_space.space = tp-&gt;rcv_wnd
4.确定window_clamp
5.tp-&gt;rcv_ssthresh = min(tp-&gt;rcv_ssthresh, tp-&gt;window_clamp);
	tp-&gt;snd_cwnd_stamp = tcp_time_stamp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1709</x>
      <y>1504</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1169</x>
      <y>200</y>
      <w>45</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.sock_owned_by_user检查到锁被持有，
	1.icsk-&gt;icsk_ack.blocked = 1
	2.重新设置icsk_delack_timer为TCP_DELACK_MIN
2.sk_stream_mem_reclaim回收内存
3.如果sk的状态在TCP_CLOSE，或者事件ICSK_ACK_TIMER没被置上，跳到out，不做处理
4.如果事件没到，重新设置icsk_delack_timer为timeout
5.清除事件
	icsk-&gt;icsk_ack.pending &amp;= ~ICSK_ACK_TIMER
6.如果prequeue中有数据
	1.通过__skb_dequeue取出prequeue中的skb，利用sk_backlog_rcv处理
	2.tp-&gt;ucopy.memory = 0
7.inet_csk_ack_scheduled检测到ICSK_ACK_SCHED
	1.如果没在交互模式(ato时间内没发报文)，扩大ato，但是不能超过icsk_rto
	2.否则重置
		icsk-&gt;icsk_ack.pingpong = 0;
		icsk-&gt;icsk_ack.ato      = TCP_ATO_MIN;
	3.tcp_send_ack发送ack
8.out:
	1.如果有内存压力，sk_stream_mem_reclaim释放内存
	2.sock_put释放sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1182</x>
      <y>196</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2059</x>
      <y>1481</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_cong_avoid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1857</x>
      <y>1478</y>
      <w>212</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2100.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2048</x>
      <y>1488</y>
      <w>35</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.通过icsk-&gt;icsk_ca_ops-&gt;cong_avoid处理拥塞窗口
2.更新tcp_sk(sk)-&gt;snd_cwnd_stamp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2064</x>
      <y>1484</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1875</x>
      <y>1413</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_init_congestion_control</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1852</x>
      <y>1407</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1287</x>
      <y>406</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1091</x>
      <y>395</y>
      <w>204</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2020.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1296</x>
      <y>415</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_register_congestion_control</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1294</x>
      <y>409</y>
      <w>14</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_reno</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1287</x>
      <y>422</y>
      <w>40</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.要注册的拥塞算法，ssthresh和cong_avoid要存在
2.如果通过tcp_ca_find在tcp_cong_list中找到名称相同的算法
	返回，否则通过list_add_tail_rcu加入到链表tcp_cong_list中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1308</x>
      <y>418</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1864</x>
      <y>1420</y>
      <w>34</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.最初的算法要是tcp_init_congestion_ops，否则退出
2.遍历tcp_cong_list，通过try_module_get获取算法
	如果成功，赋值并退出查找
	icsk-&gt;icsk_ca_ops = ca;
注：越在链表前面的拥塞算法，优先级越高
3.如果有icsk_ca_ops-&gt;init，即初始化
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1886</x>
      <y>1416</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2065</x>
      <y>1491</y>
      <w>24</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_init_congestion_ops/tcp_reno</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2058</x>
      <y>1497</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_reno_cong_avoid</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2042</x>
      <y>1504</y>
      <w>46</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.tcp_is_cwnd_limited查看是否被已经被限制，如果没被限制，直接返回
	不对拥塞窗口调整
2.如果拥塞窗口没超过限制snd_ssthresh，通过tcp_slow_start慢启动
2.如果超过了snd_ssthresh
	1.如果字节控制(sysctl_tcp_abc)
		1.如果ack的长度超过了snd_cwnd*mss_cache，
			tp-&gt;bytes_acked -= tp-&gt;snd_cwnd*tp-&gt;mss_cache;
			tp-&gt;snd_cwnd++(不超过snd_cwnd_clamp)
	2.递增tp-&gt;snd_cwnd_cnt，如果snd_cwnd_cnt到达了拥塞窗口snd_cwnd
		的大小，递增snd_cwnd(不超过snd_cwnd_clamp)，并重置snd_cwnd_cnt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2065</x>
      <y>1500</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2041</x>
      <y>1524</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_is_cwnd_limited</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2048</x>
      <y>1520</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2032</x>
      <y>1531</y>
      <w>38</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果网络上的报超过了拥塞窗口，已经被app限制，返回1
2.因为tcp_tso_should_defer在可以分割的skb预留了窗口：
	1.如果不能分割，直接返回0
	2.如果可以分割，但是剩余的窗口剩余的部分不超过预期，返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2047</x>
      <y>1527</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2074</x>
      <y>1524</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_slow_start</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2079</x>
      <y>1520</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2071</x>
      <y>1531</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果sysctl_tcp_abc打开（拥塞窗口的调整以字节为单位，不以包为单位）
	1.如果被应答的字节数(bytes_acked)没超过mss_cache,直接返回
	2.如果bytes_acked超过了2mss_cache，在sysctl_tcp_abc
		允许的情况下，递增snd_cwnd(不超过snd_cwnd_clamp)
2.清除bytes_acked
3.递增snd_cwnd(不超过snd_cwnd_clamp)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2080</x>
      <y>1527</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2117</x>
      <y>1480</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_fastretrans_alert</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1858</x>
      <y>1478</y>
      <w>269</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2670.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2109</x>
      <y>1488</y>
      <w>48</w>
      <h>123</h>
    </coordinates>
    <panel_attributes>1.如果网络上没包(!packets_out),将sacked_out清除
2.如果sacked_out没有，将fackets_out清除
3.如果被通告网络阻塞(FLAG_ECE)，将不再undo
	tp-&gt;prior_ssthresh = 0
4.如果又被sacked_out，tcp_check_sack_reneging检查sack
	有问题，直接返回
5.如果被标记为FLAG_DATA_LOST，并且拥塞发生在当前窗口
	并且不处于TCP_CA_Open，并且被应答的最大seq(fackets_out)超过了reordering
	通过tcp_mark_head_lost
注：tcp_update_reordering中记录reordering，表示第一个sack.end_seq到最后一个sack.end_seq（fackets_out）的长度
6.tcp_sync_left_out同步left_out
7.如果处于TCP_CA_Open，
	tp-&gt;retrans_stamp = 0
8.否则，如果拥塞之前的high_seq被ack
	1.如果之前处于loss
		1.icsk-&gt;icsk_retransmits = 0
		2.tcp_try_undo_recovery尝试恢复到TCP_CA_Open
	2.如果之前处于TCP_CA_CWR
		1.如果high_seq之前的全被ack(注意8的条件)
			1.通过tcp_complete_cwr调整snd_cwnd
			2.tcp_set_ca_state设置状态为TCP_CA_Open
	3.如果之前处于TCP_CA_Disorder
		1.通过tcp_try_undo_dsack复原cwnd
		2.如果没有undo_marker，或者不是reno,或者high_seq之前的全被ack
			tp-&gt;undo_marker = 0;
			tcp_set_ca_state(sk, TCP_CA_Open);
	4.如果之前的状态是TCP_CA_Recovery
		1.如果不是reno，通过tcp_reset_reno_sack重置sack(因为不用sack)
		2.通过tcp_try_undo_recovery回复cwnd，如果恢复失败，直接返回
		3.tcp_complete_cwr调整cwnd
9.处理拥塞状态，查看icsk_ca_state
	1.如果当前处于TCP_CA_Recovery
		1.如果窗口左边界没变化
			1.在reno的情况下收到dup_ack，通过tcp_add_reno_sack调整sack_out
		2.如果窗口被ack
			1.如果处于reno，通过tcp_remove_reno_sacks递减sack_out（被ack的数量）
			2.tcp_try_undo_partial查看是否撤销拥塞状态
	2.如果之前处于TCP_CA_Loss
		1.如果有发来数据(FLAG_DATA_ACKED)
			icsk-&gt;icsk_retransmits = 0
		2.因为收到了ack，所以超时的loss状态，试图通过tcp_try_undo_loss撤销
			1.如果撤销失败，tcp_moderate_cwnd调整cwnd
			2.tcp_xmit_retransmit_queue进行重发
		3.如果没返回到TCP_CA_Open，直接return
		4.如果处于TCP_CA_Open，跳到9.3
	3.default
		1.如果是reno
			1.如果左边界被应答，通过tcp_reset_reno_sack重置sacked_out
			2.如果是重复应答，通过tcp_add_reno_sack递增sacked_out
		2.如果是TCP_CA_Disorder，因为收到了应答，通过tcp_try_undo_dsack
			撤销拥塞
		3.tcp_time_to_recover检查是否需要进入TCP_CA_Recovery，如果不进recorvery
			通过tcp_try_to_open尝试退出拥塞，并直接返回
		4.在低于TCP_CA_CWR，并且pmtu(probe_size)失败(左边界没更新)
			1.tcp_mtup_probe_failed通知pmtu失败
			2.tp-&gt;snd_cwnd++
			3.tcp_simple_retransmit进行重发
		5.进入recorvery
			1.tp-&gt;high_seq = tp-&gt;snd_nxt;
				tp-&gt;prior_ssthresh = 0;
				tp-&gt;undo_marker = tp-&gt;snd_una;
				tp-&gt;undo_retrans = tp-&gt;retrans_out;
			2.如果之前的状态disorder或者open
				1.如果现在ece没置上，保存ssthresh
					tp-&gt;prior_ssthresh = tcp_current_ssthresh(sk)
				2.调整snd_ssthresh
					tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk)
				3.TCP_ECN_queue_cwr发送cwr
			3.tp-&gt;bytes_acked = 0;
				tp-&gt;snd_cwnd_cnt = 0;
				tcp_set_ca_state(sk, TCP_CA_Recovery)
10.如果收到了dupack，或者tcp_head_timedout检测到第一个skb超过了rto
	通过tcp_update_scoreboard调整记分板
11.tcp_cwnd_down递减swnd
12.tcp_xmit_retransmit_queue进行重发
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2126</x>
      <y>1483</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1925</x>
      <y>1625</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_check_sack_reneging</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1918</x>
      <y>1632</y>
      <w>41</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果sk_write_queue中的第一个skb被sack(应该直接被ack)，处理有问题
	1.按照丢帧处理
		1.tcp_enter_loss
		2.icsk-&gt;icsk_retransmits++
		3.重传第一个skb
		4.重置ICSK_TIME_RETRANS
		5.返回1，表示sack有问题
2.返回0，表示没问题
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1933</x>
      <y>1628</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1974</x>
      <y>1623</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_mark_head_lost</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1967</x>
      <y>1630</y>
      <w>44</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.如果记录了lost_skb_hint，从lost_skb_hint开始遍历，否则从sk_write_queue
	开始遍历发送链表(直到sk_send_head)
	1.记录
		tp-&gt;lost_skb_hint = skb;
		tp-&gt;lost_cnt_hint = cnt;
	2.如果超过了第一个sack.end_seq，或者超过了拥塞是记录的snd_next
		退出处理
	3.如果之前没被记分牌标记
		1.TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_LOST
		2.更新lost_out
			tp-&gt;lost_out += tcp_skb_pcount(skb)
		3.如果skb已经被重发过(retransmit_skb_hint超过了skb)
			tp-&gt;retransmit_skb_hint = NULL
		4.tcp_sync_left_out同步left_out
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1984</x>
      <y>1626</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2031</x>
      <y>1622</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_try_undo_recovery</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2019</x>
      <y>1629</y>
      <w>43</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.tcp_may_undo检查是否需要撤销拥塞
	1.tcp_undo_cwr撤销拥塞
	2.tp-&gt;undo_marker = 0
2.如果仅仅是被acked到high_seq，并且没被sack(IsReno)
	只通过tcp_moderate_cwnd调整snd_cwnd，返回1，表示没撤销成功
注：reno表示不用sack
3.tcp_set_ca_state设置状态为TCP_CA_Open
3.返回0，表示撤销成功
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2039</x>
      <y>1625</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2018</x>
      <y>1648</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_may_undo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2002</x>
      <y>1655</y>
      <w>41</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.可以被撤销(undo_marker)
2.并且没有被重发(undo_retrans)或者tcp_packet_delayed检查packet仅仅是被延迟
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2022</x>
      <y>1651</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2013</x>
      <y>1662</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_packet_delayed</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2021</x>
      <y>1658</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2003</x>
      <y>1669</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.没被重发(!retrans_stamp)
2.或者被重发了，但是现在收到的是之前的帧
	回显(rcv_tsecr)&lt;重发的时间戳(retrans_stamp)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2019</x>
      <y>1665</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2049</x>
      <y>1647</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_undo_cwr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2044</x>
      <y>1654</y>
      <w>33</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果储存prior_ssthresh
	1.通过icsk-&gt;icsk_ca_ops-&gt;undo_cwnd撤销
	2.或者调整拥塞窗口snd_cwnd为2*snd_ssthresh
	3.在撤销的情况下，prior_ssthresh超过snd_ssthresh
		1.tp-&gt;snd_ssthresh = tp-&gt;prior_ssthresh
		2.TCP_ECN_withdraw_cwr清除cwr
2.否则，调整拥塞窗口snd_cwnd为snd_ssthresh
3.tcp_moderate_cwnd调整拥塞窗口
	tp-&gt;snd_cwnd_stamp = tcp_time_stamp;
4.clear_all_retrans_hints清除所有的缓存
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2054</x>
      <y>1650</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2052</x>
      <y>1675</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_moderate_cwnd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2042</x>
      <y>1682</y>
      <w>29</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.snd_cwnd不能超过packet_out+3
2.tp-&gt;snd_cwnd_stamp = tcp_time_stamp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2060</x>
      <y>1678</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2059</x>
      <y>1671</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2024</x>
      <y>1642</y>
      <w>4</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2043</x>
      <y>1642</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2077</x>
      <y>1622</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_complete_cwr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2071</x>
      <y>1629</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.swnd不能超过snd_ssthresh
	tp-&gt;snd_cwnd_stamp = tcp_time_stamp;
2.tcp_ca_event发送CA_EVENT_COMPLETE_CWR
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2084</x>
      <y>1625</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2116</x>
      <y>1620</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_try_undo_dsack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2109</x>
      <y>1627</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果有undo_marker，但是没有undo_retrans
	1.通过tcp_undo_cwr复原
	2.tp-&gt;undo_marker = 0;
注：undo_retrans为0表示没有被重发
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2123</x>
      <y>1623</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2151</x>
      <y>1620</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_reset_reno_sack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2143</x>
      <y>1626</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.清空sacked_out
2.离开网络上的帧left_out就只包含遗失的帧(lost_out)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2159</x>
      <y>1623</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2194</x>
      <y>1618</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_add_reno_sack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2182</x>
      <y>1625</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.递增sacked_out
2.tcp_check_reno_reordering调整sack_outreordering
3.tcp_sync_left_out同步left_out
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2199</x>
      <y>1621</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2193</x>
      <y>1634</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_check_reno_reordering</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2201</x>
      <y>1630</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2179</x>
      <y>1641</y>
      <w>42</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.hole的长度初始化为lost_out，但是不能小于1，不能大于packets_out
2.sack_out+hole如果超过了packets_out，说明sack_out过多
	1.tp-&gt;sacked_out = tp-&gt;packets_out - holes
	2.tcp_update_reordering更新reordering到发出去的最右边界(packet_out+add)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2201</x>
      <y>1637</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2231</x>
      <y>1618</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_remove_reno_sacks</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2221</x>
      <y>1625</y>
      <w>36</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.tp-&gt;sacked_out -= acked-1
注：lost_out最小为1，当其大于1的时候sacked_out为0
2.tcp_check_reno_reordering调整sacked_out和reordering
3.tcp_sync_left_out更新left_ouy
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2238</x>
      <y>1621</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2270</x>
      <y>1618</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_try_undo_partial</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2261</x>
      <y>1625</y>
      <w>35</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果处于reno，或者fackets_out的大小超过了reordering
	说明只是部分被ack，fail为1
注：1.reno如果是全部被ack，就会退出TCP_CA_Recovery状态，不会运行到这
	2.fackets_out记录最大sack的seq，reordering则记录着sack的大小
2.tcp_may_undo检查是否需要undo，如果需要
	1.如果没有重传(!retrans_out),tp-&gt;retrans_stamp = 0
	2.tcp_update_reordering更新reordering为fackets_out+ack
注;reordering表示重传时最小丢失的帧,这里没有重传就导致了数据包
	被ack，所以这里撤销拥塞，认为之前的是网络延迟导致的，所以重新更新reordering
	3.tcp_undo_cwr调整cwnd和snd_ssthresh
	4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2277</x>
      <y>1621</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2315</x>
      <y>1618</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_try_undo_loss</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2305</x>
      <y>1624</y>
      <w>35</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.tcp_may_undo检查是否可以undo
	1.将(sk_write_queue,sk_send_head)的skb中的TCPCB_LOST清除
	2.clear_all_retrans_hints清除所有的hints
	3.tp-&gt;lost_out = 0;
		tp-&gt;left_out = tp-&gt;sacked_out;
	4.tcp_undo_cwr撤销拥塞
	5.inet_csk(sk)-&gt;icsk_retransmits = 0;
		tp-&gt;undo_marker = 0;
	6.如果是reno，设置状态为TCP_CA_Open
	7.返回1，表示undo成功
2.返回0，表示undo失败
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2320</x>
      <y>1621</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2350</x>
      <y>1617</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_try_undo_dsack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2342</x>
      <y>1624</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果可以撤销（undo_marker），并且没有重发(!undo_retrans)
	1.tcp_undo_cwr撤销拥塞
	2.tp-&gt;undo_marker = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2357</x>
      <y>1620</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2395</x>
      <y>1616</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_time_to_recover</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2382</x>
      <y>1623</y>
      <w>40</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果确定有丢帧(lost_out),返回1，表示进入recorvery
2.如果fackets_out超过了reordering，表示可允许的范围内
	(reordering)发生了丢帧，返回1
注：这是一般性检查，比如ack超过3个也在这里检查
3.tcp_head_timedout检查到sk_write_queue时间超过了rto
	返回1，表示丢帧
4.如果网络上的包packet_out没超过reordering，但是被应答的
	sacked_out超过了packet_out的一半，并且tcp_may_send_now
	检测暂时没办法发数据，因为没办法得到对方的反馈，返回1
5.返回0，表示停留在disorder或者返回open
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2403</x>
      <y>1619</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2439</x>
      <y>1615</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_try_to_open</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2428</x>
      <y>1622</y>
      <w>39</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.left_out=sacked_out
2.如果skb的ece置上，通过tcp_enter_cwr进入cwr
3.如果不在TCP_CA_CWR(open或者disorder)
	1.默认进入的状态是TCP_CA_Open
	2.如果有left_out，重发retrans_out，或者待回复的拥塞undo_marker
		状态设置为TCP_CA_Disorder
	3.如果状态发生了改变
		1.tcp_set_ca_state重新设置为要进入的状态
		2.记入high_seq
			tp-&gt;high_seq = tp-&gt;snd_nxt
	4.tcp_moderate_cwnd调整cwnd
4.如果处于TCP_CA_CWR，tcp_cwnd_down缓慢减小cwnd
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2444</x>
      <y>1618</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2438</x>
      <y>1645</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_cwnd_down</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2443</x>
      <y>1641</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2428</x>
      <y>1652</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.snd_cwnd_cnt最后一位向上取整，decr为snd_cwnd_cnt/2
2.如果存在decr，并且snd_cwnd没超过snd_ssthresh
	tp-&gt;snd_cwnd -= decr
3.snd_cwnd不能超过tcp_packets_in_flight(tp)+1
	tp-&gt;snd_cwnd_stamp = tcp_time_stamp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2443</x>
      <y>1648</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1932</x>
      <y>1610</y>
      <w>201</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>1990.0;10.0;10.0;150.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1982</x>
      <y>1610</y>
      <w>151</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>1490.0;10.0;10.0;130.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2036</x>
      <y>1610</y>
      <w>101</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>990.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2084</x>
      <y>1610</y>
      <w>54</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>520.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2123</x>
      <y>1610</y>
      <w>22</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2149</x>
      <y>1610</y>
      <w>13</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2151</x>
      <y>1610</y>
      <w>53</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;510.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2153</x>
      <y>1610</y>
      <w>87</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;850.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2155</x>
      <y>1610</y>
      <w>124</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1220.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2153</x>
      <y>1610</y>
      <w>170</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1680.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2155</x>
      <y>1610</y>
      <w>206</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2040.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2154</x>
      <y>1610</y>
      <w>250</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2480.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2155</x>
      <y>1610</y>
      <w>293</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2910.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2487</x>
      <y>1614</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_update_scoreboard</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2154</x>
      <y>1610</y>
      <w>342</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;3400.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2476</x>
      <y>1621</y>
      <w>48</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.如果有fack
	1.lost=fackets_out-reordering
	注：fackets_out表示最后一个sack的skb
		reordering表示能允许的乱序的包的个数
		这里超过了reordering认为丢失，
	2.通过tcp_mark_head_lost将（lost_skb_hint，high_seq）中lost
		个skb标记为TCPCB_LOST
	注：在facket_out没超过reordering时，只标记1个
2.如果没有fack，tcp_mark_head_lost标记1个skb为lost
3.如果不是reno，并且sk_write_queue超过了rto
	1.遍历重发队列
		1.如果skb的发送时间没超过rto，退出循环
		2.如果skb发送时间超过了rto
			1.如果记分板为空
				1.标记skb为TCPCB_LOST
				2.更新tp-&gt;lost_out
				3.如果retransmit_skb_hint超过了skb的seq，需要从sk_write_queue开始重新重发
					tp-&gt;retransmit_skb_hint = NULL
	2.tp-&gt;scoreboard_skb_hint = skb
	3.tcp_sync_left_out同步left_out
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2495</x>
      <y>1617</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2183</x>
      <y>1532</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>disorder
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2183</x>
      <y>1536</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cwr
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2183</x>
      <y>1540</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>recorvery
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2183</x>
      <y>1548</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>loss
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2196</x>
      <y>1528</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cwnd
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2209</x>
      <y>1528</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ssthresh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2222</x>
      <y>1528</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cwnd
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2235</x>
      <y>1528</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ssthresh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2196</x>
      <y>1524</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>进入
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2222</x>
      <y>1524</y>
      <w>26</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>退出
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2196</x>
      <y>1532</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>不变
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2209</x>
      <y>1532</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>不变
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2222</x>
      <y>1532</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>不变
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2235</x>
      <y>1532</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>不变
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2196</x>
      <y>1536</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_cwnd_down
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2209</x>
      <y>1536</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1/2 ssthresh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2222</x>
      <y>1536</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1/2 ssthresh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2235</x>
      <y>1536</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1/2 ssthresh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2196</x>
      <y>1540</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>tcp_cwnd_down
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2209</x>
      <y>1540</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1/2 ssthresh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2196</x>
      <y>1548</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2222</x>
      <y>1540</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ssthresh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2235</x>
      <y>1540</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ssthresh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2248</x>
      <y>1540</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>undo
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2222</x>
      <y>1544</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1/2 ssthresh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2235</x>
      <y>1544</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1/2 ssthresh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2248</x>
      <y>1544</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>complete
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2209</x>
      <y>1548</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1/2 ssthresh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2222</x>
      <y>1548</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ssthresh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2235</x>
      <y>1548</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ssthresh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2235</x>
      <y>1552</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1/2 ssthresh
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2222</x>
      <y>1552</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_cong_avoid
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2248</x>
      <y>1552</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>complete
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2248</x>
      <y>1548</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>undo
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1372</x>
      <y>1601</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_dsack_extend</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1378</x>
      <y>1597</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1367</x>
      <y>1608</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果没设置dsack(!tp-&gt;rx_opt.dsack),通过tcp_dsack_set
	设置dsack
2.否则通过tcp_sack_extend扩展dsack
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1378</x>
      <y>1604</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1371</x>
      <y>1617</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_dsack_set</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1376</x>
      <y>1613</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1366</x>
      <y>1623</y>
      <w>35</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果有sack(sack_ok),并且dsack开关打开(sysctl_tcp_dsack)
	1.设置dsack标志
		tp-&gt;rx_opt.dsack = 1;
	2.设置dsack
		tp-&gt;duplicate_sack[0].start_seq = seq;
		tp-&gt;duplicate_sack[0].end_seq = end_seq;
		tp-&gt;rx_opt.eff_sacks = min(tp-&gt;rx_opt.num_sacks + 1, 4 - tp-&gt;rx_opt.tstamp_ok);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1376</x>
      <y>1620</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1408</x>
      <y>1617</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_sack_extend</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1395</x>
      <y>1613</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1404</x>
      <y>1624</y>
      <w>33</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果要设置的段有sp有重叠部分
	1.如果新加的段的start_seq，在sp-&gt;start_seq之前
		sp-&gt;start_seq = seq
	2.如果其end_seq在sp-&gt;end_seq之后
		sp-&gt;end_seq = end_seq
	3.返回1，表示扩展成功
2.返回0，表示不能extend
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1413</x>
      <y>1620</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1496</x>
      <y>1570</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_sack_new_ofo_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1412</x>
      <y>1562</y>
      <w>97</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;950.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1488</x>
      <y>1578</y>
      <w>40</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.如果不存在sack(!num_sacks),跳到new_sack，添加sack
注:new_sack记录的是sack的数目，不包含dsack
2.遍历当前的selective_acks数组，
	1.tcp_sack_extend查看是否是在原有的sack上扩展，如果可以
		1.通过tcp_sack_swap将扩展的sack调整到第一个
		2.如果有多个sack，通过tcp_sack_maybe_coalesce查看是否可以合并
		注：因为扩展之后，可能会导致多个sack合并成一个
		3.直接return
3.如果已经有4个sack，删除最后一个
	this_sack--;
	tp-&gt;rx_opt.num_sacks--;
	sp--;
4.将第一个sack的位置调整出来
注：所以发送的sack是按照收到的先后顺序排列的，最新的sack永远是在第一个
5.new_sack
	sp-&gt;start_seq = seq;
	sp-&gt;end_seq = end_seq;
	tp-&gt;rx_opt.num_sacks++;
	tp-&gt;rx_opt.eff_sacks = min(tp-&gt;rx_opt.num_sacks + tp-&gt;rx_opt.dsack, 4 - tp-&gt;rx_opt.tstamp_ok)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1506</x>
      <y>1573</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1497</x>
      <y>1614</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_sack_maybe_coalesce</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1484</x>
      <y>1621</y>
      <w>42</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.2个一组遍历selective_acks
	1.通过tcp_sack_extend查看是否可以扩展sack，如果可以
		1.tp-&gt;rx_opt.num_sacks--;
		 tp-&gt;rx_opt.eff_sacks = min(tp-&gt;rx_opt.num_sacks + tp-&gt;rx_opt.dsack, 4 - tp-&gt;rx_opt.tstamp_ok);
		2.将后面的sp前移，然后continue
		注：这里continue，没有递增this_sack和swalk，因为sp前移，所以下一次合并的，相当于swalk++
	2.this_sack++, swalk++
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1504</x>
      <y>1617</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1506</x>
      <y>1610</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1958</x>
      <y>534</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_route_output_flow</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1928</x>
      <y>601</y>
      <w>40</w>
      <h>78</h>
    </coordinates>
    <panel_attributes>1.如果oldflp设置了fl4_src
	1.如果fl4_src是广播，组播或者0，返回EINVAL
	2.通过ip_dev_find查找其dev，如果找不到返回EINVAL
	3.没指定输出设备(oif == 0)，目的地址是组播地址或者广播地址
		fl.oif = dev_out-&gt;ifindex 
		goto make_route
	4.如果有对应的输入设备，dev_put将其释放
注：ip_route_output_slow是本地生成的包发送，如果是转发的报文
	会原路返回
2.如果设定了输出设备(oif)，对其进行校验
	1.dev_get_by_index遍历hash表dev_index_head，找到其ifindex
		相同的net_dev
	2.检查net_dev的in_device不为空
	3.fl4_src为空的的情况下，通过inet_select_addr为其选择一个地址
3.在fl4_dst未知的情况下
	1.fl4_dst就和fl4_src相同(从哪来回哪去)
	2.如果fl4_src也未知，即为回环地址
	3.dev_out = &amp;loopback_dev;
		dev_hold(dev_out);
		fl.oif = loopback_dev.ifindex;
		res.type = RTN_LOCAL;
		flags |= RTCF_LOCAL;
		goto make_route;
4.通过fib_lookup查找，如果失败
	1.res.fi = NULL;
	2.如果之前指定了输出设备(oif)
		1.在fl4_src未知的情况下，通过inet_select_addr为其选定地址
			res.type = RTN_UNICAST;
			goto make_route;
	3.否则释放dev_out，并且返回ENETUNREACH
5.如果找到的地址是RTN_LOCAL
	1.如果fl4_src未知，将其指定为fl4_dst
		dev_out = &amp;loopback_dev;
		dev_hold(dev_out);
		fl.oif = dev_out-&gt;ifindex;
		if (res.fi)
			fib_info_put(res.fi);
		res.fi = NULL;
		flags |= RTCF_LOCAL;
		goto make_route;
6.如果找到默认网关(prefixlen=0),并且为RTN_UNICAST，没有指定输出设备
	通过fib_select_default选择默认网关
7.如果没指定fl4_src，通过FIB_RES_PREFSRC为其指定
8.dev_out = FIB_RES_DEV(res);
	dev_hold(dev_out);
	fl.oif = dev_out-&gt;ifindex;
9.通过ip_mkroute_output指定路由
10.释放res，dev_out，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1946</x>
      <y>597</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1068</x>
      <y>495</y>
      <w>43</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.设置fib_config
2.如果是RTN_UNICAST选择main，否则选择local
3.cfg.fc_table = tb-&gt;tb_id
	cfg.fc_scope  //local是RT_SCOPE_HOST，否则为RT_SCOPE_LINK
4.如果是RTM_NEWROUTE，通过tb-&gt;tb_insert在table中添加fib
	否则通过tb-&gt;tb_delete删除fib
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1084</x>
      <y>491</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1078</x>
      <y>509</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tb-&gt;tb_delete
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1084</x>
      <y>505</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1078</x>
      <y>516</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fn_hash_delete</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1083</x>
      <y>512</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fib_hash_init</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1064</x>
      <y>523</y>
      <w>44</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.其mask的长度(fc_dst_len)不能超过32
2.在table的hash表fn_zones中查找fz，找不到，返回ESRCH
3.fz_key获取dst的网段作为key
4.fib_find_node查看fz的fz_hash中是否有fib_node
5.通过fib_find_alias在fib_node的fn_alias中找到tos或者priority满足条件的alias
6.从这个alias向后遍历所有的alias
	1.如果tos不同，直接退出遍历
	2.如果找到完全相同的fa，设置fa_to_delete
7.如果有fa_to_delete
	1.rtmsg_fib通知感兴趣的节点
	2.将fa从fib_node的链表中删除
	3.如果fib_node的alias为空，将fib_node从fz的hash中删除
	4.fib_hash_genid++;
	5.如果设置了FA_S_ACCESSED，rt_cache_flush刷写
	6.fn_free_alias释放fa
	7.如果要删除fib_node，通过fn_free_node释放
		fz-&gt;fz_nent--
	8.返回0，表示正确删除
8.否则返回ESRCH
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1083</x>
      <y>519</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1940</x>
      <y>593</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>ip_route_output_slow</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1777</x>
      <y>690</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_dev_find</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1767</x>
      <y>697</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.在ip_fib_local_table中通过tb_lookup查询
2.其type要是RTN_LOCAL
3.FIB_RES_DEV去fi的nh中获取其dev
4.dev_hold增加dev计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1782</x>
      <y>693</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1771</x>
      <y>708</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_fib_local_table-&gt;tb_lookup
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1781</x>
      <y>704</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1775</x>
      <y>715</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fn_hash_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1780</x>
      <y>711</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fib_hash_init</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1761</x>
      <y>722</y>
      <w>34</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.遍历table的fn_zone_list链表
	1.利用fz的mask获取其对应的网段key(fl4_dst)
	2.遍历fz的hash表，找到和其key相同的fib_node
	3.fib_semantic_match进一步比较，选择nh
注：fn_zone_list是按照网段的长度从大到小排列的
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1779</x>
      <y>718</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1772</x>
      <y>734</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib_semantic_match</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1758</x>
      <y>741</y>
      <w>42</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>1.遍历fib_node的fa_list链表
	1.要和寻找的tos相同
	2.fa_scope要相同
	3.fa-&gt;fa_state |= FA_S_ACCESSED
	4.如果检查到fa-&gt;fa_type有错误直接返回
	5.如果没错
		1.RTNH_F_DEAD不能置上
		2.遍历fi的fib_nh数组
			1.RTNH_F_DEAD不能置上
			2.oif为0，或者相同，需要退出这个fi的查找，继续查找alias
			3.nhsel满足条件跳到out_fill_res
			4.否则继续遍历nh
			5.continue遍历下一个alias
2.out_fill_res
	res-&gt;prefixlen = prefixlen;
	res-&gt;nh_sel = nh_sel;
	res-&gt;type = fa-&gt;fa_type;
	res-&gt;scope = fa-&gt;fa_scope;
	res-&gt;fi = fa-&gt;fa_info;
	atomic_inc(&amp;res-&gt;fi-&gt;fib_clntref);
3.返回0，表示成功
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1778</x>
      <y>737</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1779</x>
      <y>730</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1813</x>
      <y>690</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_select_addr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1818</x>
      <y>693</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1801</x>
      <y>697</y>
      <w>43</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.获取net_dev的in_device，并遍历ifa_list（地址）链表（要是主ip !IFA_F_SECONDARY）
	 寻找其中发送范围小于预期的，并且dst地址相匹配（mask范围内）的地址
	 如果没找到即是最后一个遍历的primary地址
2.如果net_dev中没有primary地址，遍历所有的net_dev(dev_base)的主ip，找到发送范围
	小于预期且不是RT_SCOPE_LINK的地址
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1860</x>
      <y>690</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1864</x>
      <y>693</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fib4_rules_ops</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1859</x>
      <y>696</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib_rules_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1864</x>
      <y>699</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1849</x>
      <y>702</y>
      <w>38</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.遍历rule的rules_list
	1.通过fib_rule_match对比rule和fl，如果没成功，继续下一个
	2.ops-&gt;action进行查找
	3.如果找到(返回值不是EAGAIN)，通过fib_rule_get增加refcnt的计数
		arg-&gt;rule = rule;
2.如果找不到，返回ENETUNREACH
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1846</x>
      <y>715</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib_rule_match</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1851</x>
      <y>712</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1830</x>
      <y>722</y>
      <w>35</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.rule的ifindex要和fl-&gt;iif相同
2.防火墙标记mark要在mark_mask下相同
3.进一步通过ops-&gt;match做匹配
4.如果rule的FIB_RULE_INVERT置上，将结果取反
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1849</x>
      <y>718</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1838</x>
      <y>734</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ops-&gt;match
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1844</x>
      <y>729</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1842</x>
      <y>737</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fib4_rule_match</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1837</x>
      <y>742</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib4_rule_match</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1826</x>
      <y>748</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.src和dst要rule中相同
2.tos也要相同
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1837</x>
      <y>745</y>
      <w>7</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1874</x>
      <y>715</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ops-&gt;action
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1878</x>
      <y>712</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1874</x>
      <y>723</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib4_rule_action</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1880</x>
      <y>718</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
fib4_rules_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1866</x>
      <y>730</y>
      <w>29</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.查看rule的action，要是FR_ACT_TO_TBL
2.通过fib_get_table获取rule的table
3.在该table中通过tbl-&gt;tb_lookup查找flp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1879</x>
      <y>726</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1943</x>
      <y>686</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mkroute_output</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1943</x>
      <y>693</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mkroute_output_def</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1948</x>
      <y>689</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1937</x>
      <y>700</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过__mkroute_output获取rtable
2.如果成功，计算其hash，rt_intern_hash
	对比rtable，并加入到hash中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1951</x>
      <y>696</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1906</x>
      <y>712</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__mkroute_output</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1961</x>
      <y>711</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rt_intern_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1912</x>
      <y>705</y>
      <w>39</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>370.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1952</x>
      <y>705</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1897</x>
      <y>720</y>
      <w>33</w>
      <h>73</h>
    </coordinates>
    <panel_attributes>1.如果fl4_src为LOOPBACK，但是dev_out的IFF_LOOPBACK
	没置上，返回EINVAL
2.根据fl4_dst设置res-&gt;type ，如果fl4_dst是BADCLASS
	或者ZERONET，返回EINVAL
3.如果dev_out的IFF_LOOPBACK置上
	flags |= RTCF_LOCAL
4.获取dev_out的in_dev
5.如果res.type是RTN_BROADCAST，释放res.fi
	flags |= RTCF_BROADCAST | RTCF_LOCAL
6.如果是RTN_MULTICAST
	1.flags |= RTCF_MULTICAST|RTCF_LOCAL
	2.如果ip_check_mc检测失败
		flags &amp;= ~RTCF_LOCAL
	3.如果有res-&gt;fi，并且其网段长度低于4，释放其fi
		fib_info_put(res-&gt;fi);
		res-&gt;fi = NULL;
7.dst_alloc申请rtable，并初始化
	1.atomic_set(&amp;rth-&gt;u.dst.__refcnt, 1);
	 rth-&gt;u.dst.flags= DST_HOST;
	 2.rth-&gt;u.dst.flags |= DST_NOXFRM; //in_dev-&gt;cnf.no_xfrm
	 	rth-&gt;u.dst.flags |= DST_NOPOLICY;//in_dev-&gt;cnf.no_policy
	 3.rth-&gt;fl.fl4_dst	= oldflp-&gt;fl4_dst;
		rth-&gt;fl.fl4_tos	= tos;
		rth-&gt;fl.fl4_src	= oldflp-&gt;fl4_src;
		rth-&gt;fl.oif	= oldflp-&gt;oif;
		rth-&gt;fl.mark    = oldflp-&gt;mark;
		rth-&gt;rt_dst	= fl-&gt;fl4_dst;
		rth-&gt;rt_src	= fl-&gt;fl4_src;
		rth-&gt;rt_iif	= oldflp-&gt;oif ? : dev_out-&gt;ifindex;
		rth-&gt;u.dst.dev	= dev_out;
		dev_hold(dev_out);
		rth-&gt;idev	= in_dev_get(dev_out);
		rth-&gt;rt_gateway = fl-&gt;fl4_dst;
		rth-&gt;rt_spec_dst= fl-&gt;fl4_src;
		rth-&gt;u.dst.output=ip_output;
	4.RTCF_LOCAL
		rth-&gt;u.dst.input = ip_local_deliver;
		rth-&gt;rt_spec_dst = fl-&gt;fl4_dst;
	5.RTCF_BROADCAST |RTCF_MULTICAST
		1.rth-&gt;rt_spec_dst = fl-&gt;fl4_src;
		2.RTCF_LOCAL，并且dev_out不是回环设备
			rth-&gt;u.dst.output = ip_mc_output;
	6.rt_set_nexthop根据res设置rt
	7.rth-&gt;rt_flags = flags
8.返回rth
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1905</x>
      <y>715</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1906</x>
      <y>797</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dst_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1909</x>
      <y>792</y>
      <w>17</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ipv4_dst_ops</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1899</x>
      <y>803</y>
      <w>35</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果定义了垃圾回收(ops-&gt;gc),并且其回收(ops-&gt;entries)
	没超过gc_thresh，通过ops-&gt;gc进行垃圾回收
2.通过kmem_cache_alloc申请dst_entry
	memset(dst, 0, ops-&gt;entry_size);
	atomic_set(&amp;dst-&gt;__refcnt, 0);
	dst-&gt;ops = ops;
	dst-&gt;lastuse = jiffies;
	dst-&gt;path = dst;
	dst-&gt;input = dst_discard_in;
	dst-&gt;output = dst_discard_out;
	atomic_inc(&amp;ops-&gt;entries);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1910</x>
      <y>800</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1944</x>
      <y>795</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rt_set_nexthop</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1926</x>
      <y>792</y>
      <w>27</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1936</x>
      <y>802</y>
      <w>37</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果res-&gt;fi存在
	1.如果存在FIB_RES_GW，并且其scope是RT_SCOPE_LINK
		rt-&gt;rt_gateway = FIB_RES_GW(*res);
	2.利用fi-&gt;fib_metrics赋值rt-&gt;u.dst.metrics
	3.如果fi-&gt;fib_mtu为0
		1.更新rt-&gt;u.dst.metrics[RTAX_MTU-1]
2.否则直接用net_dev更新rt-&gt;u.dst.metrics[RTAX_MTU-1]
3.更新RTAX_HOPLIMIT，RTAX_MTU，RTAX_ADVMSS
4.set_class_tag设置rt-&gt;u.dst.tclassid
5.rt-&gt;rt_type = res-&gt;type
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1950</x>
      <y>798</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1951</x>
      <y>719</y>
      <w>35</w>
      <h>62</h>
    </coordinates>
    <panel_attributes>1.restart
	1.遍历rt_hash_table的hash表chain
		1.通过compare_keys对比新建的rtable和hash表中的
			daddr，saddr，mark，scope，oif，iif，如果一致
			1.将rtable移到hash表头
				*rthp = rth-&gt;u.rt_next
				rcu_assign_pointer(rth-&gt;u.rt_next,
					   rt_hash_table[hash].chain);
				rcu_assign_pointer(rt_hash_table[hash].chain, rth);
			2.rth-&gt;u.dst.__use++;
				dst_hold(&amp;rth-&gt;u.dst);
				rth-&gt;u.dst.lastuse = now;
			3.通过rt_drop释放新建的rtable
			4.用hash表中的替换之前的rtable，并返回0
				*rp = rth
		2.如果rth-&gt;u.dst.__refcnt为0，记录最小的rt_score
			cand = rth;
			candp = rthp;
			min_score = score;
		3.chain_length++
		4.遍历下一个rtable
			rthp = &amp;rth-&gt;u.rt_next
2.如果有cand，并且chain_length超过了限值，将cand释放
	*candp = cand-&gt;u.rt_next;
	rt_free(cand);
3.如果是RTN_UNICAST，或者输入设备不存在(只是输出)
	1.通过arp_bind_neighbour绑定neighbor
	2.如果绑定失败
		1.如果不是因为ENOBUFS，rt_drop释放rtable，并返回error
		2.如果是因为ENOBUFS
			1.尝试attempts次，利用rt_garbage_collect进行垃圾回收
				并重新跳到restart重新查找rtable
			2.如果尝试多次失败，通过rt_drop将rtable释放，返回ENOBUFS
4.将rt插入到hash表中
	rt-&gt;u.rt_next = rt_hash_table[hash].chain
	rt_hash_table[hash].chain = rt;
5.返回rt，并返回0
	*rp = rt;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1967</x>
      <y>714</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1030</x>
      <y>404</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1033</x>
      <y>395</y>
      <w>60</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>580.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1015</x>
      <y>410</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_table_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1019</x>
      <y>407</y>
      <w>17</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_tbl</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1000</x>
      <y>416</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.通过neigh_table_init_no_netlink对tbl初始化
2.查看neigh_tables中是否有何tbl的family相同的temp
3.将tbl插入到neigh_tables中
	tbl-&gt;next	= neigh_tables;
	neigh_tables	= tbl;
4.如果有相同的temp，则报错
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1020</x>
      <y>413</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1004</x>
      <y>429</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_table_init_no_netlink</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1013</x>
      <y>426</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>997</x>
      <y>436</y>
      <w>38</w>
      <h>44</h>
    </coordinates>
    <panel_attributes>1.初始化tbl参数
	atomic_set(&amp;tbl-&gt;parms.refcnt, 1);
	INIT_RCU_HEAD(&amp;tbl-&gt;parms.rcu_head);
	tbl-&gt;parms.reachable_time
	tbl-&gt;kmem_cachep 
2.申请tbl指向的内存
	1.tbl-&gt;stats = alloc_percpu
	2.tbl-&gt;hash_mask = 1;
		tbl-&gt;hash_buckets = neigh_hash_alloc
	3.tbl-&gt;phash_buckets = kzalloc
3.如果有procfs，创建目录
	tbl-&gt;pde = create_proc_entry(tbl-&gt;id, 0, proc_net_stat);
	tbl-&gt;pde-&gt;proc_fops = &amp;neigh_stat_seq_fops;
	tbl-&gt;pde-&gt;data = tbl;
4.get_random_bytes(&amp;tbl-&gt;hash_rnd, sizeof(tbl-&gt;hash_rnd))
5.初始化timer
	1.init_timer(&amp;tbl-&gt;gc_timer);
		tbl-&gt;gc_timer.data     = (unsigned long)tbl;
		tbl-&gt;gc_timer.function = neigh_periodic_timer;
		tbl-&gt;gc_timer.expires  = now + 1;
		add_timer(&amp;tbl-&gt;gc_timer);
	2.init_timer(&amp;tbl-&gt;proxy_timer);
		tbl-&gt;proxy_timer.data	  = (unsigned long)tbl;
		tbl-&gt;proxy_timer.function = neigh_proxy_process;
		skb_queue_head_init(&amp;tbl-&gt;proxy_queue);
6.tbl-&gt;last_flush = now;
	tbl-&gt;last_rand	= now + tbl-&gt;parms.reachable_time * 20;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1013</x>
      <y>432</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1978</x>
      <y>785</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_bind_neighbour</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1983</x>
      <y>780</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1974</x>
      <y>792</y>
      <w>37</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果dst的in_device不存在，EINVAL
2.如果dst的neighbour不存在
	1.dst的rt_gateway设置为nexthop，如果dev是IFF_LOOPBACK或者IFF_POINTOPOINT
		nexthop设置为0
	2.通过__neigh_lookup_errno在arp_tbl中查找或者创建neighbor
	3.绑定
		dst-&gt;neighbour = n
3.返回0，表示正确绑定
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1985</x>
      <y>788</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1294</x>
      <y>502</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1299</x>
      <y>505</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1281</x>
      <y>508</y>
      <w>38</w>
      <h>43</h>
    </coordinates>
    <panel_attributes>1.通过nlmsg_parse检查nlmsghdr，并将attr保存在tb中
2.如果传递了ndm_ifindex
	1.通过dev_get_by_index获取其net_dev
	2.如果设置了链路层地址(NDA_LLADDR),其长度不能小于
		net_dev的addr_len
3.遍历neigh_tables链表
	1.选择tbl.family和ndm_family相同的tbl
	2.其ip层的地址(NDA_DST)不能小于tbl-&gt;key_len
	3.如果NTF_PROXY置上
		1.通过pneigh_lookup查询或者添加代理项
		2.如果存在代理项
			pn-&gt;flags = ndm-&gt;ndm_flags
		3.返回ENOBUFS
	4.ndm_ifindex的net_dev要存在
	5.neigh_lookup遍历hash_buckets，找到net_dev，primary_key
		相同的neighbor
		1.如果没找到
			1.NLM_F_CREATE没置上，返回ENOENT
			2.通过__neigh_lookup_errno创建一个neighbor
		2.如果找到了
			1.NLM_F_EXCL置上，返回EEXIST
			2.如果NLM_F_REPLACE没置，将flag的NEIGH_UPDATE_F_OVERRIDE清掉
			注：flag在之前置上了NEIGH_UPDATE_F_ADMIN | NEIGH_UPDATE_F_OVERRIDE
	6.neigh_update更新neigh的状态
	7.neigh_release递减neighbor的计数refcnt，并释放dev后返回
4.如果没找到一个合适的tbl，返回EAFNOSUPPORT
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1274</x>
      <y>555</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>phash_buckets</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1261</x>
      <y>562</y>
      <w>36</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.遍历phash_buckets，如果找到key，net_dev相同的项，
	跳到out，直接返回该项
2.如果不要求创建(!creat)，直接返回NULL
3.否则通过kmalloc申请pneigh_entry
	memcpy(n-&gt;key, pkey, key_len);
	n-&gt;dev = dev;
	dev_hold(dev)
4.执行构造函数tbl.pconstructor
5.将新申请的加入hash，并返回
	n-&gt;next = tbl-&gt;phash_buckets[hash_val];
	tbl-&gt;phash_buckets[hash_val] = n;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1278</x>
      <y>558</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1281</x>
      <y>550</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1394</x>
      <y>557</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_update</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1311</x>
      <y>550</y>
      <w>91</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;890.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1386</x>
      <y>565</y>
      <w>43</w>
      <h>97</h>
    </coordinates>
    <panel_attributes>1.neighbor的NUD_NOARP | NUD_PERMANENT的更改，需要有
	NEIGH_UPDATE_F_ADMIN权限
2.如果新状态不在NUD_VALID
	1.通过neigh_del_timer将其timer删除
	2.如果neighbor之前处于NUD_CONNECTED，现在调整成invalid，
		通过neigh_suspect更新neighbor的output
	3.neigh-&gt;nud_state = new; //更新状态
		err = 0;
		notify = old &amp; NUD_VALID;//如果是valid，则需要通知
	4.跳到out
3.调整neighbor的mac地址
	1.如果设备不需要地址(!addr_len),其mac地址不变
		lladdr = neigh-&gt;ha
	2.如果指定了lladdr，其指定的地址和之前的地址不同的情况下，如果
		之前的状态在NUD_VALID，其mac地址不变
		lladdr = neigh-&gt;ha
	3.如果没指定地址
		1.如果之前的状态不在NUD_VALID，返回EINVAL
		2.否则其地址不变
			lladdr = neigh-&gt;ha
4.如果调整的新状态在NUD_CONNECTED，更新其confirm时间
	neigh-&gt;confirmed = jiffies
5.neigh-&gt;updated = jiffies
6.如果之前在NUD_VALID
	1.mac地址要发生改变，但是NEIGH_UPDATE_F_OVERRIDE没置上
		1.update_isrouter = 0
		2.如果NEIGH_UPDATE_F_WEAK_OVERRIDE置上，并且之前处于NUD_CONNECTED
			1.使用之前的地址
				lladdr = neigh-&gt;ha;
			2.new = NUD_STALE;
		3.否则不做更改，退出
	2.如果mac地址没发生改变，并且新状态要调整为NUD_STALE，并且之前
		处于NUD_CONNECTED，或者NEIGH_UPDATE_F_WEAK_OVERRIDE置上
		其状态不发生改变
		new = old
7.如果状态要发生变化
	1.通过neigh_del_timer删除timer
	2.如果新状态处于NUD_IN_TIMER
		1.neigh_hold增加neighbor的计数
		2.neigh_add_timer重新跳读timer
	3.neigh-&gt;nud_state = new
8.如果mac地址发生了变化
	1.更新mac地址
		memcpy(&amp;neigh-&gt;ha, lladdr, dev-&gt;addr_len)
	2.neigh_update_hhs更新缓存中的mac地址
	3.如果新状态不是NUD_CONNECTED
		neigh-&gt;confirmed = jiffies -
				      (neigh-&gt;parms-&gt;base_reachable_time &lt;&lt; 1)
	4.notify = 1
9.如果状态没发生变化，之后不做处理，out
10.如果新状态处于NUD_CONNECTED，neigh_connect更新其output
	否则调整其output为neigh_suspect
11.如果之前处于NUD_VALID
	1.如果现在处于NUD_VALID，取出neighbor.arp_queue中的skb，通过
		output方法将其发送
	2.最后通过skb_queue_purge将arp_queue中的skb全部释放
12.如果需要更新update_isrouter，根据NEIGH_UPDATE_F_ISROUTER置上与否
	将neigh-&gt;flags中的NTF_ROUTER置上或者清除
13.如果需要notify，call_netevent_notifiers通知感兴趣的模块
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1399</x>
      <y>560</y>
      <w>6</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1312</x>
      <y>558</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__neigh_lookup_errno</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1303</x>
      <y>566</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1309</x>
      <y>561</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1322</x>
      <y>561</y>
      <w>27</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没找到</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1340</x>
      <y>565</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1299</x>
      <y>573</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.遍历tbl的hash_buckets
	1.对比其中的in_device,primary_key（nexthop）
		如果相同，通过neigh_hold递增neighbour.refcnt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1308</x>
      <y>569</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1284</x>
      <y>609</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1272</x>
      <y>616</y>
      <w>34</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.检查tbl-&gt;entries,如果超过了gc_thresh3，
	或者只是超过了gc_thresh2，但是5s中内没刷新(last_flush)
	通过neigh_forced_gc进行垃圾回收，如果还没低于gc_thresh3
	直接返回
2.atomic_inc_return递增tbl-&gt;entries
3.kmem_cache_alloc申请neighbour，并初始化
	memset(n, 0, tbl-&gt;entry_size);
	skb_queue_head_init(&amp;n-&gt;arp_queue);
	rwlock_init(&amp;n-&gt;lock);
	n-&gt;updated	  = n-&gt;used = now;
	n-&gt;nud_state	  = NUD_NONE;
	n-&gt;output	  = neigh_blackhole;
	n-&gt;parms	  = neigh_parms_clone(&amp;tbl-&gt;parms);
	init_timer(&amp;n-&gt;timer);
	n-&gt;timer.function = neigh_timer_handler;
	n-&gt;timer.data	  = (unsigned long)n;
	n-&gt;tbl		  = tbl;
	atomic_set(&amp;n-&gt;refcnt, 1);
	n-&gt;dead		  = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1288</x>
      <y>612</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1332</x>
      <y>572</y>
      <w>37</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.通过neigh_alloc申请neighbor
2.设置nexthop和in_device
	memcpy(n-&gt;primary_key, pkey, key_len);
	n-&gt;dev = dev;
	dev_hold(dev);
3.执行tbl的构造函数tbl-&gt;constructor
3.执行n-&gt;parms-&gt;neigh_setup
4.n-&gt;confirmed = jiffies - (n-&gt;parms-&gt;base_reachable_time &lt;&lt; 1)
5.如果tbl-&gt;entries超过了hash_mask，通过neigh_hash_grow
	对hash表进行扩充一倍
6.如果n-&gt;parms-&gt;dead置上，返回EINVAL
7.遍历hash_buckets，如果发现其中有in_device和primary_key
	相同的neighbor，neigh_hold持有hash表中的neighbor，并释放
	新建的neighbor，返回
8.将新建的neighbor插入hash，并返回
	n-&gt;next = tbl-&gt;hash_buckets[hash_val];
	tbl-&gt;hash_buckets[hash_val] = n;
	n-&gt;dead = 0;
	neigh_hold(n);
	rc = n;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1345</x>
      <y>568</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1290</x>
      <y>604</y>
      <w>57</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>550.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1366</x>
      <y>609</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_hash_grow</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1356</x>
      <y>604</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1354</x>
      <y>616</y>
      <w>30</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.通过neigh_hash_alloc重新申请hash表
2.通过get_random_bytes重新设置hash_rnd
3.遍历old_hash，将hash表中的所有neighbor
	重新计算hash，装入到new_hash
	hash_val &amp;= new_hash_mask;
	next = n-&gt;next;
	n-&gt;next = new_hash[hash_val];
	new_hash[hash_val] = n;
4.重新设置hash
	tbl-&gt;hash_buckets = new_hash;
	tbl-&gt;hash_mask = new_hash_mask;
5.neigh_hash_free释放old_hash
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1372</x>
      <y>612</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1302</x>
      <y>550</y>
      <w>20</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1238</x>
      <y>653</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_forced_gc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1243</x>
      <y>647</y>
      <w>36</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>340.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1359</x>
      <y>665</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_del_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1353</x>
      <y>672</y>
      <w>26</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果neighbor处于NUD_IN_TIMER
	1.通过del_timer将timer删除
	2.通过neigh_release递减timer的计数
	3.返回1，表示删除了timer
2.返回0，表示不用删除
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1363</x>
      <y>668</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1411</x>
      <y>667</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_suspect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1406</x>
      <y>674</y>
      <w>36</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.将neighbor.output更新为neighbor.ops.output
2.将neighbor的hh缓存链表中所有hh的hh_output更新为
	neighbor.ops.output
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1418</x>
      <y>670</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1450</x>
      <y>667</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1456</x>
      <y>670</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1443</x>
      <y>674</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.将neighbor.output更新为neighbor.ops.connected_output
2.将neighbor的hh缓存链表中所有hh的hh_output更新为
	neighbor.ops.hh_output
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1365</x>
      <y>661</y>
      <w>43</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1409</x>
      <y>661</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1416</x>
      <y>661</y>
      <w>41</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;390.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1782</x>
      <y>678</y>
      <w>164</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1620.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1816</x>
      <y>678</y>
      <w>132</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1300.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1865</x>
      <y>678</y>
      <w>85</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>830.0;10.0;10.0;120.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1947</x>
      <y>678</y>
      <w>4</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1944</x>
      <y>560</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__ip_route_output_key</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1937</x>
      <y>567</y>
      <w>35</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.遍历hash表rt_hash_table
	1.如果fl4_dst，fl4_src，oif，相同
		iif没指定，oif和mark(防火墙)相同
		fl4_tos的IPTOS_RT_MASK和RTO_ONLINK一致
		1.multipath_select_route选择一路进行路由
			1.dst_hold(&amp;(*rp)-&gt;u.dst)
			2.返回0，表示查找成功
		2.rth-&gt;u.dst.lastuse = jiffies;
			dst_hold(&amp;rth-&gt;u.dst);
			rth-&gt;u.dst.__use++;
			*rp = rth;
			return 0;
	2.遍历下一个
2.ip_route_output_slow去fib_table中查找
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1952</x>
      <y>563</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1948</x>
      <y>590</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1951</x>
      <y>543</y>
      <w>30</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.__ip_route_output_key进行路由缓存查询
2.如果指定了协议proto
	1.如果没指定fl4_src
		flp-&gt;fl4_src = (*rp)-&gt;rt_src
	2.如果没指定fl4_dst
		flp-&gt;fl4_dst = (*rp)-&gt;rt_dst
	3.xfrm_lookup进行安全路由查询
3.返回0，表示成功
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1966</x>
      <y>537</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1954</x>
      <y>556</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1963</x>
      <y>478</y>
      <w>50</w>
      <h>51</h>
    </coordinates>
    <panel_attributes>1.检查skb的rtable(skb-&gt;dst)，如果存在，跳到packet_routed
2.通过__sk_dst_check检查，如果不成功
	1.如果ssr(strict source route)置上，将daddr置换成第一跳的地址(faddr)
	2.security_sk_classify_flow进行安全检查
	3.ip_route_output_flow查找路由，如果没找到，跳到no_route，释放skb
	4.sk_setup_caps关联sk和dst
3.skb-&gt;dst = dst_clone(&amp;rt-&gt;u.dst)
4.packet_routed
	1.如果要求ssr(is_strictroute),但是rt的rt_dst和rt_gateway不同，跳到no_route，释放skb
	2.设置ip的头部
		1.skb_push获取其头部指针
		2.设置版本，长度，以及tos
			*((__be16 *)iph) = htons((4 &lt;&lt; 12) | (5 &lt;&lt; 8) | (inet-&gt;tos &amp; 0xff))
		3.设置数据长度，之前push已经调整了ip头部的长度，所有tot_len是头部+数据的长度
			iph-&gt;tot_len = htons(skb-&gt;len)
		4.ip_dont_fragment检查到pmtu，并且上层不允许分段(!ipfragok),将iph-&gt;frag_off
			的IP_DF置上，否则将其设置为0
		5.iph-&gt;ttl      = ip_select_ttl(inet, &amp;rt-&gt;u.dst);
			iph-&gt;protocol = sk-&gt;sk_protocol;
			iph-&gt;saddr    = rt-&gt;rt_src;
			iph-&gt;daddr    = rt-&gt;rt_dst;
			skb-&gt;nh.iph   = iph;
		6.optlen存在，设置ip选项
			1.调整首部的长度
				iph-&gt;ihl += opt-&gt;optlen &gt;&gt; 2
			2.ip_options_build构建IP选项
		7.ip_select_ident_more确定标志号
		8.ip_send_check设置checksum
		9.设置Qos类别
			skb-&gt;priority = sk-&gt;sk_priority
		10.dst_output发送skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1979</x>
      <y>474</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1989</x>
      <y>535</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_setup_caps</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1983</x>
      <y>542</y>
      <w>35</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.__sk_dst_set关联sk和dst
2.sk-&gt;sk_route_caps = dst-&gt;dev-&gt;features
3.调整sk_route_caps
	1.如果sk_route_caps的NETIF_F_GSO置上
		sk-&gt;sk_route_caps |= NETIF_F_GSO_MASK
	2.sk_can_gso检查到dev可以分段该协议
		1.如果header_len存在，将NETIF_F_GSO_MASK清代哦
		2.否则
			sk-&gt;sk_route_caps |= NETIF_F_SG | NETIF_F_HW_CSUM
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1994</x>
      <y>538</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1980</x>
      <y>562</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__sk_dst_set</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1974</x>
      <y>569</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.sk-&gt;sk_dst_cache = dst
2.dst_release释放old_dst
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1986</x>
      <y>565</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2003</x>
      <y>561</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_can_gso</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2008</x>
      <y>557</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1986</x>
      <y>557</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1997</x>
      <y>568</y>
      <w>29</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.sk_route_caps中有sk_gso_type对应的特性
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2007</x>
      <y>564</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1326</x>
      <y>609</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tbl-&gt;constructor
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1332</x>
      <y>604</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1331</x>
      <y>612</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_tbl</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1326</x>
      <y>616</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_constructor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1314</x>
      <y>623</y>
      <w>37</w>
      <h>57</h>
    </coordinates>
    <panel_attributes>1.设置type
	neigh-&gt;type = inet_addr_type(addr)
2.设置parms
	parms = in_dev-&gt;arp_parms;
	__neigh_parms_put(neigh-&gt;parms);
	neigh-&gt;parms = neigh_parms_clone(parms);
3.设置ops，output
	1.如果hard_header为空
		neigh-&gt;nud_state = NUD_NOARP;
		neigh-&gt;ops = &amp;arp_direct_ops;
		neigh-&gt;output = neigh-&gt;ops-&gt;queue_xmit;
	2.否则
		1.查看dev.type,如果是ARPHRD_ROSE ARPHRD_AX25 ARPHRD_NETROM
			neigh-&gt;ops = &amp;arp_broken_ops;
			neigh-&gt;output = neigh-&gt;ops-&gt;output;
			return 0;
		2.如果neigh的type，如果是RTN_MULTICAST RTN_BROADCAST IFF_POINTOPOINT
			或者dev是IFF_NOARP|IFF_LOOPBACK
			1.neigh-&gt;nud_state = NUD_NOARP
			2.设置ha
				1.RTN_MULTICAST
					arp_mc_map(addr, neigh-&gt;ha, dev, 1)
				2.IFF_NOARP|IFF_LOOPBACK
					memcpy(neigh-&gt;ha, dev-&gt;dev_addr
				3.RTN_BROADCAST IFF_POINTOPOINT
					memcpy(neigh-&gt;ha, dev-&gt;broadcast
		3.如果hard_header_cache存在
			neigh-&gt;ops = &amp;arp_hh_ops
			否则
			neigh-&gt;ops = &amp;arp_generic_ops
		4.如果neighbor处于NUD_VALID
			neigh-&gt;output = neigh-&gt;ops-&gt;connected_output
			否则
			neigh-&gt;output = neigh-&gt;ops-&gt;output
4.返回0，表示成功
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1331</x>
      <y>619</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1964</x>
      <y>528</y>
      <w>19</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1985</x>
      <y>528</y>
      <w>12</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2073</x>
      <y>535</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dst_output</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2002</x>
      <y>528</y>
      <w>79</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;770.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2074</x>
      <y>542</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb-&gt;dst-&gt;output
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2079</x>
      <y>538</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2136</x>
      <y>609</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_queue_xmit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2127</x>
      <y>616</y>
      <w>39</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.通过	netif_needs_gso检查skb是否支持gso，dev是否有skb
	的gso属性，如果没有，直接跳到gso处理
2.如果skb有frag_list，但是设备不支持NETIF_F_FRAGLIST
	通过__skb_linearize将frag_list中的数据存放到skb.data中
3.如果skb存在nr_frags，但是设备不支持NETIF_F_SG，或者illegal_highdma
	同样通过__skb_linearize将数据放在skb.data中
4.	如果skb没有校验（CHECKSUM_PARTIAL），并且
	设备不支持校验（!NETIF_F_GEN_CSUM &amp;&amp; !NETIF_F_IP_CSUM）
	通过skb_checksum_help指向校验
5.获取设备的排队规程dev-&gt;qdisc，
	1.如果定义了入队规程q-&gt;enqueue（通过queue_lock保护），
		通过q-&gt;enqueue让skb入队，并利用qdisc_run对设备
		进行流量控制
	2.如果没定义，说明没开启Qos，
		1.如果设备打开了（IFF_UP）
			1.xmit_lock之前不能被本cpu锁上，否则可能是死锁
			2.如果设备状态__LINK_STATE_XOFF没置上，通过
				dev_hard_start_xmit将skb发送
		2.如果设备没开启，返回ENETDOWN，释放skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2141</x>
      <y>612</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2158</x>
      <y>649</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_hard_start_xmit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2145</x>
      <y>646</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2148</x>
      <y>655</y>
      <w>36</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.如果是单个skb
	1.如果创建了原始套接口（socket(AF_PAKET,SOCK_RAW,hotns(ETH_P_ALL))）
	（netdev_nit），通过dev_queue_xmit_nit发送数据给该套接口
	2.如果需要硬件分段（netif_needs_gso），通过dev_gso_segment调用ptype中的gso_segment
	给skb分段
注：这里分段的时候可能所有的数据都在segs中，skb中不存在真正的数据
	3.如果这里还只是只有一个数据包通过dev-&gt;hard_start_xmit发送
	4.如果有多个数据包，通过gso部分发送
2.gso:发送多个skb
	遍历skb链表，通过dev-&gt;hard_start_xmit将数据发送
	退出条件：skb遍历完，发送出错（将出错的skb重新链入到链表中），以及__LINK_STATE_XOFF
3.换回skb的析构函数
	skb-&gt;destructor = DEV_GSO_CB(skb)-&gt;destructor
4.释放skb，返回0
注：1.pskb_copy，skb_clone中并没有复制skb的链接关系
		n-&gt;next = n-&gt;prev = NULL;
	2.对于qdisc，__skb_dequeue会将其链接关系断掉
	3.在gso部分，首个skb并没有发送。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2164</x>
      <y>652</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2205</x>
      <y>689</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;hard_start_xmit
bg=red
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2181</x>
      <y>684</y>
      <w>33</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2210</x>
      <y>692</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
e100_probe</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2205</x>
      <y>696</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_xmit_frame</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2196</x>
      <y>703</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.获取硬件的私有数据nic
2.如果nic的ich_10h_workaround置上，通过e100_exec_cmd
	执行的一个nop命令，并延时1us
3.通过e100_exec_cb发送skb
4.netdev-&gt;trans_start = jiffies
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2210</x>
      <y>699</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2191</x>
      <y>716</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_exec_cmd</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2196</x>
      <y>712</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2182</x>
      <y>723</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.等待上次命令被接收（scb.cmd_lo=0）
2.如果cmd不是cuc_resume，
	scb.gen_ptr=dma_addr
3.scb.cmd_lo=cmd
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2196</x>
      <y>719</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2215</x>
      <y>716</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_exec_cb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2220</x>
      <y>712</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2211</x>
      <y>723</y>
      <w>33</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.nic-&gt;cbs_avail要不为0
2.从nic-&gt;cb_to_use中取出一个cb，赋予当前skb
	cb = nic-&gt;cb_to_use;
	nic-&gt;cb_to_use = cb-&gt;next;
	nic-&gt;cbs_avail--;
	
	cb-&gt;skb = skb;
注：cb虽然从cb_to_use链表中脱离，但是还没从cb_to_send
	中脱离，虽然两者是同一个链表，但是两个指向的位置可能不一样
3.通过cb_prepare准备cb
4.将当前cb-&gt;command中的cb_s置上，之前的cb-&gt;prev-&gt;command清掉
5.遍历cb_to_send链表，通过e100_exec_cmd发送命令cuc_cmd
	发送数据。
注：1.根据e100_alloc_cbs，初始的cuc_cmd是cuc_start，这里会填充
		cb的起始地址，之后会根据cb.link选择下一个cb
	2.每次重加载的时候，nic-&gt;cuc_cmd = cuc_resume，所以不用加载
	dma_addr
	3.这里cb_to_send的更新是为了软件的循环
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2221</x>
      <y>719</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
cb参考e100_alloc_cbs</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2219</x>
      <y>757</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>cb_prepare
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2225</x>
      <y>752</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2217</x>
      <y>764</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_xmit_prepare</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2224</x>
      <y>760</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2212</x>
      <y>771</y>
      <w>39</w>
      <h>21</h>
    </coordinates>
    <panel_attributes> //tx_command在e100_probe--e100_get_defaults
 //中初始化，
cb-&gt;command = nic-&gt;tx_command//另外每16个包，cb_i产生一次中断
 //
cb-&gt;u.tcb.tbd_array = cb-&gt;dma_addr + offsetof(struct cb, u.tcb.tbd);
cb-&gt;u.tcb.tcb_byte_count = 0;
cb-&gt;u.tcb.threshold = nic-&gt;tx_threshold;
cb-&gt;u.tcb.tbd_count = 1;
 //发送数据的地址和长度
cb-&gt;u.tcb.tbd.buf_addr = cpu_to_le32(pci_map_single(nic-&gt;pdev,
	skb-&gt;data, skb-&gt;len, PCI_DMA_TODEVICE))
cb-&gt;u.tcb.tbd.size = cpu_to_le16(skb-&gt;len)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2222</x>
      <y>767</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2162</x>
      <y>691</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_gso_segment</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2149</x>
      <y>698</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.获取io的聚散特性，（illegal_highdma时，不关心聚散）
2.通过skb_gso_segment将skb分段成segs
3.skb-&gt;next = segs
4.保存skb的析构函数，并分配新的析构函数
	DEV_GSO_CB(skb)-&gt;destructor = skb-&gt;destructor;
	skb-&gt;destructor = dev_gso_skb_destructor;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2166</x>
      <y>684</y>
      <w>9</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2166</x>
      <y>694</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2171</x>
      <y>712</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_gso_skb_destructor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2171</x>
      <y>708</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;90.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2179</x>
      <y>715</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2165</x>
      <y>718</y>
      <w>25</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.通过kfree_skb释放掉skb-&gt;next链表
2.skb则通过其本来的析构函数DEV_GSO_CB(skb).destructor释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2147</x>
      <y>712</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_gso_segment</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2152</x>
      <y>708</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2130</x>
      <y>720</y>
      <w>34</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.frag_list应该为空
2.将skb中mac header移出data指针指向范围外
	skb-&gt;mac.raw = skb-&gt;data;
	skb-&gt;mac_len = skb-&gt;nh.raw - skb-&gt;data;
	__skb_pull(skb, skb-&gt;mac_len);
3.如果不是CHECKSUM_PARTIAL，并且header是clone的
	通过pskb_expand_head重新分配skb
注：pskb_expand_head中nhead指的是头增加的长度
	ntail是指尾部增加的长度
4.遍历hash表ptype_base
	1.找到其中协议类型type一致，ptype-&gt;dev不存在，
		但是gso_segment存在的ptype
	2.如果不是CHECKSUM_PARTIAL
		1.通过ptype-&gt;gso_send_check检查
		2.如果出错，或者skb已经分段，退出循环
		3.__skb_push将data恢复到nh.raw
	3.通过ptype-&gt;gso_segment分段
5.重新添加mac head
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2150</x>
      <y>715</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2178</x>
      <y>754</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ptype-&gt;gso_segment
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2144</x>
      <y>749</y>
      <w>42</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2093</x>
      <y>652</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qdisc_run</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2097</x>
      <y>646</y>
      <w>45</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2073</x>
      <y>658</y>
      <w>37</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果网络开启（!__LINK_STATE_XOFF），并且不处于
	流量控制阶段（!__LINK_STATE_QDISC_RUNNING,此处
	set这个标志）利用__qdisc_run进行流量控制
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2096</x>
      <y>655</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2083</x>
      <y>666</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__qdisc_run</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2089</x>
      <y>663</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2067</x>
      <y>671</y>
      <w>41</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果排队规则处于初始状态（noop_qdisc），推出流量控制的
	状态，跳到3
2.调用qdisc_restart进行发送，直到发送完毕，或者网络关闭
3.清除标志__LINK_STATE_QDISC_RUNNING
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2088</x>
      <y>669</y>
      <w>3</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2072</x>
      <y>682</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qdisc_restart</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2078</x>
      <y>678</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2042</x>
      <y>689</y>
      <w>56</w>
      <h>37</h>
    </coordinates>
    <panel_attributes>1.首先选取dev没发完的gso包（dev-&gt;gso_skb），如果没有从队列中取出skb（q-&gt;dequeue）
	1.如果设备要求上锁（!nolock），通过netif_tx_trylock给设备上_xmit_lock锁，并设置xmit_lock_owner
		1.如果上锁失败，检查正在上锁的是否为本cpu，如果是则死锁，释放skb，返回-1
		2.上锁失败，递增cpu_collision，并将skb重新加入队列。1.4.3.3
	2.此时不用在操作qdisc，将queue_lock解锁
	3.设备的__LINK_STATE_XOFF不能置上
	4.通过dev_hard_start_xmit发送skb
		1.如果返回NETDEV_TX_OK
			1.如果之前对_xmit_lock上锁，通过netif_tx_unlock解锁
			2.因为进qdisc_restart对queue_lock上锁，所有出去也需要上锁
			3.返回-1，表示发送完成，但是队列中还有报文
		2.如果返回NETDEV_TX_LOCKED，但是之前不是上的_xmit_lock
			在上queue_lock锁后，返回1.1.1
		3.如果是NETDEV_TX_BUSY
			1.如果之前对_xmit_lock上锁，通过netif_tx_unlock解锁
			2.此时要操作qdisc，对queue_lock上锁
			3.如果skb没有发送完（skb-&gt;next），将其加入到dev-&gt;gso_skb
			注：gso_skb记录上次发送失败的skb
			4.否则将其加入排队规则中q-&gt;ops-&gt;requeue
			5.netif_schedule重新调度Tx软中断
			6.返回1，表示上锁失败或者设备stopped
2.如果设备没有包可发，返回队列长度 q-&gt;q.qlen
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2076</x>
      <y>685</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2140</x>
      <y>605</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_constructor
arp_direct_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2105</x>
      <y>730</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>netif_schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2109</x>
      <y>733</y>
      <w>23</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
__LINK_STATE_XOFF不能置上</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2104</x>
      <y>736</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__netif_schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2096</x>
      <y>742</y>
      <w>32</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果__LINK_STATE_SCHED没置上，将其置上
2.获取softnet_data,将dev（next_sched），加入链表
	sd-&gt;output_queue
3.开启软中断NET_TX_SOFTIRQ
注：netif_schedule是开启发的软中断，
	netif_rx_schedule开启收的软中断
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2109</x>
      <y>739</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2111</x>
      <y>752</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
net_dev_init</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2107</x>
      <y>756</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>net_tx_action</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2097</x>
      <y>762</y>
      <w>33</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.获取softnet_data
2.遍历completion_queue，释放skb
3.遍历output_queue上的dev
	1.清除设备__LINK_STATE_SCHED
	2.如果能上锁(queue_lock),通过qdisc_run发送数据包
		或者再次触发软中断在合适时机发送
	3.如果不能上锁，通过netif_schedule触发软中断
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2111</x>
      <y>759</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2095</x>
      <y>725</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2129</x>
      <y>688</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_queue_xmit_nit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2108</x>
      <y>695</y>
      <w>37</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.遍历ptype_all链表
	1.找到输出设备dev和输入设备ptype-&gt;dev相同（或者输入设备为NULL）
		并且不是当前的ptype输出的（ptype-&gt;af_packet_priv != skb-&gt;sk，或者af_packet_priv为空）
	2.通过skb_clone克隆一个skb
	3.错误检查skb2-&gt;nh.raw
	4.赋值
		skb2-&gt;mac.raw = skb2-&gt;data;
		skb2-&gt;h.raw = skb2-&gt;nh.raw;
		skb2-&gt;pkt_type = PACKET_OUTGOING;
	5.传给上层
		ptype-&gt;func
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2131</x>
      <y>691</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2139</x>
      <y>684</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>240.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1009</x>
      <y>953</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ops-&gt;init
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1014</x>
      <y>949</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1013</x>
      <y>956</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pfifo_fast_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2026</x>
      <y>657</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pfifo_fast_enqueue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2020</x>
      <y>664</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过prio2list根据skb.priority将skb map到qdisc
	私有信息的skb头
2.如果skb链表头长度skb_queue_len还没满（tx_queue_len）
	1.qdisc-&gt;q.qlen++
	2.通过__qdisc_enqueue_tail在链表中添加skb
3.如果超过其长度，利用qdisc_drop将skb丢弃
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2032</x>
      <y>660</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2017</x>
      <y>676</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__qdisc_enqueue_tail</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2024</x>
      <y>673</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2010</x>
      <y>682</y>
      <w>31</w>
      <h>11</h>
    </coordinates>
    <panel_attributes> //将skb链接到链表末端
__skb_queue_tail(list, skb);
 //更新Qdisc
sch-&gt;qstats.backlog += skb-&gt;len;
sch-&gt;bstats.bytes += skb-&gt;len;
sch-&gt;bstats.packets++;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2024</x>
      <y>679</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2042</x>
      <y>676</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qdisc_drop</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2046</x>
      <y>673</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2042</x>
      <y>682</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过kfree_skb释放skb
2.sch-&gt;qstats.drops++
3.返回NET_XMIT_DROP
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2048</x>
      <y>679</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2037</x>
      <y>739</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pfifo_fast_dequeue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2044</x>
      <y>742</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2029</x>
      <y>745</y>
      <w>33</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.获取qdisc的私有信息qdisc_priv中的skb链表头
2.按照优先级从高到低遍历3个链表头
	1.如果链表中有skb（!skb_queue_empty）
		1.qdisc-&gt;q.qlen--
		2.利用__qdisc_dequeue_head从链表中获取skb
3.如果3个链表都为空，返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2036</x>
      <y>759</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__qdisc_dequeue_head</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2046</x>
      <y>755</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2035</x>
      <y>766</y>
      <w>26</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过__skb_dequeue从链表中取出skb
2.更新Qdisc
	sch-&gt;qstats.backlog -= skb-&gt;len
3.返回skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2045</x>
      <y>762</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2073</x>
      <y>739</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pfifo_fast_requeue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2068</x>
      <y>746</y>
      <w>26</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.qdisc-&gt;q.qlen++
2.通过__qdisc_requeue将skb重新加入到
	qdisc的prio2list链表中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2079</x>
      <y>742</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2073</x>
      <y>755</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__qdisc_requeue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2079</x>
      <y>751</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2065</x>
      <y>762</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过__skb_queue_head将skb头插至链表头
2.更新Qdisc
	sch-&gt;qstats.backlog += skb-&gt;len;
	sch-&gt;qstats.requeues++;
3.返回NET_XMIT_SUCCESS
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2079</x>
      <y>758</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2039</x>
      <y>732</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;dequeue
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2044</x>
      <y>735</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
qdisc_alloc
pfifo_fast_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2027</x>
      <y>651</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;enqueue
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2032</x>
      <y>654</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2032</x>
      <y>646</y>
      <w>110</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
qdisc_alloc
pfifo_fast_ops</panel_attributes>
    <additional_attributes>1080.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2044</x>
      <y>725</y>
      <w>14</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2073</x>
      <y>730</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>q-&gt;ops-&gt;requeue
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2078</x>
      <y>725</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2079</x>
      <y>733</y>
      <w>11</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pfifo_fast_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1027</x>
      <y>953</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>qdisc_destroy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1032</x>
      <y>949</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1034</x>
      <y>960</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ops-&gt;reset
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1040</x>
      <y>963</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pfifo_fast_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1033</x>
      <y>956</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1033</x>
      <y>967</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pfifo_fast_reset</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1039</x>
      <y>970</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1025</x>
      <y>974</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.获取qdisc的私有信息qdisc_priv
2.通过__qdisc_reset_queue将私有信息中3个skb链表
	中的所有skb释放
3.qdisc-&gt;qstats.backlog = 0;
	qdisc-&gt;q.qlen = 0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>545</x>
      <y>746</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2079</x>
      <y>545</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
__mkroute_output</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2074</x>
      <y>549</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_output</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2066</x>
      <y>556</y>
      <w>33</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.skb-&gt;dev =skb-&gt;dst-&gt;dev
	skb-&gt;protocol = htons(ETH_P_IP)
2.经netfilter处理后，调用ip_finish_output处理报文
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2079</x>
      <y>552</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2075</x>
      <y>565</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_finish_output</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2080</x>
      <y>561</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2010</x>
      <y>572</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_fragment</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2091</x>
      <y>572</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_finish_output2</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2014</x>
      <y>568</y>
      <w>68</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果skb.len超过了mtu
并且没被gso</panel_attributes>
    <additional_attributes>660.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2080</x>
      <y>568</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
否则</panel_attributes>
    <additional_attributes>10.0;10.0;150.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2077</x>
      <y>580</y>
      <w>46</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果头部空间(skb_headroom)小于链路层头部的长度并且提供了方法
	hard_header填充链路层
	1.通过skb_realloc_headroom重新分配头部空间
	2.分配失败，则释放skb
	3.替换其为新的skb
		skb_set_owner_w(skb2, skb-&gt;sk);
		kfree_skb(skb);
		skb = skb2;
2.如果有缓存，通过neigh_hh_output发送
3.如果有dst-&gt;neighbour，通过dst-&gt;neighbour-&gt;output发送
4.否则释放skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2096</x>
      <y>575</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2072</x>
      <y>603</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_realloc_headroom</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2063</x>
      <y>610</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果每增加首部长度，通过pskb_copy复制skb
2.否则
	1.skb_clone对skb复制
	2.pskb_expand_head对skb进行扩充
3.返回skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2078</x>
      <y>606</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2080</x>
      <y>598</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2128</x>
      <y>602</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dst-&gt;neighbour-&gt;output
valign=center
bg=red</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2102</x>
      <y>603</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_hh_output</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2106</x>
      <y>598</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2114</x>
      <y>598</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1268</x>
      <y>1126</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dst_input</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1016</x>
      <y>1122</y>
      <w>260</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2580.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1268</x>
      <y>1133</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb-&gt;dst-&gt;input
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1273</x>
      <y>1129</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>930</x>
      <y>1173</y>
      <w>36</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.如果in_device不存在，返回EINVAL
2.如果源是多播(MULTICAST),受限的广播(BADCLASS)
	,或者回环(LOOPBACK)，跳到martian_source
3.如果目的是广播,或者自己发自己，跳到brd_input
4.如果源是0网段(ZERONET)，跳到martian_source
5.如果目的是广播(BADCLASS),0网段(ZERONET),
	回环地址(LOOPBACK),返回EHOSTUNREACH

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>947</x>
      <y>1166</y>
      <w>57</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>550.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>969</x>
      <y>1173</y>
      <w>47</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.通过fib_lookup在fib_table中查找对应的fib_node
	如果没有IN_DEV_FORWARD，跳到e_hostunreach，返回EHOSTUNREACH
	否则跳到no_route，本地接收
2.如果找到的地址是广播(RTN_BROADCAST),跳到brd_input
3.如果找到的是本地地址(RTN_LOCAL)
	1.通过fib_validate_source验证到source的路径
	2.如果检查出错，跳到martian_source
	3.如果没找到源地址
		flags |= RTCF_DIRECTSRC
	4.spec_dst = daddr
	5.跳到local_input
4.如果不支持转发，返回EHOSTUNREACH
5.如果不是单播(RTN_UNICAST)，返回EHOSTUNREACH
6.ip_mkroute_input设置rtable和neighbor
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>983</x>
      <y>1166</y>
      <w>22</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>969</x>
      <y>1202</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>fib_validate_source</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>955</x>
      <y>1209</y>
      <w>36</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.如果存在in_dev
	1.no_addr查看in_device是否配有ip地址
	2.rpf查看是否需要做源地址校验
2.如果in_dev不存在，返回EINVAL
3.fib_lookup查找源的fib_node,如果失败，跳到last_resort
4.如果成功
	1.源地址一定要是单播(RTN_UNICAST),否则返回EINVAL
	2.spec_dst记录fib_node的fib_prefsrc
	3.itag记录nh_tclassid | tclassid
	4.如果next_hop的dev和net_dev相同，即找到
		1.没地址返回1，有地址返回0
	5.如果dev不同
		1.如果dev没配ip，跳到last_resort
		2.如果不用源地址校验，返回EINVAL
		3.以dev为输出设备，通过fib_lookup，继续查找，如果成功
			1.如果是单播(RTN_UNICAST)
				1.spec_dst记录fib_prefsrc
				2.没地址返回1，有地址返回0
			2.如果不是，返回0
5.last_resort
	1.如果不需校验源地址，返回EINVAL
	2.inet_select_addr选择ip
	3.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>966</x>
      <y>1250</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_select_addr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>950</x>
      <y>1257</y>
      <w>42</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果没有in_device,跳到no_in_dev
2.遍历in_device的primary_ifa
	1.不能大于要求的scope(寻址范围要比要求的大)
	2.如果有指定对端的ip，如果和ifa_address的mask相同
		选择这个ifa的ifa_local作为本地ip
	3.如果没指定dst，或者每一个匹配的，选择第一个ifa的ifa_local
		作为本地ip
3.no_in_dev
	1.如果选择了本地ip，返回addr
	2.遍历dev_base里的所有net_dev
		1.in_dev要存在
		2.ifa不能是RT_SCOPE_LINK
		3.ifa_scope比要求的小(寻址范围比要求的大)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>971</x>
      <y>1253</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>971</x>
      <y>1246</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>973</x>
      <y>1205</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1006</x>
      <y>1201</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mkroute_input</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>974</x>
      <y>1196</y>
      <w>7</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1006</x>
      <y>1196</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;60.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1030</x>
      <y>1173</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>brd_input
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1003</x>
      <y>1166</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;310.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1020</x>
      <y>1180</y>
      <w>42</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.protocol要是ETH_P_IP
2.如果是0网段(ZERONET),通过inet_select_addr选择一个ifa_local
3.否则通过fib_validate_source验证源地址的有效性
	1.出错，跳到martian_source
	2.没找到
		flags |= RTCF_DIRECTSRC
4.flags |= RTCF_BROADCAST;
	res.type = RTN_BROADCAST;
5.跳到local_input
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1035</x>
      <y>1176</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1107</x>
      <y>1174</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>local_input
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1004</x>
      <y>1166</y>
      <w>112</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1100.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1097</x>
      <y>1177</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
分配rtable</panel_attributes>
    <additional_attributes>170.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1092</x>
      <y>1181</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dst_alloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1105</x>
      <y>1181</y>
      <w>35</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>rth-&gt;u.dst.output= ip_rt_bug;
atomic_set(&amp;rth-&gt;u.dst.__refcnt, 1);
rth-&gt;u.dst.flags= DST_HOST
rth-&gt;u.dst.flags |= DST_NOPOLICY//in_dev-&gt;cnf.no_policy
rth-&gt;fl.fl4_dst	= daddr;
rth-&gt;rt_dst	= daddr;
rth-&gt;fl.fl4_tos	= tos;
rth-&gt;fl.mark    = skb-&gt;mark;
rth-&gt;fl.fl4_src	= saddr;
rth-&gt;rt_src	= saddr;
rth-&gt;u.dst.tclassid = itag;
rth-&gt;rt_iif	= rth-&gt;fl.iif	= dev-&gt;ifindex;
rth-&gt;u.dst.dev	= &amp;loopback_dev;
dev_hold(rth-&gt;u.dst.dev);
rth-&gt;idev	= in_dev_get(rth-&gt;u.dst.dev);
rth-&gt;rt_gateway	= daddr;
rth-&gt;rt_spec_dst= spec_dst;
rth-&gt;u.dst.input= ip_local_deliver;
rth-&gt;rt_flags 	= flags|RTCF_LOCAL;
 //RTN_UNREACHABLE
rth-&gt;u.dst.input= ip_error;
rth-&gt;u.dst.error= -err;
rth-&gt;rt_flags 	&amp;= ~RTCF_LOCAL;

rth-&gt;rt_type	= res.type;

halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1111</x>
      <y>1177</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
设置rtable</panel_attributes>
    <additional_attributes>50.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1142</x>
      <y>1181</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rt_intern_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1118</x>
      <y>1177</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
插入到rt_hash_table
这里不设置neighbor</panel_attributes>
    <additional_attributes>10.0;10.0;280.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1255</x>
      <y>1141</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_local_deliver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1261</x>
      <y>1136</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
local_input</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1068</x>
      <y>1174</y>
      <w>10</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>no_route
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1004</x>
      <y>1166</y>
      <w>70</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;680.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1063</x>
      <y>1181</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.inet_select_addr选择一个本地地址
2.res.type = RTN_UNREACHABLE
3.跳到local_input
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1073</x>
      <y>1177</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1006</x>
      <y>1208</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mkroute_input_def</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1013</x>
      <y>1204</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>997</x>
      <y>1216</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__mkroute_input</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1020</x>
      <y>1216</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rt_intern_hash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1001</x>
      <y>1211</y>
      <w>15</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>130.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1014</x>
      <y>1211</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>992</x>
      <y>1223</y>
      <w>44</w>
      <h>59</h>
    </coordinates>
    <panel_attributes>1.通过in_dev_get获取in_device
2.fib_validate_source验证源地址的有效性，如果出错，返回EINVAL
3.如果没找到对应的源地址，
	flags |= RTCF_DIRECTSRC
4.如果输入设备和输出设备一致，并且没找到源地址，并且RTCF_NAT和RTCF_MASQ没置上
	并且该设备是网关
	flags |= RTCF_DOREDIRECT
5.如果不是ip
	1.如果输入和输出设备一致，并且RTCF_DNAT没置上，返回EINVAL
	
6.dst_alloc申请rtable
7.初始话rtable
	atomic_set(&amp;rth-&gt;u.dst.__refcnt, 1)
	rth-&gt;u.dst.flags =DST_HOST//DST_BALANCED（fib_nhs） DST_NOPOLICY(no_policy) DST_NOXFRM（no_xfrm） 
	rth-&gt;fl.fl4_dst	= daddr;
	rth-&gt;rt_dst	= daddr;
	rth-&gt;fl.fl4_tos	= tos;
	rth-&gt;fl.mark    = skb-&gt;mark;
	rth-&gt;fl.fl4_src	= saddr;
	rth-&gt;rt_src	= saddr;
	rth-&gt;rt_gateway	= daddr;
	rth-&gt;rt_iif 	=
		rth-&gt;fl.iif	= in_dev-&gt;dev-&gt;ifindex;
	rth-&gt;u.dst.dev	= (out_dev)-&gt;dev;
	dev_hold(rth-&gt;u.dst.dev);
	rth-&gt;idev	= in_dev_get(rth-&gt;u.dst.dev);
	rth-&gt;fl.oif 	= 0;
	rth-&gt;rt_spec_dst= spec_dst;

	rth-&gt;u.dst.input = ip_forward;
	rth-&gt;u.dst.output = ip_output;

	rt_set_nexthop(rth, res, itag);

	rth-&gt;rt_flags = flags;
8.返回rth
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1002</x>
      <y>1219</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1276</x>
      <y>1135</y>
      <w>1523</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
__mkroute_input</panel_attributes>
    <additional_attributes>10.0;20.0;15210.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2790</x>
      <y>1137</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_forward</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1243</x>
      <y>1148</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果被分段(IP_MF|IP_OFFSET),通过ip_defrag组装
2.net_filter检查之后，通过ip_local_deliver_finish接收
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1260</x>
      <y>1144</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1203</x>
      <y>1157</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_defrag</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1394</x>
      <y>1167</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_local_deliver_finish</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1208</x>
      <y>1152</y>
      <w>51</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
IP_DEFRAG_LOCAL_DELIVER</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1258</x>
      <y>1152</y>
      <w>146</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;1440.0;150.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1385</x>
      <y>1174</y>
      <w>36</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.通过__skb_pull将ip头部调整出data的范围内
	skb-&gt;h.raw = skb-&gt;data
2.如果在raw_v4_htable中找到对应协议对应的raw_sk
	通过raw_v4_input接收，如果失败
	raw_sk = NULL
3.在inet_protos中取出上层协议的net_protocol
	1.如果有检查(!no_policy)，通过xfrm4_policy_check检查
		并通过nf_reset重置net_filter
	2.ipprot-&gt;handler接收，如果失败，跳到1重新提交
4.如果没找到对应的net_protocol
	1.如果没有raw_sk,如果xfrm4_policy_check检查通过，
		通过icmp_send发送ICMP_PROT_UNREACH
	2.否则释放skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1402</x>
      <y>1170</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1376</x>
      <y>1199</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>raw_v4_input</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1355</x>
      <y>1206</y>
      <w>41</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.raw_v4_htable[hash]为0，返回0，表示接收失败
注：hash和其传输层协议有关
2.__raw_v4_lookup在对应的协议中查找对应的sk
3.如果找到sk
	1.返回值设置为1，表示接收成功
		delivered = 1
	2.如果不是IPPROTO_ICMP，或者icmp校验失败(!icmp_filter)
		skb_clone之后，通过raw_rcv接收
	3.__raw_v4_lookup继续查找下一个sk，继续循环
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1372</x>
      <y>1202</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>100.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1339</x>
      <y>1225</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__raw_v4_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1346</x>
      <y>1221</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1318</x>
      <y>1232</y>
      <w>45</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.遍历链表，找到协议相同(num)，源地址（raddr）和sk的目的地址(daddr)相同
	目的地址(laddr),和sk的源地址(rcv_saddr)相同
	并且输入设备是sk_bound_dev_if，即找到
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1346</x>
      <y>1228</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1374</x>
      <y>1226</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>raw_rcv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1377</x>
      <y>1221</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1364</x>
      <y>1233</y>
      <w>32</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.xfrm4_policy_check检查，如果失败，释放skb
2.nf_reset重置net_filter
3.skb_push将data指向skb-&gt;nh.raw
4.raw_rcv_skb接收skb
5.返回0，表示成功接收
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1379</x>
      <y>1229</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1373</x>
      <y>1245</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>raw_rcv_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1377</x>
      <y>1241</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1372</x>
      <y>1252</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_queue_rcv_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1378</x>
      <y>1248</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1358</x>
      <y>1259</y>
      <w>38</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果需要的内存超过了sk_rcvbuf，返回ENOMEM
2.sk_filter调整skb中的长度
3.skb-&gt;dev = NULL;
	skb_set_owner_r(skb, sk);
4.skb_queue_tail将skb挂入到sk_receive_queue
5.如果sk没有SOCK_DEAD，通过sk_data_ready通知
	进程skb接收
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1378</x>
      <y>1255</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1381</x>
      <y>1195</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>140.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1419</x>
      <y>1200</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipprot-&gt;handler
valign=center
bg=red</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1410</x>
      <y>1195</y>
      <w>16</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;140.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1425</x>
      <y>1203</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_init
tcp_protocol</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>885</x>
      <y>1036</y>
      <w>43</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果RU_SUSPENDED，需要重启receiver
2.遍历rx_to_clean链表，
	1.e100_rx_indicate读取数据
	2.如果quota用完(EAGAIN),不能重启receiver，退出循环
	3.如果没数据可读，退出循环
	4.调整rx_to_clean
3.如果需要重启，将重启的rx指向rx_to_clean
4.遍历rx_to_use链表，e100_rx_alloc_skb给没有skb的rx分配skb
5.如果需要重启
	1.回复stat_ack_rnr
	2.e100_start_receiver重启receiver
	3.递增work_done，使其重新分配quota，用于接收因为没有resource丢掉的帧
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>912</x>
      <y>932</y>
      <w>24</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>220.0;10.0;100.0;80.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>892</x>
      <y>942</y>
      <w>29</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果读到stat_ack，发现不是这个dev的中断，返回IRQ_NONE
2.回复IRQ_NONE
3.如果因为没有读的资源(stat_ack_rnr)
	nic-&gt;ru_running = RU_SUSPENDED
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>907</x>
      <y>1032</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>353</x>
      <y>721</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_get_defaults</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>360</x>
      <y>716</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>348</x>
      <y>729</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>nic-&gt;blank_rfd.command = cpu_to_le16(cb_el);//默认是最后一个rx
nic-&gt;blank_rfd.rbd = 0xFFFFFFFF;
nic-&gt;blank_rfd.size = cpu_to_le16(VLAN_ETH_FRAME_LEN);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>359</x>
      <y>724</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>898</x>
      <y>1059</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_rx_indicate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>904</x>
      <y>1055</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>885</x>
      <y>1066</y>
      <w>44</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.如果没有quota，返回EAGAIN
2.如果rfd_status没数据可读(!cb_complete)，返回ENODATA
3.最大报文长度不能超过VLAN_ETH_FRAME_LEN
4.如果是最后一个rx(cb_el)
	nic-&gt;ru_running = RU_SUSPENDED
注：skb.data的头24字节存储链接层信息，
5.skb_reserve将链接层信息移出skb.data
6.skb_put将数据区域显示
7.skb-&gt;protocol = eth_type_trans(skb, nic-&gt;netdev)
8.处理skb
	1.如果报错(!cb_ok)，dev_kfree_skb_any将skb释放
	2.如果数据长度超过限制
		nic-&gt;rx_over_length_errors++;
		dev_kfree_skb_any(skb);
	3.正确接收
		nic-&gt;net_stats.rx_packets++;
		nic-&gt;net_stats.rx_bytes += actual_size;
		nic-&gt;netdev-&gt;last_rx = jiffies;
		netif_receive_skb(skb);
		work_done++
8.释放rx，用于下次接收，并返回0
	rx-&gt;skb = NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>903</x>
      <y>1062</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>897</x>
      <y>1105</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>eth_type_trans</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>902</x>
      <y>1101</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>894</x>
      <y>1112</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.设置mac头地址
	skb-&gt;mac.raw = skb-&gt;data
2.skb_pull移出其mac头
3.设置skb-&gt;pkt_type
注：PACKET_HOST是默认值，0
4.查看mac头，返回链接层协议
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>902</x>
      <y>1108</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>933</x>
      <y>1035</y>
      <w>40</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.遍历链表cb_to_clean，cb的cb_complete要置上，否则退出循环
	1.如果cb.skb存在，更新发送信息
		nic-&gt;net_stats.tx_packets++;
		nic-&gt;net_stats.tx_bytes += cb-&gt;skb-&gt;len;
	2.释放skb
		dev_kfree_skb_any(cb-&gt;skb);
		cb-&gt;skb = NULL;
		tx_cleaned = 1;//表示做过清理
	3.更新cb
		cb-&gt;status = 0;
		nic-&gt;cbs_avail++;
2.如果之前因为没资源stopped，现在因为tx_cleaned，通过
	netif_wake_queue唤醒
3.返回是否被清理过tx_cleaned
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>949</x>
      <y>1031</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>942</x>
      <y>1061</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>netif_wake_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>947</x>
      <y>1058</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>946</x>
      <y>1064</y>
      <w>35</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果dev之前__LINK_STATE_XOFF，清除这个标志</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>940</x>
      <y>1068</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__netif_schedule</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1446</x>
      <y>402</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>init_netconsole</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1449</x>
      <y>422</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>netpoll_setup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1454</x>
      <y>418</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1437</x>
      <y>428</y>
      <w>37</w>
      <h>43</h>
    </coordinates>
    <panel_attributes>1.通过np.devname利用dev_get_by_name获取net_dev
	np-&gt;dev = ndev
2.如果dev不存在npinfo，通过kmalloc申请，并初始化
	否则递增npinfo-&gt;refcnt
	npinfo-&gt;rx_flags = 0;
	npinfo-&gt;rx_np = NULL;
	spin_lock_init(&amp;npinfo-&gt;poll_lock);
	npinfo-&gt;poll_owner = -1;
	spin_lock_init(&amp;npinfo-&gt;rx_lock);
	skb_queue_head_init(&amp;npinfo-&gt;arp_tx);
	skb_queue_head_init(&amp;npinfo-&gt;txq);
	INIT_DELAYED_WORK(&amp;npinfo-&gt;tx_work, queue_process);
	atomic_set(&amp;npinfo-&gt;refcnt, 1);
3.如果没有ndev-&gt;poll_controller，返回ENOTSUPP
4.如果dev-&gt;state的__LINK_STATE_START没置上
	1.通过dev_open打开net_dev
	2.等待4s__LINK_STATE_NOCARRIER置上
	3.如果100ms就置上，会等待4s
5.如果np-&gt;local_mac为空，ndev-&gt;dev_addr存在
	np-&gt;local_mac=ndev-&gt;dev_addr
6.np-&gt;local_ip = ntohl(in_dev-&gt;ifa_list-&gt;ifa_local)
7.如果要求netpoll要求接收（np-&gt;rx_hook）
	npinfo-&gt;rx_flags |= NETPOLL_RX_ENABLED;
	npinfo-&gt;rx_np = np;
8.通过refill_skbs填充skb_pool中的skb
9.ndev-&gt;npinfo = npinfo
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1454</x>
      <y>425</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1440</x>
      <y>409</y>
      <w>34</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果设置了参数config，通过option_setup解析
	config，然后对np中的源和目标port，ip，mac赋值
2.如果没有解析成功（!configured），直接返回
3.通过netpoll_setup将np和net_dev中的netpoll_info
	关联
4.通过register_console注册netconsole
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1452</x>
      <y>405</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1882</x>
      <y>126</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>netpoll_poll</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1869</x>
      <y>133</y>
      <w>43</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.netpoll.dev要存在，dev-&gt;state的__LINK_STATE_START要置上
	poll_controller要存在
2.通过np-&gt;dev-&gt;poll_controller模拟网络设备产生中断
3.如果设备实现了np-&gt;dev-&gt;poll，通过poll_napi轮询读取报文
4.service_arp_queue处理npi-&gt;arp_tx中的arp报文
5.通过zap_completion_queue清除softnet_data的
	completion_queue
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1888</x>
      <y>129</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1855</x>
      <y>150</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>np-&gt;dev-&gt;poll_controller
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1862</x>
      <y>145</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1854</x>
      <y>156</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>e100_netpoll</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1859</x>
      <y>153</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1876</x>
      <y>150</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>poll_napi</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1895</x>
      <y>151</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>service_arp_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1917</x>
      <y>151</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>zap_completion_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1881</x>
      <y>145</y>
      <w>14</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>120.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1899</x>
      <y>145</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1907</x>
      <y>145</y>
      <w>18</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1847</x>
      <y>162</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.通过e100_intr模拟中断运行
2.e100_tx_clean释放已发送的报文得到cb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1858</x>
      <y>159</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1872</x>
      <y>157</y>
      <w>25</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果__LINK_STATE_RX_SCHED置上（两次软中断处理的间隙）
	npinfo-&gt;poll_owner不是上一次处理软中断的cpu
	npinfo-&gt;poll_lock上锁成功
	1.npinfo-&gt;rx_flags |= NETPOLL_RX_DROP，递增trapped，执行np-&gt;dev-&gt;poll（e100_poll）
	2.将trapped和npinfo-&gt;rx_flags恢复
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1878</x>
      <y>153</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>40.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1898</x>
      <y>157</y>
      <w>19</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.从npi-&gt;arp_tx不断取出skb，
	arp_reply回应
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1903</x>
      <y>154</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1919</x>
      <y>157</y>
      <w>29</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.取出链表softnet_data.completion_queue
	1.如果skb-&gt;destructor存在，通过dev_kfree_skb_any释放
	2.如果没有，通过__kfree_skb释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1926</x>
      <y>154</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1901</x>
      <y>164</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_reply</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1906</x>
      <y>161</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1884</x>
      <y>170</y>
      <w>40</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>1.netpoll要存在，并且其dev要和skb.dev相同
2.net_dev的IFF_NOARP不能置上
3.pskb_may_pull查看skb_headlen中存在（arp地址+2*ip地址+2*port）
注：skb_headlen：data~end
	len:data---end----frags----frag_list
	datalen:end----frags----frag_list
4.skb-&gt;h.raw = skb-&gt;nh.raw = skb-&gt;data
5.arp的硬件类型要么是ARPHRD_ETHER或者ARPHRD_IEEE802
	协议类型是ETH_P_IP
	操作码是ARPOP_REQUEST
6.得到mac地址sha
	源ip--sip
	目标ip--tip
7.目标ip要满足是条件之一
	1.本地ip--np-&gt;local_ip
	2.不是LOOPBACK
	3.不是MULTICAST
8.通过find_skb申请skb，header留出长度hard_header_len
9.send_skb-&gt;nh.raw = send_skb-&gt;data;
	send_skb-&gt;dev = skb-&gt;dev;
	send_skb-&gt;protocol = htons(ETH_P_ARP);
10.如果存在np-&gt;dev-&gt;hard_header，通过这个函数给arp = (struct arphdr *) skb_put(send_skb, size)
	赋值，之后返回
11.否则直接赋值
	arp-&gt;ar_hrd = htons(np-&gt;dev-&gt;type);
	arp-&gt;ar_pro = htons(ETH_P_IP);
	arp-&gt;ar_hln = np-&gt;dev-&gt;addr_len;
	arp-&gt;ar_pln = 4;
	arp-&gt;ar_op = htons(type);

	arp_ptr=(unsigned char *)(arp + 1);
	memcpy(arp_ptr, np-&gt;dev-&gt;dev_addr, np-&gt;dev-&gt;addr_len);
	arp_ptr += np-&gt;dev-&gt;addr_len;
	memcpy(arp_ptr, &amp;tip, 4);
	arp_ptr += 4;
	memcpy(arp_ptr, sha, np-&gt;dev-&gt;addr_len);
	arp_ptr += np-&gt;dev-&gt;addr_len;
	memcpy(arp_ptr, &amp;sip, 4);
12.通过netpoll_send_skb发送准备好的arp报文
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1905</x>
      <y>167</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1895</x>
      <y>89</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>netpoll_send_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1872</x>
      <y>25</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>netpoll_send_udp</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1860</x>
      <y>32</y>
      <w>41</w>
      <h>55</h>
    </coordinates>
    <panel_attributes>1.通过find_skb申请skb
2.复制消息
	memcpy(skb-&gt;data, msg, len);
	skb-&gt;len += len;
3.压入udp头部信息
	skb-&gt;h.uh = udph = (struct udphdr *) skb_push(skb, sizeof(*udph));
	udph-&gt;source = htons(np-&gt;local_port);
	udph-&gt;dest = htons(np-&gt;remote_port);
	udph-&gt;len = htons(udp_len);
	udph-&gt;check = 0;
	udph-&gt;check = csum_tcpudp_magic
4.压入ip头部信息
	skb-&gt;nh.iph = iph = (struct iphdr *)skb_push(skb, sizeof(*iph));
	/* iph-&gt;version = 4; iph-&gt;ihl = 5; */
	put_unaligned(0x45, (unsigned char *)iph);
	iph-&gt;tos      = 0;
	put_unaligned(htons(ip_len), &amp;(iph-&gt;tot_len));
	iph-&gt;id       = 0;
	iph-&gt;frag_off = 0;
	iph-&gt;ttl      = 64;
	iph-&gt;protocol = IPPROTO_UDP;
	iph-&gt;check    = 0;
	put_unaligned(htonl(np-&gt;local_ip), &amp;(iph-&gt;saddr));
	put_unaligned(htonl(np-&gt;remote_ip), &amp;(iph-&gt;daddr));
	iph-&gt;check    = ip_fast_csum
5.压入mac头部信息
	eth = (struct ethhdr *) skb_push(skb, ETH_HLEN);
	skb-&gt;mac.raw = skb-&gt;data;
	skb-&gt;protocol = eth-&gt;h_proto = htons(ETH_P_IP);
	memcpy(eth-&gt;h_source, np-&gt;local_mac, 6);
	memcpy(eth-&gt;h_dest, np-&gt;remote_mac, 6);
7.skb-&gt;dev = np-&gt;dev
8.通过netpoll_send_skb发送skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1876</x>
      <y>28</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1882</x>
      <y>95</y>
      <w>47</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.如果不存在netpoll_poll，或者dev.state状态__LINK_STATE_START
	或者__LINK_STATE_PRESENT没置上，释放skb，丢弃其数据包
2.如果npinfo-&gt;txq队列没有skb，并且npinfo-&gt;poll_owner的软中断
	不是当前的cpu，尝试发送skb 10ms
	1.如果__LINK_STATE_XOFF没置上，通过dev-&gt;hard_start_xmit
		发送skb
	2.如果发送成功（NETDEV_TX_OK），则退出循环
	3.如果没发送成功，通过netpoll_poll发送skb，或者模拟网络中断接受skb
注：1.npinfo-&gt;poll_owner是在软中断net_rx_action--netpoll_poll_lock
	中被赋值
	2.netif_tx_trylock中会赋值dev-&gt;xmit_lock_owner
	3.如果是同一个核进行进行收发，这样递归会造成死锁（因为没skb，所以会在收的时候发
		或者在发的时候收，腾出空间）
3.如果没有发送成功
	1.将skb链接到npinfo-&gt;txq链表末端
	2.将npinfo-&gt;tx_work链接到keventd_wq.cpu_wq[cpu]链表中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1900</x>
      <y>92</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1928</x>
      <y>128</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>queue_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1918</x>
      <y>135</y>
      <w>48</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.通过work利用关系netpoll_info.tx_work.work获取netpollinfo
2.从队列npinfo-&gt;txq中取出skb
	1.如果net_dev的__LINK_STATE_PRESENT或者__LINK_STATE_START
		没置上，丢弃数据包释放skb
	2.如果__LINK_STATE_XOFF没置上，通过dev-&gt;hard_start_xmit发送skb
		如果置上或者发送失败，将skb继续存在链表npinfo-&gt;txq中，并通过schedule_delayed_work
		将npinfo-&gt;tx_work推后100ms执行
注：netif_tx_lock中有对dev-&gt;xmit_lock_owner设置。
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1933</x>
      <y>131</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1916</x>
      <y>121</y>
      <w>30</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
netpoll_setup中设置了npinfo-&gt;tx_work的func</panel_attributes>
    <additional_attributes>100.0;10.0;190.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1846</x>
      <y>91</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>find_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1836</x>
      <y>98</y>
      <w>36</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.通过zap_completion_queue将cpu的completion_queue中的skb释放
2.refill_skbs填充skb_pool
3.通过alloc_skb申请skb，如果没申请到，通过skb_dequeue
	在skb_pool中申请
4.如果还没申请到，通过netpoll_poll处理待处理的skb，
	10次之后还没申请到，返回NULL
5.如果申请到，更新skb，，并返回
	atomic_set(&amp;skb-&gt;users, 1);
	skb_reserve(skb, reserve);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1850</x>
      <y>94</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1852</x>
      <y>86</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1880</x>
      <y>86</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1824</x>
      <y>117</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>zap_completion_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1832</x>
      <y>113</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1812</x>
      <y>124</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.获取cpu的completion_queue
2.通过析构函数destructor释放链表中的skb
	或者通过__kfree_skb直接释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1830</x>
      <y>120</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1860</x>
      <y>117</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>refill_skbs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1865</x>
      <y>113</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1847</x>
      <y>124</y>
      <w>30</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果skb_pool.qlen的长度小于MAX_SKBS
	通过alloc_skb申请skb，通过__skb_queue_tail
	放到skb_pool尾部
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1864</x>
      <y>120</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1887</x>
      <y>121</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放底层的资源</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>468</x>
      <y>613</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pktsched_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>468</x>
      <y>620</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>register_qdisc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>472</x>
      <y>616</y>
      <w>23</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
pfifo_qdisc_ops/bfifo_qdisc_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>457</x>
      <y>627</y>
      <w>37</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.查找链表qdisc_base中是否有和qops-&gt;id相同的Qdisc_ops
	如果有，返回EEXIST
2.如果qops中有enqueue、requeue，dequeue是NULL,将其
	noop_qdisc_ops相应的函数指针
3.将qops加入到qdisc_base链表尾端，并返回0
	qops-&gt;next = NULL;
	*qp = qops;
	rc = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>472</x>
      <y>623</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2770</x>
      <y>1144</y>
      <w>48</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.xfrm4_policy_check进行ipsec检查
2.如果存在路由警告项(router_alert),通过ip_call_ra_chain通知感兴趣的进程
	并返回NET_RX_SUCCESS，不进行转发
3.如果mac解析是不是发送给当前主机的(!PACKET_HOST),释放skb
4.因为会改ip首部，
	skb-&gt;ip_summed = CHECKSUM_NONE
5.如果ttl减到0，跳到too_many_hops，icmp_send发送超时，释放skb
6.xfrm4_route_forward进行安全检查,如果出错，释放skb
7.如果is_strictroute置上，rt_dst和rt_gateway要相等，否则icmp_send发送
	ICMP_DEST_UNREACH，并释放skb
8.skb_cow复制并在data段腾出链路层+header_len的长度
9.ip_decrease_ttl重新计算iph-&gt;check，递减ttl
10.如果RTCF_DOREDIRECT置上，并且不要求srr，通过ip_rt_send_redirect
	发送icmp
11.通过iph-&gt;tos计算skb-&gt;priority
12.net_filter检查后，通过ip_forward_finish发送
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2795</x>
      <y>1140</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2800</x>
      <y>1174</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_forward_finish</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2806</x>
      <y>1170</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2790</x>
      <y>1181</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_forward_options</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2809</x>
      <y>1181</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dst_output</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2796</x>
      <y>1177</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2805</x>
      <y>1177</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2142</x>
      <y>605</y>
      <w>137</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_constructor
arp_generic_ops</panel_attributes>
    <additional_attributes>10.0;10.0;1350.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2267</x>
      <y>612</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_resolve_output</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2255</x>
      <y>619</y>
      <w>36</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果dst或者neigh不存在，释放skb
2.__skb_pull将ip头释放
3.neigh_event_send查看是否需要arp处理，如果不需要
	1.如果存在hard_header_cache，但是不存在hh
		1.neigh_hh_init初始化该协议的hh
		2.hard_header填充skb的头部
	2.否则直接通过hard_header填充skb的头部
	3.如果填充成功，通过neigh-&gt;ops-&gt;queue_xmit发送
注：填充头部信息可以参考ether_setup
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2274</x>
      <y>615</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2220</x>
      <y>643</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_event_send</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2213</x>
      <y>650</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.neigh-&gt;used = jiffies
2.如果不在NUD_CONNECTED|NUD_DELAY|NUD_PROBE状态，
	通过__neigh_event_send发送arp
3.返回0，表示不用arp处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2231</x>
      <y>662</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__neigh_event_send</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2232</x>
      <y>669</y>
      <w>38</w>
      <h>43</h>
    </coordinates>
    <panel_attributes>1.如果在NUD_CONNECTED | NUD_DELAY | NUD_PROBE
	直接返回0
2.如果不在NUD_STALE | NUD_INCOMPLETE
	1.如果允许发送arp（mcast_probes，app_probes）
		1.设置neigh-&gt;probes的初始值为ucast_probes
		注：由neigh_timer_handler可知，最多只能发送mcast_probes 或者app_probes次
		2.neigh-&gt;nud_state     = NUD_INCOMPLETE;
			neigh-&gt;updated = jiffies;
			neigh_hold(neigh);
			neigh_add_timer(neigh, now + 1);
	2.如果不允许发送
		1.neigh-&gt;nud_state = NUD_FAILED;
			neigh-&gt;updated = jiffies;
		2.释放skb，并返回1
3.如果在NUD_STALE
	neigh_hold(neigh);
	neigh-&gt;nud_state = NUD_DELAY;
	neigh-&gt;updated = jiffies;
	neigh_add_timer(neigh,
			jiffies + neigh-&gt;parms-&gt;delay_probe_time)
4.如果在NUD_INCOMPLETE(包含之前跳到NUD_INCOMPLETE的情况)
	1.如果skb存在
		1.如果arp_queue的长度超过了限制
			1.将arp_queue中的第一个skb释放(也就是最先插入到arp_queue的)
		2.__skb_queue_tail将skb放到arp_queue的最后
	2.返回1，表示等待arp处理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2240</x>
      <y>665</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2238</x>
      <y>657</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2227</x>
      <y>646</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2276</x>
      <y>644</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_hh_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2273</x>
      <y>652</y>
      <w>37</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.遍历neigh的hh链表，查看是否存在有和其protocol相同的hh
2.如果不存在，通过kzalloc社情，并初始化
	1.hh-&gt;hh_type = protocol;
		atomic_set(&amp;hh-&gt;hh_refcnt, 0);
		hh-&gt;hh_next = NULL;
	2.如果hard_header_cache填充hh头部失败，释放hh，并返回NULL
	3.递增hh，并将hh插入到hh链表头部
		atomic_inc(&amp;hh-&gt;hh_refcnt);
		hh-&gt;hh_next = n-&gt;hh;
		n-&gt;hh	    = hh;
	4.如果处于NUD_CONNECTED
		hh-&gt;hh_output = n-&gt;ops-&gt;hh_output
		否则
		hh-&gt;hh_output = n-&gt;ops-&gt;output
3.如果存在hh，对其引用
	atomic_inc(&amp;hh-&gt;hh_refcnt);
	dst-&gt;hh = hh;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2281</x>
      <y>647</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2325</x>
      <y>645</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh-&gt;ops-&gt;queue_xmit
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2327</x>
      <y>653</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_queue_xmit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2332</x>
      <y>648</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_generic_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2224</x>
      <y>634</y>
      <w>51</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2276</x>
      <y>634</y>
      <w>7</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;50.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2286</x>
      <y>634</y>
      <w>47</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;110.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1284</x>
      <y>651</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_timer_handler</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1279</x>
      <y>647</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1275</x>
      <y>658</y>
      <w>38</w>
      <h>67</h>
    </coordinates>
    <panel_attributes>1.如果不在NUD_IN_TIMER，直接退出
2.如果状态是NUD_REACHABLE
	1.(confirmed,reachable_time)，设置时间为reachable_time
	2.(reachable_time,delay_probe_time)
		neigh-&gt;nud_state = NUD_DELAY;
		neigh-&gt;updated = jiffies;
		neigh_suspect(neigh);
		next = now + neigh-&gt;parms-&gt;delay_probe_time;
	3.如果超过了delay_probe_time
		neigh-&gt;nud_state = NUD_STALE;
		neigh-&gt;updated = jiffies;
		neigh_suspect(neigh);
		notify = 1;
3.如果处于NUD_DELAY
	1.如果在delay_probe_time之前
		neigh-&gt;nud_state = NUD_REACHABLE;
		neigh-&gt;updated = jiffies;
		neigh_connect(neigh);
		notify = 1;
		next = neigh-&gt;confirmed + neigh-&gt;parms-&gt;reachable_time;
	2.否则进行probe
		neigh-&gt;nud_state = NUD_PROBE;
		neigh-&gt;updated = jiffies;
		atomic_set(&amp;neigh-&gt;probes, 0);
		next = now + neigh-&gt;parms-&gt;retrans_time;
4.如果在NUD_PROBE|NUD_INCOMPLETE
	1.设置时间为retrans_time
	2.如果探测次数probes超过了neigh_max_probes
		1.neigh-&gt;nud_state = NUD_FAILED;
			neigh-&gt;updated = jiffies;
			notify = 1;
		2.将arp_queue中的所有skb，通过neigh-&gt;ops-&gt;error_report报告错误
		3.skb_queue_purge释放所有skb
5.如果处于NUD_IN_TIMER
	1.next最小为0.5s
	2.mod_timer定时
6.如果处于NUD_INCOMPLETE | NUD_PROBE
	1.skb_peek取出arp_queue中的skb，通过neigh-&gt;ops-&gt;solicit发送arp
	2.递增neigh-&gt;probes
7.如果需要notify，通过call_netevent_notifiers通知感兴趣的进程
8.neigh_release递减neigh的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1291</x>
      <y>654</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1286</x>
      <y>728</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh-&gt;ops-&gt;solicit
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1290</x>
      <y>724</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1287</x>
      <y>735</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_solicit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1292</x>
      <y>731</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_generic_ops
arp_broken_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1273</x>
      <y>742</y>
      <w>46</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.in_device要存在
2.检查arp_announce，设置saddr
	1.如果是0，如果skb中的saddr如果是RTN_LOCAL，就可以被设置为arp announce
	2.如果是1，不仅需要RTN_LOCAL，还需要inet_addr_onlink检查和target在同一网段
	3.如果是2，不做设置
3.如果saddr没设置，inet_select_addr选择一个primary，RT_SCOPE_LINK范围的地址
4.如果是ucast_probes，
	dst_ha = neigh-&gt;ha;//单播发送arp，需要指定neigh的地址
5.如果是app_probes，通过neigh_app_ns发送
6.其他(ucast_probes  mcast_probes),通过arp_send发送arp
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1292</x>
      <y>738</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1273</x>
      <y>763</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_addr_onlink</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1264</x>
      <y>770</y>
      <w>31</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.遍历in_dev的primary_ifa
	1.inet_ifa_match检查到target在同一网段
	2.source为0，或者inet_ifa_match检查到source在同一网段
	3.返回1，表示两个在同一网段
3.返回0，表示不在
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1278</x>
      <y>766</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1278</x>
      <y>759</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1303</x>
      <y>763</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_send</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1308</x>
      <y>759</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1298</x>
      <y>770</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.dev的IFF_NOARP不能置上
2.arp_create创建skb，填充arp头部
3.arp_xmit进行发送
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1309</x>
      <y>766</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1293</x>
      <y>779</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1312</x>
      <y>779</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_xmit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1316</x>
      <y>775</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1317</x>
      <y>782</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
net_filter后</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1311</x>
      <y>786</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_queue_xmit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1299</x>
      <y>775</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1276</x>
      <y>786</y>
      <w>34</w>
      <h>31</h>
    </coordinates>
    <panel_attributes>1.alloc_skb申请skb，其中包括arp头部，两个mac地址长度，包括链接层空间
2.skb_reserve预留出链接层空间
3.arp层空间
	skb-&gt;nh.raw = skb-&gt;data
4.skb_put腾出arp头部和dev地址的空间
5.skb-&gt;dev = dev
6.src_hw = dev-&gt;dev_addr //默认为dev的地址
	dest_hw = dev-&gt;broadcast//默认为广播地址
7.dev-&gt;hard_header填充mac头部
8.填充arp头部
	1.根据dev-&gt;type，填充硬件类型(ar_hrd),和上层协议(ar_pro)
	2.arp-&gt;ar_hln = dev-&gt;addr_len;
		arp-&gt;ar_pln = 4;
		arp-&gt;ar_op = htons(type)
	3.填充硬件地址及ip地址
		memcpy(arp_ptr, src_hw, dev-&gt;addr_len);
		memcpy(arp_ptr, &amp;src_ip,4);
		memcpy(arp_ptr, target_hw, dev-&gt;addr_len);//arp请求如果不知道target地址，填充0
		memcpy(arp_ptr, &amp;dest_ip, 4);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1298</x>
      <y>782</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1030</x>
      <y>410</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_add_pack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1035</x>
      <y>407</y>
      <w>13</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_packet_type</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1004</x>
      <y>1070</y>
      <w>2057</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_init
arp_packet_type</panel_attributes>
    <additional_attributes>10.0;10.0;20550.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3053</x>
      <y>1074</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_rcv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3043</x>
      <y>1081</y>
      <w>36</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.通过pskb_may_pull将arp头部，dev地址，ip地址
	的空间放到data段
2.硬件地址长度(ar_hln)要相同，dev的IFF_NOARP不能置上
	pkt_type不能是PACKET_OTHERHOST PACKET_LOOPBACK
	协议的长度(ar_pln)要是4
3.skb_share_check如果发送skb shared，通过skb_clone
	复制一份skb
4.通过memset将NEIGH_CB(skb)清0
5.net_filter之后，通过arp_process处理skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3058</x>
      <y>1077</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3050</x>
      <y>1099</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3056</x>
      <y>1095</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3032</x>
      <y>1107</y>
      <w>37</w>
      <h>62</h>
    </coordinates>
    <panel_attributes>1.in_dev要存在
2.检查硬件类型(ar_hrd)，以及协议(ar_pro)
3.ar_op要是ARPOP_REPLY或者ARPOP_REPLY
4.获取源dev地址 源ip 目的dev地址 目的ip
5.目的ip不能是回环地址和多播地址
6.如果设备类型是ARPHRD_DLCI，源dev设置为广播地址(最后回复的地址)
	sha = dev-&gt;broadcast
7.源ip为0(RFC2131用于检测地址冲突)
	1.如果是ARPOP_REQUEST，并且是本主机ip，arp_ignore检查到不能忽略
		以该ip为源ip和目标ip通过arp_send发送arp
	2.释放skb，并返回
8.如果ARPOP_REQUEST，并且ip_route_input能找到路由到tip(本地ip)
	1.neigh_event_ns更新sip neigh的状态机
	2.arp_ignore和arp_filter看是否接收arp
	3.如果需要发送arp，通过arp_send发送ARPOP_REPLY
	4.neigh_release释放neigh
	5.释放skb，并返回
9.如果设备支持转发(forwarding)
	1.如果RTCF_DNAT置上
		或者是单播，并且rt输出设备和输入设备不同，并且支持arp代理(arp_fwd_proxy,pneigh_lookup)
		1.neigh_event_ns创建并更新到sip的neigh
		2.如果找到neigh，通过neigh_release将neigh释放
		3.如果LOCALLY_ENQUEUED置上，或者skb的目的mac指向本机，或者proxy_delay为0
			表示arp是现在发送，通过arp_send向sip发送ARPOP_REPLY，最后释放skb
		4.如果arp要延时发送，通过pneigh_enqueue将skb链入到proxy_queue，并返回0
	注：该设备是网关，sip可以将报文发给这个网关，然后通过这个网关进行转发，所以这里直接发的是该网关的mac
10.根据__neigh_lookup在arp_tbl查询neigh，不能创建
11.如果允许不发送arp，却收到arp应答(单播)，通过
	__neigh_lookup创建neigh
注：如果本机发送了arp，那么通过之前的__neigh_lookup就一定能找到neigh
12.如果存在neigh(不管是收到ARPOP_REPLY还是ARPOP_REQUEST，这里都会更新本机的neigh)
	1.neigh的新状态被设置为NUD_REACHABLE
	2.如果更新没超过locktime，neigh不被覆盖
	3.如果不是ARPOP_REPLY，或者链接地址不是本机(PACKET_HOST)
		neigh的状态设置为NUD_STALE
	4.neigh_update更新neigh的状态
	5.neigh_release释放neigh
13.out：释放in_dev和skb，并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3054</x>
      <y>1102</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3016</x>
      <y>1172</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_ignore</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3012</x>
      <y>1179</y>
      <w>33</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.查看arp_ignore
	1.如果是0，不过滤该报文，接收该报文
	2.如果是1，目标ip是输入设备的本地地址
	3.如果是2，目标是本地地址，并且要和源ip在同一子网
	4.如果是3，目标是RT_SCOPE_LINK
	5.如果是8，不接受该报文
	6.其他则接收
2.通过inet_confirm_addr对源和目的地址进行确认
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3022</x>
      <y>1175</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3017</x>
      <y>1196</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_confirm_addr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3024</x>
      <y>1192</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3012</x>
      <y>1203</y>
      <w>33</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.首先通过confirm_addr_indev对接收的in_dev验证
	源和目的地址
2.遍历dev_baselianbiao ,confirm_addr_indev验证
	每个设备的源和目的地址，
3.如果成功，返回本地地址
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3024</x>
      <y>1199</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3020</x>
      <y>1215</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>confirm_addr_indev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3027</x>
      <y>1211</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3025</x>
      <y>1218</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3006</x>
      <y>1222</y>
      <w>36</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.local和dst要和ifa在同一网段，除非指定local或者没指定dst
2.返回比ifa_scope小的ifa_local
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3059</x>
      <y>1172</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_event_ns</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3048</x>
      <y>1179</y>
      <w>37</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过__neigh_lookup在tbl中查询到addr的neigh，如果链接地址
	存在或者不存在设备地址(!addr_len)，就创建
2.通过neigh_update更新neigh的状态为NUD_STALE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3064</x>
      <y>1175</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3021</x>
      <y>1168</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3048</x>
      <y>1168</y>
      <w>19</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1421</x>
      <y>661</y>
      <w>67</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1479</x>
      <y>666</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>n-&gt;output
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1484</x>
      <y>669</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_generic_ops
neigh-&gt;ops-&gt;connected_output</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1480</x>
      <y>674</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_connected_output</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1478</x>
      <y>681</y>
      <w>31</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.__skb_pull释放arp的头部
2.hard_header填充mac头部
3.如果填充成功，通过neigh-&gt;ops-&gt;queue_xmit
	发送skb，否则通过kfree_skb释放skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1487</x>
      <y>677</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1485</x>
      <y>699</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_queue_xmit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1483</x>
      <y>692</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh-&gt;ops-&gt;queue_xmit
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1490</x>
      <y>688</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1490</x>
      <y>695</y>
      <w>13</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_generic_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1226</x>
      <y>660</y>
      <w>38</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.遍历所有的hash_buckets
	1.如果neigh的计数refcnt等于1，并且neigh不在NUD_PERMANENT
		将neigh脱链，并释放
		注：neigh_alloc中将计数设置为1，如果没找到neigh_create将其计数增加1
			如果找到了会在neigh_lookup中递增其计数
		*np	= n-&gt;next;
		n-&gt;dead = 1;
		neigh_release(n);
2.tbl-&gt;last_flush = jiffies
3.返回是否回收过neigh
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1243</x>
      <y>656</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1234</x>
      <y>680</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1239</x>
      <y>676</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1234</x>
      <y>687</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_destroy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1239</x>
      <y>683</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
refcnt减至0</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1221</x>
      <y>694</y>
      <w>35</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果dead没置上，直接返回
2.neigh_del_timer删除neigh的闹钟
3.遍历neigh-&gt;hh
	1.hh-&gt;hh_output = neigh_blackhole;
	2.递减hh_refcnt，如果减到0，通过kfree释放
4.析构函数neigh_destructor释放
5.skb_queue_purge将arp_queue上的所有skb释放
6.释放索引
	dev_put(neigh-&gt;dev);
	neigh_parms_put(neigh-&gt;parms);
	atomic_dec(&amp;neigh-&gt;tbl-&gt;entries)
7.kmem_cache_free将neigh释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1238</x>
      <y>690</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1230</x>
      <y>717</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_del_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1235</x>
      <y>713</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1235</x>
      <y>720</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1226</x>
      <y>723</y>
      <w>22</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果处于NUD_IN_TIMER
	1.del_timer将timer释放
	2.neigh_release递减neigh计数
	3.返回1，表示删除过timer
2.返回0，表示不用删除timer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>981</x>
      <y>483</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_periodic_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>989</x>
      <y>479</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
gc_timer</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>974</x>
      <y>490</y>
      <w>34</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.如果超过了last_rand 300s
	1.更新last_rand
		tbl-&gt;last_rand = now
	2.遍历tbl-&gt;parms链表，neigh_rand_reach_time更新
		其p-&gt;reachable_time
2.hash_chain_gc记录下次要更新的hash_buckets
3.遍历当前要回收的hash_buckets
	1.如果处于NUD_PERMANENT或者NUD_IN_TIMER，遍历下一个
	2.used不能再confirmed之前
	3.neigh的计数refcnt为1，并且
		处于NUD_FAILED或者距上次使用超过gc_staletime
		1.脱链
			*np = n-&gt;next;
		2.释放
			n-&gt;dead = 1;
			neigh_release(n)
		3.continue继续下一个，这里注意neigh已经脱链
4.base_reachable_time的时间内要遍历一遍整个hash_buckets
5.mod_timer更新tbl-&gt;gc_timer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>988</x>
      <y>486</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3094</x>
      <y>1171</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_fwd_proxy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3099</x>
      <y>1174</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3088</x>
      <y>1178</y>
      <w>28</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.in_dev的proxy_arp权限存在
2.获取in_dev的medium_id，如果是0，返回1，允许代理
3.如果是-1，返回0，不允许代理
4.如果rt的out_dev的medium_id
5.out_dev的mediu_id和in_dev不同(不能是-1),
	返回1，允许代理
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3060</x>
      <y>1168</y>
      <w>40</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;380.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3128</x>
      <y>1170</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pneigh_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3061</x>
      <y>1167</y>
      <w>74</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;20.0;720.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3119</x>
      <y>1177</y>
      <w>35</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.计算hash_val(这里如果key_len不是4，hash可能不同)
2.遍历phash_buckets链表，对比key(dst_ip)和dev，如果
	相同，返回pneigh
3.如果creat没置上，直接返回NULL
4.通过kmalloc申请pneigh和key_len的长度
5.初始化pneigh，pkey是dst_ip
	memcpy(n-&gt;key, pkey, key_len);
	n-&gt;dev = dev;//dev_hold递增dev的计数
6.执行构造函数pconstructor
7.将pneigh添加到hash表
	n-&gt;next = tbl-&gt;phash_buckets[hash_val];
	tbl-&gt;phash_buckets[hash_val] = n;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3134</x>
      <y>1173</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>3168</x>
      <y>1169</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>pneigh_enqueue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3063</x>
      <y>1167</y>
      <w>113</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;20.0;1110.0;20.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>3173</x>
      <y>1172</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>3157</x>
      <y>1176</y>
      <w>36</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果tbl-&gt;proxy_queue.qlen超过了prama的限制proxy_qlen
	释放skb，并返回
2.设置下次调度skb的时间，并置上LOCALLY_ENQUEUED
	NEIGH_CB(skb)-&gt;sched_next = sched_next;
	NEIGH_CB(skb)-&gt;flags |= LOCALLY_ENQUEUED;
3.如果proxy_timer没超过sched_next，就用proxy_timer
4.dst_release递减dst的计数
	skb-&gt;dst = NULL;
5.dev_hold(skb-&gt;dev)
6.将skb加入到proxy_queue尾部，并设置proxy_timer
	__skb_queue_tail(&amp;tbl-&gt;proxy_queue, skb);
	mod_timer(&amp;tbl-&gt;proxy_timer, sched_next)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1013</x>
      <y>479</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
proxy_timer</panel_attributes>
    <additional_attributes>10.0;10.0;260.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1030</x>
      <y>483</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_proxy_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1018</x>
      <y>489</y>
      <w>39</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.遍历proxy_queue
	1.对于sched_next在now之前的skb
		1.通过__skb_unlink将skb从proxy_queue中脱链
		2.如果proxy_redo存在，并且netif_running，通过tbl-&gt;proxy_redo
			处理代理的skb
		3.如果1.1.2条件不成立，直接释放skb
		4.dev_put释放skb所在的dev
	2.sched_next记录最小没超过now的代理skb的发送时间
2.将proxy_timer设置为最小的代理skb发送时间sched_next
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1037</x>
      <y>486</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1029</x>
      <y>508</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tbl-&gt;proxy_redo
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1035</x>
      <y>504</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1034</x>
      <y>511</y>
      <w>7</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_tbl</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1029</x>
      <y>515</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>parp_redo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1034</x>
      <y>518</y>
      <w>19</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
向sip发送ARPOP_REPLY</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1029</x>
      <y>523</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_process</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2281</x>
      <y>683</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;hard_header_cache
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2288</x>
      <y>679</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2288</x>
      <y>686</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ether_setup
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2282</x>
      <y>690</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>eth_header_cache</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2272</x>
      <y>696</y>
      <w>34</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.使eth头部对其
2.网卡类型不能是ETH_P_802_3
3.设置hh_data的type，dst,src
	eth-&gt;h_proto = type;
	memcpy(eth-&gt;h_source, dev-&gt;dev_addr, dev-&gt;addr_len);
	memcpy(eth-&gt;h_dest, neigh-&gt;ha, dev-&gt;addr_len);neigh_hh_init
	hh-&gt;hh_len = ETH_HLEN;
4.返回0，表示成功填充
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2287</x>
      <y>693</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1386</x>
      <y>666</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh_update_hhs</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1392</x>
      <y>661</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>160.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1380</x>
      <y>672</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.获取header_cache_update
2.遍历neigh.hh链表，通过header_cache_update
	更新链表中的目标mac
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1391</x>
      <y>669</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1381</x>
      <y>680</y>
      <w>23</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh-&gt;dev-&gt;header_cache_update
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1392</x>
      <y>677</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1392</x>
      <y>683</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ether_setup</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1383</x>
      <y>687</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>eth_header_cache_update</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1381</x>
      <y>694</y>
      <w>23</w>
      <h>3</h>
    </coordinates>
    <panel_attributes>1.复制dst mac到hh_data(对齐)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1392</x>
      <y>690</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2097</x>
      <y>610</y>
      <w>29</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.复制数据到skb.data-hh_alen
2.skb_push更新data
3.hh-&gt;hh_output输出
注：1.次序锁类似读写锁，写的时候有spinlock
	读的时候不上锁，只读sequence，如果发现
	sequence不同，或者正在写，再次读
	2.如果这里dst mac没更新，这里发送的是广播地址
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2108</x>
      <y>606</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2103</x>
      <y>626</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>hh-&gt;hh_output
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2108</x>
      <y>622</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2108</x>
      <y>629</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_generic_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2103</x>
      <y>634</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_queue_xmit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2123</x>
      <y>1320</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dst-&gt;ops-&gt;update_pmtu
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2130</x>
      <y>1315</y>
      <w>37</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2128</x>
      <y>1323</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dst_alloc
ipv4_dst_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2121</x>
      <y>1327</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_rt_update_pmtu</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2112</x>
      <y>1334</y>
      <w>33</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.dst中的mtu超过了路径mtu，mtu超过68，并且dst_metric_locked检查其没锁上
	1.不能低于ip_rt_min_pmtu，如果低于ip_rt_min_pmtu，将mtu锁上
		dst-&gt;metrics[RTAX_LOCK-1] |= (1 &lt;&lt; RTAX_MTU)
	2.更新mtu
		dst-&gt;metrics[RTAX_MTU-1] = mtu;
	3.dst_set_expires设置rtable超时时间10min
	4.call_netevent_notifiers通知感兴趣的进程
		NETEVENT_PMTU_UPDATE
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2127</x>
      <y>1330</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2122</x>
      <y>1351</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dst_set_expires</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2128</x>
      <y>1347</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2109</x>
      <y>1358</y>
      <w>32</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.如果设置的时间在dst-&gt;expires之前，更新
	dst-&gt;expires = expires
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2126</x>
      <y>1354</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2140</x>
      <y>749</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2135</x>
      <y>754</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ptype-&gt;gso_send_check
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2142</x>
      <y>757</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ip_packet_type</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2184</x>
      <y>757</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ip_packet_type</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2136</x>
      <y>762</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_gso_send_check</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2177</x>
      <y>762</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_gso_segment</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1759</x>
      <y>406</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_fragment</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1764</x>
      <y>403</y>
      <w>59</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>570.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1742</x>
      <y>413</y>
      <w>37</w>
      <h>50</h>
    </coordinates>
    <panel_attributes>1.clear_all_retrans_hints清除所有的hint
2.新skb的head大小
	nsize = skb_headlen(skb) - len
3.如果skb_clone，并且不是linear，通过pskb_expand_head
	对数据区进行写时复制
4.sk_stream_alloc_skb申请skb，并初始化
	1.初始化长度
		sk_charge_skb(sk, buff);
		nlen = skb-&gt;len - len - nsize;
		buff-&gt;truesize += nlen;
		skb-&gt;truesize -= nlen;
	2.初始化seq
		TCP_SKB_CB(buff)-&gt;seq = TCP_SKB_CB(skb)-&gt;seq + len;
		TCP_SKB_CB(buff)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;end_seq;
		TCP_SKB_CB(skb)-&gt;end_seq = TCP_SKB_CB(buff)-&gt;seq;
	3.初始化flag
		flags = TCP_SKB_CB(skb)-&gt;flags;
		TCP_SKB_CB(skb)-&gt;flags = flags &amp; ~(TCPCB_FLAG_FIN|TCPCB_FLAG_PSH);
		TCP_SKB_CB(buff)-&gt;flags = flags;
		TCP_SKB_CB(buff)-&gt;sacked = TCP_SKB_CB(skb)-&gt;sacked;
		TCP_SKB_CB(skb)-&gt;sacked &amp;= ~TCPCB_AT_TAIL;
	4.重新计算skb和buff的csum
		buff-&gt;ip_summed = skb-&gt;ip_summed;
	5.设置时间戳
		TCP_SKB_CB(buff)-&gt;when = TCP_SKB_CB(skb)-&gt;when;
		buff-&gt;tstamp = skb-&gt;tstamp;
	6.tcp_set_skb_tso_segs设置分段信息
5.如果skb和buff已经被发送
	1.调整packets_out，sacked_out(包含reno)，retrans_out，lost_out，left_out，fackets_out
7.skb_header_release将data段释放
8.__skb_append将buff链接到skb之后
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1764</x>
      <y>409</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1975</x>
      <y>579</y>
      <w>37</w>
      <h>94</h>
    </coordinates>
    <panel_attributes>1.如果ip(IP_DF)和本地（!local_df）都不允许分段,
	通过icmp_send发送ICMP_DEST_UNREACH，并且释放skb
2.IPCB(skb)-&gt;flags |= IPSKB_FRAG_COMPLETE
3.如果存在frag_list，有可能机型快速分段
	1.以下情况需要慢速路径
		1.skb除了frag_list的部分(head+nr_frag)
			1.数据的长度不能大于mtu
			2.要8位对齐(因为不是最后一个分段)
			3.skb已经做了分段(IP_MF|IP_OFFSET)
			4.skb被clone
		2.frag_list部分
			1.数据长度不能大于mtu
			2.非最后一个frag，要对齐
			3.data段长度小于ip头部
			4.skb被共享
	2.对于每一个frag_list
		sock_hold(skb-&gt;sk);
		frag-&gt;sk = skb-&gt;sk;
		frag-&gt;destructor = sock_wfree;
			skb-&gt;truesize -= frag-&gt;truesize;
	3.重新设置skb，去除掉frag_list
		offset = 0;
		//取出frag_list
		frag = skb_shinfo(skb)-&gt;frag_list;
		skb_shinfo(skb)-&gt;frag_list = NULL;
		//设置len
		skb-&gt;data_len = first_len - skb_headlen(skb);
		skb-&gt;len = first_len;
		//设置iph
		iph-&gt;tot_len = htons(first_len);
		iph-&gt;frag_off = htons(IP_MF);
		ip_send_check(iph);
	4.循环分段发送skb
		1.如果存在frag
			1.设置第4，3层头
				frag-&gt;h.raw = frag-&gt;data;
				frag-&gt;nh.raw = __skb_push(frag, hlen);
				memcpy(frag-&gt;nh.raw, iph, hlen);
				iph = frag-&gt;nh.iph;
				iph-&gt;tot_len = htons(frag-&gt;len);
			2.ip_copy_metadata复制skb中的相关属性
			3.如果是第一个分段，通过ip_options_fragment将一些选项
				改成IPOPT_NOOP
			注：iph已经被更改成frag的
			4.更新数据的offset
				offset += skb-&gt;len - hlen;
				iph-&gt;frag_off = htons(offset&gt;&gt;3);
			5.如果不是最后一个frag
				iph-&gt;frag_off |= htons(IP_MF)
			6.ip_send_check设置checksum
		2.通过output将skb发送
		3.如果出错或者frag_list遍历完成，退出循环
		4.调整要发送的skb，和下一个frag
			skb = frag;
			frag = skb-&gt;next;
			skb-&gt;next = NULL;
	5.如果发送出错，将出错的frag全部释放
	6.返回err
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1996</x>
      <y>575</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>180.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2016</x>
      <y>579</y>
      <w>39</w>
      <h>53</h>
    </coordinates>
    <panel_attributes>1.遍历要分段的数据(left)
	1.分段的长度不能超过mtu，如果不是最后一个分段(len &lt; left),
		要对齐
		len &amp;= ~7
	2.alloc_skb申请skb，包好数据长度 ip头部长度 链接层头部长度
	3.ip_copy_metadata复制skb中的相关属性
	4.skb_reserve预留链接层头部长度
	5.设置ip头部，tcp头部
		skb_put(skb2, len + hlen);
		skb2-&gt;nh.raw = skb2-&gt;data;
		skb2-&gt;h.raw = skb2-&gt;data + hlen;
	6.skb_set_owner_w设置新的skb
	7.复制ip头部
		memcpy(skb2-&gt;nh.raw, skb-&gt;data, hlen)
	8.通过skb_copy_bits从ptr开始复制
	9.更新数据长度
		left -= len
	10.设置iph
		iph = skb2-&gt;nh.iph;
		iph-&gt;frag_off = htons((offset &gt;&gt; 3));
		注：frag_off有16位，绝对大于mtu，
			ip的totlen只有16字节，所以ip数据包最高只能有64k的长度
			所以不会出现offset溢出的情况
		iph-&gt;frag_off |= htons(IP_MF)//不是最后一个分段
		iph-&gt;tot_len = htons(len + hlen);
	11.第一个分段的ip选项已经复制，通过ip_options_fragment调整ip选项
	12.更新偏移
		ptr += len;
		offset += len;
	13.ip_send_check设置checksum
	14.output发送分段skb2
	15.释放skb，返回err
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2015</x>
      <y>575</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
slow_path</panel_attributes>
    <additional_attributes>10.0;10.0;130.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2165</x>
      <y>769</y>
      <w>44</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.gso_type不能是除了SKB_GSO_TCPV4 SKB_GSO_UDP SKB_GSO_DODGY SKB_GSO_TCP_ECN
	0之外的类型
2.pskb_may_pull将iph移到data段
注：skb_gso_segment会将mac先移出然后恢复
3.头部长度不能小于iph
4.通过pskb_may_pull将ip头部(包含ip选项)移到data
	skb-&gt;h.raw = __skb_pull(skb, ihl);
	iph = skb-&gt;nh.iph;
	id = ntohs(iph-&gt;id);
	proto = iph-&gt;protocol &amp; (MAX_INET_PROTOS - 1);
5.调用inet_protos[proto]的gso_segment进行分段
6.如果没分段，或者分段出错，直接返回
7.设置每个分段
	iph-&gt;id = htons(id++);
	iph-&gt;tot_len = htons(skb-&gt;len - skb-&gt;mac_len);
	iph-&gt;check = ip_fast_csum(skb-&gt;nh.raw, iph-&gt;ihl)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2184</x>
      <y>765</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2176</x>
      <y>799</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ops-&gt;gso_segment
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2181</x>
      <y>795</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2182</x>
      <y>802</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_protocol</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2176</x>
      <y>806</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_tso_segment</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2162</x>
      <y>813</y>
      <w>45</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.通过pskb_may_pull在将tcp首部放到data段
2.检查skb tcp首部长度
3.通过pskb_may_pull将tcp的首部(包括选项)放到data
4.__skb_pull移出tcp首部
5.如果硬件可以自己分段
	1.type要是SKB_GSO_TCPV4 SKB_GSO_TCPV6
	2.mss = skb_shinfo(skb)-&gt;gso_size;
		skb_shinfo(skb)-&gt;gso_segs = (skb-&gt;len + mss - 1) / mss;
		segs = NULL;
6.通过skb_segment进行分段
7.循环处理segs的th(两个skb一起循环)
	1.设置第一个skb的th
		1.将第一个skb的fin和push清掉
		2.计算第一个skb的check
	2.更新seq，并计算第二个skb的seq，重置cwr
注：1.fin和push存在最后一个skb中
	2.cwe存在首个skb中
8.计算最后一个skb的check
9.返回segs
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2181</x>
      <y>809</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2171</x>
      <y>848</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_segment</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2177</x>
      <y>844</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2157</x>
      <y>855</y>
      <w>47</w>
      <h>91</h>
    </coordinates>
    <panel_attributes>1.通过__skb_push将tcp ip mac首部恢复
2.循环将skb分段
	1.分段的长度不能超过skb.len mss
	2.确定hsize
		1.首部长度要全部在head，
		2.要复制的数据hsize不能超过len
		3.如果是不是聚合IO,所有的数据要在hsize中
	3.alloc_skb分配skb，head的空间包括hsize，首部长度(每个分段都有)
		已经填充(headroom)
	4.将新分配的skb放入到链表segs中
	5.复制skb的属性
		nskb-&gt;dev = skb-&gt;dev;
		nskb-&gt;priority = skb-&gt;priority;
		nskb-&gt;protocol = skb-&gt;protocol;
		nskb-&gt;dst = dst_clone(skb-&gt;dst);
		memcpy(nskb-&gt;cb, skb-&gt;cb, sizeof(skb-&gt;cb));
		nskb-&gt;pkt_type = skb-&gt;pkt_type;
		nskb-&gt;mac_len = skb-&gt;mac_len;
	6.skb_reserve填充(headroom)，复制首部，注意首部都在head中
		skb_reserve(nskb, headroom);
		nskb-&gt;mac.raw = nskb-&gt;data;
		nskb-&gt;nh.raw = nskb-&gt;data + skb-&gt;mac_len;
		nskb-&gt;h.raw = nskb-&gt;nh.raw + (skb-&gt;h.raw - skb-&gt;nh.raw);
		memcpy(skb_put(nskb, doffset), skb-&gt;data, doffset);//doffset因为1，所以绝对在head中
	7.如果不是聚合IO,通过skb_copy_and_csum_bits将数据复制到head中
		并计算nskb-&gt;csum，然后进行下一个分段
		注：这里continue应该需要执行while的offset更新
	8.复制hsize
		nskb-&gt;ip_summed = CHECKSUM_PARTIAL;
		nskb-&gt;csum = skb-&gt;csum;
		memcpy(skb_put(nskb, hsize), skb-&gt;data + offset, hsize);
	9.循环复制frags中len的长度
		1.将frags给nskb
			*frag = skb_shinfo(skb)-&gt;frags[i];//这里是值复制，不是指针复制
			get_page(frag-&gt;page);
		2.去除frags中被之前段取出的长度(因为在2.9.5中没更新pos)
		3.更新nksb frag的数量k
			k++
		4.如果整个frag都在len中
			i++;
			pos += size;
		5.如果只有部分frag在，将frag的长度更新(减去不在len范围内的长度)，并退出循环
			frag-&gt;size -= pos + size - (offset + len);
		6.更新下一个frag
			frag++
	10.更新nskb的frags
		skb_shinfo(nskb)-&gt;nr_frags = k;
		nskb-&gt;data_len = len - hsize;
		nskb-&gt;len += nskb-&gt;data_len;
		nskb-&gt;truesize += nskb-&gt;data_len;
	11.更新偏移量offset，并判断skb.len是否复制完成
3.返回segs
注：len表示skb要复制的数据长度
	offset表示线性skb复制到哪个seq
	hsize表示除头部外的head段的长度
	pos表示旧skb中的frags起始位置
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2175</x>
      <y>851</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1607</x>
      <y>467</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_copy_and_csum_bits</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1605</x>
      <y>462</y>
      <w>10</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;80.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1601</x>
      <y>473</y>
      <w>37</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>1.首先复制head
	1.csum_partial_copy_nocheck复制，并计算checksum
	2.如果len复制完成，直接返回checksum
	3.否则更新
		offset += copy;
		to     += copy;
		pos	= copy;
2.复制frags
	1.查看要复制的是否在frags内，如果在
		1.复制的长度不能超过要求的长度len
		2.csum_partial_copy_nocheck复制并计算当前frags的checksum
		3.csum_block_add合并之前的checksum
		4.如果len复制完成，返回checksum
		5.否则更新
			offset += copy;
			to     += copy;
			pos    += copy;
	2.调整start到下一个frags
3.复制frag_list
	1.看是否在frag_list所在的skb中
		1.要复制的长度不能超过len
		2.skb_copy_and_csum_bits递归复制并计算checksum，csum_block_add
			合并checksum
		3.如果len复制完成，返回checksum
		4.否则更新
			offset += copy;
			to     += copy;
			pos    += copy;
	2.调整start
4.返回checksum
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1615</x>
      <y>470</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2131</x>
      <y>769</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.检查ip头部
2.调用inet_protos[proto].gso_send_check
	检查tcp头部
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2142</x>
      <y>765</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2137</x>
      <y>779</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ops-&gt;gso_send_check
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2143</x>
      <y>775</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2137</x>
      <y>786</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>Use case 1</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2142</x>
      <y>782</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2128</x>
      <y>793</y>
      <w>24</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.pskb_may_pull将tcp首部放在head
2.计算check
3.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2141</x>
      <y>789</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1379</x>
      <y>404</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipfrag_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1092</x>
      <y>395</y>
      <w>294</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;2920.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1373</x>
      <y>411</y>
      <w>34</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.计算ipfrag_hash_rnd
2.设置ipfrag_secret_timer
	init_timer(&amp;ipfrag_secret_timer);
	ipfrag_secret_timer.function = ipfrag_secret_rebuild;
	ipfrag_secret_timer.expires = jiffies + sysctl_ipfrag_secret_interval;
	add_timer(&amp;ipfrag_secret_timer);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1384</x>
      <y>407</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1389</x>
      <y>422</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1384</x>
      <y>426</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipfrag_secret_rebuild</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1371</x>
      <y>433</y>
      <w>40</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.get_random_bytes重新计算ipfrag_hash_rnd
2.遍历所有的ipq_hash
	1.将hash表中的所有ipq从hlist_del从hash表中删除
	2.hlist_add_head将ipq加入到重新计算的hash中
注：不可能出现删了又加的可能，因为比较了新的hash hval和旧的hash i
3.mod_timer重新设置ipfrag_secret_timer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1390</x>
      <y>429</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1187</x>
      <y>1164</y>
      <w>45</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.如果ip_frag_mem超过了限值，通过ip_evictor进行垃圾回收
2.通过ip_find查询或者创建ipq，如果成功
	1.ip_frag_queue将skb加入到ipq的fragments链表
	2.如果第一个分段和最后一个分段都收到，并且ipq总长度和end相同
		通过ip_frag_reasm进行分段的组装
	3.ipq_put递减refcut(因为ip_find中递增了refcnt)
3.如果没找到ipq，或者创建失败，释放skb，并返回NULL
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1208</x>
      <y>1160</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1156</x>
      <y>1182</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_evictor</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1190</x>
      <y>1182</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_find</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1179</x>
      <y>1189</y>
      <w>38</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.遍历ipq_hash，看是否能找到id，src，dst,pro，user相同的
	ipq，如果能找到，就返回
2.否则通过ip_frag_create创建
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1195</x>
      <y>1185</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1189</x>
      <y>1198</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_frag_create</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1194</x>
      <y>1194</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1176</x>
      <y>1205</y>
      <w>41</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>1.通过frag_alloc_queue申请ipq
2.初始化ipq
	qp-&gt;protocol = iph-&gt;protocol;
	qp-&gt;last_in = 0;
	qp-&gt;id = iph-&gt;id;
	qp-&gt;saddr = iph-&gt;saddr;
	qp-&gt;daddr = iph-&gt;daddr;
	qp-&gt;user = user;
	qp-&gt;len = 0;
	qp-&gt;meat = 0;
	qp-&gt;fragments = NULL;
	qp-&gt;iif = 0;
	qp-&gt;peer = sysctl_ipfrag_max_dist ? inet_getpeer(iph-&gt;saddr, 1) : NULL;
3.初始化超时timer和spinlock
	init_timer(&amp;qp-&gt;timer);
	qp-&gt;timer.data = (unsigned long) qp;	/* pointer to queue	*/
	qp-&gt;timer.function = ip_expire;		/* expire function	*/
	
	spin_lock_init(&amp;qp-&gt;lock);
	atomic_set(&amp;qp-&gt;refcnt, 1);
4.ip_frag_intern将ipq插入到hash
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1194</x>
      <y>1201</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1087</x>
      <y>1243</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>frag_alloc_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1092</x>
      <y>1239</y>
      <w>91</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>890.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1084</x>
      <y>1249</y>
      <w>16</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过kmalloc申请ipq
2.递增ip_frag_mem
3.返回ipq
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1091</x>
      <y>1246</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1160</x>
      <y>1243</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_frag_intern</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1165</x>
      <y>1239</y>
      <w>22</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>200.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1148</x>
      <y>1249</y>
      <w>40</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.如果smp，在上锁之后，需要重新查看ipq_hash，如果存在，
	通过ipq_put将ipq释放
	qp_in-&gt;last_in |= COMPLETE;
	ipq_put(qp_in, NULL)
2.设置超时时间qp-&gt;timer，如果之前没被加入闹钟，递增qp-&gt;refcnt
3.加入hash表
	tomic_inc(&amp;qp-&gt;refcnt);
	hlist_add_head(&amp;qp-&gt;list, &amp;ipq_hash[hash]);
4.加入lru链表
	INIT_LIST_HEAD(&amp;qp-&gt;lru_list);
	list_add_tail(&amp;qp-&gt;lru_list, &amp;ipq_lru_list);
5.递增ip_frag_nqueues
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1165</x>
      <y>1246</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1241</x>
      <y>1183</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_frag_queue</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1234</x>
      <y>1190</y>
      <w>42</w>
      <h>79</h>
    </coordinates>
    <panel_attributes>1.如果last_in的COMPLETE置上，直接释放skb
2.如果skb没被本机的ip分段(!IPSKB_FRAG_COMPLETE),并且
	距之前的rid太长(ip_frag_too_far),并且ip_frag_reinit
	检查到ipq已经被回收，通过ipq_kill删除ipq的关系
3.如果是最后一个分段(!IP_MF)
	1.如果ipq.len超过了整体长度的end，或者有两个end(LAST_IN已经置上，但是end却不相等)
		释放skb，并返回
	2.记录线性skb的长度
		qp-&gt;last_in |= LAST_IN;
		qp-&gt;len = end;
4.如果不是最后一个分段
	1.如果没对齐，使end对齐，并重新设置
		skb-&gt;ip_summed = CHECKSUM_NONE
	2.如果线性长度超过了ipq.len
		1.如果ipq的LAST_IN已经置上，释放skb，并返回
		2.更新
			qp-&gt;len = end
5.如果没有任何数据(end==offset)，直接返回
6.通过pskb_pull将ip头部放到head，并移出data
7.通过pskb_trim_rcsum重新设置ip_summed，并通过__pskb_trim
	将len之后的data清除
8.遍历fragments链表(offset从小到大排列)，找到一个比当前offset大的skb
9.如果prev和skb有重叠的部分
	1.如果超过了现在skb的end，释放skb，并返回
	2.pskb_pull将重复部分放到head，并移出data
	3.skb-&gt;ip_summed = CHECKSUM_NONE
10.skb和next有重叠的部分
	1.如果重叠的部分小于next的长度
		1.通过pskb_pull将重叠的部分移出data
		2.FRAG_CB(next)-&gt;offset += i;
			qp-&gt;meat -= i;
		3.next-&gt;ip_summed = CHECKSUM_NONE
		4.退出循环
	2.如果大于next的长度
		1.将next从fragments链表中移出
		2.qp-&gt;meat -= free_it-&gt;len
		3.释放next，即free_it
11.更新skb的offset，并将其加入fragments链表
	FRAG_CB(skb)-&gt;offset = offset
12.qp-&gt;iif = skb-&gt;dev-&gt;ifindex
	skb-&gt;dev = NULL;
13.skb_get_timestamp给ipq打时间戳
14.meat表示没重叠的部分，也就是ipq的总长度，而ipq.len记录的是最后一个字节seq
	qp-&gt;meat += skb-&gt;len;
15.atomic_add(skb-&gt;truesize, &amp;ip_frag_mem);
16.如果是第一个分段
	qp-&gt;last_in |= FIRST_IN
17.list_move_tail将ipq加入到ipq_lru_list最后
18.返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1290</x>
      <y>1181</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_frag_reasm</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1277</x>
      <y>1188</y>
      <w>40</w>
      <h>69</h>
    </coordinates>
    <panel_attributes>1.ip报文的长度不能超过65535
注：ip_frag_queue中已经将ip头部移出ipq.len
2.通过pskb_expand_head做head的写时复制
3.如果head存在frag_list
	1.alloc_skb分配skb管理结构
	2.将clone加入到fragments链表
		clone-&gt;next = head-&gt;next;
		head-&gt;next = clone;
	3.将head的frag_list给到clone
		skb_shinfo(clone)-&gt;frag_list = skb_shinfo(head)-&gt;frag_list;
		skb_shinfo(head)-&gt;frag_list = NULL;
	4.更新clone和head的长度
		clone-&gt;len = clone-&gt;data_len = head-&gt;data_len - plen;
		head-&gt;data_len -= clone-&gt;len;
		head-&gt;len -= clone-&gt;len;
	5.更新clone的csum
		clone-&gt;csum = 0;
		clone-&gt;ip_summed = head-&gt;ip_summed;
	6.atomic_add(clone-&gt;truesize, &amp;ip_frag_mem);
4.将ipq中除head外的skb，作为head的frag_list
	skb_shinfo(head)-&gt;frag_list = head-&gt;next;
5.skb_push将head的ip首部恢复，并将head移出分段记录
	atomic_sub(head-&gt;truesize, &amp;ip_frag_mem);
6.遍历head分段链表
	1.更新head的len
		head-&gt;data_len += fp-&gt;len;
		head-&gt;len += fp-&gt;len;
		head-&gt;truesize += fp-&gt;truesize;
	2.如果ip_summed不同
		head-&gt;ip_summed = CHECKSUM_NONE
	3.如果都CHECKSUM_COMPLETE，通过csum_add计算head-&gt;csum
	4.移出分段记录
		atomic_sub(fp-&gt;truesize, &amp;ip_frag_mem)
7.释放head.next，并打时间戳
	head-&gt;next = NULL;
	head-&gt;dev = dev;
	skb_set_timestamp(head, &amp;qp-&gt;stamp);
8.清除分段信息
	iph-&gt;frag_off = 0;
	iph-&gt;tot_len = htons(len);
	qp-&gt;fragments = NULL;
9.返回head
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1245</x>
      <y>1186</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1294</x>
      <y>1184</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1160</x>
      <y>1176</y>
      <w>45</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>430.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1195</x>
      <y>1176</y>
      <w>10</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>80.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1204</x>
      <y>1176</y>
      <w>44</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1207</x>
      <y>1176</y>
      <w>90</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;880.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1224</x>
      <y>1273</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_frag_too_far</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1231</x>
      <y>1268</y>
      <w>11</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>90.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1210</x>
      <y>1279</y>
      <w>35</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.递增peer-&gt;rid
2.如果收到skb，并且读的id超过max，不可靠，返回1
注：这怎么防止大块数据传输过程中如果即被netif分段，
	又被ip分段的情况，就会存在id相同，src，dst相同，
	但是offset出现重合的情况
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1228</x>
      <y>1276</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1257</x>
      <y>1272</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_frag_reinit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1263</x>
      <y>1268</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1250</x>
      <y>1279</y>
      <w>37</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.重新设置垃圾回收时间sysctl_ipfrag_time，如果已经timeout
	递增refcnt，并返回refcnt
2.遍历fragments链表，并通过frag_kfree_skb释放skb
3.重置ipq
	qp-&gt;last_in = 0;
	qp-&gt;len = 0;
	qp-&gt;meat = 0;
	qp-&gt;fragments = NULL;
	qp-&gt;iif = 0;
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1262</x>
      <y>1275</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1198</x>
      <y>1242</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_expire</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1203</x>
      <y>1239</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1191</x>
      <y>1249</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.如果COMPLETE，通过ipq_put递减refcnt，并返回
2.ipq_kill删除ipq的关系
3.如果收到了第一个分段，并且qp-&gt;iif存在
	1.通过icmp_send发送ICMP_TIME_EXCEEDED
	2.dev_put释放head-&gt;dev
3.ipq_put递减refcnt,并返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1203</x>
      <y>1245</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1198</x>
      <y>1263</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipq_kill</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1203</x>
      <y>1259</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1175</x>
      <y>1270</y>
      <w>34</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.del_timer删除其垃圾回收的定时器，如果不在闹钟内
	递减refcnt
2.如果ipq没有COMPLETE
	1.通过ipq_unlink将其冲hash和lru链表中删除
	2.atomic_dec(&amp;ipq-&gt;refcnt);
		ipq-&gt;last_in |= COMPLETE;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1202</x>
      <y>1266</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1152</x>
      <y>1272</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipq_put</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1157</x>
      <y>1268</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1157</x>
      <y>1275</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果递减refcnt至0</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1151</x>
      <y>1279</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_frag_destroy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1143</x>
      <y>1286</y>
      <w>33</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.COMPLETE要置上
2.qp-&gt;timer已删除
3.inet_putpeer释放peer
4.释放fragments中的skb
5.frag_free_queue更新ip_frag_mem，并释放ipq
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1156</x>
      <y>1282</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1142</x>
      <y>1189</y>
      <w>33</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果ip_frag_mem没超过限制sysctl_ipfrag_low_thresh
	直接返回
2.清理ipq直到ip_frag_mem低于限值
	1.如果ipq_lru_list为空，直接返回
	2.不为空
		1.递增refcnt
		2.如果没有COMPLETE，ipq_kill释放其关系
		3.ipq_put递减refcnt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1161</x>
      <y>1185</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1337</x>
      <y>406</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>icmp_init</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1092</x>
      <y>394</y>
      <w>252</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;2500.0;120.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1329</x>
      <y>413</y>
      <w>37</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.sock_create_kern创建SOCK_RAW类型的socket
	sk-&gt;sk_allocation = GFP_ATOMIC
	sk-&gt;sk_sndbuf =
			(2 * ((64 * 1024) + sizeof(struct sk_buff)));
	inet-&gt;uc_ttl = -1;//默认，从dst中获取
	inet-&gt;pmtudisc = IP_PMTUDISC_DONT
2.sk-&gt;sk_prot-&gt;unhash防止数据收到
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1342</x>
      <y>409</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1337</x>
      <y>429</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;unhash
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1344</x>
      <y>425</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1343</x>
      <y>432</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
raw_prot</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1337</x>
      <y>436</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>raw_v4_unhash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1342</x>
      <y>439</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1329</x>
      <y>442</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过sk_del_node_init将sk_node从hash中删除
2.如果真的又被删除，通过sock_prot_dec_use
	递减sk_prot的计数
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1427</x>
      <y>1202</y>
      <w>744</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_init
icmp_protocol</panel_attributes>
    <additional_attributes>10.0;20.0;7420.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2163</x>
      <y>1205</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>icmp_rcv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2146</x>
      <y>1213</y>
      <w>46</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.检查checksum
	1.CHECKSUM_COMPLETE，csum_fold进行验证
	2.CHECKSUM_NONE，__skb_checksum_complete软件进行验证
2.pskb_pull将icmp头部移出data
3.icmph-&gt;type不能超过NR_ICMP_TYPES
4.如果是广播和多播
	1.如果忽略报文(sysctl_icmp_echo_ignore_broadcasts),但是icmp类型是
		ICMP_ECHO，或者ICMP_TIMESTAMP时，不做处理
	2.如果不是ICMP_ECHO ICMP_TIMESTAMP ICMP_ADDRESS ICMP_ADDRESSREPLY
		不做处理
5.递增icmp_pointers[icmph-&gt;type].input_entry
6.调用icmp_pointers[icmph-&gt;type].handler处理icmp报文
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2168</x>
      <y>1208</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2155</x>
      <y>1237</y>
      <w>25</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>icmp_pointers[icmph-&gt;type].handler
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2165</x>
      <y>1232</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2112</x>
      <y>1240</y>
      <w>53</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ICMP_DEST_UNREACH
ICMP_SOURCE_QUENCH
ICMP_TIME_EXCEEDED
ICMP_PARAMETERPROB</panel_attributes>
    <additional_attributes>510.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2107</x>
      <y>1245</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>icmp_unreach</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2091</x>
      <y>1252</y>
      <w>48</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.pskb_may_pull尝试将iph移到data，并检查ip头部
注：unreach的报文在icmp头部之后，会存在出错的ip报文头部(包括选项)
	+至少前8字节的数据
2.如果type是ICMP_DEST_UNREACH
	1.如果code是ICMP_FRAG_NEEDED
		1.如果没有禁止pmtu，通过ip_rt_frag_needed更新路由缓存项，并更新mtu
	2.如果超过了NR_ICMP_UNREACH，直接返回
3.如果是参数错误ICMP_PARAMETERPROB，获取指针
4.sysctl_icmp_ignore_bogus_error_responses忽略目的ip为广播地址的错误
5.pskb_may_pull将icmp所传的出错ip+数据放到head
6.如果能在raw_v4_htable中找到对应的raw_sk，通过raw_err处理
7.传给对应传输层处理inet_protos[hash].err_handler
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2111</x>
      <y>1248</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2055</x>
      <y>1277</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>raw_err</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2060</x>
      <y>1272</y>
      <w>41</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>390.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2159</x>
      <y>1277</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>inet_protos[hash].err_handler
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2110</x>
      <y>1272</y>
      <w>61</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;590.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2166</x>
      <y>1280</y>
      <w>10</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_protocol</panel_attributes>
    <additional_attributes>20.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2162</x>
      <y>1240</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ICMP_MIB_OUTREDIRECTS</panel_attributes>
    <additional_attributes>20.0;10.0;170.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2172</x>
      <y>1245</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>icmp_redirect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2157</x>
      <y>1252</y>
      <w>41</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.pskb_may_pull尝试将iph移到data，并检查ip头部
2.检查code，如果ICMP_REDIR_NET ICMP_REDIR_NETTOS
	ICMP_REDIR_HOST ICMP_REDIR_HOSTTOS，通过
	ip_rt_redirect做重定向
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2177</x>
      <y>1248</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2203</x>
      <y>1266</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_rt_redirect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2190</x>
      <y>1259</y>
      <w>21</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;190.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2241</x>
      <y>1245</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>icmp_echo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2170</x>
      <y>1240</y>
      <w>77</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ICMP_MIB_OUTECHOS</panel_attributes>
    <additional_attributes>10.0;10.0;750.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2232</x>
      <y>1252</y>
      <w>35</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.如果没设置sysctl_icmp_echo_ignore_all
	1.设置icmp_param
		icmp_param.data.icmph	   = *skb-&gt;h.icmph;
		icmp_param.data.icmph.type = ICMP_ECHOREPLY;
		icmp_param.skb		   = skb;
		icmp_param.offset	   = 0;
		icmp_param.data_len	   = skb-&gt;len;
		icmp_param.head_len	   = sizeof(struct icmphdr);
	2.icmp_reply发送响应
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2246</x>
      <y>1248</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2242</x>
      <y>1271</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>icmp_reply</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2247</x>
      <y>1267</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2228</x>
      <y>1278</y>
      <w>42</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.ip_options_echo保存ip选项
2.icmp_xmit_lock上锁
3.icmp_param-&gt;data.icmph.checksum = 0;
4.更新变量
	icmp_out_count(icmp_param-&gt;data.icmph.type);
5.设置tos和daddr
	inet-&gt;tos = skb-&gt;nh.iph-&gt;tos;
	daddr = ipc.addr = rt-&gt;rt_src;//如果是srr，即为第一跳地址faddr
	ipc.opt = NULL;
6.ip_route_output_key查找rtable
7.icmpv4_xrlim_allow安全检查
8.icmp_push_reply发送应答
9.释放rtable和锁
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2247</x>
      <y>1274</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2171</x>
      <y>1240</y>
      <w>116</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ICMP_TIMESTAMP</panel_attributes>
    <additional_attributes>10.0;10.0;1140.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2279</x>
      <y>1244</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>icmp_timestamp</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2283</x>
      <y>1247</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2270</x>
      <y>1251</y>
      <w>38</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.skb的长度不能小于4
2.do_gettimeofday获取时间戳
3.skb_copy_bits将时间戳覆盖icmp头部4字节？
4.icmp_param.data.icmph	   = *skb-&gt;h.icmph;
	icmp_param.data.icmph.type = ICMP_TIMESTAMPREPLY;
	icmp_param.data.icmph.code = 0;
	icmp_param.skb		   = skb;
	icmp_param.offset	   = 0;
	icmp_param.data_len	   = 0;
	icmp_param.head_len	   = sizeof(struct icmphdr) + 12
5.icmp_reply发送回复
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2769</x>
      <y>1175</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>icmp_send</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2774</x>
      <y>1170</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2747</x>
      <y>1182</y>
      <w>41</w>
      <h>64</h>
    </coordinates>
    <panel_attributes>1.如果接收的skb的iph检查没通过，不做处理
2.如果skb的目的不是本机(PACKET_HOST)，不做处理
3.如果是广播或者多播路由，不做处理
4.如果有分段，不做处理
5.如果是发的是error
	1.如果接收的是icmp
		1.skb_header_pointer返回接收icmp type所在的位置
		2.检查接收icmp的type，不能超过NR_ICMP_TYPES，并且不能是error
6.icmp_xmit_lock上锁
7.选择src
	1.默认为iph的dst
	2.如果不是RTCF_LOCAL
		1.如果sysctl_icmp_errors_use_inbound_ifaddr，通过inet_select_addr
			选择寻址范围是RT_SCOPE_LINK的src
		2.否则src为0
8.确定tos
	1.如果发送icmp error，以iph.tos为基础调整
	3.否则就为iph.tos
9.ip_options_echo解析存储ip选项
10.设置icmp_param
	icmp_param.data.icmph.type	 = type;
	icmp_param.data.icmph.code	 = code;
	icmp_param.data.icmph.un.gateway = info;
	icmp_param.data.icmph.checksum	 = 0;
	icmp_param.skb	  = skb_in;
	icmp_param.offset = skb_in-&gt;nh.raw - skb_in-&gt;data;
11.更新内部变量
	icmp_out_count(icmp_param.data.icmph.type);
	inet_sk(icmp_socket-&gt;sk)-&gt;tos = tos;
12.准备输出参数
	ipc.addr = iph-&gt;saddr;
	ipc.opt = &amp;icmp_param.replyopts;
13.通过ip_route_output_key查找到源地址的路由
注：如果是ssr，源地址是保存的第一跳的地址，否则为iph.saddr
14.icmpv4_xrlim_allow做安全检查
15.根据mtu设置icmp_param.data_len(ip~end的长度)和
	icmp_param.head_len = sizeof(struct icmphdr)
16.icmp_push_reply发送应答
17.释放路由rt和锁后，返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2773</x>
      <y>1178</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2706</x>
      <y>1249</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_options_echo</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2691</x>
      <y>1256</y>
      <w>34</w>
      <h>24</h>
    </coordinates>
    <panel_attributes>1.初始化dopt
	memset(dopt, 0, sizeof(struct ip_options))
	dopt-&gt;is_data = 1
2.如果没有sopt，返回0
	dopt-&gt;optlen = 0
3.选择目的地址
	1.如果skb-&gt;dst，daddr为rt_spec_dst，
		这个是在ip_route_input_slow中验证source时被设置
	2.否则直接为iph中的daddr
4.如果需要记录addr(sopt-&gt;rr)
5.设置时间戳(sopt-&gt;ts)
6.设置strict route(sopt-&gt;srr)
7.设置sopt-&gt;cipso
8.最后设置IPOPT_END
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2710</x>
      <y>1252</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2712</x>
      <y>1245</y>
      <w>43</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>410.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2772</x>
      <y>1249</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>icmp_push_reply</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2776</x>
      <y>1245</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2766</x>
      <y>1256</y>
      <w>38</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过ip_append_data创建发送的skb，并添加到发送队列
	如果失败，通过ip_flush_pending_frames释放资源
2.如果成功，取出icmp_socket上的skb，通过csum_partial_copy_nocheck
	复制skb并计算checksum
3.通过ip_push_pending_frames输出
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2779</x>
      <y>1252</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2730</x>
      <y>1270</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_append_data</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2791</x>
      <y>1269</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_flush_pending_frames</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2829</x>
      <y>1268</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_push_pending_frames</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2734</x>
      <y>1265</y>
      <w>51</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
icmp_glue_bits</panel_attributes>
    <additional_attributes>490.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2786</x>
      <y>1265</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;120.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2796</x>
      <y>1265</y>
      <w>42</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;400.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2785</x>
      <y>1276</y>
      <w>32</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.__skb_dequeue_tail从链表后面取出skb，并释放
2.inet-&gt;cork.flags &amp;= ~IPCORK_OPT;
3.释放inet-&gt;cork.opt
	kfree(inet-&gt;cork.opt);
	inet-&gt;cork.opt = NULL;
4.释放inet-&gt;cork.rt
	ip_rt_put(inet-&gt;cork.rt);
		inet-&gt;cork.rt = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2800</x>
      <y>1272</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2687</x>
      <y>1283</y>
      <w>43</w>
      <h>46</h>
    </coordinates>
    <panel_attributes>1.如果是探测报文(MSG_PROBE)，直接返回0
2.如果队列sk_write_queue为空
	1.复制选项和源地址
		memcpy(inet-&gt;cork.opt, opt, sizeof(struct ip_options)+opt-&gt;optlen);
		inet-&gt;cork.flags |= IPCORK_OPT;
		inet-&gt;cork.addr = ipc-&gt;addr;
	2.设置分片，路由及初始化
		dst_hold(&amp;rt-&gt;u.dst);
		inet-&gt;cork.fragsize = mtu = dst_mtu(rt-&gt;u.dst.path);
		inet-&gt;cork.rt = rt;
		inet-&gt;cork.length = 0;
		sk-&gt;sk_sndmsg_page = NULL;
		sk-&gt;sk_sndmsg_off = 0;
	3.如果有header_len，调整icmp头部长度transhdrlen，以及（data（包含ip头部）+头部长度）length
4.如果不为空，取之前的路由，选项，mtu
	rt = inet-&gt;cork.rt;
	opt = inet-&gt;cork.opt;
	transhdrlen = 0;
	exthdrlen = 0;
	mtu = inet-&gt;cork.fragsize;
5.如果长度超过了65535，通过ip_local_error，同胞错误，并返回EMSGSIZE
6.如果是第一段(transhdrlen),长度低于mtu，底层要求做checksum(NETIF_F_ALL_CSUM)
	并且没exthdrlen，
		csummode = CHECKSUM_PARTIAL
7.更新数据的长度
	inet-&gt;cork.length += length;
8.如果udp数据长度超过了mtu，并且设备要求分段(NETIF_F_UFO)
	通过ip_ufo_append_data进行分段和添加
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2705</x>
      <y>1273</y>
      <w>32</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>300.0;10.0;240.0;70.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2666</x>
      <y>1331</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_icmp_error
ip_local_error</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2655</x>
      <y>1339</y>
      <w>37</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.以inet_sock方式解析sk
注：sk是inet_sock的头部
2.如果不允许接收错误信息(!inet-&gt;recverr)，返回
3.通过skb_clone复制一个skb
4.填写skb.cb,以sock_exterr_skb方式解析
	serr-&gt;ee.ee_errno = err;
	serr-&gt;ee.ee_origin = SO_EE_ORIGIN_ICMP;
	serr-&gt;ee.ee_type = skb-&gt;h.icmph-&gt;type; 
	serr-&gt;ee.ee_code = skb-&gt;h.icmph-&gt;code;
	serr-&gt;ee.ee_pad = 0;
	serr-&gt;ee.ee_info = info;
	serr-&gt;ee.ee_data = 0;
	serr-&gt;addr_offset = (u8*)&amp;(((struct iphdr*)(skb-&gt;h.icmph+1))-&gt;daddr) - skb-&gt;nh.raw;
	serr-&gt;port = port;
5.指向传输层的头
	skb-&gt;h.raw = payload
6.利用skb_pull将skb的data指针指向payload，并更新len
注：skb_pull释放数据
7.通过sock_queue_err_skb将其加入传输控制块的错误队列
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2672</x>
      <y>1334</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2668</x>
      <y>1375</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_queue_err_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2674</x>
      <y>1370</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2656</x>
      <y>1383</y>
      <w>36</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.sk_rmem_alloc+truesize不能超过sk的sk_rcvbuf
2.skb_set_owner_r设置skb
3.将skb加入到sk_error_queue的队尾
4.如果sk的SOCK_DEAD没置上，sk_data_ready通知sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2674</x>
      <y>1378</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2662</x>
      <y>1395</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_set_owner_r</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2667</x>
      <y>1391</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2652</x>
      <y>1402</y>
      <w>23</w>
      <h>10</h>
    </coordinates>
    <panel_attributes> //设置skb
skb-&gt;sk = sk;
skb-&gt;destructor = sock_rfree;
 //设置sk_rmem_alloc
 sk_rmem_alloc+=skb-&gt;truesize
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2666</x>
      <y>1398</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2671</x>
      <y>1328</y>
      <w>37</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>350.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2711</x>
      <y>1332</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_ufo_append_data</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2717</x>
      <y>1328</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2735</x>
      <y>1273</y>
      <w>14</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
普通添加数据</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2735</x>
      <y>1281</y>
      <w>49</w>
      <h>125</h>
    </coordinates>
    <panel_attributes>1.通过skb_peek_tail发现没有skb在sk_write_queue，跳到alloc_new_skb
2.循环添加数据
	1.如果skb中剩余的长度低于要添加的长度
		copy = maxfraglen - skb-&gt;len//maxfraglen是mtu对齐的
	2.alloc_new_skb：如果skb内没有剩余的空间
		1.如果链表之前的skb超过了maxfraglen，计算其差异fraggap
		2.设置此次添加的数据datalen
			1.默认为
				datalen = length + fraggap
			2.和ip头部加起来不能大于mtu
			3.本次添加的数据
				fraglen = datalen + fragheaderlen
		3.如果之后还会加添数据(MSG_MORE),并且底层不支持NETIF_F_SG
			申请skb的长度是mtu，否则为要添加的fraglen
		4.如果要发送的长度低于mtu，表示有足够的空间，alloclen的长度还要加上trailer_len
		5.如果是第一个分段，通过sock_alloc_send_skb申请skb
		6.否则写的限制(sk_wmem_alloc)没超过2*sk_sndbuf,通过sock_wmalloc申请skb
		7.初始化skb checksum和预留链接层头部
			skb-&gt;ip_summed = csummode;
			skb-&gt;csum = 0;
			skb_reserve(skb, hh_len);
			data = skb_put(skb, fraglen);//ip+数据空间
			skb-&gt;nh.raw = data + exthdrlen;//ip头部位置，ip前面是exthdrlen
			data += fragheaderlen;
			skb-&gt;h.raw = data + exthdrlen;//icmp，udp头部位置
		8.如果之前skb有超过mtu的(fraggap)
			1.skb_copy_and_csum_bits复制fraggap到data + transhdrlen(udp，icmp数据区)
			注：transhdrlen之前已经加上了exthdrlen
			2.prev_skb的checksum
			3.更新data
				data += fraggap;
			3.pskb_trim_unique将maxfraglen之后的空间清空
		9.通过getfrag复制skb_in数据到data，并计算checksum
		注：1.ip_append_data中并没有设置icmp首部，是在icmp_push_reply中设置的
			2.from中存储skb_in，skb_in中的offset，第3个参数offset表示已经复制的offset
		10.更新循环变量
			offset += copy;
			length -= datalen - fraggap;
			transhdrlen = 0;
			exthdrlen = 0;
			csummode = CHECKSUM_NONE;
		11.__skb_queue_tail将skb挂入到sk_write_queue
		12.继续复制数据
	3.copy不能大于length(之前不是检查过吗？)
	4.如果不允许聚合IO(!NETIF_F_SG),通过getfrag复制并计算checksum
		如果失败，通过__skb_trim将复制的清掉，跳到error
	5.如果有聚合IO
		1.如果page存在，且page内存在空闲的空间
			1.复制的长度不能超过剩余的空间
			2.如果sk_sndmsg_page的page和frag指向的page不一致
				1.frag不能超过MAX_SKB_FRAGS
				2.重新添加frag，指向page，及offset
					get_page(page);
	 				skb_fill_page_desc(skb, i, page, sk-&gt;sk_sndmsg_off, 0);
					frag = &amp;skb_shinfo(skb)-&gt;frags[i];
		注：sk_sndmsg_page记录最后一个page，sk_sndmsg_off记录在page中的offset
		2.如果需要新申请page
			1.复制长度不能高于PAGE_SIZE
			2.alloc_pages申请page
				sk-&gt;sk_sndmsg_page = page;
				sk-&gt;sk_sndmsg_off = 0;
			3.填充frag
				skb_fill_page_desc(skb, i, page, 0, 0);
				frag = &amp;skb_shinfo(skb)-&gt;frags[i];
			4.更新计数
				skb-&gt;truesize += PAGE_SIZE;
				atomic_add(PAGE_SIZE, &amp;sk-&gt;sk_wmem_alloc);
		3.如果申请page量超过MAX_SKB_FRAGS，返回EMSGSIZE
		4.通过icmp_glue_bits复制数据并计算checksum
		5.更新skb的计数
			sk-&gt;sk_sndmsg_off += copy;
			frag-&gt;size += copy;
			skb-&gt;len += copy;
			skb-&gt;data_len += copy;
	6.更新循环计算
		offset += copy;
		length -= copy;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2747</x>
      <y>1417</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>icmp_glue_bits</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2732</x>
      <y>1423</y>
      <w>43</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.skb_copy_and_csum_bits复制skb中的数据到to，并计算checksum
2.skb-&gt;csum = csum_block_add
3.如果发送的icmp是错误，nf_ct_attach
4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2750</x>
      <y>1420</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2752</x>
      <y>1410</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>getfrag
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2756</x>
      <y>1405</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2754</x>
      <y>1413</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2820</x>
      <y>1275</y>
      <w>45</w>
      <h>82</h>
    </coordinates>
    <panel_attributes>1.通过__skb_dequeue从sk_write_queue中取出第一个skb，tail_skb
	指向其frag_list
2.__skb_pull使data指向ip头部
3.再次通过__skb_dequeue循环取出sk_write_queue将之后的skb取出
	1.__skb_pull将data指向udp，icmp首部
	注：通过ip_append_data可知，只有第一个skb有exthdrlen，之后的都没有
	2.将skb挂入到frag_list链表中
		*tail_skb = tmp_skb;
		tail_skb = &amp;(tmp_skb-&gt;next);
	3.更新skb
		skb-&gt;len += tmp_skb-&gt;len;
		skb-&gt;data_len += tmp_skb-&gt;len;
		skb-&gt;truesize += tmp_skb-&gt;truesize;
	4.释放temp_skb
		__sock_put(tmp_skb-&gt;sk);
		tmp_skb-&gt;destructor = NULL;
		tmp_skb-&gt;sk = NULL;
4.分段
	1.如果IP_PMTUDISC_DO没置上，需要将skb-&gt;local_df = 1
	注：IP_PMTUDISC_DO表示不允许分段
	2.如果IP_PMTUDISC_DO置上，或者skb的长度低于mtu并且ip_dont_fragment
		检测到不用分段
		df = htons(IP_DF)
5.如果有选项IPCORK_OPT，通过ip_options_build构建ip选项，
	iph-&gt;ihl += opt-&gt;optlen&gt;&gt;2
6.设置ttl，iph-&gt;ttl 
	1.如果是RTN_MULTICAST，选择mc_ttl
	2.其他通过ip_select_ttl设置ttl
7.设置iph
	iph-&gt;version = 4;
	iph-&gt;ihl = 5;
	iph-&gt;tos = inet-&gt;tos;
	iph-&gt;tot_len = htons(skb-&gt;len);
	iph-&gt;frag_off = df;
	ip_select_ident(iph, &amp;rt-&gt;u.dst, sk);//设置id
	iph-&gt;protocol = sk-&gt;sk_protocol;
	iph-&gt;saddr = rt-&gt;rt_src;
	iph-&gt;daddr = rt-&gt;rt_dst;
	ip_send_check(iph);//设置checksum
8.设置skb
	skb-&gt;priority = sk-&gt;sk_priority;
	skb-&gt;dst = dst_clone(&amp;rt-&gt;u.dst);
9.net_filter之后，通过dst_output发送skb
10.out:
	1.清除选项
		inet-&gt;cork.flags &amp;= ~IPCORK_OPT;
		kfree(inet-&gt;cork.opt);
		inet-&gt;cork.opt = NULL;
	2.释放rt
		ip_rt_put(inet-&gt;cork.rt);
		inet-&gt;cork.rt = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2838</x>
      <y>1271</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2815</x>
      <y>1361</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_dont_fragment</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2821</x>
      <y>1356</y>
      <w>7</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2820</x>
      <y>1364</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2803</x>
      <y>1368</y>
      <w>37</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.不允许分段的IP_PMTUDISC_DO标志置上
2.或者处于IP_PMTUDISC_WANT，但是还没达到最小的mtu
注：IP_PMTUDISC_WANT表示只有最小的mtu才允许分段
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2848</x>
      <y>1361</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_select_ttl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2843</x>
      <y>1356</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;110.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2843</x>
      <y>1368</y>
      <w>21</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.默认是inet-&gt;uc_ttl
2.如果值小于0，获取dst中的ttl
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2854</x>
      <y>1364</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2089</x>
      <y>1278</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_rt_frag_needed</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2096</x>
      <y>1272</y>
      <w>9</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>70.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2077</x>
      <y>1285</y>
      <w>39</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.如果不用做pmtu(no_pmtu_disc),返回0
2.根据出错的iph的头部，找到响应的rth，并且其mtu没到最小(!dst_metric_locked)
	1.以icmp头部中返回的mtu作为默认值
	2.如果mtu小于68，或者高于之前的mtu
		1.guess_mtu找到比old_mtu稍小一点的mtu
		注：如果得到的mtu为0，以old_mtu-iph头部为旧mtu
	3.如果低于现存的mtu
		1.通过dst_confirm更新neigh-&gt;confirmed
		2.不能低于ip_rt_min_pmtu，如果低于，则锁住
			rth-&gt;u.dst.metrics[RTAX_LOCK-1] |=
								(1 &lt;&lt; RTAX_MTU)
		3.更新缓存
			rth-&gt;u.dst.metrics[RTAX_MTU-1] = mtu;
		4.dst_set_expires设置dst-&gt;expires
	5.返回新得到的mtu
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2094</x>
      <y>1281</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1252</x>
      <y>729</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>neigh-&gt;ops-&gt;error_report
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1259</x>
      <y>724</y>
      <w>25</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>230.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1254</x>
      <y>738</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>arp_error_report</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1258</x>
      <y>732</y>
      <w>13</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
arp_generic_ops
arp_direct_ops
arp_broken_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1240</x>
      <y>741</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1235</x>
      <y>745</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dst_link_failure</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1256</x>
      <y>746</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>kfree_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1260</x>
      <y>741</y>
      <w>8</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
释放skb</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1240</x>
      <y>748</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1232</x>
      <y>752</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dst-&gt;ops-&gt;link_failure
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1239</x>
      <y>755</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ipv4_dst_ops</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1234</x>
      <y>759</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipv4_link_failure</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1225</x>
      <y>766</y>
      <w>33</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.通过icmp_send发送ICMP_DEST_UNREACH
2.通过dst_set_expires设置dst-&gt;expires，timeout为0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1239</x>
      <y>762</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2020</x>
      <y>784</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rt_garbage_collect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1984</x>
      <y>780</y>
      <w>44</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;420.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2023</x>
      <y>835</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rt_may_expire</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2011</x>
      <y>842</y>
      <w>38</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.__refcnt如果存在，返回0，表示不能回收
2.超时expires，返回1，表示需要回收
3.如果age超过了tmo1（和多播或者广播的情况下有其他的rtable等同）
	并且age超过tmo2(和redirect和notified的情况下没设置超时等同)
	返回1，表示需要回收
注：age = jiffies - rth-&gt;u.dst.lastuse//距上次使用的时间
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2028</x>
      <y>838</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2015</x>
      <y>791</y>
      <w>35</w>
      <h>41</h>
    </coordinates>
    <panel_attributes>1.如果距上次处理时间没超过ip_rt_gc_min_interval，只有在
	rt的数量超过了限值ip_rt_max_size，才做处理
2.确定回收的数目goal，和剩余的rt equilibrium
3.如果距上次回收超过了ip_rt_gc_min_interval，更新计时
	last_gc = now;
4.如果不要求回收，跳到work_done
5.从rover处遍历hash表
	1.通过rt_may_expire查看rtable是否需要回收
	2.如果不需要，缩小广播所需的tmo，进一步的遍历
		tmo &gt;&gt;= 1;
	3.如果需要，将rt释放
		rt_free(rth);
		goal--;
	4.当前hash遍历完后，如果完成了goal，跳出循环
6.rover = k;
7.如果完成了goal，跳到work_done
8.如果expire减到0，不做处理，跳到12
9.expire &gt;&gt;= 1
10.如果rt的数量低于ip_rt_max_size，跳到out
11.只有不在in_softirq，或者没有超过1 tick，才能继续回收
12.再次检查rt是否低于ip_rt_max_size，跳到out
13.返回1，表示没有任何空闲的rtable供申请
14.workdone：
	1.调整expire
	2.返回0，表示有供申请的rtable
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2027</x>
      <y>787</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2028</x>
      <y>831</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1106</x>
      <y>414</y>
      <w>46</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1143</x>
      <y>420</y>
      <w>35</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>init_timer(&amp;rt_flush_timer);
rt_flush_timer.function = rt_run_flush;

init_timer(&amp;rt_periodic_timer);
rt_periodic_timer.function = rt_check_expire;
add_timer(&amp;rt_periodic_timer);//在ip_rt_gc_interval~2ip_rt_gc_interval之间，防止timer的集中处理

init_timer(&amp;rt_secret_timer);
rt_secret_timer.function = rt_secret_rebuild;
add_timer(&amp;rt_secret_timer)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1158</x>
      <y>441</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rt_check_expire</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1165</x>
      <y>436</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1158</x>
      <y>448</y>
      <w>45</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.获取上一次遍历的bucket rover
2.确定需要回收的bucket的数目goal
3.从rover+1遍历hash表rt_hash_table，直到goal回收完
	1.如果有expires，但是没有超时，递减广播需要的tmo，并继续遍历hash表
		tmo &gt;&gt;= 1
	2.如果没设置expires，rt_may_expire检查是否需要将rtable过期，如果不需要过期
		递减tmo &gt;&gt;= 1，继续遍历hash表
	3.rt_free 释放rtable，并继续遍历
	4.如果期间产生了时间中断，退出循环
4.存储rover，并修改时钟rt_periodic_timer为ip_rt_gc_interval
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1163</x>
      <y>444</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1174</x>
      <y>469</y>
      <w>9</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rt_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1177</x>
      <y>465</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1161</x>
      <y>476</y>
      <w>22</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.multipath_remove移除多路路由
2.call_rcu_bh调用dst_rcu_free
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1178</x>
      <y>472</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1169</x>
      <y>484</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dst_rcu_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1176</x>
      <y>480</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1168</x>
      <y>490</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dst_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1173</x>
      <y>487</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1161</x>
      <y>496</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.obsolete大于1，直接返回
2.如果没有引用__refcnt，通过dst_destroy将其释放
3.如果还有子dst，通过__dst_free设置定时器回收dst
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1173</x>
      <y>493</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1155</x>
      <y>505</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dst_destroy</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1161</x>
      <y>501</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>150.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1151</x>
      <y>512</y>
      <w>28</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果dst存在缓存hh，通过atomic_dec_and_test
	递减hh_refcnt计数，如果减到0，将其释放
2.释放neigh
	dst-&gt;neighbour = NULL;
	neigh_release(neigh);
3.递减dst的计数
	atomic_dec(&amp;dst-&gt;ops-&gt;entries)
4.dst-&gt;ops-&gt;destroy销毁dst
5.dev_put释放dst.dev
6.kmem_cache_free释放dst的空间
7.释放dst-&gt;child的引用，如果没被完全释放
	即返回，设置定时器释放(nohash)
	否则重新跳到1，继续释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1160</x>
      <y>508</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1185</x>
      <y>505</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__dst_free</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1190</x>
      <y>501</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1182</x>
      <y>512</y>
      <w>34</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.___dst_free设置dst-&gt;obsolete = 2，
	在dev没有或者没打开的情况下
	dst-&gt;input = dst_discard_in;
	dst-&gt;output = dst_discard_out;
2.dst加入到dst_garbage_list链表
3.dst_gc_timer_inc超过了0.5s
	dst_gc_timer_inc = DST_GC_INC;
	dst_gc_timer_expires = DST_GC_MIN;
	mod_timer(&amp;dst_gc_timer, jiffies + dst_gc_timer_expires)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1191</x>
      <y>508</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1191</x>
      <y>531</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dst_run_gc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1194</x>
      <y>527</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
dst_gc_timer</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1180</x>
      <y>538</y>
      <w>31</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.如果被锁住，重新设置0.1s的定时，并返回
2.暂时删除dst_gc_timer
3.遍历dst_garbage_list
	1.dst的引用__refcnt不能有
	2.dst_destroy销毁dst
	3.如果obsolete&lt;=1，___dst_free设置obsolete
		后，将其重新加入链表
4.如果链表全部处理完，设置dst_gc_timer_inc
	并返回
5.如果有过销毁
	dst_gc_timer_inc = DST_GC_INC;
	dst_gc_timer_expires = DST_GC_MIN;
	否则，增加时间间隔
	dst_gc_timer_expires += dst_gc_timer_inc
	dst_gc_timer_inc += DST_GC_INC
6.设置闹钟dst_gc_timer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1196</x>
      <y>534</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1209</x>
      <y>441</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rt_secret_rebuild</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1170</x>
      <y>436</y>
      <w>47</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;450.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1205</x>
      <y>448</y>
      <w>33</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.通过rt_cache_flush进行刷写（最小delay进行刷新）
2.重新定时rt_secret_timer为ip_rt_secret_interval
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1213</x>
      <y>444</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1213</x>
      <y>455</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rt_cache_flush</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1217</x>
      <y>451</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1217</x>
      <y>458</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1204</x>
      <y>462</y>
      <w>41</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.如果delay&lt;0，以ip_rt_min_delay进行刷新
2.multipath_flush进行多路路由刷新
3.如果rt_flush_timer已经被定时，并且不是立即刷新(delay&gt;0)
	rt_deadline又被设置(说明有任务等待刷新)
	1.上一个任务最多还有(rt_deadline - now)时间超时
	2.如果不在中断，这个超时时间没有超过ip_rt_max_delay-ip_rt_min_delay
		tmo=0
	3.delay不能超过上一次tmo
4.如果delay设置为0，rt_run_flush立即刷新，并返回
5.rt_deadline被设置为不能超过ip_rt_max_delay
	rt_deadline = now + ip_rt_max_delay.
6.rt_flush_timer被设置delay时间进行刷新
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1215</x>
      <y>486</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rt_run_flush</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1221</x>
      <y>482</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1211</x>
      <y>493</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.遍历整个hash表rt_run_flush
	1.将rtable链表取出
	2.通过rt_free释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1220</x>
      <y>489</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2193</x>
      <y>1273</y>
      <w>34</w>
      <h>69</h>
    </coordinates>
    <panel_attributes>1.以下情况不做处理
	1.没有in_device
	2.新旧网关相同
	3.in_device不支持重定向
	4.新网关是多播，广播，无效地址
	5.在不是share_media的情况下
		1.新旧网关不在同一条链路上
		2.如果启用secure_redict,ip_fib_check_default检查到新网关不可达
	6.在启用share_media的情况下，新网关不是单播(RTN_UNICAST)
2.两重遍历，条件由紧到宽（src完全相同，0）（dev完全相同，0）
	1.查找hash表内有没有完全一致的rtable
	2.如果找到了，通过dst_alloc分配rtable
	3.初始化rt
		*rt = *rth;//拷贝
		INIT_RCU_HEAD(&amp;rt-&gt;u.dst.rcu_head);
		rt-&gt;u.dst.__use		= 1;
		atomic_set(&amp;rt-&gt;u.dst.__refcnt, 1);
		dev_hold(rt-&gt;u.dst.dev)
		rt-&gt;u.dst.child		= NULL;
		rt-&gt;u.dst.obsolete	= 0;
		rt-&gt;u.dst.lastuse	= jiffies;
		rt-&gt;u.dst.path		= &amp;rt-&gt;u.dst;
		rt-&gt;u.dst.neighbour	= NULL;
		rt-&gt;u.dst.hh		= NULL;
		rt-&gt;u.dst.xfrm		= NULL;
		
		rt-&gt;rt_flags		|= RTCF_REDIRECTED;
		rt-&gt;rt_gateway		= new_gw;
	4.dst_confirm通知neigh
	5.atomic_inc(&amp;rt-&gt;peer-&gt;refcnt)
	6.arp_bind_neighbour绑定neigh，
		1.如果不处于NUD_VALID，
			1.通过neigh_event_send发送arp
			2.说明原来的rt还没加入到hash，所以将rt和rth都释放
				然后继续查找
				ip_rt_put(rth);
				rt_drop(rt);
	7.call_netevent_notifiers通知感兴趣的进程
	8.rt_del将rth从hash中删除
	9.rt_intern_hash将rt加入到hash
	10.继续查找其他的rtable
3.reject_redirect，in_dev_put释放in_device
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2208</x>
      <y>1269</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2204</x>
      <y>1345</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>rt_del</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2199</x>
      <y>1352</y>
      <w>28</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.ip_rt_put递减rt的refcnt计数
2.查找rt_hash_table，将其从hash表中删除
	并通过rt_free试图释放rt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2209</x>
      <y>1348</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2208</x>
      <y>1341</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>879</x>
      <y>1175</y>
      <w>44</w>
      <h>55</h>
    </coordinates>
    <panel_attributes>1.以下条件会返回EINVAL
	1.没有in_device
	2.src为多播，badclass,回环地址，或者不是ip，返回EINVAL
	3.如果src是ZERONET
		1.daddr要是LOCAL_MCAST，就通过inet_select_addr给其选择一个
			RT_SCOPE_LINK范围的路由目的项
	4.fib_validate_source验证源地址的有效性
2.dst_alloc申请rtable
	rth-&gt;u.dst.output= ip_rt_bug;
	atomic_set(&amp;rth-&gt;u.dst.__refcnt, 1);
	rth-&gt;u.dst.flags= DST_HOST;
	rth-&gt;u.dst.flags |= DST_NOPOLICY;//no_policy
	rth-&gt;fl.fl4_dst	= daddr;
	rth-&gt;rt_dst	= daddr;
	rth-&gt;fl.fl4_tos	= tos;
	rth-&gt;fl.mark    = skb-&gt;mark;
	rth-&gt;fl.fl4_src	= saddr;
	rth-&gt;rt_src	= saddr;
	rth-&gt;rt_iif	=
	rth-&gt;fl.iif	= dev-&gt;ifindex;
	rth-&gt;u.dst.dev	= &amp;loopback_dev;
	dev_hold(rth-&gt;u.dst.dev);
	rth-&gt;idev	= in_dev_get(rth-&gt;u.dst.dev);
	rth-&gt;fl.oif	= 0;
	rth-&gt;rt_gateway	= daddr;
	rth-&gt;rt_spec_dst= spec_dst;
	rth-&gt;rt_type	= RTN_MULTICAST;
	rth-&gt;rt_flags	= RTCF_MULTICAST;
	//our，本地
	rth-&gt;u.dst.input= ip_local_deliver;
	rth-&gt;rt_flags |= RTCF_LOCAL;
	//不是本地，in_device支持mc_forwarding
	rth-&gt;u.dst.input = ip_mr_input;
3.rt_intern_hash将rtable放到hash中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>901</x>
      <y>1171</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1281</x>
      <y>112</y>
      <w>17</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ipv4_rcv_saddr_equal</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1276</x>
      <y>116</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_get_port</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1275</x>
      <y>123</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__udp_lib_get_port</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1281</x>
      <y>119</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
udp_hash</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1259</x>
      <y>130</y>
      <w>43</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果没指定port
	1.port_rover为port查找的起始点，要在sysctl_local_port_range[0]~sysctl_local_port_range[1]
	2.遍历hash表
		1.如果其中有empty的bucket，即找到，但是result要在范围内
		2.如果没有，就找其中size最短的bucket
	3.如果是找的最短的，需要通过__udp_lib_lport_inuse检查hash表中没有相同的port
		如果没找到，返回1，表示error
	4.如果找到port，
		*port_rover = snum = result
2.如果有指定port，检查hash表bucket内看是否有冲突的sk，如果有，返回1，表示error
3.inet_sk(sk)-&gt;num = snum;
4.如果sk没被hash，通过sk_add_node将sk加入到hash表，并增加sk-&gt;sk_prot
	计数，最后返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1280</x>
      <y>126</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2285</x>
      <y>92</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_lib_close</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2262</x>
      <y>89</y>
      <w>31</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
udp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;290.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2282</x>
      <y>99</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk_common_release</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2289</x>
      <y>95</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2274</x>
      <y>106</y>
      <w>38</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.sk-&gt;sk_prot-&gt;destroy释放sk的frame
2.sk-&gt;sk_prot-&gt;unhash将sk脱离hash
3.sock_orphan设置sk的状态为SOCK_DEAD
4.xfrm_sk_free_policy进行安全检查
5.sock_put释放sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2289</x>
      <y>102</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2283</x>
      <y>118</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;destroy
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2289</x>
      <y>114</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2288</x>
      <y>121</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2281</x>
      <y>125</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_destroy_sock</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2285</x>
      <y>128</y>
      <w>4</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2275</x>
      <y>131</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_flush_pending_frames</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2272</x>
      <y>138</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果有数据没被处理up-&gt;pending
	1.up-&gt;len = 0;
		up-&gt;pending = 0;
	2.ip_flush_pending_frames将发送队列上的skb释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2283</x>
      <y>134</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2278</x>
      <y>149</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_flush_pending_frames</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2287</x>
      <y>145</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2276</x>
      <y>156</y>
      <w>35</w>
      <h>15</h>
    </coordinates>
    <panel_attributes>1.__skb_dequeue_tail将skb从sk_write_queue中取下
	并通过kfree_skb释放
2.释放选项
	inet-&gt;cork.flags &amp;= ~IPCORK_OPT;
	kfree(inet-&gt;cork.opt);
	inet-&gt;cork.opt = NULL;
3.释放rt
	ip_rt_put(inet-&gt;cork.rt);
	inet-&gt;cork.rt = NULL;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2286</x>
      <y>152</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2306</x>
      <y>118</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;unhash
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2310</x>
      <y>114</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2306</x>
      <y>125</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_lib_unhash</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2312</x>
      <y>121</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2306</x>
      <y>132</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.sk_del_node_init将sk从hash表中删除，并通过
	__sock_put递减sk的计数
2.如果又被删除
	inet_sk(sk)-&gt;num = 0;
	sock_prot_dec_use(sk-&gt;sk_prot)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2310</x>
      <y>128</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1489</x>
      <y>59</y>
      <w>42</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果是AF_UNSPEC，通过sk-&gt;sk_prot-&gt;disconnect断开链接
2.如果没有绑定port(!inet_sk(sk)-&gt;num),通过inet_autobind自动绑定port
3.sk-&gt;sk_prot-&gt;connect链接目的端
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1497</x>
      <y>55</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1504</x>
      <y>68</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;connect
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1512</x>
      <y>64</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1509</x>
      <y>75</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip4_datagram_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1514</x>
      <y>71</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
udp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1499</x>
      <y>81</y>
      <w>45</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.目的地址长度要满足要求
2.family要是AF_INET
3.如果是多播地址
	1.如果没指定输出设备，inet-&gt;mc_index
	2.如果没指定源地址，inet-&gt;mc_addr
3.ip_route_connect查找路由
4.如果路由是RTCF_BROADCAST，但是sk不支持广播，释放rt，并返回EACCES
5.如果没指定inet-&gt;saddr，或者inet-&gt;rcv_saddr
	inet-&gt;saddr = rt-&gt;rt_src
	inet-&gt;rcv_saddr = rt-&gt;rt_src
6.设置sk
	net-&gt;daddr = rt-&gt;rt_dst;
	inet-&gt;dport = usin-&gt;sin_port;
	sk-&gt;sk_state = TCP_ESTABLISHED;
	inet-&gt;id = jiffies;
7.sk_dst_set设置新的rtable
8.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1516</x>
      <y>78</y>
      <w>6</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1530</x>
      <y>112</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_route_connect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1534</x>
      <y>108</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1527</x>
      <y>119</y>
      <w>42</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.如果没指定src或者dst，通过__ip_route_output_key查找rtable
2.然后通过ip_route_output_flow进行安全检查
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1535</x>
      <y>115</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1540</x>
      <y>67</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;disconnect
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1525</x>
      <y>64</y>
      <w>26</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;240.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1550</x>
      <y>70</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
udp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1546</x>
      <y>81</y>
      <w>31</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.重置sk
	sk-&gt;sk_state = TCP_CLOSE;
	inet-&gt;daddr = 0;
	inet-&gt;dport = 0;
	sk-&gt;sk_bound_dev_if = 0;
2.如果SOCK_BINDADDR_LOCK没锁住，通过
	inet_reset_saddr重置saddr，rcv_saddr
3.如果SOCK_BINDPORT_LOCK没锁住
	sk-&gt;sk_prot-&gt;unhash(sk);
	inet-&gt;sport = 0;
4.sk_dst_reset重置dst
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1545</x>
      <y>74</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_disconnect</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1551</x>
      <y>77</y>
      <w>6</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;40.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1661</x>
      <y>133</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1662</x>
      <y>126</y>
      <w>93</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
udp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;910.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1746</x>
      <y>133</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_sendmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1710</x>
      <y>141</y>
      <w>45</w>
      <h>67</h>
    </coordinates>
    <panel_attributes>1.长度不能超过0xFFFF，否则返回EMSGSIZE
2.不能有带外数据MSG_OOB，否则返回EOPNOTSUPP
3.如果其他进程正在添加数据(up-&gt;pending)
	1.如果不是AF_INET，返回EINVAL
	2.如果是AF_INET，直接用pending的rt，跳到do_append_data添加data
4.如果设置了msg_name
	1.将msg_name解析为addr，如果长度不对，返回EINVAL
	2.family要正确
	3.daddr = usin-&gt;sin_addr.s_addr;
		dport = usin-&gt;sin_port;
	4.如果目的port是0，返回EINVAL
5.如果没设置msg_name
	1.sk状态要在TCP_ESTABLISHED
	2.daddr = inet-&gt;daddr;
		dport = inet-&gt;dport;
		connected = 1;
6.如果有msg_controllen
	1.通过ip_cmsg_send将其放置到ipc.opt
	2.如果存在opt，free=1
	3.connected = 0;
7.如果ipc.opt不存在，
	ipc.opt = inet-&gt;opt
8.如果需要严格路由srr
	1.daddr要存在
	2.第一跳地址ipc.opt-&gt;faddr
	3.connected = 0
9.如果是localRoute dontRoute srtictRoute
	tos |= RTO_ONLINK;
	connected = 0;
10.如果是多播
	1.如果没设置oif
		ipc.oif = inet-&gt;mc_index;
	2.如果没设置saddr
		saddr = inet-&gt;mc_addr;
	3.connected = 0;
11.如果connect存在，需要通过sk_dst_check验证sk的rtable
12.如果验证没通过
	1.通过ip_route_output_flow重新查找路由
	2.如果rt是广播，sk支持广播
	3.如果是connected，sk_dst_set设置新的rtable
13.如果msg的MSG_CONFIRM置上，跳到do_confirm
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1727</x>
      <y>136</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1758</x>
      <y>141</y>
      <w>38</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>1.back_from_confirm
	1.如果之前没设置daddr
		daddr = ipc.addr = rt-&gt;rt_dst
	2.如果锁上之后，发现pending，返回EINVAL
	3.inet-&gt;cork.fl.fl4_dst = daddr;
		inet-&gt;cork.fl.fl_ip_dport = dport;
		inet-&gt;cork.fl.fl4_src = saddr;
		inet-&gt;cork.fl.fl_ip_sport = inet-&gt;sport;
		up-&gt;pending = AF_INET;
2.do_append_data
	1.up-&gt;len += ulen;
	2.确定复制的方法getfrag
	3.ip_append_data将数据复制到sk_write_queue
	4.如果出错，udp_flush_pending_frames将发送队列中的skb
		全部释放
	5.如果没有更多的数据要发送(!corkreq),通过
		udp_push_pending_frames将其发送
	6.如果sk_write_queue为空
		up-&gt;pending = 0;
	注：以上三种情况都会将pending清掉，
3.out
	1.ip_rt_put释放rt
	2.如果msg有设置ipc.opt，通过kfree将其释放
	3.返回err
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1752</x>
      <y>136</y>
      <w>20</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;180.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1799</x>
      <y>141</y>
      <w>32</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.通过dst_confirm更新neigh的confirm
2.如果有更多msg，或者msg还没复制，跳到back_from_confirm
3.否则，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1752</x>
      <y>136</y>
      <w>67</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
do_confirm</panel_attributes>
    <additional_attributes>10.0;10.0;650.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2026</x>
      <y>129</y>
      <w>127</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
udp_prot</panel_attributes>
    <additional_attributes>10.0;20.0;1250.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2144</x>
      <y>132</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_recvmsg</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2130</x>
      <y>139</y>
      <w>47</w>
      <h>39</h>
    </coordinates>
    <panel_attributes>1.如果有addr_len，返回地址的长度
2.如果有MSG_ERRQUEUE，ip_recv_error接收错误报文
3.try_again
	1.skb_recv_datagram接收skb
	2.要复制的长度不能超过skb的长度(减去udp首部长度)
		msg-&gt;msg_flags |= MSG_TRUNC
	3.如果不需要考虑checksum，通过skb_copy_datagram_iovec复制到msg
		否则通过skb_copy_and_csum_datagram_iovec复制
	注：不考虑checksum条件
		1.CHECKSUM_UNNECESSARY
		2.is_udplite或MSG_TRUNC情况下，__udp_lib_checksum_complete检查checksum正确
	注：如果checksum检查错误
		1.skb_kill_datagram检查skb，如果是peek，将其从链表中删除，并free
		2.如果不需要block，返回EAGAIN
		3.如果需要block，跳到try_again，重新遍历
	4.sock_recv_timestamp打时间戳
	5.如果要求复制地址
		sin-&gt;sin_family = AF_INET;
		sin-&gt;sin_port = skb-&gt;h.uh-&gt;source;
		sin-&gt;sin_addr.s_addr = skb-&gt;nh.iph-&gt;saddr;
		memset(sin-&gt;sin_zero, 0, sizeof(sin-&gt;sin_zero));
	6.如果要求获取控制信息，通过ip_cmsg_recv获取
	7.释放skb
	8.返回复制的长度
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2150</x>
      <y>135</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2126</x>
      <y>182</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_recv_error</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2132</x>
      <y>185</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2121</x>
      <y>225</y>
      <w>20</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_copy_datagram_iovec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2129</x>
      <y>228</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2117</x>
      <y>232</y>
      <w>42</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.利用memcpy_toiovec首先复制skb_headlen部分
	不包含nr_frags，frag_list）
2.遍历nr_frags，通过memcpy_toiovec复制vaddr + frag-&gt;page_offset +offset - start
	到iovec，直到len复制完成，或者复制出错，或者frags遍历完成
3.遍历frag_list，递归使用skb_copy_datagram_iovec
	遍历list中的skb，直到len复制完成，或者复制出错，或者frag_list遍历完成
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2128</x>
      <y>245</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>memcpy_toiovec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2133</x>
      <y>248</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2120</x>
      <y>252</y>
      <w>32</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.iov_len表示iov_base空闲的空间
2.如果iov_base中有空闲空间，通过copy_to_user
	向iov_base复制数据
3.如果iov_base复制满了之后换下一个iov，直到len复制完成
	或者copy_to_user出错
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2133</x>
      <y>241</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2111</x>
      <y>190</y>
      <w>42</w>
      <h>32</h>
    </coordinates>
    <panel_attributes>1.如果想复制的长度len超过了skb的长度copied
	msg-&gt;msg_flags |= MSG_TRUNC;
	copied = len;
2.通过skb_copy_datagram_iovec将skb中的内容复制到msg.msg_iov中
3.通过sock_recv_timestamp获取skb的时间戳复制到
	msg_control中（如果SOCK_RCVTSTAMP置上，否则复制到sk.sk_stamp）
4.在msgname中存储出错报文的
	sin-&gt;sin_family
	sin-&gt;sin_addr.s_addr //目的地址
	sin-&gt;sin_port//目的端口
5.获取出错报文信息放到msg.msg_control
	1.如果是icmp，将源地址复制到msg的control中
		sin-&gt;sin_family = AF_INET;
		sin-&gt;sin_addr.s_addr = skb-&gt;nh.iph-&gt;saddr;
		sin-&gt;sin_port = 0;
	2.如果进一步要求控制报文cmsg_flags，通过ip_cmsg_recv获取
6.msg-&gt;msg_flags |= MSG_ERRQUEUE
7.检查sk_error_queue，不为空，通过sk-&gt;sk_error_report唤醒
	等待传输的进程
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2130</x>
      <y>221</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2130</x>
      <y>177</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2158</x>
      <y>182</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>skb_recv_datagram</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2164</x>
      <y>177</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2155</x>
      <y>190</y>
      <w>34</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.检查sk_err是否有错，如果有，返回NULL
2.循环获取skb
	1.如果MSG_PEEK置上
		1.通过skb_peek获取skb，并递增skb.users
	2.否则通过skb_dequeue在sk_receive_queue获取skb
	3.如果有skb，即返回
	4.如果没有timeo，返回NULL
	5.否则通过wait_for_packet等待skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2166</x>
      <y>185</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2163</x>
      <y>207</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>wait_for_packet</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2168</x>
      <y>203</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2160</x>
      <y>214</y>
      <w>38</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.设置wait挂入到sk_sleep
2.如果有sk_err，返回1
3.如果sk_receive_queue不为空，直接退出
4.如果RCV_SHUTDOWN，返回1
5.如果sk是connect的，但是sk的状态不在TCP_ESTABLISHED
	或者TCP_LISTEN，返回1
6.如果signal_pending，根据timo返回
7.schedule_timeout等待
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2168</x>
      <y>210</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1428</x>
      <y>1201</y>
      <w>995</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_init
udp_protocol</panel_attributes>
    <additional_attributes>10.0;30.0;9930.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2415</x>
      <y>1202</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_rcv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2415</x>
      <y>1210</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__udp4_lib_rcv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2420</x>
      <y>1205</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2370</x>
      <y>1218</y>
      <w>48</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.通过pskb_may_pull将udp头部移到head
2.头部中标识的总长度ulen，不能超过skb.len
3.如果是轻量级udp
	1.总长度不能小于头部长度
	2.pskb_trim_rcsum将之后的数据清空不能出错
	3.udp4_csum_init进行checksum初始化
4.否则直接通过udp4_csum_init进行初始化
5.如果是广播或者多播，通过__udp4_lib_mcast_deliver处理
6.通过__udp4_lib_lookup查找最符合条件的sk
7.如果找到了sk
	1.通过udp_queue_rcv_skb将skb保存到队列
	2.sock_put释放sk
	3.如果大于0，表示需要重新提交，否则返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2393</x>
      <y>1213</y>
      <w>30</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>280.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2344</x>
      <y>1244</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__udp4_lib_mcast_deliver</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2381</x>
      <y>1245</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__udp4_lib_lookup</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2370</x>
      <y>1253</y>
      <w>40</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.根据hash找到hash表中对应的bucket
	1.dport要一致(inet-&gt;num)
	2.不能是ipv6_only_sock
	3.找出最大的score
		1.PF_INET +1
		2.rcv_saddr(daddr)相同，+2
		2.saddr相同，+2
		3.sport相同，+2
		4.sk_bound_dev_if相同，+2
		注：如果是0，才能继续比较，否则如果不同，不做score的比较
	4.如果所有都相同，返回sk，否则记录score最大的sk
2.如果找到了sk，通过sock_hold递增其计数
3.返回sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2387</x>
      <y>1248</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2420</x>
      <y>1218</y>
      <w>35</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.通过xfrm4_policy_check进行安全检查
2.nf_reset释放skb内nf相关
3.udp_lib_checksum_complete检查到checksum错误，报错
4.icmp_send发送ICMP_DEST_UNREACH
5.释放skb，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2421</x>
      <y>1213</y>
      <w>12</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
如果没找到sk</panel_attributes>
    <additional_attributes>10.0;10.0;100.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2418</x>
      <y>1244</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_queue_rcv_skb</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2387</x>
      <y>1239</y>
      <w>5</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>30.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2409</x>
      <y>1239</y>
      <w>18</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2412</x>
      <y>1252</y>
      <w>40</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.xfrm4_policy_check进行安全检查
2.nf_reset释放skb内nf相关
3.如果是封装(encap_type)
	1.通过udp_encap_rcv接收
	2.如果返回0，表示错误，释放skb
	3.如果小于0，表示需要重新提交，经安全检查之后，返回-ret
4.如果是udp_lite
	1.pcrlen不能为0
	2.cscov不能小于pcrlen
5.__udp_lib_checksum_complete检查checksum
6.sock_queue_rcv_skb将skb加入到sk_receive_queue，
	并通知sk_data_ready，如果出错，则释放skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2425</x>
      <y>1247</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2353</x>
      <y>1239</y>
      <w>32</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2327</x>
      <y>1251</y>
      <w>40</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.根据dport在hash表中找到对应的bucket
2.udp_v4_mcast_next在bucket中找到第一个适合的sk
3.如果找到了对应的sk
	1.通过udp_v4_mcast_next找到下一个符合条件的sk
	2.如果存在sknext，通过skb_clone拷贝skb
	3.通过udp_queue_rcv_skb将skb挂入到接收队列
		如果出错，释放skb
	4.如果存在下一个skb，继续遍历下一个
4.如果没找到sk，释放skb
5.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2350</x>
      <y>1247</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2425</x>
      <y>1277</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_encap_rcv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2430</x>
      <y>1272</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2413</x>
      <y>1284</y>
      <w>43</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.skb长度小于udp首部长度，返回1，表示继续通过udp的协议接收
2.如果不是封装，返回1
3.如果pskb_may_pull将udp头部和舒服移到head，出错，返回1
4.查看封装类型encap_type
	1.UDP_ENCAP_ESPINUDP
		1.数据长度是1的话，不能是ff，否则返回0，skb不被接收
		2.数据长度超过了ip_esp_hdr，udpdata32不是0
			len = sizeof(struct udphdr)
		3.否则返回1
	2.UDP_ENCAP_ESPINUDP_NON_IKE
		1.数据长度是1的话，不能是ff，否则返回0，skb不被接收
		2.数据长度超过了ip_esp_hdr +2个32字节数据
			len = sizeof(struct udphdr) + 2 * sizeof(u32)
		3.否则返回1
5.通过pskb_expand_head做skb的写时复制
6.调整
	iph-&gt;tot_len = htons(ntohs(iph-&gt;tot_len) - len)
7.skb的长度不能小于ip+废弃的len，否则返回0
8.指向esp
	skb-&gt;h.raw = skb_pull(skb, len)
9.iph-&gt;protocol = IPPROTO_ESP;
10.返回-1，表示重新提交
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2430</x>
      <y>1280</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2338</x>
      <y>1272</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>udp_v4_mcast_next</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2345</x>
      <y>1268</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2325</x>
      <y>1279</y>
      <w>36</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.遍历bucket链表
	1.inet-&gt;num要一致
	2.peer的地址要相同(或者为0)
	3.peer的port要相同(或者没指定)
	4.rcv_saddr没指定或者相同（loc_addr应该是广播地址）
	5.不能是ipv6
	7.sk_bound_dev_if如果指定了，要相同
	8.ip_mc_sf_allow检测通过(返回1)
2.如果满足即返回sk
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2342</x>
      <y>1275</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2333</x>
      <y>1298</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_sf_allow</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2339</x>
      <y>1294</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2323</x>
      <y>1305</y>
      <w>40</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果不是多播，返回1，表示检查通过
2.遍历链表inet-&gt;mc_list
	1.广播地址s_addr相同
	2.输入设备相同
3.如果没有找到，返回1
4.如果找到了
	1.如果没有pmc-&gt;sflist，其sfmode要是MCAST_EXCLUDE
	2.在sflist中查找peer ip
		1.如果MCAST_INCLUDE，需要在这个数组中
		2.如果是MCAST_EXCLUDE，不能在这个数组中
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2337</x>
      <y>1301</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1683</x>
      <y>251</y>
      <w>182</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;1680.0;40.0;1800.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>851</x>
      <y>1170</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_check_mc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>839</x>
      <y>1177</y>
      <w>38</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.遍历in_dev的mc_list链表，如果有im.multiaddr的地址
	和dst的组播地址mc_addr相同，跳出循环
2.如果找到im，
	1.IPPROTO_IGMP，返回1表示check通过
	2.如果有源地址src_addr
		1.遍历组播im的sources链表，如果找到其源地址，即找到psf
		2.如果找到了psf，检查通过条件
			1.sf_count[MCAST_INCLUDE]（在saddr是psf规定的地址）
			2.psf的sf_count[MCAST_EXCLUDE]和im的sfcount[MCAST_EXCLUDE]不等
				(im-&gt;sfcount[MCAST_EXCLUDE]中记录的是不在乎源的socket，这里不相等
				说明有不在乎的源地址的socket)
		3.如果没找到psf，检查通过条件
			im-&gt;sfcount[MCAST_EXCLUDE] != 0（addr不是im排除地址）
	3.如果没有源地址，检查通过
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>855</x>
      <y>1173</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>858</x>
      <y>1160</y>
      <w>123</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1210.0;10.0;10.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1278</x>
      <y>1134</y>
      <w>1633</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ip_route_input_mc</panel_attributes>
    <additional_attributes>10.0;30.0;16310.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2903</x>
      <y>1135</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mr_input</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2392</x>
      <y>35</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2387</x>
      <y>39</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock-&gt;ops-&gt;setsockopt
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2393</x>
      <y>42</y>
      <w>14</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_stream_ops
inet_dgram_ops</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2389</x>
      <y>46</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sk-&gt;sk_prot-&gt;setsockopt
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2395</x>
      <y>49</y>
      <w>8</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
tcp_prot</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2391</x>
      <y>53</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>tcp_setsockopt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2364</x>
      <y>58</y>
      <w>21</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>icsk-&gt;icsk_af_ops-&gt;setsockopt
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2370</x>
      <y>56</y>
      <w>28</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>260.0;10.0;10.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2416</x>
      <y>59</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_tcp_setsockopt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2398</x>
      <y>56</y>
      <w>27</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SOL_TCP</panel_attributes>
    <additional_attributes>10.0;10.0;250.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2374</x>
      <y>61</y>
      <w>11</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ipv4_specific</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2369</x>
      <y>65</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_setsockopt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2374</x>
      <y>68</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2370</x>
      <y>73</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>do_ip_setsockopt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2377</x>
      <y>83</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mroute_setsockopt</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2376</x>
      <y>76</y>
      <w>9</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2365</x>
      <y>86</y>
      <w>21</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MRT_ADD_VIF</panel_attributes>
    <additional_attributes>190.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2361</x>
      <y>91</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vif_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2355</x>
      <y>98</y>
      <w>40</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.VIF_EXISTS检查到vifi已经被占用，返回EADDRINUSE
2.查看vifc_flags
	1.如果是VIFF_REGISTER，通过ipmr_reg_vif创建接收pim的网络设备
	2.如果是VIFF_TUNNEL，通过ipmr_new_tunnel新建ip-ip的隧道
	3.如果是0，通过ip_dev_find找一个到s_addr的dev
3.更新组播转发标志
	in_dev-&gt;cnf.mc_forwarding++
4.dev_set_allmulti更新dev_set_allmulti标志(组播报文功能)
	并通过ip_rt_multicast_event立即刷新路由
5.设置vif_table[vifi]
	v-&gt;rate_limit=vifc-&gt;vifc_rate_limit;
	v-&gt;local=vifc-&gt;vifc_lcl_addr.s_addr;
	v-&gt;remote=vifc-&gt;vifc_rmt_addr.s_addr;
	v-&gt;flags=vifc-&gt;vifc_flags;
	v-&gt;flags |= VIFF_STATIC//不是mr_socket
	v-&gt;threshold=vifc-&gt;vifc_threshold;
	v-&gt;bytes_in = 0;
	v-&gt;bytes_out = 0;
	v-&gt;pkt_in = 0;
	v-&gt;pkt_out = 0;
	v-&gt;link = dev-&gt;ifindex;
	v-&gt;link = dev-&gt;iflink//VIFF_TUNNEL|VIFF_REGISTER
	v-&gt;dev=dev
6.更新计数reg_vif_num maxvif
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2366</x>
      <y>94</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2369</x>
      <y>137</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipmr_new_tunnel</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2373</x>
      <y>130</y>
      <w>7</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>50.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2399</x>
      <y>132</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_set_allmulti</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2389</x>
      <y>130</y>
      <w>19</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;170.0;20.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2394</x>
      <y>138</y>
      <w>39</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.dev-&gt;flags |= IFF_ALLMULTI;
2.dev-&gt;allmulti += inc
3.如果allmulti变为0，将IFF_ALLMULTI去掉
4.如果flag发生了改变，通过dev_mc_upload上传dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2405</x>
      <y>135</y>
      <w>5</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2406</x>
      <y>149</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_mc_upload</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2410</x>
      <y>145</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2349</x>
      <y>144</y>
      <w>43</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.__dev_get_by_name根据"tunl0"获取dev
2.如果找到dev
	1.设置隧道参数
		memset(&amp;p, 0, sizeof(p));
		p.iph.daddr = v-&gt;vifc_rmt_addr.s_addr;
		p.iph.saddr = v-&gt;vifc_lcl_addr.s_addr;
		p.iph.version = 4;
		p.iph.ihl = 5;
		p.iph.protocol = IPPROTO_IPIP;
		sprintf(p.name, "dvmrp%d", v-&gt;vifc_vifi);
		ifr.ifr_ifru.ifru_data = (void*)&amp;p;
	2.转换成KERNEL_DS，通过do_ioctl做通道的添加(SIOCADDTUNNEL)
	3.通过__dev_get_by_name查找通道
		1.dev-&gt;flags |= IFF_MULTICAST
		2.inetdev_init为net_dev设置in_device
		3.in_dev-&gt;cnf.rp_filter = 0
		4.dev_open打开设备
3.返回dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2375</x>
      <y>140</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2360</x>
      <y>177</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev-&gt;do_ioctl
valign=center</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2366</x>
      <y>173</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SIOCADDTUNNEL</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2366</x>
      <y>180</y>
      <w>20</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ipip_init--&gt;ipip_tunnel_setup</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2361</x>
      <y>184</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipip_tunnel_ioctl</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2365</x>
      <y>187</y>
      <w>15</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
SIOCADDTUNNEL
SIOCCHGTUNNEL</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2347</x>
      <y>191</y>
      <w>41</w>
      <h>38</h>
    </coordinates>
    <panel_attributes>1.进程要有admin权限(CAP_NET_ADMIN)
2.copy_from_user复制参数ifr.ifr_ifru.ifru_data
3.检查iph
4.ipip_tunnel_locate查找或者新建(SIOCADDTUNNEL)tunnel
5.不能更改ipip_fb_tunnel_dev
	1.如果找到了tunnel，但是dev不同，返回EEXIST
	2.如果没找到tunnel
		1.point-point和daddr不能同时存在
		2.通过net_dev获取tunnel
		3.脱链-更改-链接
			ipip_tunnel_unlink(t);
			t-&gt;parms.iph.saddr = p.iph.saddr;
			t-&gt;parms.iph.daddr = p.iph.daddr;
			memcpy(dev-&gt;dev_addr, &amp;p.iph.saddr, 4);
			memcpy(dev-&gt;broadcast, &amp;p.iph.daddr, 4);
			ipip_tunnel_link(t);
		4.netdev_state_change通知状态改变
	3.找到了tunnel
		1.如果是更改
			t-&gt;parms.iph.ttl = p.iph.ttl;
			t-&gt;parms.iph.tos = p.iph.tos;
			t-&gt;parms.iph.frag_off = p.iph.frag_off;
		2.将t-&gt;parms通过ifr-&gt;ifr_ifru.ifru_data返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2357</x>
      <y>232</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipip_tunnel_locate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2363</x>
      <y>228</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2347</x>
      <y>239</y>
      <w>39</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.通过local和remote获取hash
2.遍历hash tunnels，找到其中local和remote一致的tunnel
	如果找到，返回tunnel
3.如果不新建，返回NULL
4.如果新建
	1.获取name
	2.alloc_netdev分配net_dev，并通过ipip_tunnel_setup初始化
	3.设置net_dev和tunnel
		dev-&gt;init = ipip_tunnel_init;
		nt-&gt;parms = *parms;
	4.register_netdevice注册net_dev
	5.ipip_tunnel_link将tunnel挂入tunnels
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2363</x>
      <y>235</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2402</x>
      <y>90</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>vif_delete</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2385</x>
      <y>86</y>
      <w>25</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MRT_DEL_VIF</panel_attributes>
    <additional_attributes>10.0;10.0;230.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2396</x>
      <y>97</y>
      <w>40</w>
      <h>20</h>
    </coordinates>
    <panel_attributes>1.检查vifi
2.释放dev
	dev = v-&gt;dev;
	v-&gt;dev = NULL
3.调整reg_vif_num maxvif
4.dev_set_allmulti递减allmulti
5.如果存在in_device,刷新rt_cache
	in_dev-&gt;cnf.mc_forwarding--;
6.VIFF_TUNNEL|VIFF_REGISTER,通过unregister_netdevice
	注销netdevice
7.释放dev,并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2407</x>
      <y>93</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2386</x>
      <y>86</y>
      <w>72</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
MRT_ADD_MFC</panel_attributes>
    <additional_attributes>10.0;10.0;700.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2449</x>
      <y>89</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipmr_mfc_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2440</x>
      <y>96</y>
      <w>43</w>
      <h>36</h>
    </coordinates>
    <panel_attributes>1.查找mfc_cache_array，找到mfc_origin和mfc_mcastgrp一致的项
2.如果找到，更新
	1.c-&gt;mfc_parent = mfc-&gt;mfcc_parent;
	2.ipmr_update_thresholds根据mfc-&gt;mfcc_ttls更新
	3.c-&gt;mfc_flags |= MFC_STATIC//不是mr_route
3.要新建的mfcc_mcastgrp是多播
4.ipmr_cache_alloc申请mfc
5.c-&gt;mfc_origin=mfc-&gt;mfcc_origin.s_addr;
	c-&gt;mfc_mcastgrp=mfc-&gt;mfcc_mcastgrp.s_addr;
	c-&gt;mfc_parent=mfc-&gt;mfcc_parent;
	ipmr_update_thresholds(c, mfc-&gt;mfcc_ttls);
	c-&gt;mfc_flags |= MFC_STATIC//mr_route
6.挂入到链表
	c-&gt;next = mfc_cache_array[line];
	mfc_cache_array[line] = c;
7.遍历链表mfc_unres_queue，其中如果有和新建mfc的
	mfc_origin和mfc_mcastgrp相同的mfc
	1.递减cache_resolve_queue_len
	2.如果递减至0，删除ipmr_expire_timer
8.如果找到uc
	1.ipmr_cache_resolve以新mfc处理其上的skb
	2.kmem_cache_free释放uc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2454</x>
      <y>92</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2449</x>
      <y>135</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipmr_cache_resolve</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2456</x>
      <y>131</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2436</x>
      <y>142</y>
      <w>32</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.依次取出uc-&gt;mfc_un.unres.unresolved上的skb
	1.如果version是0
		1.skb_pull将iph放到head
		2.
		3.rtnl_unicast递交skb到相应的进程
	2.ip_mr_forward以新的mfc进行转发
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2454</x>
      <y>138</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2885</x>
      <y>1142</y>
      <w>45</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>1.如果skb已经经过本地转发(IPSKB_FORWARDED),跳到dont_forward
	以免递归forward
2.如果不是本地接收
	1.如果router_alert，通过ip_call_ra_chain进行通知
	2.如果是skb是IPPROTO_IGMP
		1.如果存在mroute_socket
			1.通过nf_reset重置
			2.raw_rcv接收到mroute_socket，并返回0
3.ipmr_cache_find在mfc_cache_array找对应的mfc
4.如果没找到找到组播转发缓存
	1.如果本地接收(locak)
		1.skb_clone复制skb
		2.ip_local_deliver接收skb
	2.ipmr_find_vif在vif_table中找到对应的vif
	3.如果找到对应的虚拟接口，通过ipmr_cache_unresolved将skb
		挂入到对应的unresolved链表
	4.如果没找到对应的虚拟接口，通过kfree_skb将其示范给，并返回ENODEV
5.如果找到cache
	1.ip_mr_forward进行转发
	2.如果本地接收，通过ip_local_deliver接收
6.返回0
7.dont_forward
	1.如果本地接收，通过ip_local_deliver接收
	2.释放skb，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2908</x>
      <y>1138</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2881</x>
      <y>1185</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipmr_cache_unresolved</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2921</x>
      <y>1185</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mr_forward</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2888</x>
      <y>1181</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2927</x>
      <y>1181</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2863</x>
      <y>1192</y>
      <w>48</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.遍历mfc_unres_queue，看是否能找到saddr和daddr相同的mfc
2.如果没有
	1.如果cache_resolve_queue_len没超过限值，通过ipmr_cache_alloc_unres
		申请uc，如果没申请到，kfree_skb将其释放，并返回ENOBUFS
	2.初始化mfc
		c-&gt;mfc_parent=-1;
		c-&gt;mfc_origin=skb-&gt;nh.iph-&gt;saddr;
		c-&gt;mfc_mcastgrp=skb-&gt;nh.iph-&gt;daddr;
	3.ipmr_cache_report通知mroute_socket
	4.将mfc挂入到mfc_unres_queue链表
		atomic_inc(&amp;cache_resolve_queue_len);
		c-&gt;next = mfc_unres_queue;
		mfc_unres_queue = c;
	5.mod_timer修改ipmr_expire_timer到c-&gt;mfc_un.unres.expires
3.如果unresolved链表中的skb超过了3，通过kfree_skb释放skb，并返回ENOBUFS
4.skb_queue_tail将skb挂到c-&gt;mfc_un.unres.unresolved后面
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2888</x>
      <y>1188</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2862</x>
      <y>1222</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipmr_cache_alloc_unres</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2851</x>
      <y>1229</y>
      <w>42</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.kmem_cache_alloc申请mfc
2.初始化
	1.memset(c, 0, sizeof(*c))
	2.skb_queue_head_init初始化skb链表c-&gt;mfc_un.unres.unresolved
	3.c-&gt;mfc_un.unres.expires = jiffies + 10*HZ
3.返回mfc
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2870</x>
      <y>1225</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2901</x>
      <y>1222</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipmr_cache_report</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2871</x>
      <y>1218</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2908</x>
      <y>1218</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2896</x>
      <y>1229</y>
      <w>47</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>1.如果是IGMPMSG_WHOLEPKT，需要通过skb_realloc_headroom在skb
	前面增加出iph的空间
2.否则通过alloc_skb申请128data空间的skb
3.如果是IGMPMSG_WHOLEPKT
	1.skb_push腾出前面iph的空间
	2.修改协议头位置
		skb-&gt;nh.raw = skb-&gt;h.raw = (u8*)msg;
	3.以skb为基础填充这个iph空间
		memcpy(msg, pkt-&gt;nh.raw, sizeof(struct iphdr));
	4.重新调整iph
		msg-&gt;im_msgtype = IGMPMSG_WHOLEPKT;
		msg-&gt;im_mbz = 0;
 		msg-&gt;im_vif = reg_vif_num;
		skb-&gt;nh.iph-&gt;ihl = sizeof(struct iphdr) &gt;&gt; 2;
		skb-&gt;nh.iph-&gt;tot_len = htons(ntohs(pkt-&gt;nh.iph-&gt;tot_len) + sizeof(struct iphdr));
4.如果不是
	1.skb_put腾出iph的空间
		memcpy(skb-&gt;data,pkt-&gt;data,ihl);//复制iph
		skb-&gt;nh.iph-&gt;protocol = 0;
		msg = (struct igmpmsg*)skb-&gt;nh.iph;
		msg-&gt;im_vif = vifi;
		skb-&gt;nh.iph-&gt;tot_len=htons(skb-&gt;len);
	2.skb-&gt;dst = dst_clone(pkt-&gt;dst);
	3.skb_put再腾出igmphdr
		igmp-&gt;type	=
		msg-&gt;im_msgtype = assert;
		igmp-&gt;code 	=	0;
	4.skb-&gt;h.raw = skb-&gt;nh.raw;
5.如果不存在mroute_socket，释放skb
6.sock_queue_rcv_skb将skb挂入到mroute_socket的sk_receive_queue
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2907</x>
      <y>1225</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2917</x>
      <y>1192</y>
      <w>49</w>
      <h>34</h>
    </coordinates>
    <panel_attributes>1.获取虚拟接口vif
	vif = cache-&gt;mfc_parent;
2.更新mfc
	cache-&gt;mfc_un.res.pkt++;
	cache-&gt;mfc_un.res.bytes += skb-&gt;len;
3.如果输入设备和虚拟接口不一致
	1.如果输入设备异常(0),跳到dont_forward
	2.cache-&gt;mfc_un.res.wrong_if++;
	3.ipmr_find_vif在vif_table找对应的vif
	4.查找成功，需要发送路由警告(mroute_do_assert),是pim协议(mroute_do_pim)
		或者ttls有效，并且距上一次assert超过了MFC_ASSERT_THRESH
			1.cache-&gt;mfc_un.res.last_assert = jiffies;
			2.ipmr_cache_report向mroute_socket报告
4.更新vif的包数量和数据长度
	vif_table[vif].pkt_in++;
	vif_table[vif].bytes_in+=skb-&gt;len;
5.遍历虚拟接口maxvif~minvif
	1.ipmr_queue_xmit发送到对应的虚拟接口
	2.如果local置上，需要通过skb_clone复制一份，然后发送
6.dont_forward：
	1.如果local没置上，需要将skb释放，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2928</x>
      <y>1188</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2950</x>
      <y>1229</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipmr_queue_xmit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2958</x>
      <y>1225</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2946</x>
      <y>1236</y>
      <w>41</w>
      <h>49</h>
    </coordinates>
    <panel_attributes>1.如果虚拟接口的dev不存在，释放skb并返回
2.如果VIFF_REGISTER
	1.vif-&gt;pkt_out++;
	vif-&gt;bytes_out+=skb-&gt;len;
	netdev_priv(vif-&gt;dev))-&gt;tx_bytes += skb-&gt;len;
	netdev_priv(vif-&gt;dev))-&gt;tx_packets++;
	2.ipmr_cache_report报告mroute_socket
	3.释放skb，并返回
3.如果VIFF_TUNNEL
	1.ip_route_output_key查询到vif-&gt;remote路由
	2.encap = sizeof(struct iphdr)
4.否则，通过ip_route_output_key查找到iph-&gt;daddr的路由
5.如果要转发的长度超过了mtu，并且不允许分段，释放rt，skb，并返回
6.获取头部长度
	encap += LL_RESERVED_SPACE(dev) + rt-&gt;u.dst.header_len
7.skb_cow做写时复制，head的空间设置为encap，如果失败，释放rt，skb，并返回
8.更新vif
	vif-&gt;pkt_out++;
	vif-&gt;bytes_out+=skb-&gt;len;
9.skb换新的dst
	dst_release(skb-&gt;dst);
	skb-&gt;dst = &amp;rt-&gt;u.dst;
10.ip_decrease_ttl递减ttl
11.如果是VIFF_TUNNEL
	1.通过ip_encap给skb封装一层iph的头
	2.netdev_priv(vif-&gt;dev))-&gt;stat.tx_packets++;
		etdev_priv(vif-&gt;dev))-&gt;stat.tx_bytes+=skb-&gt;len
12.标志skb被转发，以免对回环设备转发
	IPCB(skb)-&gt;flags |= IPSKB_FORWARDED;
13.net_filter之后，通过ipmr_forward_finish转发后返回
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2959</x>
      <y>1232</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2940</x>
      <y>1288</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_encap</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2973</x>
      <y>1288</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ipmr_forward_finish</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2947</x>
      <y>1284</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2979</x>
      <y>1284</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2935</x>
      <y>1295</y>
      <w>25</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.skb_push向前腾出iph的空间
2.iph-&gt;version	= 	4;
	iph-&gt;tos	=	skb-&gt;nh.iph-&gt;tos;
	iph-&gt;ttl	=	skb-&gt;nh.iph-&gt;ttl;
	iph-&gt;frag_off	=	0;
	iph-&gt;daddr	=	daddr;
	iph-&gt;saddr	=	saddr;
	iph-&gt;protocol	=	IPPROTO_IPIP;
	iph-&gt;ihl	=	5;
	iph-&gt;tot_len	=	htons(skb-&gt;len);
	ip_select_ident(iph, skb-&gt;dst, NULL);
	ip_send_check(iph);
3.skb-&gt;h.ipiph = skb-&gt;nh.iph;
	skb-&gt;nh.iph = iph;
4.重置IPCB(skb)-&gt;opt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2945</x>
      <y>1291</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2964</x>
      <y>1295</y>
      <w>34</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.如果有IPCB(skb)-&gt;opt，通过ip_forward_options构建ip选项
2.dst_output将skb输出
注：这里走的是ip_mc_output
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2979</x>
      <y>1291</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2369</x>
      <y>543</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_output</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2082</x>
      <y>542</y>
      <w>296</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
__mkroute_output</panel_attributes>
    <additional_attributes>10.0;40.0;2940.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2361</x>
      <y>550</y>
      <w>46</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.设置skb的输出设备和协议
	skb-&gt;dev = dev;
	skb-&gt;protocol = htons(ETH_P_IP);
2.如果是多播，以下情况需要ip_dev_loopback_xmit复制一份给回环接口
	1.不是本地输出的组播报文(!sk),或者要求组播回发(mc_loop)
	2.路由标记为RTCF_LOCAL，或者还没被转发(!IPSKB_FORWARDED)
3.如果ttl减到0，通过kfree将其释放
4.如果是广播，需要复制一份，然后通过ip_dev_loopback_xmit发给回环接口
5.net_filter之后，通过ip_finish_output发出。
注：arp_constructor里标记的是NO_ARP，neigh_resolve_output不用发arp报文，
	而直接通过dev_queue_xmit发出
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2375</x>
      <y>546</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2376</x>
      <y>572</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_dev_loopback_xmit</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2384</x>
      <y>568</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2363</x>
      <y>579</y>
      <w>45</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.newskb-&gt;mac.raw = newskb-&gt;data;//指向链接层
	__skb_pull(newskb, newskb-&gt;nh.raw - newskb-&gt;data)//将mac移出data
注：ip_mc_output下是没有链接层头的
2.newskb-&gt;pkt_type = PACKET_LOOPBACK;
	newskb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
3.netif_rx接收skb，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2384</x>
      <y>575</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2379</x>
      <y>593</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>netif_rx</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2369</x>
      <y>599</y>
      <w>41</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果被net_poll接收（netpoll_rx），则不处理（NET_RX_DROP）
2.如果要求时间戳（!skb-&gt;tstamp.off_sec），通过net_timestamp
3.获取cpu的softnet_data--queue
4.如果queue的长度超过了netdev_max_backlog，
	通过kfree_skb释放skb，并返回NET_RX_DROP
	__get_cpu_var(netdev_rx_stat).dropped++
5.如果没超过：
	1.如果qlen不为0，说明有包在软中断中处理，直接将
		skb加入到input_pkt_queue末端
	2.如果qlen为0，将虚拟网络设备backlog_dev加入到poll_list
		中，并将软中断打开后，将skb加入到input_pkt_queue末端
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2384</x>
      <y>596</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2378</x>
      <y>620</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>netpoll_rx</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2383</x>
      <y>617</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2367</x>
      <y>626</y>
      <w>38</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果net_dev不存在netpoll信息块npinfo，或者禁止信息
	块输入，直接返回0
2.通过__netpoll_rx接收报文，返回接收状态
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2383</x>
      <y>623</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2378</x>
      <y>635</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__netpoll_rx</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2384</x>
      <y>632</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2363</x>
      <y>641</y>
      <w>47</w>
      <h>21</h>
    </coordinates>
    <panel_attributes>1.要有netpoll，要是以太网报文（ARPHRD_ETHER）
2.如果是arp报文（ETH_P_ARP），查看trap（处理所有的数据包，不满足条件丢掉）
	skb_queue_tail(&amp;npinfo-&gt;arp_tx, skb);
注：trap为0处理满足条件的数据包，不满足条件丢给协议栈
3.如果是ip数据报（eth_hdr(skb)-&gt;h_proto=ETH_P_IP）
	1.要是本地数据报（skb-&gt;pkt_type != PACKET_OTHERHOST）
	2.不能共享（!skb_shared(skb)）
	3.数据报有效
	4.是udp（iph-&gt;protocol = IPPROTO_UDP）
	5.npinfo和报文中的地址和端口一致
	6.满足以上条件后，通过np-&gt;rx_hook接收
	7.通过kfree_skb释放skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2383</x>
      <y>638</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2384</x>
      <y>589</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1430</x>
      <y>1199</y>
      <w>1082</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
inet_init
igmp_protocol</panel_attributes>
    <additional_attributes>10.0;50.0;10800.0;10.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2505</x>
      <y>1200</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_rcv</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2511</x>
      <y>1203</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2493</x>
      <y>1208</y>
      <w>41</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.in_dev要存在，否则释放skb，并返回0
2.pskb_may_pull将igmp头部移到head空间
3.检查ip_summed
	1.如果是CHECKSUM_COMPLETE，csum_fold检查checksum
	2.如果没检查通过，或者CHECKSUM_NONE，通过__skb_checksum_complete
		验证checksum
4.查看ih-&gt;type，做出相应处理
5.释放in_dev，释放skb，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2487</x>
      <y>1221</y>
      <w>26</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
IGMP_HOST_MEMBERSHIP_QUERY</panel_attributes>
    <additional_attributes>210.0;10.0;40.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2483</x>
      <y>1226</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_heard_query</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2515</x>
      <y>1221</y>
      <w>29</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
IGMP_HOST_MEMBERSHIP_REPORT:
IGMPV2_HOST_MEMBERSHIP_REPORT:
IGMPV3_HOST_MEMBERSHIP_REPORT:</panel_attributes>
    <additional_attributes>80.0;10.0;200.0;80.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2529</x>
      <y>1238</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_heard_report</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2521</x>
      <y>1229</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.不是回环接口报告（skb-&gt;dst-&gt;fl.iif == 0）
2.在pkt_type是多播或者广播时，通过igmp_heard_report
	报告
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2535</x>
      <y>1234</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2377</x>
      <y>76</y>
      <w>133</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
IP_ADD_MEMBERSHIP:
IP_DROP_MEMBERSHIP: </panel_attributes>
    <additional_attributes>10.0;10.0;1310.0;100.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2377</x>
      <y>76</y>
      <w>284</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
IP_BLOCK_SOURCE:
IP_UNBLOCK_SOURCE:
IP_ADD_SOURCE_MEMBERSHIP:
IP_DROP_SOURCE_MEMBERSHIP:</panel_attributes>
    <additional_attributes>10.0;10.0;2820.0;100.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2484</x>
      <y>86</y>
      <w>40</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.参数的长度得大于ip_mreq
2.如果有超过ip_mreqn长度，将所有参数复制到mreq
	否则将mreq重置之后，将ip_mreq复制到mreq(少一个ifindex)
3.如果是IP_ADD_MEMBERSHIP，通过ip_mc_join_group添加
	否则通过ip_mc_leave_group移除group
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2485</x>
      <y>99</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_join_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2490</x>
      <y>95</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2485</x>
      <y>106</y>
      <w>31</w>
      <h>28</h>
    </coordinates>
    <panel_attributes>1.所加入的组要是多播地址，否则返回EINVAL
2.ip_mc_find_dev查找in_dev,如果没找到，返回ENODEV
3.遍历inet.mc_list，查看是否有多播地址和设备一致的
	如果找到，即返回
4.如果没找到
	1.inet.mc_list中的数量不能超过sysctl_igmp_max_memberships
	2.通过sock_kmalloc申请iml
	3.将请求的参数复制到iml-&gt;multi
		memcpy(&amp;iml-&gt;multi, imr, sizeof(*imr));
	4.加入链表
		iml-&gt;next = inet-&gt;mc_list;
		inet-&gt;mc_list = iml;
	5.初始化
		iml-&gt;sflist = NULL;
		iml-&gt;sfmode = MCAST_EXCLUDE;
	6.ip_mc_inc_group加入到对应的组
	7.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2491</x>
      <y>102</y>
      <w>5</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2481</x>
      <y>137</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_find_dev</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2469</x>
      <y>144</y>
      <w>37</w>
      <h>17</h>
    </coordinates>
    <panel_attributes>1.如果存在imr_ifindex，通过inetdev_by_index在dev_index_head
	中找到对应的netdevice，如果找到，通过__in_dev_put释放
	并返回，如果没找到。即返回NULL
2.如果有local地址(imr_address)，通过ip_dev_find查找对应的fib_node
	如果没找到，返回NULL,否则递减net_dev计数
3.如果上述两个条件均不存在，通过ip_route_output_key寻找到组的rt
	dev = rt-&gt;u.dst.dev;
	ip_rt_put(rt);
4.如果2,3找到对应的dev，返回对应的in_device
	imr-&gt;imr_ifindex = dev-&gt;ifindex;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2483</x>
      <y>140</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2512</x>
      <y>137</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sock_kmalloc</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2507</x>
      <y>144</y>
      <w>37</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.申请内存的限制sk_omem_alloc不能超过sysctl_optmem_max
2.如果可以申请
	atomic_add(size, &amp;sk-&gt;sk_omem_alloc);
	mem = kmalloc(size, priority);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2517</x>
      <y>140</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2487</x>
      <y>133</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2510</x>
      <y>133</y>
      <w>9</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;70.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2550</x>
      <y>137</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_inc_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2511</x>
      <y>133</y>
      <w>46</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;440.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2546</x>
      <y>144</y>
      <w>33</w>
      <h>62</h>
    </coordinates>
    <panel_attributes>1.遍历mc_list，如果找到了有和多播地址一样的组
	1.im-&gt;users++
	2.ip_mc_add_src
	3.返回
2.如果没找到
	1.通过kmalloc申请im
	2.初始化
		im-&gt;users=1;
		im-&gt;interface=in_dev;
		in_dev_hold(in_dev);
		
		im-&gt;multiaddr=addr;
		//任意源地址
		im-&gt;sfmode = MCAST_EXCLUDE;
		im-&gt;sfcount[MCAST_INCLUDE] = 0;
		im-&gt;sfcount[MCAST_EXCLUDE] = 1;
		im-&gt;sources = NULL;

		im-&gt;tomb = NULL;
		im-&gt;crcount = 0;
		atomic_set(&amp;im-&gt;refcnt, 1);
		spin_lock_init(&amp;im-&gt;lock);
		im-&gt;tm_running=0;
		
		init_timer(&amp;im-&gt;timer);
		im-&gt;timer.data=(unsigned long)im;
		im-&gt;timer.function=&amp;igmp_timer_expire;
		
		im-&gt;unsolicit_count = IGMP_Unsolicited_Report_Count;
		im-&gt;reporter = 0;
		im-&gt;gsquery = 0;
		im-&gt;loaded = 0;
	3.加入链表
		im-&gt;next=in_dev-&gt;mc_list;
		in_dev-&gt;mc_list=im;
	4.igmpv3_del_delrec清空所有对多播地址的阻塞
	5.通过igmp_group_added将im加入到相应的igmp
	6.如果设备没有dead，通过ip_rt_multicast_event刷新缓存
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2556</x>
      <y>140</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2441</x>
      <y>211</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_add_src</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2490</x>
      <y>212</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmpv3_del_delrec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2579</x>
      <y>208</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_group_added</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2445</x>
      <y>205</y>
      <w>114</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>1120.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2497</x>
      <y>205</y>
      <w>65</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>630.0;10.0;10.0;70.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2563</x>
      <y>205</y>
      <w>24</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;220.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2429</x>
      <y>220</y>
      <w>33</w>
      <h>40</h>
    </coordinates>
    <panel_attributes>如果sf_setstate检查到old_in发生了变化1.遍历dev.mc_list，看是否能找到对应的多播地址
	如果没找到，返回ESRCH
2.如果delta为0，递增改模式下socket的计数
	pmc-&gt;sfcount[sfmode]++
3.通过ip_mc_add1_src将源过滤加到pmc
注：由此可知，delta=0时，对应的过滤模式下，
	pmc.sfcount一定比psf.sf_count大
4.如果添加出错，撤销之前操作
	1.pmc-&gt;sfcount[sfmode]--
	2.ip_mc_del1_src清除其souce过滤
5.如果没出错，并且pmc exclude的值发生改变
	1.如果有exclude
		pmc-&gt;sfmode = MCAST_EXCLUDE
	2.否则置为
		pmc-&gt;sfmode = MCAST_INCLUDE
	3.设置可重传的report
		pmc-&gt;crcount = in_dev-&gt;mr_qrv ? in_dev-&gt;mr_qrv : 
			IGMP_Unsolicited_Report_Count;
		in_dev-&gt;mr_ifc_count = pmc-&gt;crcount;
	4.将pmc中所有的psf
		psf-&gt;sf_crcount = 0;
	5.igmp_ifc_event更新mr_ifc_timer
6.如果sf_setstate检查到old_in发生了变化，通过
	igmp_ifc_event设置mr_ifc_timer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2446</x>
      <y>214</y>
      <w>3</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2421</x>
      <y>267</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_add1_src</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2403</x>
      <y>274</y>
      <w>42</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.遍历pmc.sources，查看其中是否有和要过滤的源地址相同的psf
2.如果没有通过kzalloc申请，并初始化之后，放到sources链表中
	psf-&gt;sf_inaddr = *psfsrc;
	psf_prev-&gt;sf_next = psf;
3.递增相应过滤模式下socket的计数
	psf-&gt;sf_count[sfmode]++
4.如果是第一次添加对应的过滤，通过ip_rt_multicast_event
	刷新缓存，并返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2425</x>
      <y>270</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2455</x>
      <y>267</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_del1_src</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2448</x>
      <y>274</y>
      <w>39</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.遍历pmc.sources，看是否能找到源过滤地址相同的psf
2.如果没找到，或者psf对应的socket(sf_count[sfmode])是0
	返回ESRCH
3.否则
	1.psf-&gt;sf_count[sfmode]--
	2.如果sf_count减到0，通过ip_rt_multicast_event刷新缓存
	3.如果include和exclude模式下的psf都不存在
		1.将psf脱链
			psf_prev-&gt;sf_next = psf-&gt;sf_next;
		2.如果sf_oldin置上，并且不处于igmpV1和igmpV2
			1.设置psf-&gt;sf_crcount(重传report的次数)
			2.将psf挂入到tomb
			psf-&gt;sf_next = pmc-&gt;tomb;
			pmc-&gt;tomb = psf;
			3.返回1
		3.否则直接将psf释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2376</x>
      <y>268</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sf_markstate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2380</x>
      <y>271</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2364</x>
      <y>275</y>
      <w>36</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>1.遍历pmc.sources中所有的psf，标志sf_oldin
	1.sf_oldin置上的条件是这个过滤条件要么全部socket接收
		要么全部socket不接受
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2461</x>
      <y>270</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2502</x>
      <y>266</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>sf_setstate</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2506</x>
      <y>269</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2491</x>
      <y>273</y>
      <w>36</w>
      <h>33</h>
    </coordinates>
    <panel_attributes>1.遍历pmc.sources，计算每个psf的new_in
	1.如果new_in存在，old_in不存在
		1.遍历pmc.tomb，如果找到源地址相同的psf，将其脱链
		2.psf-&gt;sf_crcount = qrv
			rv++
	2.如果old_in存在，new_in不存在
		1.psf-&gt;sf_crcount = 0
		2.申请一个dpsf，并赋值之后，放到tomb中
			*dpsf = *psf;
			dpsf-&gt;sf_next = pmc-&gt;tomb;
			pmc-&gt;tomb = dpsf;
		3.dpsf-&gt;sf_crcount = qrv;
			rv++
注：1.当psf和pmc的模式相同时，old_in置上
	2.sf_crcount表示psf可以发送的次数，后续会在is_in中做判断
	3.source存在所有的psf，但是crcount可能为0，tomb中存在
		和pmc sfmode不同的psf。
	4.当old_in从0~1时，psf从tomb中删除，并且置上crcount，开始发送
	5.当old_in从1~0时，复制一个psf到tomb，并且将source中psf.crcount不发
		但是发tomb中的dpsf.crcount
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2380</x>
      <y>259</y>
      <w>58</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>560.0;10.0;10.0;90.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2426</x>
      <y>259</y>
      <w>13</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>110.0;10.0;10.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2442</x>
      <y>259</y>
      <w>18</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;160.0;80.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2444</x>
      <y>259</y>
      <w>65</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;630.0;70.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2646</x>
      <y>86</y>
      <w>30</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.长度要等于ip_mreq_source
2.copy_from_user从用户态将参数考入内核
3.查看optname
	1.IP_BLOCK_SOURCE
		omode = MCAST_EXCLUDE;
		add = 1;
	2.IP_UNBLOCK_SOURCE
		omode = MCAST_EXCLUDE;
		add = 0;
	3.IP_ADD_SOURCE_MEMBERSHIP
		1.ip_mc_join_group根据参数mreq添加组filter
		2.添加源filter
			omode = MCAST_INCLUDE;
			add = 1
	4.IP_DROP_SOURCE_MEMBERSHIP
		omode = MCAST_INCLUDE;
		add = 0;
4.ip_mc_source添加源filter
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2655</x>
      <y>120</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_source</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2661</x>
      <y>115</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2647</x>
      <y>127</y>
      <w>43</w>
      <h>62</h>
    </coordinates>
    <panel_attributes>1.组地址不是多播地址，即返回
2.ip_mc_find_dev分别通过ifindex，local，组地址查找in_device
3.遍历inet.mc_list，找到group和dev相同的pmc。如果不存在
	，EINVAL，跳到done
4.如果有源过滤(sflist),过滤模式(sfmode)得相同
5.如果不存在源过滤，并且过滤模式不同
	1.ip_mc_add_src更改组in_device的filter模式为omode
	2.ip_mc_del_src删除组in_device原来的模式
	3.更改inet中组的模式
		pmc-&gt;sfmode = omode;
6.如果要删除源过滤(add=0)
	1.如果不存在源过滤，跳到done
	2.遍历数组psl-&gt;sl_addr，看是否能找到地址相同的源，找到退出
	3.如果没找到，跳到done
	4.如果sl_count只有一个，并且要求drop_member(MCAST_INCLUDE,由IP_DROP_SOURCE_MEMBERSHIP可知)
		leavegroup置1，跳到done
	5.ip_mc_del_src删除imr_sourceaddr的源过滤
	6.将sl_addr数组填充删除的位置
	7.返回0，跳到done
7.如果sl_count超过了sysctl_igmp_max_msf，返回ENOBUFS，跳到done
8.如果没有源过滤，或者源过滤达到了max
	1.在max的基础上加IP_SFBLOCK
	2.sock_kmalloc申请新的源过滤数组
	3.newpsl-&gt;sl_max = count;
		newpsl-&gt;sl_count = count - IP_SFBLOCK;
	4.复制psl到newpsl
	5.sock_kfree_s将原来的psf释放
	6.pmc-&gt;sflist = psl = newpsl;
9.查找sl_addr中是否由源过滤地址一致的项，如果没有跳到done
10.如果存在
	1.将数组中i的位置空出来(需要这步吗？)
	2.psl-&gt;sl_addr[i] = mreqs-&gt;imr_sourceaddr;
		psl-&gt;sl_count++;
		err = 0;
	3.ip_mc_add_src添加源过滤到in_device
11.done
	1.如果leavegroup置上，通过ip_mc_leave_group删除group
	2.返回err
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2661</x>
      <y>123</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2648</x>
      <y>194</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_del_src</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2653</x>
      <y>188</y>
      <w>8</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>60.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2643</x>
      <y>201</y>
      <w>36</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.遍历in_dev.mc_list，找到其中过滤组地址相同的pmc
2.sf_markstate设置sf_oldin
3.如果delta为0
	1.sfmode模式的sfcount不能为0
	2.pmc-&gt;sfcount[sfmode]--
4.ip_mc_del1_src将psfsrc数组中的源过滤全删除
5.如果pmc从exclude过渡到include
	1.pmc-&gt;sfmode = MCAST_INCLUDE;
	2.pmc-&gt;crcount = in_dev-&gt;mr_qrv ? in_dev-&gt;mr_qrv : 
			IGMP_Unsolicited_Report_Count;
		in_dev-&gt;mr_ifc_count = pmc-&gt;crcount;
	3.清除sources链表中所有的sf_crcount
	4.igmp_ifc_event设置mr_ifc_timer
6.如果sf_setstate检查到old_in发生了变化，通过
	igmp_ifc_event设置mr_ifc_timer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2653</x>
      <y>197</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2691</x>
      <y>194</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_leave_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2674</x>
      <y>188</y>
      <w>23</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;210.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2685</x>
      <y>201</y>
      <w>43</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.在inet.mc_list中,找到group dev相同的iml
	1.移出链表
		*imlp = iml-&gt;next
	2.如果存在in_dev，通过ip_mc_dec_group将
		in_dev中组过滤删除
	3.sock_kfree_s释放iml
2.如果没找到，返回EADDRNOTAVAIL(没有in_dev，返回ENODEV)
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2699</x>
      <y>197</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2695</x>
      <y>217</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_dec_group</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2700</x>
      <y>213</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2686</x>
      <y>224</y>
      <w>34</w>
      <h>16</h>
    </coordinates>
    <panel_attributes>1.遍历in_dev.mc_list，找到组地址相同的项i
	1.--i-&gt;users 
	2.如果减到0
		1.脱链
			*ip = i-&gt;next
		2.igmp_group_dropped发送igmp从组中删除
		3.如果in_dev.dead没置上，通过ip_rt_multicast_event
			刷新缓存
		4.ip_ma_put释放该项
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2701</x>
      <y>220</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2694</x>
      <y>243</y>
      <w>15</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_group_dropped</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2701</x>
      <y>239</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2478</x>
      <y>219</y>
      <w>31</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.遍历in_dev.mc_tomb，找到组地址相同的pmc
	1.将其脱链
		pmc_prev-&gt;next = pmc-&gt;next
	2.将pmc.tomb所有的源过滤释放
		kfree(psf);
	3.释放in_dev和pmc
		in_dev_put(pmc-&gt;interface);
		kfree(pmc);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2496</x>
      <y>215</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2568</x>
      <y>215</y>
      <w>40</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.如果im.loaded没置上，通过ip_mc_filter_add将filter添加到device
	im-&gt;loaded = 1;
2.如果多播地址是IGMP_ALL_HOSTS，直接返回
3.如果in_dev.dead，直接返回
4.如果正处于igmpv1或者igmpv2，通过igmp_start_timer启动定时器
5.否则确定im-&gt;crcount之后，通过igmp_ifc_event启动定时器
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2586</x>
      <y>211</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2582</x>
      <y>231</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_start_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2587</x>
      <y>226</y>
      <w>4</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2568</x>
      <y>237</y>
      <w>35</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.im-&gt;tm_running=1
2.随机选择一个delay，通过mod_timer调整im-&gt;timer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2585</x>
      <y>234</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2615</x>
      <y>231</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_ifc_event</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2602</x>
      <y>226</y>
      <w>22</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;200.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2606</x>
      <y>238</y>
      <w>31</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>1.如果处于igmpv1或者igmpv2，直接返回
2.确定in_dev-&gt;mr_ifc_count(超时时，重传的最大次数)
3.igmp_ifc_start_timer启动in_dev-&gt;mr_ifc_timer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2620</x>
      <y>234</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2537</x>
      <y>230</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_filter_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2543</x>
      <y>226</y>
      <w>31</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>290.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2537</x>
      <y>237</y>
      <w>27</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.arp_mc_map查看设备是否支持组播
2.dev_mc_add添加filter
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2543</x>
      <y>233</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2545</x>
      <y>245</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_mc_add</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2550</x>
      <y>241</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2535</x>
      <y>252</y>
      <w>37</w>
      <h>27</h>
    </coordinates>
    <panel_attributes>1.kmalloc申请dmi
2.遍历net_dev.mc_list,看是否能找到组播地址相同的dmi
	1.如果glbl置上
		dmi-&gt;dmi_gusers = 1;
	2.如果之前的dmi_gusers没置上，不用调整dmi_users，否则
		dmi-&gt;dmi_users++;
	3.返回
3.初始化dmi
	memcpy(dmi-&gt;dmi_addr, addr, alen);
	dmi-&gt;dmi_addrlen = alen;
	dmi-&gt;next = dev-&gt;mc_list;
	dmi-&gt;dmi_users = 1;
	dmi-&gt;dmi_gusers = glbl ? 1 : 0;
	dev-&gt;mc_list = dmi;
	dev-&gt;mc_count++;
4.__dev_mc_upload将组播更新至硬件
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2549</x>
      <y>248</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2546</x>
      <y>282</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>__dev_mc_upload</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2551</x>
      <y>278</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2536</x>
      <y>289</y>
      <w>34</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.如果net_dev没有IFF_UP直接返回
2.如果net_dev的set_multicast_list不存在，或者
	netif_device_present检查其没有present，直接返回
3.通过dev-&gt;set_multicast_list设置组播过滤
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2551</x>
      <y>285</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;20.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2587</x>
      <y>1308</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_timer_expire</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2594</x>
      <y>1303</y>
      <w>13</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ip_mc_inc_group
im-&gt;timer</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2576</x>
      <y>1315</y>
      <w>35</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.im-&gt;tm_running=0
2.如果还存在unsolicit_count
	1.im-&gt;unsolicit_count--
	2.igmp_start_timer重启im.timer
3.根据处在的igmp version，通过igmp_send_report
	发送报告
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2593</x>
      <y>1311</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2587</x>
      <y>1328</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_send_report</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2594</x>
      <y>1325</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2573</x>
      <y>1335</y>
      <w>48</w>
      <h>54</h>
    </coordinates>
    <panel_attributes>1.如果是IGMPV3_HOST_MEMBERSHIP_REPORT，通过igmpv3_send_report
	发送报告
2.如果是IGMP_HOST_LEAVE_MESSAGE，发送目的地变更为IGMP_ALL_ROUTER
3.默认目的地为组播地址
4.ip_route_output_key寻找到目的地的路由
5.如果没有找到发出的设备，释放路由，返回-1
6.alloc_skb申请skb(长度是ll+iph+4+igmp)
	1.skb-&gt;dst = &amp;rt-&gt;u.dst
	2.skb_reserve预留出链接层空间
	3.skb_put腾出ip+4头部空间
		skb-&gt;nh.iph = iph
		iph-&gt;version  = 4;
		iph-&gt;ihl      = (sizeof(struct iphdr)+4)&gt;&gt;2;
		iph-&gt;tos      = 0xc0;
		iph-&gt;frag_off = htons(IP_DF);
		iph-&gt;ttl      = 1;
		iph-&gt;daddr    = dst;
		iph-&gt;saddr    = rt-&gt;rt_src;
		iph-&gt;protocol = IPPROTO_IGMP;
		iph-&gt;tot_len  = htons(IGMP_SIZE);
		ip_select_ident(iph, &amp;rt-&gt;u.dst, NULL);
		((u8*)&amp;iph[1])[0] = IPOPT_RA;
		((u8*)&amp;iph[1])[1] = 4;
		((u8*)&amp;iph[1])[2] = 0;
		((u8*)&amp;iph[1])[3] = 0;
		ip_send_check(iph);
	4.skb_put腾出igmp的空间
		ih-&gt;type=type;
		ih-&gt;code=0;
		ih-&gt;csum=0;
		ih-&gt;group=group;
		ih-&gt;csum=ip_compute_csum
7.net_filter之后，通过dst_output发送
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2595</x>
      <y>1331</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2592</x>
      <y>1393</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmpv3_send_report</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2601</x>
      <y>1388</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1721</x>
      <y>212</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_cmsg_send</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1708</x>
      <y>220</y>
      <w>38</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.以cmsg-&gt;cmsg_len依次解析msg_control
	1.CMSG_OK是指：cmsg_len要超过长度cmsghdr，并且该数据结构不超过msg_controllen
	2.cmsg_level要是SOL_IP
	3.查看cmsg_type
		1.如果是IP_RETOPTS，将CMSG_DATA整合到ipc-&gt;opt中
		2.如果是IP_PKTINFO，以in_pktinfo解析CMSG_DATA
			ipc-&gt;oif = info-&gt;ipi_ifindex;//输出网络设备
			ipc-&gt;addr = info-&gt;ipi_spec_dst.s_addr;//目的地址
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1727</x>
      <y>215</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1156</x>
      <y>1295</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1156</x>
      <y>1302</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1125</x>
      <y>1239</y>
      <w>59</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
</panel_attributes>
    <additional_attributes>570.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1727</x>
      <y>207</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2093</x>
      <y>221</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>300.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2579</x>
      <y>1400</y>
      <w>44</w>
      <h>14</h>
    </coordinates>
    <panel_attributes>1.如果没指定pmc，需要对in_dev.mc_list中除了IGMP_ALL_HOSTS
	都进行下面操作，否则只对指定的pmc做
	1.如果pmc有exclude，
		type = IGMPV3_MODE_IS_EXCLUDE
		否则即为
		type = IGMPV3_MODE_IS_INCLUDE
	2.add_grec为skb添加组信息
2.igmpv3_sendpack发送skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2598</x>
      <y>1396</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2574</x>
      <y>1417</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_grec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2580</x>
      <y>1413</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2611</x>
      <y>1413</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2606</x>
      <y>1417</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmpv3_sendpack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2599</x>
      <y>1424</y>
      <w>31</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.设置iph
	iplen = skb-&gt;tail - (unsigned char *)skb-&gt;nh.iph;
	pip-&gt;tot_len = htons(iplen);
	ip_send_check(pip);
2.设置igmp
	pig-&gt;csum = ip_compute_csum
3.net_filter之后，通过dst_output发送skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2611</x>
      <y>1420</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2579</x>
      <y>1420</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2556</x>
      <y>1424</y>
      <w>41</w>
      <h>86</h>
    </coordinates>
    <panel_attributes>1.如果type是IGMPV3_MODE_IS_INCLUDE或者IGMPV3_MODE_IS_EXCLUDE
	isquery就置上
2.如果是IGMPV3_MODE_IS_EXCLUDE或者IGMPV3_CHANGE_TO_EXCLUDE
	将truncate置上
3.如果要有源被阻止(sdeleted),选择pmc-&gt;tomb链表，否则选pmc-&gt;sources
4.如果源过滤链表不存在，跳到empty_source

5.如果truncate置上
	1.如果skb剩余的空间不能容纳这个pmc所有的filter
		1.通过igmpv3_sendpack将之前的skb发送
		2.通过igmpv3_newpack新建一个skb
	注：grec_size统计source中符合条件的psf,而不统计tomb中的，因为
		在truncate条件下，tomb中的因为sdeleted都不会统计(tomb中既有
		exclude又有include，并不是单一的模式)

6.遍历链表的psf
	1.is_in检查是否满足发出条件
	2.发出后，清除query标志
		psf-&gt;sf_gsresp = 0;
	3.如果没足够的空间容纳psf(或者头(first)+psf)
		1.如果是truncate，并且不是第一个psf，skb满了之后退出
		2.设置前一个skb中psf的数量
			pgr-&gt;grec_nsrcs = htons(scount)
		3.igmpv3_sendpack将skb发送
		4.igmpv3_newpack新建一个skb
		5.重置
			first = 1;
			scount = 0;//skb中psf的统计
	4.如果是第一个psf，通过add_grhead添加头
		first = 0
	5.添加一个psf
		psrc = (__be32 *)skb_put(skb, sizeof(__be32));
		*psrc = psf-&gt;sf_inaddr;
		scount++; stotal++;//stotal是pmc所有满足条件的psf
	6.如果是ALLOW_NEW_SOURCES，或者BLOCK_OLD_SOURCES(此时存在sf_crcount)
		1.减少psf发送的次数
			psf-&gt;sf_crcount--
		2.如果sf_crcount发送完成
			1.将psf移出链表
			2.释放psf
			3.继续下一个循环
		注：只删除tomb链表，或者pmc删除时删除source
7.empty_source
	1.如果之前没发psf
		1.如果是ALLOW_NEW_SOURCES或者 BLOCK_OLD_SOURCES，直接返回skb
		2.如果pmc要发送，或者被查询isquery
			1.如果skb的空间不足，通过igmpv3_sendpack将skb发出
				skb=NULL
			2.add_grhead添加组的头部
	2.设置pmc中发送psf的数量pgr-&gt;grec_nsrcs
	3.如果isquery
		pmc-&gt;gsquery = 0
	4.返回skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2467</x>
      <y>1233</y>
      <w>46</w>
      <h>53</h>
    </coordinates>
    <panel_attributes>1.如果收到的是igmpv1或者igmpv2(igmp长度为8)
	1.如果code是0，表示igmpv1
		1.max_delay = IGMP_Query_Response_Interval;
			in_dev-&gt;mr_v1_seen = jiffies +
				IGMP_V1_Router_Present_Timeout;
		2.查询的group设置为0，普通查询，表示是全部的组
	2.如果不为0，igmpv2
		1.max_delay = ih-&gt;code*(HZ/IGMP_TIMER_SCALE);
			in_dev-&gt;mr_v2_seen = jiffies +
				IGMP_V2_Router_Present_Timeout;
	3.清空igmpv3的信息
		1.清除重传次数
			in_dev-&gt;mr_ifc_count = 0;
		2.删除timer mr_ifc_timer
		3.igmpv3_clear_delrec清除被阻止的源和组
2.如果收到的是igmpv3(len&gt;12)
	1.pskb_may_pull将igmpv3_query头移到head
	2.获取ih3-&gt;nsrcs，并再次通过pskb_may_pull将所有的igmpv3头部信息放到data
	3.通过igmp.code获取最大时延in_dev-&gt;mr_maxdelay
	4.设置in_dev-&gt;mr_qrv(预计网络中丢失的报文)
	5.如果是普通查询(!group)
		1.不能指定源
		2.igmp_gq_start_timer设置mr_gq_timer之后，返回
	6.mark表示指定组和源的查询
3.遍历in_dev.mc_list，找到其中组相同(不能是IGMP_ALL_HOSTS)的项
	1.如果im.timer正在运行(tm_running,表示之前的查询未结束)，只有
		两个请求都要求进行组和源的查询，才置上im-&gt;gsquery
	2.否则
		im-&gt;gsquery = mark
	3.如果不是组和源的查询(!gsquery)，或者在gsquery情况下，需要
		igmp_marksources标记特定的查询源
		1.通过igmp_mod_timer调整im.timer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2491</x>
      <y>1229</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2464</x>
      <y>1289</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmpv3_clear_delrec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2460</x>
      <y>1296</y>
      <w>34</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.获取被阻止的组链表in_dev-&gt;mc_tomb，
	1.通过ip_mc_clear_src将tomb，sources全部释放
	2.将pmc释放
2.遍历in_dev.mc_list中的pmc
	1.将每个pmc中的源阻止链表tomb释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2472</x>
      <y>1292</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2466</x>
      <y>1309</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_clear_src</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2470</x>
      <y>1305</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2460</x>
      <y>1316</y>
      <w>26</w>
      <h>13</h>
    </coordinates>
    <panel_attributes>1.释放pmc-&gt;tomb所有的psf
2.释放pmc-&gt;sources上所有的psf
3.pmc-&gt;tomb = NULL;
	pmc-&gt;sources = NULL;
	pmc-&gt;sfmode = MCAST_EXCLUDE;
	pmc-&gt;sfcount[MCAST_INCLUDE] = 0;
	pmc-&gt;sfcount[MCAST_EXCLUDE] = 1;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2472</x>
      <y>1312</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2503</x>
      <y>1290</y>
      <w>18</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_gq_start_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2496</x>
      <y>1297</y>
      <w>37</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.in_dev-&gt;mr_gq_running = 1
2.mod_timer调整in_dev-&gt;mr_gq_timer为0~max_delay之间的任意值
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2511</x>
      <y>1293</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2472</x>
      <y>1285</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2509</x>
      <y>1285</y>
      <w>3</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2511</x>
      <y>1285</y>
      <w>38</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;360.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2540</x>
      <y>1289</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_marksources</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2535</x>
      <y>1296</y>
      <w>36</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.如果pmc是MCAST_EXCLUDE，直接通过igmp_xmarksources处理
2.如果是include
	1.遍历其sources链表
		1.如果要求的源过滤已经遍历完了，退出
		2.找到dources链表中和其源过滤一样的psf
			psf-&gt;sf_gsresp = 1;
			scount++;
	2.如果没找到对应的源过滤，返回0
		pmc-&gt;gsquery = 0;
	3.否则，返回1
		pmc-&gt;gsquery = 1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2546</x>
      <y>1292</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2542</x>
      <y>1318</y>
      <w>17</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_xmarksources</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2549</x>
      <y>1314</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2532</x>
      <y>1325</y>
      <w>30</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>1.遍历pmc.sources，
	1.直到源过滤数组遍历完成，退出循环
	2.只有psf完全被组exclude
		scount++
2.pmc-&gt;gsquery = 0;
3.如果所有的都被exlude，返回0，否则返回1
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2549</x>
      <y>1321</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2584</x>
      <y>1288</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_mod_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2511</x>
      <y>1285</y>
      <w>78</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;760.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2574</x>
      <y>1295</y>
      <w>35</w>
      <h>9</h>
    </coordinates>
    <panel_attributes>1.通过del_timer将im.timer删除，如果之前timer被调度
	1.如果距超时时间没超过max_delay
		1.通过add_timer重新调度
		2.im-&gt;tm_running=1后，返回
2.否则通过igmp_start_timer重新开启im.timer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2590</x>
      <y>1291</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2540</x>
      <y>1514</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>grec_size</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2545</x>
      <y>1517</y>
      <w>21</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
igmpv3_grec+4*igmp_scount</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2539</x>
      <y>1521</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_scount</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2529</x>
      <y>1528</y>
      <w>33</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.遍历pmc.sources中所有的psf，通过is_in查看是否
	满足条件，如果满足条件
	scount++
2.返回scount
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2544</x>
      <y>1524</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2537</x>
      <y>1539</y>
      <w>11</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>is_in</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2541</x>
      <y>1535</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2523</x>
      <y>1546</y>
      <w>41</w>
      <h>43</h>
    </coordinates>
    <panel_attributes>1.type是IS_INCLUDE 或者 IS_EXCLUDE
	1.不查看组被删除(gdeleted),或者tomb链表(sdeleted)上的psf
	2.如果gsquery=0，或者gsquery=1 &amp;&amp; sf_gsresp=1(有查询标记)
		1.如果pmc是include，返回1，所有的psf具备发出
		2.否则pmc是exclude
			1.psf有include，如果是IS_EXCLUDE，返回0
			2.在完全被exclude时，返回1
	3.如果没被查询，返回0
2.如果是CHANGE_TO_INCLUDE
	1.不查看组被删除(gdeleted),或者tomb链表(sdeleted)上的psf
	2.发include的psf
3.CHANGE_TO_EXCLUDE
	1.不查看组被删除(gdeleted),或者tomb链表(sdeleted)上的psf
	2.发有并且完全被exclude的psf
4.ALLOW_NEW_SOURCES
	1.不查看组被删除(gdeleted)
	2.sf_crcount要存在
		1.MCAST_INCLUDE时，发sources上的
		2.exclude，发tomb上的
5.BLOCK_OLD_SOURCES
	1.如果pmc是include
		1.整个组被删，psf需要发出
		2.有sf_crcount，发tomb上的
	2.如果是exclude
		1.有sf_crcount，pmc没被删，source链表上的
6.都不满足，返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2541</x>
      <y>1542</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2574</x>
      <y>1513</y>
      <w>14</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmpv3_newpack</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2565</x>
      <y>1520</y>
      <w>42</w>
      <h>51</h>
    </coordinates>
    <panel_attributes>1.通过alloc_skb申请skb(size+链接层头部)
2.ip_route_output_key寻找路由，如果没找到对应的设备，释放skb，rt
3.初始化
	1.skb-&gt;dst = &amp;rt-&gt;u.dst;
		skb-&gt;dev = dev;
	2.skb_reserve预留出链接层头部空间
	3.skb_put腾出iph
		skb-&gt;nh.iph
	4.初始化iph
		pip-&gt;version  = 4;
		pip-&gt;ihl      = (sizeof(struct iphdr)+4)&gt;&gt;2;
		pip-&gt;tos      = 0xc0;
		pip-&gt;frag_off = htons(IP_DF);
		pip-&gt;ttl      = 1;
		pip-&gt;daddr    = rt-&gt;rt_dst;
		pip-&gt;saddr    = rt-&gt;rt_src;
		pip-&gt;protocol = IPPROTO_IGMP;
		pip-&gt;tot_len  = 0;	/* filled in later */
		ip_select_ident(pip, &amp;rt-&gt;u.dst, NULL);
		((u8*)&amp;pip[1])[0] = IPOPT_RA;
		((u8*)&amp;pip[1])[1] = 4;
		((u8*)&amp;pip[1])[2] = 0;
		((u8*)&amp;pip[1])[3] = 0;
	5.设置igmp头部
		skb-&gt;h.igmph = (struct igmphdr *)pig;
		pig-&gt;type = IGMPV3_HOST_MEMBERSHIP_REPORT;
		pig-&gt;resv1 = 0;
		pig-&gt;csum = 0;
		pig-&gt;resv2 = 0;
		pig-&gt;ngrec = 0;
4.返回skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2580</x>
      <y>1516</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2616</x>
      <y>1512</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>add_grhead</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2622</x>
      <y>1515</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2608</x>
      <y>1519</y>
      <w>33</w>
      <h>18</h>
    </coordinates>
    <panel_attributes>1.如果没有skb，通过igmpv3_newpack申请一个
2.skb_put腾出igmpv3_grec的空间
	pgr-&gt;grec_type = type;
	pgr-&gt;grec_auxwords = 0;
	pgr-&gt;grec_nsrcs = 0;
	pgr-&gt;grec_mca = pmc-&gt;multiaddr;
3.skb增加一个组
	pih-&gt;ngrec = htons(ntohs(pih-&gt;ngrec)+1)
4，返回组的头部和skb
	*ppgr = pgr
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2545</x>
      <y>1509</y>
      <w>27</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>250.0;10.0;10.0;50.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2579</x>
      <y>1509</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2585</x>
      <y>1509</y>
      <w>39</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;370.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2518</x>
      <y>1245</y>
      <w>36</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.如果是IGMP_ALL_HOSTS，直接返回
2.遍历in_dev.mc_list中的im
	1.如果report的组相同，表示该网络内有对应的组成员
	所以通过igmp_stop_timer将im.timer关闭，不用在
	回复之前因为query所设置的im.timer
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2533</x>
      <y>1241</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2526</x>
      <y>1258</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_stop_timer</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2531</x>
      <y>1254</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2520</x>
      <y>1265</y>
      <w>20</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>1.通过del_timer删除im.timer
2.im-&gt;tm_running=0;
	im-&gt;reporter = 0;
	im-&gt;unsolicit_count = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2530</x>
      <y>1261</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2609</x>
      <y>250</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_ifc_timer_expire</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2618</x>
      <y>244</y>
      <w>12</w>
      <h>8</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ip_mc_init_dev
mr_ifc_timer</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;60.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>130</x>
      <y>1124</y>
      <w>39</w>
      <h>19</h>
    </coordinates>
    <panel_attributes>1.in_dev-&gt;mc_tomb = NULL
2.in_dev-&gt;mr_gq_running = 0;
	init_timer(&amp;in_dev-&gt;mr_gq_timer);
	in_dev-&gt;mr_gq_timer.data=(unsigned long) in_dev;
	in_dev-&gt;mr_gq_timer.function=&amp;igmp_gq_timer_expire;
3.in_dev-&gt;mr_ifc_count = 0;
	init_timer(&amp;in_dev-&gt;mr_ifc_timer);
	in_dev-&gt;mr_ifc_timer.data=(unsigned long) in_dev;
	in_dev-&gt;mr_ifc_timer.function=&amp;igmp_ifc_timer_expire;
	in_dev-&gt;mr_qrv = IGMP_Unsolicited_Report_Count;
4.rwlock_init(&amp;in_dev-&gt;mc_list_lock);
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>146</x>
      <y>1120</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2597</x>
      <y>257</y>
      <w>30</w>
      <h>10</h>
    </coordinates>
    <panel_attributes>1.igmpv3_send_cr发送report
2.如果还存在mr_ifc_count
	1.in_dev-&gt;mr_ifc_count--;
	2.igmp_ifc_start_timer重新定时mr_ifc_timer
3.__in_dev_put释放in_dev
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2615</x>
      <y>253</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2605</x>
      <y>269</y>
      <w>12</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>igmpv3_send_cr</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2610</x>
      <y>266</y>
      <w>3</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;30.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2595</x>
      <y>277</y>
      <w>38</w>
      <h>35</h>
    </coordinates>
    <panel_attributes>1.遍历in_dev.mc_tomb（被删除的组）
	1.如果组的模式是MCAST_INCLUDE，将现在block的psf（sources和tomb上的）
		通过add_grec添加到skb
	2.如果要求report pmc(pmc.crcount)
		1.如果pmc是exclude，通过add_grec在skb添加组头(empty_source)
			通知CHANGE_TO_INCLUDE
		2.pmc-&gt;crcount--
		3.如果递减至0，通过igmpv3_clear_zeros将tomb和source上的psf全部删除
	3.如果不用报告pmc，并且pmc的psf都被删除
		1.将pmc移出链表in_dev.mc_tomb
		2.释放pmc
2.遍历in_dev.mc_list
	1.如果pmc有exclude
		1.souce新加的会BLOCK_OLD_SOURCES，tomb新加的会ALLOW_NEW_SOURCES
	2.如果是include
		1.souce新加的会ALLOW_NEW_SOURCES，tomb新加的会BLOCK_OLD_SOURCES
	3.如果pmc需要发
		1.如果pmc是exclude，add_grec添加完全被exclude的
		2.如果是include，add_grec添加完全被include的
		3.pmc-&gt;crcount--
4.igmpv3_sendpack发送skb
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2610</x>
      <y>273</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2683</x>
      <y>250</y>
      <w>42</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.如果im.loaded
	1.im-&gt;loaded = 0
	2.ip_mc_filter_del将设备的组播filter删除
2.如果是IGMP_ALL_HOSTS，直接返回
3.igmp_stop_timer停止im.timer
4.如果设备没有dead
	1.如果处于igmpv1，直接跳到done
	2.如果处于igmpv2，如果之前发送过(im-&gt;reporter)，通过igmp_send_report
		发送IGMP_HOST_LEAVE_MESSAGE,并跳到done
	3.igmpv3_add_delrec回收im
	4.igmp_ifc_event设置mr_ifc_timer，发送report
5.done：
	1.通过ip_mc_clear_src将source和tomb清空
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2700</x>
      <y>246</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2677</x>
      <y>275</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_filter_del</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2714</x>
      <y>275</y>
      <w>13</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmpv3_add_delrec</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2684</x>
      <y>271</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2666</x>
      <y>282</y>
      <w>32</w>
      <h>5</h>
    </coordinates>
    <panel_attributes>1.arp_mc_map检查到链接层可以处理组播
2.通过dev_mc_delete删除net_dev上的组播
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2681</x>
      <y>278</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2674</x>
      <y>290</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>dev_mc_delete</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2679</x>
      <y>286</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2662</x>
      <y>297</y>
      <w>30</w>
      <h>22</h>
    </coordinates>
    <panel_attributes>1.遍历net_dev.mc_list，找到地址相同的dmi
	1.如果glbl存在，直接将dmi-&gt;dmi_users置0
	（如果old_glbl已经为0，返回ENOENT）
	2.否则，--dmi-&gt;dmi_users
	3.如果dmi_users还存在，返回0
	4.如果不存在
		1.移出mc_list
			*dmip = dmi-&gt;next;
		2.释放dmi
			dev-&gt;mc_count--;
			kfree(dmi);
		3.__dev_mc_upload设置网卡
		4.返回0
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2677</x>
      <y>293</y>
      <w>4</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>20.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2718</x>
      <y>271</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2704</x>
      <y>282</y>
      <w>39</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.申请pmc
	pmc-&gt;interface = im-&gt;interface;
	in_dev_hold(in_dev);
	pmc-&gt;multiaddr = im-&gt;multiaddr;
	pmc-&gt;crcount = in_dev-&gt;mr_qrv ? in_dev-&gt;mr_qrv :
		IGMP_Unsolicited_Report_Count;
	pmc-&gt;sfmode = im-&gt;sfmode;
2.如果pmc是include，会设置tomb和source，在igmpv3_send_cr中发送
	pmc-&gt;tomb = im-&gt;tomb;
	pmc-&gt;sources = im-&gt;sources;
	im-&gt;tomb = im-&gt;sources = NULL;
	psf-&gt;sf_crcount = pmc-&gt;crcount;
3.将pmc加入in_dev.mc_tomb
	pmc-&gt;next = in_dev-&gt;mc_tomb;
	in_dev-&gt;mc_tomb = pmc;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2718</x>
      <y>278</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2505</x>
      <y>1304</y>
      <w>16</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>igmp_gq_timer_expire</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2510</x>
      <y>1300</y>
      <w>12</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
ip_mc_init_dev
mr_gq_timer</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2497</x>
      <y>1311</y>
      <w>34</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>in_dev1.in_dev-&gt;mr_gq_running = 0
2.igmpv3_send_report发送所有组的psf(普通查询)
3.__in_dev_put释放
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2511</x>
      <y>1307</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2378</x>
      <y>76</y>
      <w>172</w>
      <h>11</h>
    </coordinates>
    <panel_attributes>lt=.&gt;
IP_MSFILTER</panel_attributes>
    <additional_attributes>10.0;10.0;1700.0;90.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2542</x>
      <y>85</y>
      <w>39</w>
      <h>12</h>
    </coordinates>
    <panel_attributes>1.长度不能低于ip_msfilter头部的长度
2.kmalloc申请msf，并通过copy_from_user接收用户的传参
3. msf-&gt;imsf_numsrc需要在一定范围内
4.如果总体长度不符合，返回EINVAL
5.ip_mc_msfilter
6.释放msf
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>2558</x>
      <y>100</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_mc_msfilter</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2564</x>
      <y>96</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>2544</x>
      <y>107</y>
      <w>46</w>
      <h>25</h>
    </coordinates>
    <panel_attributes>1.filter的地址得是组播
2.模式得是include或者exclude
3.存在in_dev4.
4.如果模式是include，但是没有src，执行ip_mc_leave_group，并返回
5.遍历inet.mc_list，找到组播地址相同的pmc
6.如果msf指定了源
	1.通过sock_kmalloc申请源过滤结构newpsl
	2.设置源的数组
		newpsl-&gt;sl_max = newpsl-&gt;sl_count = msf-&gt;imsf_numsrc;
		memcpy(newpsl-&gt;sl_addr, msf-&gt;imsf_slist,
			msf-&gt;imsf_numsrc * sizeof(msf-&gt;imsf_slist[0]));
	3.ip_mc_add_src将数组添加置in_dev.mc_list的pmc中
7.如果没指定源，依旧通过ip_mc_add_src增加in_dev中pmc的sfcount
8.将原来的源过滤psf释放
9.采用新的模式
	pmc-&gt;sflist = newpsl;
	pmc-&gt;sfmode = msf-&gt;imsf_fmode;
	err = 0;
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>2564</x>
      <y>103</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1654</x>
      <y>1473</y>
      <w>31</w>
      <h>30</h>
    </coordinates>
    <panel_attributes>1.skb_push腾出iph头部包括选项的空间
2.初始化iph
	iph-&gt;version  = 4;
	iph-&gt;ihl      = 5;
	iph-&gt;tos      = inet-&gt;tos;
	iph-&gt;frag_off //ip_dont_fragment设置IP_DF
	iph-&gt;ttl      = ip_select_ttl(inet, &amp;rt-&gt;u.dst);
	iph-&gt;daddr    = rt-&gt;rt_dst;
	iph-&gt;saddr    = rt-&gt;rt_src;
	iph-&gt;protocol = sk-&gt;sk_protocol;
	iph-&gt;tot_len  = htons(skb-&gt;len);
	ip_select_ident(iph, &amp;rt-&gt;u.dst, sk);
	skb-&gt;nh.iph   = iph;
	iph-&gt;ihl += opt-&gt;optlen&gt;&gt;2;
	ip_options_build(skb, opt, daddr, rt, 0);
	ip_send_check
3.skb-&gt;priority = sk-&gt;sk_priority;
4.net_filter之后通过dst_output发送
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1661</x>
      <y>1468</y>
      <w>5</w>
      <h>7</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;30.0;50.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1971</x>
      <y>1307</y>
      <w>24</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>1.tcp_v4_send_ack发送ack
2.inet_twsk_put释放tw
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1984</x>
      <y>1303</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLUseCase</id>
    <coordinates>
      <x>1982</x>
      <y>1365</y>
      <w>12</w>
      <h>4</h>
    </coordinates>
    <panel_attributes>ip_send_reply</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1986</x>
      <y>1361</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
  <element>
    <id>UMLGeneric</id>
    <coordinates>
      <x>1964</x>
      <y>1372</y>
      <w>40</w>
      <h>26</h>
    </coordinates>
    <panel_attributes>1.通过ip_options_echo复制接收skb的ip选项
2.确定目的地址
	daddr = ipc.addr = rt-&gt;rt_src
3.如果有ip选项，设置ipc.opt，如果要求srr(严格路由)
	daddr = replyopts.opt.faddr
4.ip_route_output_key查找到目的地址的路由
5.inet-&gt;tos = skb-&gt;nh.iph-&gt;tos;
	sk-&gt;sk_priority = skb-&gt;priority;
	sk-&gt;sk_protocol = skb-&gt;nh.iph-&gt;protocol;
6.通过ip_append_data添加数据到sk.sk_write_queue中
7.如果sk_write_queue中有skb
	1.如果ip上一层(这里是tcp)需要checksum，通过csum_fold计算
	2.skb-&gt;ip_summed = CHECKSUM_NONE
	3.ip_push_pending_frames实现sk_write_queue上skb的聚合io
		并发送
8.通过ip_rt_put释放rt
halign=left</panel_attributes>
    <additional_attributes/>
  </element>
  <element>
    <id>Relation</id>
    <coordinates>
      <x>1987</x>
      <y>1368</y>
      <w>3</w>
      <h>6</h>
    </coordinates>
    <panel_attributes>lt=.&gt;</panel_attributes>
    <additional_attributes>10.0;10.0;10.0;40.0</additional_attributes>
  </element>
</diagram>
